{"meta":{"title":"yubiii","subtitle":"","description":"","author":"John Doe","url":"https://xiaofanshutu.github.io","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2022-06-17T07:16:23.391Z","comments":false,"path":"404.html","permalink":"https://xiaofanshutu.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2022-06-17T07:16:23.622Z","updated":"2022-06-17T07:16:23.622Z","comments":false,"path":"baidu_verify_xxxxxxx.html","permalink":"https://xiaofanshutu.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"","date":"2022-06-17T07:16:23.628Z","updated":"2022-06-17T07:16:23.628Z","comments":false,"path":"google1xxxxxxx0.html","permalink":"https://xiaofanshutu.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2022-06-17T07:16:23.620Z","comments":false,"path":"about/index.html","permalink":"https://xiaofanshutu.github.io/about/index.html","excerpt":"","text":""},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2022-06-17T07:16:23.429Z","comments":false,"path":"List/index.html","permalink":"https://xiaofanshutu.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2022-06-17T07:16:23.621Z","comments":false,"path":"archives/index.html","permalink":"https://xiaofanshutu.github.io/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2022-06-17T07:16:23.623Z","comments":false,"path":"categories/index.html","permalink":"https://xiaofanshutu.github.io/categories/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2022-06-17T07:16:23.624Z","comments":false,"path":"census/index.html","permalink":"https://xiaofanshutu.github.io/census/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2022-06-17T08:09:55.549Z","comments":false,"path":"contact/index.html","permalink":"https://xiaofanshutu.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 cutiebambiの友链信息 博客名称: cutiebambiの博客 博客网址: https://xiaofanshutu.github.io/ 博客头像: https://cdn.jsdelivr.net/gh/xiaofanshutu/myBlogPic@main/matery/img/logo.png 博客介绍: The harder you work, the luckier you will be"},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2022-06-17T07:16:23.628Z","comments":false,"path":"friends/index.html","permalink":"https://xiaofanshutu.github.io/friends/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2022-06-17T07:16:23.630Z","comments":false,"path":"resource/index.html","permalink":"https://xiaofanshutu.github.io/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2022-06-17T07:16:23.632Z","comments":false,"path":"tags/index.html","permalink":"https://xiaofanshutu.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-06-28T07:53:23.584Z","updated":"2022-06-17T07:16:23.406Z","comments":false,"path":"List/galleries/index.html","permalink":"https://xiaofanshutu.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-06-17T07:16:23.431Z","comments":false,"path":"List/music/index.html","permalink":"https://xiaofanshutu.github.io/List/music/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2022-06-17T07:16:23.430Z","comments":false,"path":"List/movies/index.html","permalink":"https://xiaofanshutu.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-06-17T07:16:23.433Z","comments":false,"path":"List/tools/index.html","permalink":"https://xiaofanshutu.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"动漫卡通","date":"2022-06-17T08:40:11.341Z","updated":"2022-06-17T08:40:11.341Z","comments":false,"path":"List/galleries/动漫卡通/index.html","permalink":"https://xiaofanshutu.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E5%8D%A1%E9%80%9A/index.html","excerpt":"","text":""}],"posts":[{"title":"Oracle","slug":"黑马Oracle/oracle learning","date":"2025-07-07T09:36:01.015Z","updated":"2025-07-08T00:10:40.463Z","comments":true,"path":"posts/f145fed6.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/f145fed6.html","excerpt":"Oracle简介Oracle特点Oracle数据库具有以下特点： 支持多用户，大事务量的事务处理 数据安全性和完整性控制 支持分布式数据处理 可移植性 Oracle体系结构数据库Oracle数据库是数据的物理存储。Oracle的数据库是指一个操作系统只有一个库，可以看做Oracle只有一个大数据库。 实例一个Oracle实例（Oracle Instance）有一系列的后台进程（Background Processes）和内存结构（Memory Structures）组成。一个数据库可以有多个(n个)实例。","text":"Oracle简介Oracle特点Oracle数据库具有以下特点： 支持多用户，大事务量的事务处理 数据安全性和完整性控制 支持分布式数据处理 可移植性 Oracle体系结构数据库Oracle数据库是数据的物理存储。Oracle的数据库是指一个操作系统只有一个库，可以看做Oracle只有一个大数据库。 实例一个Oracle实例（Oracle Instance）有一系列的后台进程（Background Processes）和内存结构（Memory Structures）组成。一个数据库可以有多个(n个)实例。 数据文件(dbf) 数据文件是数据库的物理存储单位。数据库的数据是存储在表空间中的。 一个表空间可以由一个或多个数据文件组成，一个数据文件只能属于一个表空间。 一旦数据文件被加入到某个表空间，就不能删除这个文件，如果要删除该数据文件，必须删除其所属的表空间才可以。 表空间 表空间是Oracle对物理数据库上相关数据文件（ORA或者DBF文件）的逻辑映射。 一个数据库在逻辑上被划分成一到若干个表空间，每个表空间包含了在逻辑上相关联的一组结构。 每个数据库至少有一个表空间称之为 system 表空间 。 每个表空间由同一磁盘上的一个或多个文件组成，这些文件叫数据文件(datafile) 。一个数据文件只能属于一个表空间。 注： (1)表的数据，是有用户放入某一个表空间的，而这个表空间会随机把这些表数据放到一个或者多个数据文件中。 (2)逻辑结构最小单位是数据块，不是磁盘块。 由于 oracle 的数据库不是普通的概念， oracle 是由用户和表空间对数据进行管理和存放的。但是表不是由表空间去查询的，而是由用户去查的。因为不同用户可以在同一个表空间建立同一个名字的表！这里区分就是用户了！ 图片理解： 这个符号是指一个数据文件由多个磁盘块组成 用户表空间—&gt;用户—&gt;表 用户是在表空间下建立的。用户登陆后只能看到和操作自己的表 , Oracle的用户与MySQL的数据库类似，每建立一个应用需要创建一个用户。 超级管理员账户 数据库操作创建表空间12345CREATE tablespace waterbossdatafile 'D:\\2_dan\\learningVideo\\oracle\\waterboss.dbf'size 100mautoextend ONnext 10m; 名字可以一样，也可以不一样 创建用户123create user wateruserIDENTIFIED BY 123456default tablespace waterboss; wateruser：用户名 123456：密码 waterboss：默认表空间名称 用户赋权1grant dba to wateruser;--给用户赋dba权限 表的创建、修改与删除创建表语法： 12345CREATE TABLE 表名称(字段名 类型 长度 primary key字段名 类型 长度......); 12345678910create table t_owners(id number primary key,name varchar2(30),addressid number,housenumber varchar2(30),watermeter varchar2(30),adddate date,ownertypeid number); 数据类型字符型 CHAR : 固定长度的字符类型，最多存储 2000 个字节 VARCHAR2 : 可变长度的字符类型，最多存储 4000 个字节 LONG : 大文本类型。 最大可以存储 2G 数值型 NUMBER : 数值类型 例如：NUMBER (5) 最大可以存的数为 99999NUMBER(5,2) 最大可以存的数为 999.99 日期型 DATE ：日期时间型，精确到秒 TIMESTAMP ：精确到秒的小数点后 9 位 二进制型 CLOB : 存储字符 最大可以存 4G BLOB ：存储图像、声音、 视频等二进制数据 最多可以存 4G 修改表增加字段语法 12345ALTER TABLE 表名称 ADD( 列名1 类型 [DEFAULT 默认值]， 列名2 类型 [DEFAULT 默认值]); 12345ALTER TABLE T_OWNERS ADD(REMARK VARCHAR2 20OUTDATE DATE) 修改字段语法 12345ALTER TABLE 表名称 MODIFY(列名1 类型 [DEFAULT 默认值]，列名2 类型 [DEFAULT 默认值]) 12345ALTE R TABLE T_OWNERS MODIFY(REMARK CHAR 20OUTDATE TIMESTAMP) 修改字段名语法 1ALTER TABLE 表名称 RNAME COLUMN 原列名 TO 新列名 1ALTER TABLE T_OWNERS RENAME COLUMN OUTDATE TO EXITDATE 删除字段名 12345--删除一个字段ALTER TABLE 表名称 DROP COLUMN 列名--删除多个字段ALTER TABLE 表名称 DROP( 列名1, 列名2...) 12--删除字段ALTER TABLE T_OWNERS DROP COLUMN REMARK 删除表1DROP TABLE 表名称 数据增删改插入数据语法： 1INSERT INTO 表名( 列名1，列名2，...) VALUES ( 值1，值2...) 1insert into T_OWNERS_COPY VALUES(11, '张三丰', 1, '123', '321', sysdate, 1); 修改数据方式1 1update 表名 set 列名1=值1, 列名2=值2,... where 修改条件; 1update T_OWNERS_COPY set NAME = '小红', ADDRESSID = '888' where id = 1; 方式2 1truncate table 表名 两种方式的区别： truncate删除的数据不可以rollback，delete删除的数据可以rollback 删除数据语法： 1delete fromm 表名 where 删除条件; 1delete from T_OWNERS_COPY where id = 11; JDBC连接Oracle导入驱动包ojdbc8.jaroracle 19c安装之后的ojdbc.jar包在下面这个地方可以找到，D:\\6_application\\oracle\\jdbc\\lib 将上面的jar添加到工程的library，否则会报下面这个错误。 12345678910111213141516171819java.lang.ClassNotFoundException: oracle.jdbc.driver.OracleDriver at java.net.URLClassLoader.findClass(URLClassLoader.java:382) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) at java.lang.Class.forName0(Native Method) at java.lang.Class.forName(Class.java:264) at dao.BaseDao.&lt;clinit&gt;(BaseDao.java:11) at dao.OwnerDao.add(OwnerDao.java:15) at test.Test01.main(Test01.java:17)Exception in thread \"main\" java.lang.RuntimeException: java.sql.SQLException: No suitable driver found for jdbc:oracle:thin:@localhost:1521:orcl at dao.OwnerDao.add(OwnerDao.java:26) at test.Test01.main(Test01.java:17)Caused by: java.sql.SQLException: No suitable driver found for jdbc:oracle:thin:@localhost:1521:orcl at java.sql.DriverManager.getConnection(DriverManager.java:689) at java.sql.DriverManager.getConnection(DriverManager.java:247) at dao.BaseDao.getConnection(BaseDao.java:23) at dao.OwnerDao.add(OwnerDao.java:15) ... 1 more BaseDao123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package dao;import java.sql.*;/** * 基础数据访问类 */public class BaseDao { static { try { Class.forName(\"oracle.jdbc.driver.OracleDriver\"); // 加载Oracle JDBC驱动 } catch (Exception e) { e.printStackTrace(); } } /** * 获取数据库连接 * * @return 数据库连接对象 */ public static Connection getConnection() throws SQLException { //痩连接: jdbc:oracle:thin return DriverManager.getConnection(\"jdbc:oracle:thin:@localhost:1521:orcl\", \"wateruser\", \"123456\"); } /** * 关闭数据库连接 * * @param conn 数据库连接对象 */ public static void close(ResultSet rs, Statement stmt, Connection conn) { if (rs != null) { try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if (stmt != null) { try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn != null) { try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } }} OwnerDao1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package dao;import entity.Owners;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;public class OwnerDao { public static void add(Owners owner) { Connection conn = null; //预处理，防止注入攻击 PreparedStatement stmt = null; try { conn = BaseDao.getConnection(); stmt = conn.prepareStatement(\"INSERT INTO T_OWNERS_COPY (id, name, addressid, housenumber, watermeter, adddate, ownertypeid) VALUES (?, ?, ?, ?, ?, ?, ?)\"); stmt.setLong(1, owner.getId()); stmt.setString(2, owner.getName()); stmt.setLong(3, owner.getAddressid()); stmt.setString(4, owner.getHousenumber()); stmt.setString(5, owner.getWatermeter()); //日期转为长整型Long, 然后再构造为java.sql.Date类型 stmt.setDate(6, new java.sql.Date(owner.getAdddate().getTime())); stmt.setLong(7, owner.getOwnertypeid()); stmt.executeUpdate(); } catch (SQLException e) { throw new RuntimeException(e); } finally { BaseDao.close(null, stmt, conn); } } public static void modify(Owners owner) { Connection conn = null; PreparedStatement stmt = null; try { conn = BaseDao.getConnection(); stmt = conn.prepareStatement(\"update T_OWNERS_COPY set name =?, addressid=?, housenumber=?, watermeter=?, adddate=?, ownertypeid=? where id=?\"); stmt.setString(1, owner.getName()); stmt.setLong(2, owner.getAddressid()); stmt.setString(3, owner.getHousenumber()); stmt.setString(4, owner.getWatermeter()); stmt.setDate(5, new java.sql.Date(owner.getAdddate().getTime())); stmt.setLong(6, owner.getOwnertypeid()); stmt.setLong(7, owner.getId()); stmt.executeUpdate(); } catch (SQLException e) { throw new RuntimeException(e); } finally { BaseDao.close(null, stmt, conn); } } public static void delete(Owners owner) { Connection conn = null; PreparedStatement stmt = null; try { conn = BaseDao.getConnection(); stmt = conn.prepareStatement(\"delete from T_OWNERS_COPY where id=?\"); stmt.setLong(1, owner.getId()); stmt.executeUpdate(); } catch (SQLException e) { throw new RuntimeException(e); } finally { BaseDao.close(null, stmt, conn); } }} 实体类Owners123456789101112131415161718192021public class Owners { private Long id;//业主编号 private String name;// 业主名称 private Long addressid;// 地址编号 private String housenumber;// 门牌号 private String watermeter;// 水表编号 private Date adddate;// 登记日期 private Long ownertypeid;// 业主类型 ID public Long getId() { return id; } public void setId(Long id) { this.id = id; } /* 其他getter，setter方法，省略 */} 测试代码1234567891011121314public class Test02 { public static void main(String[] args) { Owners owner = new Owners(); owner.setId(1L); owner.setName(\"张三\"); owner.setAddressid(111L); owner.setHousenumber(\"111号\"); owner.setWatermeter(\"6666\"); owner.setAdddate(new java.util.Date()); owner.setOwnertypeid(888L); OwnerDao.modify(owner); }} 执行modify方法之前 执行modify方法之后 数据导入与导出数据库导入与导出整库导出1exp system/超级管理员用户system的密码 full=y --full=y表示整库导出 执行命令后会在当前目录下生成一个叫EXPDAT.DMP，此文件为备份文件。 添加file参数即可指定备份文件的名称 1exp system/超级管理员用户system的密码 file=文件名 full=y 整库导入1imp system/超级管理员用户system的密码 full=y 如果指定file 参数，则按照file指定的备份文件进行导入 1imp system/超级管理员用户system的密码 full=y file=water.dmp 按用户导入与导出导出1exp system/itcast owner=wateruser file=wateruser.dmp 导入1imp system/itcast file=wateruser.dmp fromuser=wateruser 导入前特意删掉T_OWNERS_COPY表 导入后刷新，表成功导入 按表导入与导出导出1exp wateruser/123456 file=a.dmp tables=t_account,a_area 导入1imp wateruser/123456 file=a.dmp tables=t_account,a_area 单表查询简单条件查询精确查询需求：查询水表编号为30408 的业主记录 查询语句： 123456SELECT * FROM T_OWNERS WHERE watermeter = '30408' 查询结果： 模糊查询需求：查询业主名称包含“刘”的业主记录 查询语句： 123456SELECT * FROM t_owners WHERE name LIKE '%刘%' 查询结果： and运算符需求：查询业主名称包含“刘”的并且门牌号包含5 的业主记录 查询语句： 1234567SELECT * FROM t_owners WHERE name LIKE '%刘%' AND housenumber LIKE '%5%' 查询结果： or运算符需求：查询业主名称包含“刘”的或者门牌号包含5 的业主记录 查询语句： 1234567SELECT * FROM t_owners WHERE name LIKE '%刘%' OR housenumber LIKE '%5%' 查询结果： and和or运算符混合使用需求：查询业主名称包含“刘”的或者门牌号包含5 的业主记录，并且地址编号为3 的记录。 查询语句： 12345678--and 的优先级比or 大，需要用()来改变优先级。SELECT * FROM t_owners WHERE ( name LIKE '%刘%' OR housenumber LIKE '%5%' ) AND addressid =3 查询结果： 范围查询需求：查询台账记录中用水字数大于等于10000，并且小于等于20000 的记录 用&gt;= 和&lt;=来实现 查询语句： 1234567SELECT * FROM T_ACCOUNT WHERE usenum &gt;= 10000 AND usenum &lt;= 20000 查询结果： 用between .. and ..来实现 查询语句： 1234567SELECT * FROM T_ACCOUNT WHERE usenum BETWEEN 10000 AND 20000 查询结果： 空值查询需求1：查询T_PRICETABLE 表中MAXNUM 为空的记录 查询语句： 123456SELECT * FROM T_PRICETABLE t WHERE maxnum IS NULL 查询结果： 需求2：查询T_PRICETABLE 表中MAXNUM 不为空的记录 查询语句： 123456SELECT * FROM T_PRICETABLE t WHERE maxnum IS NOT NULL 查询结果： 去重需求：查询业主表中的地址ID,不重复显示 查询语句： 1234SELECT DISTINCT addressid FROM T_OWNERS 查询结果： 排序查询需求1：对T_ACCOUNT 表按使用量进行升序排序 查询语句： 1234567--默认是升序SELECT * FROM T_ACCOUNT ORDER BY usenum 查询结果： 需求2：对T_ACCOUNT 表按使用量进行降序排序 查询语句： 123456SELECT * FROM T_ACCOUNT ORDER BY usenum DESC 查询结果： 基于伪列的查询在Oracle 的表的使用过程中，实际表中还有一些附加的列，称为伪列。伪列就像表中的列一样，但是在表中并不存储。伪列只能查询，不能进行增删改操作。 ROWID表中的每一行在数据文件中都有一个物理地址，ROWID 伪列返回的就是该行的物理地址。 使用ROWID 可以快速的定位表中的某一行。 ROWID 值可以唯一的标识表中的一行。 由于ROWID 返回的是该行的物理地址，因此使用ROWID 可以显示行是如何存储的。 查询语句： 12345SELECT ROWID , t.* FROM T_AREA t 查询结果： ROWNUM在查询 的结果集中，ROWNUMM为结果集中每一行标识一个行号。第一行返回1，第二行返回2…。通过它可以限制查询结果集中返回的行数。 查询语句： 12345SELECT ROWNUM , t.* FROM T_OWNERTYPE t 查询结果： 聚合统计Oralce中的聚合统计是通过分组函数来实现的。 聚合函数 求和sum 需求：统计2012 年所有用户的用水量总和 查询语句： 123456SELECT sum( usenum ) FROM t_account WHERE year = '2012' 查询结果： 求平均avg 需求：统计2012 年所有用水量（字数）的平均值 查询语句： 123456SELECT avg(usenum) FROM T_ACCOUNT WHERE year = '2012' 查询结果： 求最大值max 需求：统计2012 年最高用水量（字数） 查询语句： 123456SELECT max( usenum ) FROM T_ACCOUNT WHERE year = '2012' 查询结果： 求最小值min 需求：统计2012 年最低用水量（字数） 查询语句： 123456SELECT min( usenum ) FROM T_ACCOUNT WHERE year = '2012' 查询结果： 统计记录个数count 需求：统计业主类型ID 为1 的业主数量 查询语句： 123456SELECT count( * ) FROM T_OWNERS t WHERE ownertypeid =1 查询结果： 分组聚合group by需求：按区域分组统计水费合计数 查询语句： 1234567SELECT areaid, sum( money ) FROM t_account GROUP BY areaid 查询结果： 分组后条件查询having需求：查询水费合计大于16900 的区域及水费合计 查询语句： 123456789SELECT areaid, sum( money ) FROM t_account GROUP BY areaid HAVING sum( money ) &gt; 169000 查询结果： 连接查询多表内连接查询需求1：查询显示业主编号，业主名称，业主类型名称，如下图： 查询语句： 123456789SELECT o.id 业主编号, o.name 业主名称, ot.name 业主类型 FROM T_OWNERS o, T_OWNERTYPE ot WHERE o.ownertypeid = ot.id 查询结果： 需求2：查询显示业主编号，业主名称、地址和业主类型，如下图 查询语句： 123456789101112SELECT o.id 业主编号, o.name 业主名称, ad.name 地址, ot.name 业主类型 FROM T_OWNERS o, T_OWNERTYPE ot, T_ADDRESS ad WHERE o.ownertypeid = ot.id AND o.addressid = ad.id 查询结果： 需求3：查询显示业主编号、业主名称、地址、所属区域、业主分类，如下图： 查询语句： 123456789101112131415SELECT o.id 业主编号, o.name 业主名称, ar.name 区域, ad.name 地址, ot.name 业主类型 FROM T_OWNERS o, T_OWNERTYPE ot, T_ADDRESS ad, T_AREA ar WHERE o.ownertypeid = ot.id AND o.addressid = ad.id AND ad.areaid = ar.id 查询结果： 需求：查询显示业主编号、业主名称、地址、所属区域、收费员、业主分类，如下图： 查询语句： 123456789101112131415161718SELECT ow.id 业主编号, ow.name 业主名称, ad.name 地址, ar.name 所属区域, op.name 收费员, ot.name 业主类型 FROM T_OWNERS ow, T_OWNERTYPE ot, T_ADDRESS ad, T_AREA ar, T_OPERATOR op WHERE ow.ownertypeid = ot.id AND ow.addressid = ad.id AND ad.areaid = ar.id AND ad.operatorid = op.id 查询结果： 左外连接查询需求1：查询业主的账务记录，显示业主编号、名称、年、月、金额。如果此业主没有账务记录也要列出姓名。 分析：业主表为左表、账务表为右表。 按照SQL1999标准的语法，查询语句： 123456789SELECT ow.id, ow.name, ac.year, ac.month, ac.money FROM T_OWNERS ow LEFT JOIN T_ACCOUNT ac ON ow.id = ac.owneruuid 查询结果： 按照Oracle提供的语法，查询语句： 如果是左外连接，就在右表所在的条件后面加上(+) 1234567891011SELECT ow.id, ow.name, ac.year, ac.month, ac.money FROM T_OWNERS ow, T_ACCOUNT ac WHERE ow.id = ac.owneruuid ( + ) 查询结果： 和上面的结果一样 右外连接查询需求：查询业主的账务记录，显示业主编号、名称、年、月、金额。如果账务记录没有对应的业主信息，也要列出记录。如下图： 按照SQL1999标准的语法，查询语句： 123456789SELECT ow.id, ow.name, ac.year, ac.month, ac.money FROM T_OWNERS ow RIGHT JOIN T_ACCOUNT ac ON ow.id = ac.owneruuid 查询结果： 按照Oracle提供的语法，查询语句： 1234567891011SELECT ow.id, ow.name, ac.year, ac.month, ac.money FROM T_OWNERS ow, T_ACCOUNT ac WHERE ow.id ( + ) = ac.owneruuid 查询结果： 和上面的结果一样 子查询where子句中的子查询单行子查询 只返回一条记录 单行操作符 需求：查询2012 年1 月用水量大于平均值的台账记录 查询语句： 12345678SELECT * FROM T_ACCOUNT WHERE year = '2012' AND month = '01' AND usenum &gt; ( SELECT avg( usenum ) FROM T_ACCOUNT WHERE year = '2012' AND month = '01' ) 查询结果： 多行子查询 可能会返回多条记录 多行操作符 in运算符需求1：查询地址编号为1 、3、4 的业主记录 查询语句： 123456SELECT * FROM T_OWNERS WHERE addressid IN ( 1, 3, 4 ) 查询结果： 需求2：查询地址含有“花园”的业主的信息 查询语句： 123456SELECT * FROM T_OWNERS WHERE addressid IN ( SELECT id FROM t_address WHERE name LIKE '%花园%' ) 查询结果： 需求3：查询地址不含有“花园”的业主的信息 查询语句： 123456SELECT * FROM T_OWNERS WHERE addressid NOT IN ( SELECT id FROM t_address WHERE name LIKE '%花园%' ) 查询结果： from子句中的子查询from 子句的子查询为多行子查询需求：查询显示业主编号，业主名称，业主类型名称，条件为业主类型为”居民”，使用子查询实现。 查询语句： 12345678910111213141516SELECT * FROM ( SELECT o.id 业主编号, o.name 业主名称, ot.name 业主类型 FROM T_OWNERS o, T_OWNERTYPE ot WHERE o.ownertypeid = ot.id ) WHERE 业主类型= '居民' 查询结果： select子句中的子查询select 子句的子查询必须为单行子查询 需求1：列出业主信息，包括ID，名称，所属地址。 查询语句： 123456SELECT id, name, ( SELECT name FROM t_address WHERE id = addressid ) addressname FROM t_owners 查询结果： 需求2：列出业主信息，包括ID，名称，所属地址，所属区域。 查询语句： 1234567SELECT id, name, ( SELECT name FROM t_address WHERE id = addressid ) addressname, ( SELECT ( SELECT name FROM t_area WHERE id = areaid ) FROM t_address WHERE id = addressid ) adrename FROM t_owners; 查询结果：","categories":[{"name":"Oracle","slug":"Oracle","permalink":"https://xiaofanshutu.github.io/categories/Oracle/"}],"tags":[]},{"title":"事务","slug":"动力节点MySQL/第08章 事务","date":"2025-07-02T22:59:12.930Z","updated":"2025-07-02T23:06:43.133Z","comments":true,"path":"posts/93ac284c.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/93ac284c.html","excerpt":"事务概述 事务是一个最小的工作单元。在数据库当中，事务表示一件完整的事儿。 一个业务的完成可能需要多条DML语句共同配合才能完成，例如转账业务，需要执行两条DML语句，先更新张三账户的余额，再更新李四账户的余额，为了保证转账业务不出现问题，就必须保证要么同时成功，要么同时失败，怎么保证同时成功或者同时失败呢？就需要使用事务机制。 也就是说用了事务机制之后，在同一个事务当中，多条DML语句会同时成功，或者同时失败，不会出现一部分成功，一部分失败的现象。 事务只针对DML语句有效：因为只有这三个语句是改变表中数据的。 insert delete update事务四大特性：ACID 原子性（Atomicity）：是指事务包含的所有操作要么全部成功，要么同时失败。 一致性（Consistency）：是指事务开始前，和事务完成后，数据应该是一致的。例如张三和李四的钱加起来是5000，中间不管进行过多少次的转账操作(update)，总量5000是不会变的。这就是事务的一致性。 隔离性（Isolation）：隔离性是当多个⽤户并发访问数据库时，⽐如操作同⼀张表时，数据库为每⼀个⽤户开启的事务，不能被其他事务的操作所⼲扰，多个并发事务之间要相互隔离。 持久性（Durability）：持久性是指⼀个事务⼀旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。 演示MySQL事务在dos命令窗口中开启MySQL事务：start transaction; 或者：begin;回滚事务：rollback;提交事务：commit;只要执行以上的rollback或者commit，事务都会结束。MySQL默认情况下采用的事务机制是：自动提交。所谓自动提交就是只要执行一条DML语句则提交一次。 事务隔离级别 隔离级别从低到高排序：读未提交 &lt; 读提交 &lt; 可重复读 &lt; 串行化****不同隔离级别会存在不同的现象，现象按照严重性从高到低排序：脏读 &gt; 不可重复读 &gt; 幻读 查看与设置隔离级别mysql默认的隔离级别：可重复读（REPEATABLE READ）。 查看当前会话的隔离级别：select @@transaction_isolation; 查看全局的隔离级别：select @@gobal.transaction_isolation; 设置事务隔离级别： 会话级：set session transaction isolation level read committed; 全局级：set global transaction isolation level read committed;不同现象脏读指的是一个事务读取了另一个事务尚未提交的数据，即读取了另一个事务中的脏数据（Dirty Data）。在此情况下，如果另一个事务回滚了或者修改了这些数据，那么读取这些脏数据的事务所处理的数据就是不准确的。不可重复读指在一个事务内，多次读取同一个数据行，得到的结果可能是不一样的。这是由于其他事务对数据行做出了修改操作，导致数据的不一致性。幻读指在事务执行过程中，前后两次相同的查询条件得到的结果集不一致，可能会变多或变少。隔离级别读未提交（READ UNCOMMITTED）A事务与B事务，A事务可以读取到B事务未提交的数据。这是最低的隔离级别。几乎两个事务之间没有隔离。这种隔离级别是一种理论层面的，在实际的数据库产品中，没有从这个级别起步的。当事务隔离级别是读未提交时，三种现象都存在：脏读，不可重复读，幻读。我们可以开启两个DOS命令窗口，模拟两个事务，演示一下这种隔离级别。三种现象中最严重的是脏读，我们只需要演示脏读问题即可，因为存在脏读的话，就一定存在不可重复读和幻读问题。 将全局事务隔离级别设置为：READ UNCOMMITTED","text":"事务概述 事务是一个最小的工作单元。在数据库当中，事务表示一件完整的事儿。 一个业务的完成可能需要多条DML语句共同配合才能完成，例如转账业务，需要执行两条DML语句，先更新张三账户的余额，再更新李四账户的余额，为了保证转账业务不出现问题，就必须保证要么同时成功，要么同时失败，怎么保证同时成功或者同时失败呢？就需要使用事务机制。 也就是说用了事务机制之后，在同一个事务当中，多条DML语句会同时成功，或者同时失败，不会出现一部分成功，一部分失败的现象。 事务只针对DML语句有效：因为只有这三个语句是改变表中数据的。 insert delete update事务四大特性：ACID 原子性（Atomicity）：是指事务包含的所有操作要么全部成功，要么同时失败。 一致性（Consistency）：是指事务开始前，和事务完成后，数据应该是一致的。例如张三和李四的钱加起来是5000，中间不管进行过多少次的转账操作(update)，总量5000是不会变的。这就是事务的一致性。 隔离性（Isolation）：隔离性是当多个⽤户并发访问数据库时，⽐如操作同⼀张表时，数据库为每⼀个⽤户开启的事务，不能被其他事务的操作所⼲扰，多个并发事务之间要相互隔离。 持久性（Durability）：持久性是指⼀个事务⼀旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。 演示MySQL事务在dos命令窗口中开启MySQL事务：start transaction; 或者：begin;回滚事务：rollback;提交事务：commit;只要执行以上的rollback或者commit，事务都会结束。MySQL默认情况下采用的事务机制是：自动提交。所谓自动提交就是只要执行一条DML语句则提交一次。 事务隔离级别 隔离级别从低到高排序：读未提交 &lt; 读提交 &lt; 可重复读 &lt; 串行化****不同隔离级别会存在不同的现象，现象按照严重性从高到低排序：脏读 &gt; 不可重复读 &gt; 幻读 查看与设置隔离级别mysql默认的隔离级别：可重复读（REPEATABLE READ）。 查看当前会话的隔离级别：select @@transaction_isolation; 查看全局的隔离级别：select @@gobal.transaction_isolation; 设置事务隔离级别： 会话级：set session transaction isolation level read committed; 全局级：set global transaction isolation level read committed;不同现象脏读指的是一个事务读取了另一个事务尚未提交的数据，即读取了另一个事务中的脏数据（Dirty Data）。在此情况下，如果另一个事务回滚了或者修改了这些数据，那么读取这些脏数据的事务所处理的数据就是不准确的。不可重复读指在一个事务内，多次读取同一个数据行，得到的结果可能是不一样的。这是由于其他事务对数据行做出了修改操作，导致数据的不一致性。幻读指在事务执行过程中，前后两次相同的查询条件得到的结果集不一致，可能会变多或变少。隔离级别读未提交（READ UNCOMMITTED）A事务与B事务，A事务可以读取到B事务未提交的数据。这是最低的隔离级别。几乎两个事务之间没有隔离。这种隔离级别是一种理论层面的，在实际的数据库产品中，没有从这个级别起步的。当事务隔离级别是读未提交时，三种现象都存在：脏读，不可重复读，幻读。我们可以开启两个DOS命令窗口，模拟两个事务，演示一下这种隔离级别。三种现象中最严重的是脏读，我们只需要演示脏读问题即可，因为存在脏读的话，就一定存在不可重复读和幻读问题。 将全局事务隔离级别设置为：READ UNCOMMITTED 1set global transaction isolation level read uncommitted; 开启两个DOS命令窗口来模拟两个事务：A事务与B事务。 A事务 B事务 mysql&gt; use powernode mysql&gt; use powernode mysql&gt; start transaction; mysql&gt; start transaction; mysql&gt; select * from a; mysql&gt; insert into a values(4); mysql&gt; select * from a; 通过以上测试，可以看到，A事务读取到了B事务还没有提交的数据。这种现象就是脏读。 读提交（READ COMMITTED）A事务与B事务，A事务可以读取到B事务提交之后的数据。Oracle数据库默认的就是这种隔离级别。 将数据库的全局事务隔离级别设置为读提交：READ COMMITTED 1set global transaction isolation level read committed; 演示： A事务 B事务 mysql&gt; use powernode mysql&gt; use powernode mysql&gt; start transaction; mysql&gt; start transaction; mysql&gt; select * from a; mysql&gt; insert into a values(4); mysql&gt; select * from a; mysql&gt; commit; mysql&gt; select * from a; 通过以上测试看出，A事务只能读取到B事务提交之后的数据。这种隔离级别解决了脏读问题，但肯定是存在不可重复读和幻读问题。因为只要事务B进行了增删改操作之后并提交了，事务A读取到的数据肯定是不同的。即：不可重复读和幻读都存在。 可重复读（REPEATABLE READ）这个隔离级别是MySQL数据库默认的。A事务和B事务，A事务开启后，读取了某一条记录，然后B事务对这条记录进行修改并提交，A事务读取到的还是修改前的数据。这种隔离级别称为可重复读。 将数据库全局隔离级别修改为可重复读： 1set global transaction isolation level repeatable read; 演示： A事务 B事务 mysql&gt; use powernode mysql&gt; use powernode mysql&gt; start transaction; mysql&gt; start transaction; mysql&gt; select empno,ename,sal from emp where empno=7369; mysql&gt; update emp set ename=’SMITH’,sal=8000 where empno=7369; mysql&gt; commit; mysql&gt; select empno,ename,sal from emp where empno=7369; 通过以上测试得知：当事务隔离级别设置为可重复读时，避免了不可重复读问题。 那么在MySQL当中，当事务隔离级别设置为可重复读时，能够避免幻读问题吗？测试一下： 事务A 事务B mysql&gt; use powernode mysql&gt; use powernode mysql&gt; start transaction; mysql&gt; start transaction; mysql&gt; select * from a; mysql&gt; insert into a values(5); mysql&gt; commit; mysql&gt; select * from a; 通过以上测试得知：当事务隔离级别设置为可重复读时，也避免了幻读问题。是完全避免了幻读问题吗？并不是。请看以下测试： 事务A 事务B mysql&gt; use powernode mysql&gt; use powernode mysql&gt; start transaction; mysql&gt; start transaction; mysql&gt; select * from a; mysql&gt; insert into a values(6); mysql&gt; commit; mysql&gt; select * from a for update; 通过以上测试得知：当事务隔离级别设置为可重复读，MySQL会尽最大努力避免幻读问题，但这种隔离级别无法完全避免幻读问题。 串行化（SERIALIZABLE）这种隔离级别最高，避免了所有的问题，缺点是效率低，因为这种隔离级别会导致事务排队处理，不支持并发。 设置数据库全局隔离级别为串行化： 1set global transaction isolation level serializable; 演示： 事务A 事务B mysql&gt; use powernode mysql&gt; use powernode mysql&gt; start transaction; mysql&gt; start transaction; mysql&gt; select * from a; mysql&gt; insert into a values(7); mysql&gt; select * from a; mysql&gt; commit; 通过以上测试得知：当事务隔离级别设置为串行化时，事务只能排队执行，不支持并发。 可重复读的幻读问题在上面讲解过程中我提到，MySQL默认的隔离级别可重复读，在很大程度上避免了幻读问题（并不能完全解决），那么它是如何解决幻读问题的呢，解决方案包括两种： 针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好的避免了幻读问题。 针对当前读（select … for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好的避免了幻读问题。 快照读是如何解决幻读的什么是快照读？普通的select语句都是采用的快照读。顾名思义：在整个事务的处理过程中，执行相同的一个select语句时，每次都是读取的快照。（快照指的是固定的某个时刻的数据，就像现实世界中的拍照一样，把那个美好的时刻留下来）。也就是说，当事务隔离级别是可重复读，并且执行的select语句是一个普通的select语句时，都会采用快照读的方式读取数据，底层实现原理是： 底层由 MVCC（多版本并发控制）实现，实现的方式是开始事务后，在执行第一个查询语句后，会创建一个 Read View，后续的查询语句利用这个 Read View，通过这个 Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的，即使中途有其他事务插入了新纪录，是查询不出来这条数据的，所以就很好的避免了幻读问题。 演示： 事务A 事务B mysql&gt; use powernode mysql&gt; use powernode mysql&gt; start transaction; mysql&gt; start transaction; mysql&gt; select * from a; //快照读 mysql&gt; insert into a values(5); mysql&gt; commit; mysql&gt; select * from a; //快照读 当前读是如何解决幻读的当前读，顾名思义：每一次都读取最新的数据。当前读包括：update、delete、insert、select…for update。这个很好理解，因为增删改的时候都要基于最新的数据进行增删改。而select…for update原理是：对查询范围内的数据进行加锁，不允许其它事务对这个范围内的数据进行增删改。也就是说这个select语句范围内的数据是不允许并发的，只能排队执行，从而避免幻读问题。select…for update加的锁叫做：next-key lock。我们可以称其为：间隙锁 + 记录锁。间隙锁用来保证在锁定的范围内不允许insert操作。记录锁用来保证在锁定的范围内不允许delete和update操作。 假如有这样的数据：SQL语句是这样写的： 1select * from a where id between 2 and 4 for update; 那么id在[2-4]区间的所有记录行被锁定，不能插入3是通过间隙锁来搞定的。不能修改或删除2和4是通过记录锁来搞定的。 演示： 事务A 事务B mysql&gt; use powernode mysql&gt; use powernode mysql&gt; start transaction; mysql&gt; start transaction; mysql&gt; select * from a where id between 2 and 4 for update; // 当前读 出现幻读的两种情况在同一个事务处理过程中，如果前后两次都采用快照读，或者都采用当前读，则不会出现幻读问题。如果第一次使用快照读，后面使用了当前读，则会出现幻读问题。 第一种产生幻读的场景A事务与B事务。在A事务中第一次查询使用快照读，B事务插入数据。然后在A事务中第二次查询使用当前读。则会产生幻读现象。演示： 事务A 事务B mysql&gt; use powernode mysql&gt; use powernode mysql&gt; start transaction; mysql&gt; start transaction; mysql&gt; select * from a; mysql&gt; insert into a values(5); mysql&gt; commit; mysql&gt; select * from a for update; // 产生了幻读 第二种产生幻读的场景事务A与事务B，在事务A中第一次查询使用快照读，在事务B中插入一条数据，然后在事务A中更新事务B插入的那条记录，最后在事务A中再次使用快照读。则会发生幻读现象。 事务A 事务B mysql&gt; use powernode mysql&gt; use powernode mysql&gt; start transaction; mysql&gt; start transaction; mysql&gt; select * from a; mysql&gt; insert into a values(6); mysql&gt; commit; mysql&gt; update a set id=100 where id=6; //主要是因为这个SQL语句的执行触发了当前读 mysql&gt; select * from a; // 产生了幻读 总结可重复读的幻读问题MySQL的可重复读隔离级别（默认隔离级），根据不同的查询方式，分别提出了避免幻读的方案： 针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读。 针对当前读（select … for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读。 我举例了两个发生幻读场景的例子。 第一个例子：对于快照读， MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。 第二个例子：对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。 所以，MySQL 可重复读隔离级别并没有彻底解决幻读，只是很大程度上避免了幻读现象的发生。要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://xiaofanshutu.github.io/categories/MySQL/"}],"tags":[]},{"title":"视图","slug":"动力节点MySQL/第07章 视图","date":"2025-07-02T22:46:02.851Z","updated":"2025-07-02T22:53:57.145Z","comments":true,"path":"posts/50a54d3c.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/50a54d3c.html","excerpt":"只能将select语句创建为视图。 创建视图 1create or replace view v_emp as select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno; 视图作用 如果开发中有一条非常复杂的SQL，而这个SQL在多处使用，会给开发和维护带来成本。使用视图可以降低开发和维护的成本。 视图可以隐藏表的字段名。 修改视图 1alter view v_emp as select e.ename,d.dname,d.deptno from emp e join dept d on e.deptno = d.deptno; 删除视图 drop view if exists v_emp; 对视图增删改（DML：insert delete update）可以影响到原表数据。","text":"只能将select语句创建为视图。 创建视图 1create or replace view v_emp as select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno; 视图作用 如果开发中有一条非常复杂的SQL，而这个SQL在多处使用，会给开发和维护带来成本。使用视图可以降低开发和维护的成本。 视图可以隐藏表的字段名。 修改视图 1alter view v_emp as select e.ename,d.dname,d.deptno from emp e join dept d on e.deptno = d.deptno; 删除视图 drop view if exists v_emp; 对视图增删改（DML：insert delete update）可以影响到原表数据。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://xiaofanshutu.github.io/categories/MySQL/"}],"tags":[]},{"title":"数据库设计三范式","slug":"动力节点MySQL/第06章 三范式","date":"2025-07-02T13:41:22.456Z","updated":"2025-07-02T13:45:23.490Z","comments":true,"path":"posts/80436e1d.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/80436e1d.html","excerpt":"什么是数据库设计三范式数据库表设计的原则。教你怎么设计数据库表有效，并且节省空间。 三范式 第一范式：任何一张表都应该有主键，每个字段是原子性的不能再分 以下表的设计不符合第一范式：无主键，并且联系方式可拆分。 应该这样设计： 第二范式：建立在第一范式基础上的，另外要求所有非主键字段完全依赖主键，不能产生部分依赖 以下表存储了学生和老师的信息 虽然符合第一范式，但是违背了第二范式，学生姓名、老师姓名都产生了部分依赖。导致数据冗余。","text":"什么是数据库设计三范式数据库表设计的原则。教你怎么设计数据库表有效，并且节省空间。 三范式 第一范式：任何一张表都应该有主键，每个字段是原子性的不能再分 以下表的设计不符合第一范式：无主键，并且联系方式可拆分。 应该这样设计： 第二范式：建立在第一范式基础上的，另外要求所有非主键字段完全依赖主键，不能产生部分依赖 以下表存储了学生和老师的信息 虽然符合第一范式，但是违背了第二范式，学生姓名、老师姓名都产生了部分依赖。导致数据冗余。 以下这种设计方式就是符合第二范式的： 第三范式：建立在第二范式基础上的，非主键字段不能传递依赖于主键字段 以下设计方式就是违背第三范式的 以上因为产生了传递依赖，导致班级名称冗余。 以下这种方式就是符合第三范式的： 一对多怎么设计口诀：一对多两张表，多的表加外键。 多对多怎么设计多对多三张表，关系表添加外键。 一对一怎么设计两种方案： 第一种：主键共享 第二种：外键唯一 最终的设计最终以满足客户需求为原则，有的时候会拿空间换速度。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://xiaofanshutu.github.io/categories/MySQL/"}],"tags":[]},{"title":"MySQL表相关","slug":"动力节点MySQL/第05章 表相关","date":"2025-06-30T23:16:56.277Z","updated":"2025-07-01T00:07:26.004Z","comments":true,"path":"posts/31637be2.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/31637be2.html","excerpt":"创建表语法格式： 123456create table 表名( 字段名1 数据类型, 字段名2 数据类型, 字段名3 数据类型, ......); 例如：创建学生表 12345create table t_student( no int, name varchar, gender char(1) default '男'); 插入数据语法格式： 1insert into 表名(字段名1, 字段名2, 字段名3,......) values (值1,值2,值3,......); 字段名和值要一一对应。类型要一一对应，数量要一一对应。字段名也可以省略，如果字段名省略就表示把所有字段名都写上去了，并且顺序和建表时的顺序相同。","text":"创建表语法格式： 123456create table 表名( 字段名1 数据类型, 字段名2 数据类型, 字段名3 数据类型, ......); 例如：创建学生表 12345create table t_student( no int, name varchar, gender char(1) default '男'); 插入数据语法格式： 1insert into 表名(字段名1, 字段名2, 字段名3,......) values (值1,值2,值3,......); 字段名和值要一一对应。类型要一一对应，数量要一一对应。字段名也可以省略，如果字段名省略就表示把所有字段名都写上去了，并且顺序和建表时的顺序相同。 删除表语法格式： 1drop table 表名; 或者 1drop table if exists 表名; 判断是否存在这个表，如果存在则删除。避免不存在时的报错。 MySQL数据类型数据类型（data_type）是指系统中所允许的数据的类型。数据库中的每个列都应该有适当的数据类型，用于限制或允许该列中存储的数据。例如，列中存储的为数字，则相应的数据类型应该为数值类型。如果使用错误的数据类型可能会严重影响应用程序的功能和性能，所以在设计表时，应该特别重视数据列所用的数据类型。更改包含数据的列不是一件小事，这样做可能会导致数据丢失。因此，在创建表时必须为每个列设置正确的数据类型和长度。MySQL 的数据类型可以分为整数类型、浮点数类型、定点数类型、日期和时间类型、字符串类型、二进制类型等。 整数类型tinyint：1个字节（微小整数）smallint：2个字节（小整数）mediumint：3个字节（中等大小的整数）int（integer）：4个字节（普通大小整数）bigint：8个字节（大整数） 浮点数类型float：4个字节，单精度（最多5位小数）double：8个字节，双精度（最多16位小数） 定点数类型decimal：定点数类型。底层实际上采用字符串的形式存储数字。语法：decimal(m, d)例如：decimal(3, 2) 表示3个有效数字，2个小数。（有效数字最多65个，小数位最多30个） 日期和时间类型year：1个字节，只存储年，格式YYYYtime：3个字节，只存储时间，格式HH:MM:SS / HHMMSSdate：3个字节，只存储年月日，格式：YYYY-MM-DDdatetime：8个字节，存储年月日+时分秒，格式：YYYY-MM-DD HH:MM:SS（从公元1000年公元9999年）timestamp：4个字节，存储年月日+时分秒，格式：YYYY-MM-DD HH:MM:SS（从公元1980年公元2040年）或者格式为 YYYYMMDDHHMMSS（采用这种格式不需要使用单引号，当然你使用单引号也可以） 字符串类型charchar(m)：m长度是0~255个字符。固定长度字符串，在定义时指定字符串列长。当保存时，在右侧填充空格以达到指定的长度。m表示列的长度，范围是 0～255 个字符。例如，CHAR(4) 定义了一个固定长度的字符串列，包含的字符个数最大为 4。当插入的字符长度大于4，则报错（除非超过4个长度之后都是空格字符，则空格字符会自动被删除用来保证插入的成功）。 varcharvarchar(m)：m长度是0~16383个字符长度可变的字符串。varchar 的最大实际长度由最长的行的大小和使用的字符集确定，而实际占用的空间为字符串的实际长度加 1。例如，varchar(50) 定义了一个最大长度为 50 的字符串，如果插入的字符串只有 10 个字符，则实际存储的字符串为 10 个字符和一个字符串结束字符。varchar在值保存和检索时尾部的空格仍保留。 texttext类型： tinytext 表示长度为 255字符的 TEXT 列。 text 表示长度为 65535字符的 TEXT 列。 mediumtext 表示长度为 16777215字符的 TEXT 列。 longtext 表示长度为 4294967295 或 4GB 字符的 TEXT 列。enum enum类型： 语法：&lt;字段名&gt; enum(‘值1’,’值2’,…) 该字段插入值时，只能是指定的枚举值。 set set类型： 语法：&lt;字段名&gt; set(‘值1’,’值2’,’值3’,…) 注意：值不可重复。 该字段插入值时，只能是指定的值。 二进制类型BLOB（Binary Large Object）类型：二进制大对象，可以存储图片、声音、视频等文件。 blob：小的，最大长度65535个字节 mediumblob：中等的，最大长度16777215个字节 longblob：大的，最大长度4GB的字节增删改表结构DDL创建一个学生表12345create table t_student( no bigint, name varchar(255), age int comment '年龄'); 查看建表语句1show create table 表名; 修改表名1alter table 表名 rename 新表名; 新增字段1alter table 表名 add 字段名 数据类型; 修改字段名1alter table 表名 change 旧字段名 新字段名 数据类型; 修改字段数据类型1alter table 表名 modify column 字段名 数据类型; 删除字段1alter table 表名 drop 字段名; DML语句当我们对表中的数据进行增删改的时候，称它为DML语句。（数据操纵语言），主要包括：insert、delete、update insert 增语法格式： 1insert into 表名(字段名1,字段名2,字段名3,...) values(值1,值2,值3,...); 表名后面的小括号当中的字段名如果省略掉，表示自动将所有字段都列出来了，并且字段的顺序和建表时的顺序一致。一般为了可读性强，建议把字段名写上。 1insert into 表名 values(值1,值2,值3,...); 一次可以插入多条记录： 1insert into t_stu(no,name,age) values(1,'jack',20),(2,'lucy',30); delete 删语法格式： 12345# 将所有记录全部删除delete from 表名;# 删除符合条件的记录delete from 表名 where 条件; 以上的删除属于DML的方式删除，这种删除的数据是可以通过事务回滚的方式重新恢复的，但是删除的效率较低。（这种删除是支持事务的。）另外还有一种删除表中数据的方式，但是这种方式不支持事务，不可以回滚，删了之后数据是永远也找不回来了。这种删除叫做：表被截断。注意：这个语句删除效率非常高，巨大的表，瞬间干掉所有数据。但不可恢复。 1truncate table 表名; update 改语法格式： 1update 表名 set 字段名1=值1, 字段名2=值2, 字段名3=值3 where 条件; 如果没有更新条件的话，所有记录全部更新。 约束constraint创建表时，可以给表的字段添加约束，可以保证数据的完整性、有效性。比如大家上网注册用户时常见的：用户名不能为空。对不起，用户名已存在。等提示信息。约束通常包括： 非空约束：not null 检查约束：check 唯一性约束：unique 主键约束：primary key 外键约束：foreign key非空约束语法格式：12345create table t_stu( no int, name varchar(255) not null, age int); name字段不能为空。插入数据时如果没有给name指定值，则报错。 检查约束123456create table t_stu( no int, name varchar(255), age int, check(age &gt; 18)); 唯一性约束语法格式： 12345create table t_stu( no int, name varchar(255), email varchar(255) unique); email字段设置为唯一性，唯一性的字段值是可以为NULL的。但不能重复。以上在字段后面添加的约束，叫做列级约束。当然，添加约束还有另一种方式：表级约束： 123456create table t_stu( no int, name varchar(255), email varchar(255), unique(email)); 使用表级约束可以为多个字段添加联合唯一。 123456create table t_stu( no int, name varchar(255), email varchar(255), unique(name,email)); 创建约束时也可以给约束起名字，将来可以通过约束的名字来删除约束： 123456create table t_stu( no int, name varchar(255), email varchar(255), constraint t_stu_name_email_unique unique(name,email)); 所有的约束都存储在一个系统表当中：table_constraints。这个系统表在这个数据库当中：information_schema 主键约束 主键：primary key，简称PK 主键约束的字段不能为NULL，并且不能重复。 任何一张表都应该有主键，没有主键的表可以视为无效表。 主键值是这行记录的身份证号，是唯一标识。在数据库表中即使两条数据一模一样，但由于主键值不同，我们也会认为是两条完全的不同的数据。 主键分类： 根据字段数量分类： 单一主键（1个字段作为主键）==&gt;建议的 复合主键（2个或2个以上的字段作为主键） 根据业务分类： 自然主键（主键和任何业务都无关，只是一个单纯的自然数据）===&gt;建议的 业务主键（主键和业务挂钩，例如：银行卡账号作为主键） 单一主键（建议使用这种方式） 12345create table t_student( id bigint primary key, sno varchar(255) unique, sname varchar(255) not null) 复合主键（很少用，了解） 123456create table t_user( no int, name varchar(255), age int, primary key(no,name)); 主键自增：既然主键值是一个自然的数字，mysql为主键值提供了一种自增机制，不需要我们程序员维护，mysql自动维护该字段 1234create table t_vip( no int primary key auto_increment, name varchar(255)); 外键约束 有这样一个需求：要求设计表，能够存储学生以及学校信息。 第一种方案：一张表 这种方式会导致数据冗余，浪费空间。 第二种方案：两张表：一张存储学生，一张存储学校 t_school 表t_student 表如果采用以上两张表存储数据，对于学生表来说，sno这个字段的值是不能随便填的，这个sno是学校编号，必须要求这个字段中的值来自学校表的sno。为了达到要求，此时就必须要给t_student表的sno字段添加外键约束了。 外键约束：foreign key，简称FK。 添加了外键约束的字段中的数据必须来自其他字段，不能随便填。 假设给a字段添加了外键约束，要求a字段中的数据必须来自b字段，b字段不一定是主键，但至少要有唯一性。 外键约束可以给单个字段添加，叫做单一外键。也可以给多个字段联合添加，叫做复合外键。复合外键很少用。 a表如果引用b表中的数据，可以把b表叫做父表，把a表叫做子表。 创建表时，先创建父表，再创建子表。 插入数据时，先插入父表，在插入子表。 删除数据时，先删除子表，再删除父表。 删除表时，先删除子表，再删除父表。 如何添加外键：1234567891011create table t_school( sno int primary key, sname varchar(255) ); create table t_student( no int primary key, name varchar(255), age int, sno int, constraint t_school_sno_fk foreign key(sno) references t_school(sno) ); 级联删除 创建子表时，外键可以添加：on delete cascade，这样在删除父表数据时，子表会级联删除。谨慎使用。 1234567create table t_student( no int primary key, name varchar(255), age int, sno int, constraint t_school_sno_fk foreign key(sno) references t_school(sno) on delete cascade ); 1234###删除约束alert table t_student drop foreign key t_student_sno_fk;###添加约束alert table t_student add constraint t_student_sno_fk foreign key(sno) references t_school(sno) on delete cascade; 级联更新 1234567create table t_student( no int primary key, name varchar(255), age int, sno int, constraint t_school_sno_fk foreign key(sno) references t_school(sno) on update cascade ); 级联置空 1234567create table t_student( no int primary key, name varchar(255), age int, sno int, constraint t_school_sno_fk foreign key(sno) references t_school(sno) on delete set null );","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://xiaofanshutu.github.io/categories/MySQL/"}],"tags":[]},{"title":"MySQL数据库概述","slug":"动力节点MySQL/第01章 数据库概述","date":"2025-06-29T23:08:23.981Z","updated":"2025-06-29T23:37:55.231Z","comments":true,"path":"posts/ca9a1c2c.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/ca9a1c2c.html","excerpt":"什么是数据库 数据库是一门独立的学科，只要是做软件开发的，数据库都要学。 数据库（电子化的文件柜）是“按照数据结构来组织、存储和管理数据的仓库”。是一个长期存储在计算机内的、有组织的、可共享的、统一管理的大量数据的集合。 它的存储空间很大，可以存放百万条、千万条、上亿条数据。 数据库并不是随意地将数据进行存放，是有一定的规则的，否则查询的效率会很低。 当今世界是一个充满着数据的互联网世界，充斥着大量的数据。即这个互联网世界就是数据世界。数据的来源有很多，比如出行记录、消费记录、浏览的网页、发送的消息等等。除了文本类型的数据，图像、音乐、声音都是数据。 数据库对应的英文单词是DataBase，简称DB。 数据库类型 关系型数据库 关系型数据库是依据关系模型来创建的数据库。所谓关系模型就是“一对一、一对多、多对多”等关系模型，关系模型就是指二维表格模型，因而一个关系型数据库就是由二维表及其之间的联系组成的一个数据组织。 关系型数据可以很好地存储一些关系模型的数据，比如一个老师对应多个学生的数据（“多对多”），一本书对应多个作者（“一对多”），一本书对应一个出版日期（“一对一”）。 关系模型包括数据结构（数据存储的问题，二维表）、操作指令集合（SQL语句）、完整性约束(表内数据约束、表与表之间的约束)。 非关系型数据库（NoSQL） NoSQL，泛指非关系型的数据库。随着互联网web2.0网站的兴起，传统的关系数据库在处理web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，出现了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。 NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，特别是大数据应用难题。NoSQL最常见的解释是“non-relational”， “Not Only SQL”也被很多人接受。 NoSQL仅仅是一个概念，泛指非关系型的数据库，区别于关系数据库，它们不保证关系数据的ACID特性。NoSQL是一项全新的数据库革命性运动，其拥护者们提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入。 NoSQL有如下优点：易扩展，NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。无形之间也在架构的层面上带来了可扩展的能力。大数据量，高性能，NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单。数据库管理系统 数据库管理系统（Database Management System，简称DBMS）是为管理数据库而设计的电脑软件系统，一般具有存储、截取、安全保障、备份等基础功能。 数据库管理系统是数据库系统的核心组成部分，主要完成对数据库的操作与管理功能，实现数据库对象的创建、数据库存储数据的查询、添加、修改与删除操作和数据库的用户管理、权限管理等。 常见的数据库管理系统有：MySQL、Oracle、DB2、MS SQL Server、SQLite、PostgreSQL、Sybase等。 什么是SQL 结构化查询语言（Structured Query Language）简称SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。 结构化查询语言是高级的非过程化编程语言，允许用户在高层数据结构上工作。它不要求用户指定对数据的存放方法，也不需要用户了解具体的数据存放方式，所以具有完全不同底层结构的不同数据库系统, 可以使用相同的结构化查询语言作为数据输入与管理的接口。结构化查询语言语句可以嵌套，这使它具有极大的灵活性和强大的功能。 SQL的分类 DQL 数据查询语言（Data Query Language, DQL）是SQL语言中，负责进行数据查询而不会对数据本身进行修改的语句，这是最基本的SQL语句。保留字SELECT是DQL（也是所有SQL）用得最多的动词，其他DQL常用的保留字有FROM，WHERE，GROUP BY，HAVING和ORDER BY。这些DQL保留字常与其他类型的SQL语句一起使用。 DDL 数据定义语言 (Data Definition Language, DDL) 是SQL语言集中，负责数据结构定义与数据库对象定义的语言，由CREATE、ALTER与DROP三个语法所组成，最早是由 Codasyl (Conference on Data Systems Languages) 数据模型开始，现在被纳入 SQL 指令中作为其中一个子集。 DML 数据操纵语言（Data Manipulation Language, DML）是SQL语言中，负责对数据库对象运行数据访问工作的指令集，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入、更新与删除。 DCL 数据控制语言 (Data Control Language) 在SQL语言中，是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。由 GRANT 和 REVOKE 两个指令组成。DCL以控制用户的访问权限为主，GRANT为授权语句，对应的REVOKE是撤销授权语句。 TPL 数据事务管理语言（Transaction Processing Language）它的语句能确保被DML语句影响的表的所有行及时得以更新。TPL语句包括BEGIN TRANSACTION，COMMIT和ROLLBACK。 CCL 指针控制语言（Cursor Control Language），它的语句，像DECLARE CURSOR，FETCH INTO和UPDATE WHERE CURRENT用于对一个或多个表单独行的操作。 DBMS、SQL、DB之间的关系 DBMS通过执行SQL来操作DB中的数据。","text":"什么是数据库 数据库是一门独立的学科，只要是做软件开发的，数据库都要学。 数据库（电子化的文件柜）是“按照数据结构来组织、存储和管理数据的仓库”。是一个长期存储在计算机内的、有组织的、可共享的、统一管理的大量数据的集合。 它的存储空间很大，可以存放百万条、千万条、上亿条数据。 数据库并不是随意地将数据进行存放，是有一定的规则的，否则查询的效率会很低。 当今世界是一个充满着数据的互联网世界，充斥着大量的数据。即这个互联网世界就是数据世界。数据的来源有很多，比如出行记录、消费记录、浏览的网页、发送的消息等等。除了文本类型的数据，图像、音乐、声音都是数据。 数据库对应的英文单词是DataBase，简称DB。 数据库类型 关系型数据库 关系型数据库是依据关系模型来创建的数据库。所谓关系模型就是“一对一、一对多、多对多”等关系模型，关系模型就是指二维表格模型，因而一个关系型数据库就是由二维表及其之间的联系组成的一个数据组织。 关系型数据可以很好地存储一些关系模型的数据，比如一个老师对应多个学生的数据（“多对多”），一本书对应多个作者（“一对多”），一本书对应一个出版日期（“一对一”）。 关系模型包括数据结构（数据存储的问题，二维表）、操作指令集合（SQL语句）、完整性约束(表内数据约束、表与表之间的约束)。 非关系型数据库（NoSQL） NoSQL，泛指非关系型的数据库。随着互联网web2.0网站的兴起，传统的关系数据库在处理web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，出现了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。 NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，特别是大数据应用难题。NoSQL最常见的解释是“non-relational”， “Not Only SQL”也被很多人接受。 NoSQL仅仅是一个概念，泛指非关系型的数据库，区别于关系数据库，它们不保证关系数据的ACID特性。NoSQL是一项全新的数据库革命性运动，其拥护者们提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入。 NoSQL有如下优点：易扩展，NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。无形之间也在架构的层面上带来了可扩展的能力。大数据量，高性能，NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单。数据库管理系统 数据库管理系统（Database Management System，简称DBMS）是为管理数据库而设计的电脑软件系统，一般具有存储、截取、安全保障、备份等基础功能。 数据库管理系统是数据库系统的核心组成部分，主要完成对数据库的操作与管理功能，实现数据库对象的创建、数据库存储数据的查询、添加、修改与删除操作和数据库的用户管理、权限管理等。 常见的数据库管理系统有：MySQL、Oracle、DB2、MS SQL Server、SQLite、PostgreSQL、Sybase等。 什么是SQL 结构化查询语言（Structured Query Language）简称SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。 结构化查询语言是高级的非过程化编程语言，允许用户在高层数据结构上工作。它不要求用户指定对数据的存放方法，也不需要用户了解具体的数据存放方式，所以具有完全不同底层结构的不同数据库系统, 可以使用相同的结构化查询语言作为数据输入与管理的接口。结构化查询语言语句可以嵌套，这使它具有极大的灵活性和强大的功能。 SQL的分类 DQL 数据查询语言（Data Query Language, DQL）是SQL语言中，负责进行数据查询而不会对数据本身进行修改的语句，这是最基本的SQL语句。保留字SELECT是DQL（也是所有SQL）用得最多的动词，其他DQL常用的保留字有FROM，WHERE，GROUP BY，HAVING和ORDER BY。这些DQL保留字常与其他类型的SQL语句一起使用。 DDL 数据定义语言 (Data Definition Language, DDL) 是SQL语言集中，负责数据结构定义与数据库对象定义的语言，由CREATE、ALTER与DROP三个语法所组成，最早是由 Codasyl (Conference on Data Systems Languages) 数据模型开始，现在被纳入 SQL 指令中作为其中一个子集。 DML 数据操纵语言（Data Manipulation Language, DML）是SQL语言中，负责对数据库对象运行数据访问工作的指令集，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入、更新与删除。 DCL 数据控制语言 (Data Control Language) 在SQL语言中，是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。由 GRANT 和 REVOKE 两个指令组成。DCL以控制用户的访问权限为主，GRANT为授权语句，对应的REVOKE是撤销授权语句。 TPL 数据事务管理语言（Transaction Processing Language）它的语句能确保被DML语句影响的表的所有行及时得以更新。TPL语句包括BEGIN TRANSACTION，COMMIT和ROLLBACK。 CCL 指针控制语言（Cursor Control Language），它的语句，像DECLARE CURSOR，FETCH INTO和UPDATE WHERE CURRENT用于对一个或多个表单独行的操作。 DBMS、SQL、DB之间的关系 DBMS通过执行SQL来操作DB中的数据。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://xiaofanshutu.github.io/categories/MySQL/"}],"tags":[]},{"title":"MySQL数据库安装","slug":"动力节点MySQL/第02章 MySQL的安装","date":"2025-06-29T23:08:23.981Z","updated":"2025-06-30T14:07:52.359Z","comments":true,"path":"posts/1bbb3b3c.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/1bbb3b3c.html","excerpt":"MySQL概述 MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，MySQL AB公司被Sun公司收购，Sun公司又被Oracle公司收购，目前属于Oracle公司。 MySQL是目前最流行的关系型数据库管理系统，在WEB应用方面MySQL是最好的RDBMS应用软件之一。 国内淘宝网站就使用的是MySQL集群。 MySQL特点 MySQL有开源版本和收费版本，你使用开源版本是不收费的。 MySQL支持大型数据库，可以处理上千万记录的大型数据库。 MySQL使用标准的SQL数据库语言形式。 MySQL在很多系统上面都支持。 MySQL对Java，C都有很好的支持，当然其他的语言也支持比如Python、PHP。 MySQL是可以定制的，采用了GPL协议，你可以修改源码来开发自己的MySQL系统。 MySQL的下载官网下载 第一步：打开MySQL官网https://www.mysql.com/ 第二步：点击”DOWNLOADS”","text":"MySQL概述 MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，MySQL AB公司被Sun公司收购，Sun公司又被Oracle公司收购，目前属于Oracle公司。 MySQL是目前最流行的关系型数据库管理系统，在WEB应用方面MySQL是最好的RDBMS应用软件之一。 国内淘宝网站就使用的是MySQL集群。 MySQL特点 MySQL有开源版本和收费版本，你使用开源版本是不收费的。 MySQL支持大型数据库，可以处理上千万记录的大型数据库。 MySQL使用标准的SQL数据库语言形式。 MySQL在很多系统上面都支持。 MySQL对Java，C都有很好的支持，当然其他的语言也支持比如Python、PHP。 MySQL是可以定制的，采用了GPL协议，你可以修改源码来开发自己的MySQL系统。 MySQL的下载官网下载 第一步：打开MySQL官网https://www.mysql.com/ 第二步：点击”DOWNLOADS” 第三步：当前页继续下拉，直到找到下图链接 第四步：点击上图链接，进入下面页面，其中“MySQL Community Server”是解压版mysql，“MySQL Installer for Windows”是安装版，这里我们选择解压版 第五步：点击上图“MySQL Community Server” 第六步：点击上图第1个“Download” 第七步：点击上图“No thanks, just start my download.”开始下载，直到下载完毕。 网盘下载链接：https://pan.baidu.com/s/1lRWC069K8GE-8rxr259ArQ?pwd=2009 提取码：2009 MySQL安装与配置 将下载的zip压缩包解压，我这里直接解压到C盘的根目录下 mysql的根目录为：C:\\mysql-8.0.24-winx64 将C:\\mysql-8.0.24-winx64\\bin目录配置到环境变量path当中 初始化data目录 使用管理员身份打开dos命令窗口（按win键，输入cmd，点击管理员身份运行） cd命令切换到mysql的bin目录下，执行mysqld –initialize –console进行data目录初始化，此时会在控制台生成一个随机密码，下图红框中就是随机密码 技巧：左键选中密码，直接点击右键，此时密码已经复制到剪贴板中了，然后随便找一个文件，将密码粘贴到文件中保存起来。 安装MySQL服务：cd命令切换到bin目录下，执行命令mysqld -install 查看mysql服务名称：此电脑-右键-管理-服务和应用程序-服务-找MySQL服务，如下图mysql服务名称：MySQL 启动MySQL服务：net start mysql，注意start后面是mysql服务的名称 停止mysql服务的命令：net stop mysql注意：启停mysql服务也可以在上一步的图中点击右键进行启停服务。 登录mysql：输入mysql -uroot -p，然后回车，输入刚才的随机密码，然后回车，看到下图表示成功登录mysql 修改MySQL的root账户密码：ALTER USER ‘root’@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘新密码’; 使用新密码登录mysql MySQL卸载 停止mysql的服务 删除mysql服务 删除mysql的目录 登录MySQL本地登录 如果mysql的服务是启动的，打开dos命令窗口，输入：mysql -uroot -p，回车，然后输入root账户的密码 解释“mysql -uroot -p”：mysql是一个命令，在bin目录下，对应的命令文件是mysql.exe，如果将bin目录配置到环境变量path中，才可以在以上位置使用该命令。-uroot 表示登录的用户是root，u实际上是user单词的首字母。-p 表示登录时使用密码，p实际上是password单词的首字母。 也可以将密码以明文的形式写到-p后面，这样做可能会导致你的密码泄露 远程登录 假设mysql安装在A机器上，现在你要在B机器上连接mysql数据库，此时需要使用远程登录，远程登录时加上远程机器的ip地址即可 -h中的h实际上是host单词的首字母。在-h后面的是远程计算机的ip地址。127.0.0.1是计算机默认的本机IP地址。127.0.0.1又可以写作：localhost，他们是等效的。注意：mysql默认情况下root账户是不支持远程登录的，其实这是一种安全策略，为了保护root账户的安全。如果希望root账户支持远程登录，这是需要进行设置的。 mysql8 开放root账户远程登录权限（危险动作） 第一步：现在本地使用root账户登录mysql 第二步：use mysql; 第三步：update user set host = ‘%’ where user = ‘root’; 第四步：flush privileges;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://xiaofanshutu.github.io/categories/MySQL/"}],"tags":[]},{"title":"MySQL初始化数据","slug":"动力节点MySQL/第03章 初始化数据","date":"2025-06-29T23:08:23.981Z","updated":"2025-06-30T14:17:31.084Z","comments":true,"path":"posts/f4fc1fe7.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/f4fc1fe7.html","excerpt":"MySQL命令行基本命令 列出当前数据库管理系统中有哪些数据库。1show databases; 创建数据库，起名bjpowernode。 1create database bjpowernode1; 使用bjpowernode数据库。 1use bjpowernode; 查看当前用的是哪个数据库。 1select database(); 查看当前数据库中有哪些表。 1show tables; 删除数据库bjpowernode。 1drop database bjpowernode; 退出mysql exit quit ctrl + c 查看当前mysql版本 1select version(); 还可以使用mysql.exe命令来查看版本信息（在没有登录mysql之前使用）：mysql –version 数据库表的概述 name age gender 张三 20 男 李四 22 女","text":"MySQL命令行基本命令 列出当前数据库管理系统中有哪些数据库。1show databases; 创建数据库，起名bjpowernode。 1create database bjpowernode1; 使用bjpowernode数据库。 1use bjpowernode; 查看当前用的是哪个数据库。 1select database(); 查看当前数据库中有哪些表。 1show tables; 删除数据库bjpowernode。 1drop database bjpowernode; 退出mysql exit quit ctrl + c 查看当前mysql版本 1select version(); 还可以使用mysql.exe命令来查看版本信息（在没有登录mysql之前使用）：mysql –version 数据库表的概述 name age gender 张三 20 男 李四 22 女 以上就是数据库表格的直观展示形式。 表格英文单词table。 表是数据库存储数据的基本单元，数据库存储数据的时候，是将数据存储在表对象当中的。为什么将数据存储在表中呢？因为表存储数据非常直观。 任何一张表都有行和列： 行：记录（一行就是一条数据） 列：字段（name字段、age字段、gender字段） 每个字段包含以下属性： 字段名：name、age、gender都是字段的名字 字段的数据类型：每个字段都有数据类型，比如：字符类型、数字类型、日期类型 字段的数据长度：每个字段有可能会有长度的限制 字段的约束：比如某些字段要求该字段下的数据不能重复、不能为空等，用来保证表格中数据合法有效 初始化测试数据为了方便后面内容的学习，老师提前准备了表以及表中的测试数据，以下是建表并且初始化数据的sql脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051DROP TABLE IF EXISTS EMP;DROP TABLE IF EXISTS DEPT;DROP TABLE IF EXISTS SALGRADE;CREATE TABLE DEPT(DEPTNO int(2) not null , DNAME VARCHAR(14) , LOC VARCHAR(13), primary key (DEPTNO));CREATE TABLE EMP(EMPNO int(4) not null , ENAME VARCHAR(10), JOB VARCHAR(9), MGR INT(4), HIREDATE DATE DEFAULT NULL, SAL DOUBLE(7,2), COMM DOUBLE(7,2), primary key (EMPNO), DEPTNO INT(2) );CREATE TABLE SALGRADE( GRADE INT, LOSAL INT, HISAL INT);INSERT INTO DEPT ( DEPTNO, DNAME, LOC ) VALUES ( 10, 'ACCOUNTING', 'NEW YORK'); INSERT INTO DEPT ( DEPTNO, DNAME, LOC ) VALUES ( 20, 'RESEARCH', 'DALLAS'); INSERT INTO DEPT ( DEPTNO, DNAME, LOC ) VALUES ( 30, 'SALES', 'CHICAGO'); INSERT INTO DEPT ( DEPTNO, DNAME, LOC ) VALUES ( 40, 'OPERATIONS', 'BOSTON'); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7369, 'SMITH', 'CLERK', 7902, '1980-12-17', 800, NULL, 20); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7499, 'ALLEN', 'SALESMAN', 7698, '1981-02-20', 1600, 300, 30); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7521, 'WARD', 'SALESMAN', 7698, '1981-02-22', 1250, 500, 30); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7566, 'JONES', 'MANAGER', 7839, '1981-04-02', 2975, NULL, 20); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7654, 'MARTIN', 'SALESMAN', 7698, '1981-09-28', 1250, 1400, 30); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7698, 'BLAKE', 'MANAGER', 7839, '1981-05-01', 2850, NULL, 30); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7782, 'CLARK', 'MANAGER', 7839, '1981-06-09', 2450, NULL, 10); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7788, 'SCOTT', 'ANALYST', 7566, '1987-04-19', 3000, NULL, 20); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7839, 'KING', 'PRESIDENT', NULL, '1981-11-17', 5000, NULL, 10); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7844, 'TURNER', 'SALESMAN', 7698, '1981-09-08', 1500, 0, 30); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7876, 'ADAMS', 'CLERK', 7788, '1987-05-23', 1100, NULL, 20); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7900, 'JAMES', 'CLERK', 7698, '1981-12-03', 950, NULL, 30); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7902, 'FORD', 'ANALYST', 7566, '1981-12-03', 3000, NULL, 20); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7934, 'MILLER', 'CLERK', 7782, '1982-01-23', 1300, NULL, 10); INSERT INTO SALGRADE ( GRADE, LOSAL, HISAL ) VALUES ( 1, 700, 1200); INSERT INTO SALGRADE ( GRADE, LOSAL, HISAL ) VALUES ( 2, 1201, 1400); INSERT INTO SALGRADE ( GRADE, LOSAL, HISAL ) VALUES ( 3, 1401, 2000); INSERT INTO SALGRADE ( GRADE, LOSAL, HISAL ) VALUES ( 4, 2001, 3000); INSERT INTO SALGRADE ( GRADE, LOSAL, HISAL ) VALUES ( 5, 3001, 9999); commit; 什么是sql脚本：文件名是.sql，并且该文件中编写了大量的SQL语句，执行sql脚本程序就相当于批量执行SQL语句。 你入职的时候，项目一般都是进展了一部分，多数情况下你进项目组的时候数据库的表以及数据都是有的，项目经理第一天可能会给你一个较大的sql脚本文件，你需要执行这个脚本文件来初始化你的本地数据库。（当然，也有可能数据库是共享的。） 创建文件：bjpowernode.sql，把以上SQL语句全部复制到sql脚本文件中。 执行SQL脚本文件，初始化数据库 第一步：命令窗口登录mysql 第二步：创建数据库bjpowernode（如果之前已经创建就不需要再创建了）：create database bjpowernode; 第三步：使用数据库bjpowernode：use bjpowernode; 第四步：source命令执行sql脚本，注意：source命令后面是sql脚本文件的绝对路径。 &nbsp; 第五步：查看是否初始化成功，执行：show tables; &nbsp; 使用其他的mysql客户端工具也可以执行sql脚本，比如navicat。使用source命令执行sql脚本的优点：可支持大文件。 熟悉测试数据emp dept salgrade三张表分别存储什么信息 emp：员工信息 dept：部门信息 salgrade：工资等级信息 查看表结构：desc或describe，语法格式：desc或describe +表名以上的结果展示的不是表中的数据，而是表的结构。 Field是字段名 Type是这个字段的数据类型 Null是这个字段是否允许为空 Key是这个字段是否为主键或外键 Default是这个字段的默认值 对以上表结构进行解释说明： emp表 empno：员工编号，int类型（整数），不能为空，主键（主键后期学习约束时会进行说明） ename：员工姓名，varchar类型（字符串） job：工作岗位，varchar类型 mgr：上级领导编号，int类型 hiredate：雇佣日期，date类型（日期类型） sal：月薪，double类型（带有浮点的数字） comm：补助津贴，double类型 deptno：部门编号，int类型 dept表 deptno：部门编号，int类型，主键 dname：部门名称，varchar类型 loc：位置，varchar类型 salgrade表 grade：等级，int类型 losal：最低工资，int类型 hisal：最高工资，int类型 对于以上表结构要提前了解，后面学习的内容需要你马上反应出：哪个字段是什么意思。查看一下表中的数据，来加深一下印象（以下SQL语句会在后面课程中学习）：","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://xiaofanshutu.github.io/categories/MySQL/"}],"tags":[]},{"title":"MySQL查询DQL专题","slug":"动力节点MySQL/第04章 查询DQL专题","date":"2025-06-29T23:08:23.976Z","updated":"2025-06-30T23:15:59.024Z","comments":true,"path":"posts/5d301c0f.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/5d301c0f.html","excerpt":"简单查询查询是SQL语言的核心，用于表达SQL查询的select查询命令是功能最强也是最为复杂的SQL语句，它的作用就是从数据库中检索数据，并将查询结果返回给用户。 select语句由：select子句(查询内容)、from子句(查询对象)、where子句(查询条件)、order by子句(排序方式)、group by子句(分组方式)等组成。查询语句属于SQL语句中的DQL语句，是所有SQL语句中最为复杂也是最重要的语句，所以必须掌握。接下来我们先从简单查询语句开始学习。 查一个字段查询一个字段说的是：一个表有多列，查询其中的一列。语法格式：select 字段名 from 表名; select和from是关键字，不能随便写 一条SQL语句必须以“;”结尾 对于SQL语句来说，大小写都可以 字段名和表名属于标识符，按照表的实际情况填写，不知道字段名的，可以使用desc命令查看表结构 案例1：查询公司中所有员工编号 1select empno from emp; 案例2：查询公司中所有员工姓名 1SELECT ENAME FROM EMP;","text":"简单查询查询是SQL语言的核心，用于表达SQL查询的select查询命令是功能最强也是最为复杂的SQL语句，它的作用就是从数据库中检索数据，并将查询结果返回给用户。 select语句由：select子句(查询内容)、from子句(查询对象)、where子句(查询条件)、order by子句(排序方式)、group by子句(分组方式)等组成。查询语句属于SQL语句中的DQL语句，是所有SQL语句中最为复杂也是最重要的语句，所以必须掌握。接下来我们先从简单查询语句开始学习。 查一个字段查询一个字段说的是：一个表有多列，查询其中的一列。语法格式：select 字段名 from 表名; select和from是关键字，不能随便写 一条SQL语句必须以“;”结尾 对于SQL语句来说，大小写都可以 字段名和表名属于标识符，按照表的实际情况填写，不知道字段名的，可以使用desc命令查看表结构 案例1：查询公司中所有员工编号 1select empno from emp; 案例2：查询公司中所有员工姓名 1SELECT ENAME FROM EMP; 在mysql命令行客户端中，sql语句没有分号是不会执行的：末尾加上“;”就执行了：以上sql虽然以分号结尾之后执行了，但是报错了，错误信息显示：语法错误。假设一个SQL语句在书写过程中出错了，怎么终止这条SQL呢？\\c 任务1：查询所有部门名称。 任务2：查询所有薪资等级。 查多个字段查询多个字段时，在字段名和字段名之间添加“,”即可。语法格式：select 字段名1,字段名2,字段名3 from 表名;案例1：查询员工编号以及员工姓名。 1select empno, ename from emp; 字段的前后顺序无所谓（只是显示结果列的时候顺序变了)： 1select ename, empno from emp; 任务1：查询部门编号、部门名称以及位置。 任务2：查询员工的名字以及工作岗位。 查所有字段查询所有字段的可以将每个字段都列出来查询，也可以采用“*”来代表所有字段案例1：查询员工的所有信息 1select * from emp; 案例2：查询所有部门信息 1select * from dept; 采用“*”进行查询存在的缺点： select * from dept; 在执行的时候会被解析为 select DEPTNO, DNAME, LOC from dept; 再执行，所以这种效率方面弱一些。 采用“”的可读性较差，通过“”很难看出都有哪些具体的字段。 什么时候使用“*”？ 这个SQL语句不在项目编码中使用，如果平时自己想快速查看表中所有数据的话，这种写法还是很给力的。 任务1：查询所有的薪资等级以及每个薪资等级的最低工资和最高工资。 查询时字段可参与数学运算在进行查询操作的时候，字段是可以参与数学运算的，例如加减乘除等。案例1：查询每个员工的月薪 1select ename, sal from emp; 案例2：查询每个员工的年薪（月薪 * 12) 1select ename, sal * 12 from emp; 任务1：查询每个员工月薪加1000之后的月薪 任务2：查询每个员工月薪加1000之后的年薪 查询时字段可起别名我们借用一下之前的SQL语句 1select ename, sal * 12 from emp; 以上的查询结果列名“sal * 12”可读性较差，是否可以给查询结果的列名进行重命名呢？ as关键字 使用as关键字1select ename, sal * 12 as yearsal from emp; 通过as关键字起别名后，查询结果列显示yearsal，可读性增强。 省略as关键字 其实as关键字可以省略，只要使用空格即可 1select ename, sal * 12 yearsal from emp; 通过以上测试，得知as可以省略，可以使用空格代替as，但如果别名中有空格呢？ 别名中有空格1select ename, sal * 12 year sal from emp; 可以看出，执行报错了，说语法有问题，这是为什么？分析一下：SQL语句编译器在检查该语句的时候，在year后面遇到了空格，会继续找from关键字，但year后面不是from关键字，所以编译器报错了。怎么解决这个问题？记住：如果别名中有空格的话，可以将这个别名使用双引号或者单引号将其括起来。 12select ename, sal * 12 \"year sal\" from emp;select ename, sal * 12 'year sal' from emp; 在mysql中，字符串既可以使用双引号也可以使用单引号，但还是建议使用单引号，因为单引号属于标准SQL。 别名中有中文 如果别名采用中文呢？1select ename, sal * 12 年薪 from emp; 别名是中文是可以的，但是对于低版本的mysql来说会报错，需要添加双引号或单引号。我们当前使用的mysql版本是：8.0.24 任务：查询所有员工的信息，要求每个字段名采用中文显示。 条件查询通常在进行查询操作的时候，都是查询符合某些条件的数据，很少将表中所有数据都取出来。怎么取出表的部分数据？需要在查询语句中添加条件进行数据的过滤。常见的过滤条件如下： 条件 说明 = 等于 &lt;&gt;或!= 不等于 &gt;= 大于等于 &lt;= 小于等于 &gt; 大于 &lt; 小于 between…and… 等同于 &gt;= and &lt;= is null 为空 is not null 不为空 &lt;=&gt; 安全等于（可读性差，很少使用了）。 and 或 &amp;&amp; 并且 or 或 || 或者 in 在指定的值当中 not in 不在指定的值当中 exists not exists like 模糊查询 条件查询语法格式123456select ...from ...where 过滤条件; 过滤条件放在where子句当中，以上语句的执行顺序是： 第一步：先执行from 第二步：再通过where条件过滤 第三步：最后执行select，查询并将结果展示到控制台 等于、不等于等于 =判断等量关系，支持多种数据类型，比如：数字、字符串、日期等。案例1：查询月薪3000的员工编号及姓名 123456select empno,enamefrom empwhere sal = 3000; 案例2：查询员工FORD的岗位及月薪 123456select job, salfrom empwhere ename = 'FORD'; 存储在表emp中的员工姓名是FORD，全部大写，如果在查询的时候，写成全部小写会怎样呢？ 123456select job, salfrom empwhere ename = 'ford'; 通过测试发现，即使写成小写ford，也是可以查询到结果的，不过这里需要注意的是：在Oracle数据库当中是查询不到数据的，Oracle的语法要比MySQL的语法严谨。对于SQL语句本身来说是不区分大小写的，但是对于表中真实存储的数据，大写A和小写a还是不一样的，这一点Oracle做的很好。MySQL的语法更随性。另外在Oracle当中，字符串是必须使用单引号括起来的，但在MySQL当中，字符串可以使用单引号，也可以使用双引号，如下： 123456select job, salfrom empwhere ename = \"FORD\"; 案例3：查询岗位是MANAGER的员工编号及姓名 123456select empno, enamefrom empwhere job = 'MANAGER'; 任务：查询工资级别是1的最低工资以及最高工资 不等于 &lt;&gt; 或 !=判断非等量关系，支持字符串、数字、日期类型等。不等号有两种写法，第一种&lt;&gt;，第二种!=，第二种写法和Java程序中的不等号相同，第一种写法比较诡异，不过也很好理解，比如&lt;&gt;3，表示小于3、大于3，就是不等于3。你get到了吗？案例1：查询工资不是3000的员工编号、姓名、薪资 123456select empno,ename,salfrom empwhere sal &lt;&gt; 3000; 案例2：查询工作岗位不是MANAGER的员工姓名和岗位 123456select ename,jobfrom empwhere job &lt;&gt; 'MANAGER'; 任务：查询不在部门编号为10的部门工作的员工信息 大于、大于等于、小于、小于等于大于 &gt;案例：找出薪资大于3000的员工姓名、薪资 123456select ename, salfrom empwhere sal &gt; 3000; 大于等于 &gt;=案例：找出薪资大于等于3000的员工姓名、薪资 123456select ename, salfrom empwhere sal &gt;= 3000; 小于 &lt;案例：找出薪资小于3000的员工姓名、薪资 123456select ename, salfrom empwhere sal &lt; 3000; 小于等于 &lt;=案例：找出薪资小于等于3000的员工姓名、薪资 123456select ename, salfrom empwhere sal &lt;= 3000; andand表示并且，还有另一种写法：&amp;&amp;案例：找出薪资大于等于3000并且小于等于5000的员工姓名、薪资。 123456select ename,salfrom empwhere sal &gt;= 3000 and sal &lt;= 5000; 任务：找出工资级别为2~4（包含2和4）的最低工资和最高工资。 oror表示或者，还有另一种写法：||案例：找出工作岗位是MANAGER和SALESMAN的员工姓名、工作岗位 123456select ename, jobfrom empwhere job = 'MANAGER' or job = 'SALESMAN'; 注意：这个题目描述中有这样一句话：MANAGER和SALESMAN，有的同学一看到“和”，就直接使用“and”了，因为“和”对应的英文单词是“and”，如果是这样的话，就大错特错了，因为and表示并且，使用and表示工作岗位既是MANAGER又是SALESMAN的员工，这样的员工是不存在的，因为每一个员工只有一个岗位，不可能同时从事两个岗位。所以使用and是查询不到任何结果的。如下 123456select ename, jobfrom empwhere job = 'MANAGER' and job = 'SALESMAN'; 任务：查询20和30部门的员工信息。 and和or的优先级问题and和or同时出现时，and优先级较高，会先执行，如果希望or先执行，这个时候需要给or条件添加小括号。另外，以后遇到不确定的优先级时，可以通过添加小括号的方式来解决。对于优先级问题没必要记忆。案例：找出薪资小于1500，并且部门编号是20或30的员工姓名、薪资、部门编号。先来看一下错误写法： 123456select ename,sal,deptnofrom empwhere sal &lt; 1500 and deptno = 20 or deptno = 30; 认真解读题意得知：薪资小于1500是一个大前提，要找出的是薪资小于1500的，满足这个条件的前提下，再找部门编号是20或30的，显然以上的运行结果中出现了薪资为1600的，为什么1600的会出现呢？这是因为“sal &lt; 1500 and deptno = 20”结合在一起了，“depnto = 30”成了一个独立的条件。会导致部门编号为30的所有员工全部查询出来。我们应该让“deptno = 20 or deptno = 30”结合在一起，正确写法如下： 123456select ename,sal,deptnofrom empwhere sal &lt; 1500 and (deptno = 20 or deptno = 30); 任务：找出薪资小于1500的，并且工作岗位是CLERK和SALESMAN的员工姓名、薪资、岗位。 between…and…between…and…等同于 &gt;= and &lt;=做区间判断的，包含左右两个边界值。它支持数字、日期、字符串等数据类型。between…and…在使用时一定是**左小右大**。左大右小时无法查询到数据。between…and… 和 &gt;= and &lt;=只是在写法结构上有区别，执行原理和效率方面没有区别。案例：找出薪资在1600到3000的员工姓名、薪资 123456select ename,salfrom empwhere sal between 1600 and 3000; 采用左大右小的方式： 123456select ename,salfrom empwhere sal between 3000 and 1600; 没有查询到任何数据，所以在使用的时候一定要注意：左小右大。 任务：查询在1982-01-23到1987-04-19之间入职的员工 注意：以上SQL语句中日期需要加上单引号。 is null、is not null判断某个数据是否为null，不能使用等号，只能使用 is null判断某个数据是否不为null，不能使用不等号，只能使用 is not null在数据库中null不是一个值，不能用等号和不等号衡量，null代表什么也没有，没有数据，没有值 is null案例1：找出津贴为空的员工姓名、薪资、津贴。 123456select ename,sal,commfrom empwhere comm is null; 我们使用等号，尝试一下： 123456select ename,sal,commfrom empwhere comm = null; 查询不到任何数据，所以判断是否为空，不能用等号。 is not null案例2：找出津贴不为空的员工姓名、薪资、津贴 123456select ename,sal,commfrom empwhere comm is not null; in、not ininjob in(‘MANAGER’,’SALESMAN’,’CLERK’) 等同于 job = ‘MANAGER’ or job = ‘SALESMAN’ or job = ‘CLERK’sal in(1600, 3000, 5000) 等同于 sal = 1600 or sal = 3000 or sal = 5000in后面有一个小括号，小括号当中有多个值，值和值之间采用逗号隔开sal in(1500, 5000)，需要注意的是：这个并不是说薪资在1500到5000之间，in不代表区间，表示sal是1500的和sal是5000的案例1：找出工作岗位是MANAGER和SALESMAN的员工姓名、薪资、工作岗位第一种：使用or 123456select ename,sal,jobfrom empwhere job = 'MANAGER' or job = 'SALESMAN'; 第二种：使用in 123456select ename,sal,jobfrom empwhere job in('MANAGER', 'SALESMAN'); 案例2：找出薪资是1500/1600/3000的员工姓名、工作岗位 123456select ename,jobfrom empwhere sal in(1500, 1600, 3000); 任务：找出部门编号是10和20的员工编号、姓名。（要求使用两种方案） not injob not in(‘MANAGER’,’SALESMAN’) 等同于 job &lt;&gt; ‘MANAGER’ and job &lt;&gt; ‘SALESMAN’sal not in(1600, 5000) 等同于 sal &lt;&gt; 1600 and sal &lt;&gt; 5000案例：找出工作岗位不是MANAGER和SALESMAN的员工姓名、工作岗位第一种：使用and 123456select ename,jobfrom empwhere job &lt;&gt; 'MANAGER' and job &lt;&gt; 'SALESMAN'; 第二种：使用not in 123456select ename,jobfrom empwhere job not in('MANAGER', 'SALESMAN'); 任务：找出薪资不是1600和3000的员工姓名、薪资。 in、not in 与 NULL先来看一下emp表中的数据 1select * from emp; 通过表中数据观察到，有4个员工的津贴不为NULL，剩下10个员工的津贴都是NULL。写这样一条SQL语句： 1select * from emp where comm in(NULL, 300); 为什么以上执行结果只有一条记录呢？分析一下：首先你要知道in的执行原理实际上是采用=和or的方式，也就是说，以上SQL语句实际上是： 1select * from emp where comm = NULL or comm = 300; 其中NULL不能用等号=进行判断，所以comm = NULL结果是false，然而中间使用的是or，所以comm = NULL被忽略了。所以查询结果就以上一条数据。通过以上的测试得知：in是自动忽略NULL的。再写这样一条SQL语句： 1select * from emp where comm not in(NULL, 300); 以上的执行结果奇怪了，为什么没有查到任何数据呢？我们分析一下：首先你要知道not in的执行原理实际上是采用&lt;&gt;和and的方式，也就是说，以上SQL语句实际上是： 1select * from emp where comm &lt;&gt; NULL and comm &lt;&gt; 300; 其中NULL的判断不能使用&lt;&gt;，所以comm &lt;&gt; NULL结果是false，由于后面是and，and表示并且，comm &lt;&gt; NULL已经是false了，所以and右边的就没必要运算了，comm &lt;&gt; NULL and comm &lt;&gt; 300的整体运算结果就是false。所以查询不到任何数据。通过以上测试得知，not in是不会自动忽略NULL的，所以在使用not in的时候一定要提前过滤掉NULL。 in和or的效率比拼在MySQL当中，如何统计一个SQL语句的执行时长？ 可以使用这个命令：show profiles; 这个命令可以查看在mysql中执行的所有SQL以及命令的耗费时长。 show profiles; 是在mysql5.0.37之后添加的。所以要确保你的mysql版本没问题。 如何开启时长统计功能：set profiling = 1; 查看时长统计功能是否开启：show variables like ‘%pro%’; 查看每条SQL的耗时：show profiles; 查看其中某条SQL耗时明细：show profile for query query_id; 查看最新一条SQL的耗时明细：show profile; 查看cpu，io等信息：show profile block io, cpu for query query_id; or的效率为O(n)，而in的效率为O(log n), 当n越大的时候效率相差越明显（也就是说数据量越大的时候，in的效率越高）。以下是测试过程：第一步，创建测试表，并生成测试数据，测试数据为1000万条记录。数据库中关闭了query cache，因此数据库缓存不会对查询造成影响。具体的代码如下： 123456789101112131415161718192021222324252627#创建测试的test表DROP TABLE IF EXISTS test; CREATE TABLE test( ID INT(10) NOT NULL, `Name` VARCHAR(20) DEFAULT '' NOT NULL, PRIMARY KEY( ID ) )ENGINE=INNODB DEFAULT CHARSET utf8; #创建生成测试数据的存储过程DROP PROCEDURE IF EXISTS pre_test; DELIMITER //CREATE PROCEDURE pre_test() BEGIN DECLARE i INT DEFAULT 0; SET autocommit = 0; WHILE i&lt;10000000 DO INSERT INTO test ( ID,`Name` ) VALUES( i, CONCAT( 'Carl', i ) ); SET i = i+1; IF i%2000 = 0 THEN COMMIT; END IF; END WHILE; END; //DELIMITER ;#执行存储过程生成测试数据CALL pre_test(); 以上SQL看不懂没关系，先执行它，进行数据初始化准备工作。第二步：分三种情况进行测试，分别是：第1种情况：in和or所在列为主键的情形。第2种情况：in和or所在列创建有索引的情形。第3种情况：in和or所在列没有索引的情形。每种情况又采用不同的in和or的数量进行测试。由于测试语句的数据量有4种情况，我这里就称为A组、B组、C组、D组，其中A组为3个值，B组为150个值，C组为300个值，D组为1000个值。具体的测试语句如下： 1234567891011121314151617181920212223#A组#in和or中有3条数据的情况SELECT * FROM test WHERE id IN (1,23,48);SELECT * FROM test WHERE id =1 OR id=23 OR id=48;#B组#in和or中有150条数据的情况SELECT * FROM test WHERE id IN (59617932,98114476,89047409,26968186,56586105,35488201,53251989,18182139,71164231,57655852,7948544,60658339,50758185,66667117,34771253,68699137,27877290,44275282,1585444,71219424,90937482,83928635,24588528,81933207,9607562,12013895,84640278,85549596,53249244,8567444,85402877,15040223,54266509,17718135,91687882,22930500,94756430,66031097,13084573,18137443,89917778,46845456,43939093,35943480,18213703,46362815,49835919,83137546,2101409,74932951,11984477,93113331,77848222,68546065,33728734,90793684,44975642,61387237,52483391,97716233,49449060,22411182,30776331,60597240,6911731,45789095,62075344,8379933,97910423,86861971,81342386,93423963,83852896,18566482,22747687,51420625,75862064,26402882,93958561,85202979,97049369,67674725,9475653,92302381,78133617,49295001,36517340,81387142,15707241,60832834,93157830,64171432,58537826,70141767,7326025,36632075,9639624,8900056,99702164,35108945,87820933,57302965,16652391,41845132,62184393,70136913,79574630,32562398,94616790,61258220,73162018,81644480,19453596,97380163,1204733,33357040,84854495,13888863,49041868,89272326,38405345,571248,6349029,70755321,79307694,60619684,92624181,73135306,23279848,95612954,55845916,6223606,43836918,37459781,67969314,99398872,7616960,37189193,50151920,62881879,12364637,33204320,27135672,28441504,47373461,87967926,30631796,20053540,18735984,83406724);SELECT * FROM test WHERE id=59617932 OR id=98114476 OR id=89047409 OR id=26968186 OR id=56586105 OR id=35488201 OR id=53251989 OR id=18182139 OR id=71164231 OR id=57655852 OR id=7948544 OR id=60658339 OR id=50758185 OR id=66667117 OR id=34771253 OR id=68699137 OR id=27877290 OR id=44275282 OR id=1585444 OR id=71219424 OR id=90937482 OR id=83928635 OR id=24588528 OR id=81933207 OR id=9607562 OR id=12013895 OR id=84640278 OR id=85549596 OR id=53249244 OR id=8567444 OR id=85402877 OR id=15040223 OR id=54266509 OR id=17718135 OR id=91687882 OR id=22930500 OR id=94756430 OR id=66031097 OR id=13084573 OR id=18137443 OR id=89917778 OR id=46845456 OR id=43939093 OR id=35943480 OR id=18213703 OR id=46362815 OR id=49835919 OR id=83137546 OR id=2101409 OR id=74932951 OR id=11984477 OR id=93113331 OR id=77848222 OR id=68546065 OR id=33728734 OR id=90793684 OR id=44975642 OR id=61387237 OR id=52483391 OR id=97716233 OR id=49449060 OR id=22411182 OR id=30776331 OR id=60597240 OR id=6911731 OR id=45789095 OR id=62075344 OR id=8379933 OR id=97910423 OR id=86861971 OR id=81342386 OR id=93423963 OR id=83852896 OR id=18566482 OR id=22747687 OR id=51420625 OR id=75862064 OR id=26402882 OR id=93958561 OR id=85202979 OR id=97049369 OR id=67674725 OR id=9475653 OR id=92302381 OR id=78133617 OR id=49295001 OR id=36517340 OR id=81387142 OR id=15707241 OR id=60832834 OR id=93157830 OR id=64171432 OR id=58537826 OR id=70141767 OR id=7326025 OR id=36632075 OR id=9639624 OR id=8900056 OR id=99702164 OR id=35108945 OR id=87820933 OR id=57302965 OR id=16652391 OR id=41845132 OR id=62184393 OR id=70136913 OR id=79574630 OR id=32562398 OR id=94616790 OR id=61258220 OR id=73162018 OR id=81644480 OR id=19453596 OR id=97380163 OR id=1204733 OR id=33357040 OR id=84854495 OR id=13888863 OR id=49041868 OR id=89272326 OR id=38405345 OR id=571248 OR id=6349029 OR id=70755321 OR id=79307694 OR id=60619684 OR id=92624181 OR id=73135306 OR id=23279848 OR id=95612954 OR id=55845916 OR id=6223606 OR id=43836918 OR id=37459781 OR id=67969314 OR id=99398872 OR id=7616960 OR id=37189193 OR id=50151920 OR id=62881879 OR id=12364637 OR id=33204320 OR id=27135672 OR id=28441504 OR id=47373461 OR id=87967926 OR id=30631796 OR id=20053540 OR id=18735984 OR id=83406724;#C组#in和or中有300条数据的情况SELECT * FROM test WHERE id IN (37092877,94859722,74276090,8763830,38727241,95732954,93414819,55070016,3591352,73857925,92290525,15210159,83905516,54934589,83004136,31442143,6060569,22209206,27649629,11464943,77822402,28714780,10058522,62252663,13751461,38997875,47320577,64507359,36137908,54297630,97411161,56542672,22017966,55190708,70072386,24300664,93413617,23621629,74772508,62774612,43001947,46161388,85563006,70177147,63960440,18001207,81734850,10635060,6551152,54877885,44426798,73950635,18713144,21690065,82153543,26048520,79954773,22411093,97307339,74193176,1413532,88006544,36062746,24043946,17132007,95958217,26112542,27303972,17247403,56778979,60928031,69369613,90584759,86234538,41726089,25315005,27568726,25091624,15307765,83130887,42726438,75872353,18991223,47819224,75457713,54659391,54889687,65229322,17124556,38376043,1989975,45973571,48597804,58632319,43388664,97010450,94745635,13217373,40472912,40220510,58319808,48228318,48936085,86281500,65466706,96815281,11751559,50188155,76649755,35315411,20360954,17739218,10918461,51429591,41447650,65170472,26810295,80912347,17157209,75851858,61150903,4408208,61200404,6655467,66863737,51549112,61951371,14368308,14663119,8762531,31765056,30560647,41048147,95526521,94929131,56881239,79014587,62705983,15892901,66151473,98846144,79336731,35949035,26250054,97536202,40575682,6965144,91059908,97939380,30854180,1965937,17193347,76584991,70467475,6559872,97386594,13939914,20379091,84906436,45989448,17337270,4949675,96963499,12561575,77153018,73213368,68283041,33977574,86290771,70381017,73095085,454900,44614195,48171334,49603342,7430998,29447060,47643508,82393912,83169846,94256496,35275444,40024984,25377535,46571333,32510994,70927802,92017916,97302502,22859741,32726786,79071601,93977472,47409421,49311618,77366144,84838598,59401507,67110877,42075938,76962007,27984930,72982484,81363683,75017478,88624177,67220235,88290070,26311443,87681081,77960250,4996033,68448074,67762279,99650583,36766422,27233152,71436659,25428777,81481679,51070397,88351803,78755075,26783938,83610840,45650662,86305644,1717314,66176062,6507047,45084786,74402982,55661367,35721238,40424913,24294239,30223531,55367671,56777532,12604154,4870493,14750488,74039611,42549918,70710424,56247316,63002053,71117605,16510883,67417211,34057637,74185092,58603491,66987830,73584171,9178319,47096502,1554825,37756804,85168245,92690138,6120773,99586029,74696745,61803307,56631845,42681796,58965644,68703695,69660559,15879062,26713059,85186928,63117471,53007808,74576547,32187857,13701205,88645881,24507258,87453800,39624977,75862710,62419627,70804059,10461373,18265782,56366177,68093007,75760763,43931574,65808002,49148775,98019987,71183123,53762434,78851856,37767085,89124453,47566746);SELECT * FROM test WHERE id=37092877 OR id=94859722 OR id=74276090 OR id=8763830 OR id=38727241 OR id=95732954 OR id=93414819 OR id=55070016 OR id=3591352 OR id=73857925 OR id=92290525 OR id=15210159 OR id=83905516 OR id=54934589 OR id=83004136 OR id=31442143 OR id=6060569 OR id=22209206 OR id=27649629 OR id=11464943 OR id=77822402 OR id=28714780 OR id=10058522 OR id=62252663 OR id=13751461 OR id=38997875 OR id=47320577 OR id=64507359 OR id=36137908 OR id=54297630 OR id=97411161 OR id=56542672 OR id=22017966 OR id=55190708 OR id=70072386 OR id=24300664 OR id=93413617 OR id=23621629 OR id=74772508 OR id=62774612 OR id=43001947 OR id=46161388 OR id=85563006 OR id=70177147 OR id=63960440 OR id=18001207 OR id=81734850 OR id=10635060 OR id=6551152 OR id=54877885 OR id=44426798 OR id=73950635 OR id=18713144 OR id=21690065 OR id=82153543 OR id=26048520 OR id=79954773 OR id=22411093 OR id=97307339 OR id=74193176 OR id=1413532 OR id=88006544 OR id=36062746 OR id=24043946 OR id=17132007 OR id=95958217 OR id=26112542 OR id=27303972 OR id=17247403 OR id=56778979 OR id=60928031 OR id=69369613 OR id=90584759 OR id=86234538 OR id=41726089 OR id=25315005 OR id=27568726 OR id=25091624 OR id=15307765 OR id=83130887 OR id=42726438 OR id=75872353 OR id=18991223 OR id=47819224 OR id=75457713 OR id=54659391 OR id=54889687 OR id=65229322 OR id=17124556 OR id=38376043 OR id=1989975 OR id=45973571 OR id=48597804 OR id=58632319 OR id=43388664 OR id=97010450 OR id=94745635 OR id=13217373 OR id=40472912 OR id=40220510 OR id=58319808 OR id=48228318 OR id=48936085 OR id=86281500 OR id=65466706 OR id=96815281 OR id=11751559 OR id=50188155 OR id=76649755 OR id=35315411 OR id=20360954 OR id=17739218 OR id=10918461 OR id=51429591 OR id=41447650 OR id=65170472 OR id=26810295 OR id=80912347 OR id=17157209 OR id=75851858 OR id=61150903 OR id=4408208 OR id=61200404 OR id=6655467 OR id=66863737 OR id=51549112 OR id=61951371 OR id=14368308 OR id=14663119 OR id=8762531 OR id=31765056 OR id=30560647 OR id=41048147 OR id=95526521 OR id=94929131 OR id=56881239 OR id=79014587 OR id=62705983 OR id=15892901 OR id=66151473 OR id=98846144 OR id=79336731 OR id=35949035 OR id=26250054 OR id=97536202 OR id=40575682 OR id=6965144 OR id=91059908 OR id=97939380 OR id=30854180 OR id=1965937 OR id=17193347 OR id=76584991 OR id=70467475 OR id=6559872 OR id=97386594 OR id=13939914 OR id=20379091 OR id=84906436 OR id=45989448 OR id=17337270 OR id=4949675 OR id=96963499 OR id=12561575 OR id=77153018 OR id=73213368 OR id=68283041 OR id=33977574 OR id=86290771 OR id=70381017 OR id=73095085 OR id=454900 OR id=44614195 OR id=48171334 OR id=49603342 OR id=7430998 OR id=29447060 OR id=47643508 OR id=82393912 OR id=83169846 OR id=94256496 OR id=35275444 OR id=40024984 OR id=25377535 OR id=46571333 OR id=32510994 OR id=70927802 OR id=92017916 OR id=97302502 OR id=22859741 OR id=32726786 OR id=79071601 OR id=93977472 OR id=47409421 OR id=49311618 OR id=77366144 OR id=84838598 OR id=59401507 OR id=67110877 OR id=42075938 OR id=76962007 OR id=27984930 OR id=72982484 OR id=81363683 OR id=75017478 OR id=88624177 OR id=67220235 OR id=88290070 OR id=26311443 OR id=87681081 OR id=77960250 OR id=4996033 OR id=68448074 OR id=67762279 OR id=99650583 OR id=36766422 OR id=27233152 OR id=71436659 OR id=25428777 OR id=81481679 OR id=51070397 OR id=88351803 OR id=78755075 OR id=26783938 OR id=83610840 OR id=45650662 OR id=86305644 OR id=1717314 OR id=66176062 OR id=6507047 OR id=45084786 OR id=74402982 OR id=55661367 OR id=35721238 OR id=40424913 OR id=24294239 OR id=30223531 OR id=55367671 OR id=56777532 OR id=12604154 OR id=4870493 OR id=14750488 OR id=74039611 OR id=42549918 OR id=70710424 OR id=56247316 OR id=63002053 OR id=71117605 OR id=16510883 OR id=67417211 OR id=34057637 OR id=74185092 OR id=58603491 OR id=66987830 OR id=73584171 OR id=9178319 OR id=47096502 OR id=1554825 OR id=37756804 OR id=85168245 OR id=92690138 OR id=6120773 OR id=99586029 OR id=74696745 OR id=61803307 OR id=56631845 OR id=42681796 OR id=58965644 OR id=68703695 OR id=69660559 OR id=15879062 OR id=26713059 OR id=85186928 OR id=63117471 OR id=53007808 OR id=74576547 OR id=32187857 OR id=13701205 OR id=88645881 OR id=24507258 OR id=87453800 OR id=39624977 OR id=75862710 OR id=62419627 OR id=70804059 OR id=10461373 OR id=18265782 OR id=56366177 OR id=68093007 OR id=75760763 OR id=43931574 OR id=65808002 OR id=49148775 OR id=98019987 OR id=71183123 OR id=53762434 OR id=78851856 OR id=37767085 OR id=89124453 OR id=47566746;#D组#in和or中有1000条数据的情况SELECT * FROM test WHERE id IN (93674701,9720356,31732184,53855095,33144472,71864888,27541768,27238726,83648428,12942332,26918445,19781953,81861032,74800064,12286132,6624397,64942581,70512799,46356598,88292448,87069909,38175756,98121997,62570414,15900806,51527968,89092372,8084203,53772848,78871524,3608561,85909562,41702172,61800503,57877634,93407278,30824340,13159046,49055339,73058078,983603,73571456,51694978,75136628,82716874,83551181,7964224,47505945,92695321,15885152,79282709,18572099,27392970,14552787,19848227,4518183,11773920,22285326,71605145,2402625,63365854,70973600,10584706,83688869,84268419,6026005,36545233,24462648,19293921,17561083,52105483,59243514,35230465,34650779,30053489,24225251,59642405,81933853,94495716,26364324,25980634,5579237,14569289,89417845,71178959,4143920,20467990,53316808,21288525,82249537,37737589,44712689,36788133,15668654,4697556,63785060,11555169,36401204,92276179,4135929,75453019,28231031,8649240,11576980,20262028,56242424,11305608,5655216,90240601,28569373,5296027,10739594,72751648,22531251,12535926,36347415,19740655,69125465,7523885,88128548,88830806,25010302,29411467,99614288,32646290,16592563,69036910,32604729,88737786,90169676,57646877,72105460,40027541,70362483,37221415,25284914,69691185,17972978,1544661,47324366,25337670,91133621,63697117,48652228,18538437,79966496,26066529,65334307,8305141,86289387,20178085,88836090,74948034,14101728,7837868,83548120,65602502,83129211,24785681,65000269,49140174,62636621,31096695,52276400,28546681,83631937,57100225,42531528,28326396,38641032,93055463,20525612,66073509,35154065,29007664,12600294,76829494,73917074,67226149,12478806,39842542,70312958,82792046,49668650,46280815,96555182,22966062,83158116,87566530,66277804,7944142,90649884,64342810,9881875,14833854,82959569,50523207,48788762,3801076,14677723,63080506,96215352,36302231,35067168,11695282,19447382,66401373,40822285,41406321,48630216,78955925,57194625,52097877,16169037,44834346,2593695,29948466,41842778,50510473,39669493,64590865,26160800,94882286,2703212,41243905,89363549,82819429,25565895,86836890,58385785,55898457,99305620,43332680,98223672,4494624,25408421,28054121,48197701,90633404,25825550,90631154,24867226,61846156,38911183,67826056,10676975,57116645,474292,82387517,56211477,46555785,49282428,99468990,81172472,26720330,38692582,96073680,88412290,28829489,1816508,75321051,81650509,23175973,42008725,60743468,52532114,731909,77811415,86804961,29675484,33584929,180367,93687804,41093066,5987495,27291494,78229979,63194139,34357776,9992084,22643334,22407822,69740170,29581361,50036776,88768091,82537322,83709895,55361776,90616169,44595355,9468440,54552233,73496954,46104486,92947715,38522993,88515232,57725249,48507967,25309486,91597013,85635814,69579638,68775627,57556546,77900275,95965693,9601780,5448068,54075952,64335883,80114875,14793294,21016639,1959922,93176996,7893733,51407895,45849129,33857790,30096194,78021982,66555961,15842998,77678123,56648395,8171848,80152264,78616680,80098122,22882409,77242219,3124519,60865422,43164198,43256621,73261157,12541949,49780175,23167183,10509251,41809106,25655902,6752559,39850293,50992519,40061483,84526968,93056718,53267125,53914467,39404926,83672449,21484465,34147538,13437853,74079093,50400032,85705998,7557614,10300505,79264856,65669946,23899714,53506926,36081544,11113765,65755643,5826515,60392667,55562374,98132987,80904530,92663352,7283593,3709276,52078745,84847057,34235334,63889320,70036669,58603533,27394053,54766781,50920854,80202681,67618417,82912294,20150728,20042189,86403320,38738266,58393070,50887299,12170654,16212895,37361223,13677457,19503506,20213757,84240441,39618969,26401150,47937678,55871130,79189571,5717133,12444503,95283334,14827147,22008485,56345882,43237192,56980197,68699371,46407250,72120555,70694039,46438829,17774982,36484024,138767,89563532,54847019,7815592,44909604,50479084,17462504,96594465,58317102,92426225,91894699,4501659,43315607,9442814,19705166,87751308,95588126,92372510,20281564,19251355,10321183,34573093,19074704,84678191,24383998,27670253,50223562,34091936,99304371,32477827,54273037,86525073,73253547,33316827,6724062,76707318,78171148,44729510,16697684,68966388,57448392,51380186,35344477,98153122,51825492,27202774,26901641,37527637,88241695,15100257,30418000,21821200,95511035,9289513,83870196,54628801,39402988,88345504,84232433,13925255,70816934,6822742,14400466,430652,87397095,89773413,10883914,89939310,39597573,49356789,62857680,93292662,55644642,81922551,94304087,63705961,137763,22392805,65195561,39498904,22576234,59467794,46389072,66341462,44602153,18204976,45366397,3880945,98231882,27999162,38209350,10599910,77139550,35114264,57109708,93064441,34801782,24938667,84955486,53018874,37969943,64372852,69596670,21288762,12774121,97588451,23575359,10954061,50363988,56263940,61520763,85096643,36250068,19807406,20984386,24520668,44631794,62587890,44963362,7663521,78505677,98442373,90280978,14494324,16069861,11397153,87726305,26133866,42024935,93393929,72575268,76384597,42272046,81658814,40811718,86054463,35997739,51075676,62839927,68179261,19292480,10464999,6342696,75842285,28671096,30029838,19617648,94667632,75855376,83477767,456684,81197213,1961395,79590898,470693,64786459,90138714,30486571,75566704,64467558,21380112,17742907,7733647,92017,64615799,72272722,66873854,77198963,35594848,42694993,12431322,2247181,11020746,42416726,19127785,95444937,36842133,4203521,48149533,45322440,59710953,38250773,31370132,26889920,45927952,55298246,31197238,44744953,35531670,38850041,29759177,76433451,33696500,2823716,68574340,68889919,35744793,64772909,41562277,72606631,54617176,76086087,61060196,1593669,4666059,44201567,97015910,51039786,47534369,36899420,95163693,34278055,24361819,93200909,29991418,63172824,53644148,61454424,44726508,64910883,31088636,14005026,83267869,28497493,12406441,34686539,70646963,7687253,23115957,64556990,49701688,76843379,22370877,11199132,15492661,72101877,47154152,54969058,96696025,33567129,95788960,13301506,38695877,52992551,37817234,82136809,28111091,84977065,93404791,56350318,27576451,84170153,37381626,22432144,35119973,23922989,98961080,14336913,49612713,47410677,41559348,64216475,75502736,16203656,81726720,64541981,82181762,95869963,1086041,76856852,99484886,47292021,99746735,79082859,67416188,46391963,58631281,80994168,9464550,5851058,16534935,63307701,91875109,18716507,15870646,6003995,836024,35610568,39574140,76244639,83403189,51252728,6516065,94907007,81605606,40398075,40258386,6692981,50852074,2869416,97682971,44427361,9608914,58464559,81806036,20047387,66264452,58063775,54179837,48463792,17877188,31718426,64192249,35574859,3671766,88905164,78137697,46929619,21063327,83078770,93293821,41618319,3832324,91310612,79854291,68734227,8826717,80881657,95208907,7079422,30037415,5494004,44809486,97620027,35689182,13120783,26108678,1537176,16538727,50841024,36515680,82635278,11112660,16276555,72997511,93487848,88201238,53997085,15198916,61214583,78412499,3585265,1402827,56445518,47661453,25615629,58263458,62155263,46608555,15822703,82285214,76021596,84571697,45999350,40074628,8219220,5429523,74024203,22354037,17605466,60436920,52777032,65801717,43656316,10424270,48035786,29493228,83897372,62101275,84793857,56894828,70636689,72497148,67388694,68146510,64298548,97117498,25553211,54226533,90395845,24172623,91712292,98280822,54042497,25032894,6833135,39011254,9837753,63507766,26747954,45941264,99955245,80051546,78510759,71322333,92407609,95809491,18999217,23430377,11861293,42583098,24163209,11358738,3237302,3176665,87151132,2789150,63905882,59864282,3673596,19570439,22883042,72375525,51614404,47526636,98443133,99140135,33855918,28333489,81416033,2670097,4897577,24439616,36643479,40817600,76022791,40072872,95193435,96967607,24983145,49883271,94602753,83555050,85455145,34563229,72328311,12002151,71481181,72998351,1489188,38426973,91893116,61594591,89693630,6268166,20056665,62169880,17143472,35103925,22452590,54272289,34236829,78028543,84474414,40386926,50550952,49413559,48781941,22927237,44447815,29960478,47578119,10192558,87733936,88699383,38808712,79944807,84014713,31865463,72617685,19557568,47865990,39069638,20086122,1777562,29018078,78358083,94561719,46281152,99789008,86929490,16534451,55989144,52455669,54561585,97379646,20416183,87617750,76115505,3282482,8383619,45456319,29576432,67750627,61736333,33745442,51502165,35349384,78106651,23232822,94851387,78254073,82406754,10317954,70125940,45067526,27061875,25640164,52574899,93819227,93789607,96122951,31673246,70431904,54067896,37146857,37817889,14058940,60710246,64844350,91604383,71972005,13888349,19093493,27397281,61085409,66529387,82761299,72236310,19277077,96599501,68304096,48292937,97503321,88011133,29224803,79782945,79965966,83716914,90432214,48938902,12498489,30246261,91624049,68652396,23677785,44084687,3865123,37823170,45287730,38784682,28058351,68226368,61569897,44737876,70575908,25568463,24668386,88650569,35559584,1897737,77844785,29780669,84004602,29029776,91003545,48058106,9463847);SELECT * FROM test WHERE id=93674701 OR id=9720356 OR id=31732184 OR id=53855095 OR id=33144472 OR id=71864888 OR id=27541768 OR id=27238726 OR id=83648428 OR id=12942332 OR id=26918445 OR id=19781953 OR id=81861032 OR id=74800064 OR id=12286132 OR id=6624397 OR id=64942581 OR id=70512799 OR id=46356598 OR id=88292448 OR id=87069909 OR id=38175756 OR id=98121997 OR id=62570414 OR id=15900806 OR id=51527968 OR id=89092372 OR id=8084203 OR id=53772848 OR id=78871524 OR id=3608561 OR id=85909562 OR id=41702172 OR id=61800503 OR id=57877634 OR id=93407278 OR id=30824340 OR id=13159046 OR id=49055339 OR id=73058078 OR id=983603 OR id=73571456 OR id=51694978 OR id=75136628 OR id=82716874 OR id=83551181 OR id=7964224 OR id=47505945 OR id=92695321 OR id=15885152 OR id=79282709 OR id=18572099 OR id=27392970 OR id=14552787 OR id=19848227 OR id=4518183 OR id=11773920 OR id=22285326 OR id=71605145 OR id=2402625 OR id=63365854 OR id=70973600 OR id=10584706 OR id=83688869 OR id=84268419 OR id=6026005 OR id=36545233 OR id=24462648 OR id=19293921 OR id=17561083 OR id=52105483 OR id=59243514 OR id=35230465 OR id=34650779 OR id=30053489 OR id=24225251 OR id=59642405 OR id=81933853 OR id=94495716 OR id=26364324 OR id=25980634 OR id=5579237 OR id=14569289 OR id=89417845 OR id=71178959 OR id=4143920 OR id=20467990 OR id=53316808 OR id=21288525 OR id=82249537 OR id=37737589 OR id=44712689 OR id=36788133 OR id=15668654 OR id=4697556 OR id=63785060 OR id=11555169 OR id=36401204 OR id=92276179 OR id=4135929 OR id=75453019 OR id=28231031 OR id=8649240 OR id=11576980 OR id=20262028 OR id=56242424 OR id=11305608 OR id=5655216 OR id=90240601 OR id=28569373 OR id=5296027 OR id=10739594 OR id=72751648 OR id=22531251 OR id=12535926 OR id=36347415 OR id=19740655 OR id=69125465 OR id=7523885 OR id=88128548 OR id=88830806 OR id=25010302 OR id=29411467 OR id=99614288 OR id=32646290 OR id=16592563 OR id=69036910 OR id=32604729 OR id=88737786 OR id=90169676 OR id=57646877 OR id=72105460 OR id=40027541 OR id=70362483 OR id=37221415 OR id=25284914 OR id=69691185 OR id=17972978 OR id=1544661 OR id=47324366 OR id=25337670 OR id=91133621 OR id=63697117 OR id=48652228 OR id=18538437 OR id=79966496 OR id=26066529 OR id=65334307 OR id=8305141 OR id=86289387 OR id=20178085 OR id=88836090 OR id=74948034 OR id=14101728 OR id=7837868 OR id=83548120 OR id=65602502 OR id=83129211 OR id=24785681 OR id=65000269 OR id=49140174 OR id=62636621 OR id=31096695 OR id=52276400 OR id=28546681 OR id=83631937 OR id=57100225 OR id=42531528 OR id=28326396 OR id=38641032 OR id=93055463 OR id=20525612 OR id=66073509 OR id=35154065 OR id=29007664 OR id=12600294 OR id=76829494 OR id=73917074 OR id=67226149 OR id=12478806 OR id=39842542 OR id=70312958 OR id=82792046 OR id=49668650 OR id=46280815 OR id=96555182 OR id=22966062 OR id=83158116 OR id=87566530 OR id=66277804 OR id=7944142 OR id=90649884 OR id=64342810 OR id=9881875 OR id=14833854 OR id=82959569 OR id=50523207 OR id=48788762 OR id=3801076 OR id=14677723 OR id=63080506 OR id=96215352 OR id=36302231 OR id=35067168 OR id=11695282 OR id=19447382 OR id=66401373 OR id=40822285 OR id=41406321 OR id=48630216 OR id=78955925 OR id=57194625 OR id=52097877 OR id=16169037 OR id=44834346 OR id=2593695 OR id=29948466 OR id=41842778 OR id=50510473 OR id=39669493 OR id=64590865 OR id=26160800 OR id=94882286 OR id=2703212 OR id=41243905 OR id=89363549 OR id=82819429 OR id=25565895 OR id=86836890 OR id=58385785 OR id=55898457 OR id=99305620 OR id=43332680 OR id=98223672 OR id=4494624 OR id=25408421 OR id=28054121 OR id=48197701 OR id=90633404 OR id=25825550 OR id=90631154 OR id=24867226 OR id=61846156 OR id=38911183 OR id=67826056 OR id=10676975 OR id=57116645 OR id=474292 OR id=82387517 OR id=56211477 OR id=46555785 OR id=49282428 OR id=99468990 OR id=81172472 OR id=26720330 OR id=38692582 OR id=96073680 OR id=88412290 OR id=28829489 OR id=1816508 OR id=75321051 OR id=81650509 OR id=23175973 OR id=42008725 OR id=60743468 OR id=52532114 OR id=731909 OR id=77811415 OR id=86804961 OR id=29675484 OR id=33584929 OR id=180367 OR id=93687804 OR id=41093066 OR id=5987495 OR id=27291494 OR id=78229979 OR id=63194139 OR id=34357776 OR id=9992084 OR id=22643334 OR id=22407822 OR id=69740170 OR id=29581361 OR id=50036776 OR id=88768091 OR id=82537322 OR id=83709895 OR id=55361776 OR id=90616169 OR id=44595355 OR id=9468440 OR id=54552233 OR id=73496954 OR id=46104486 OR id=92947715 OR id=38522993 OR id=88515232 OR id=57725249 OR id=48507967 OR id=25309486 OR id=91597013 OR id=85635814 OR id=69579638 OR id=68775627 OR id=57556546 OR id=77900275 OR id=95965693 OR id=9601780 OR id=5448068 OR id=54075952 OR id=64335883 OR id=80114875 OR id=14793294 OR id=21016639 OR id=1959922 OR id=93176996 OR id=7893733 OR id=51407895 OR id=45849129 OR id=33857790 OR id=30096194 OR id=78021982 OR id=66555961 OR id=15842998 OR id=77678123 OR id=56648395 OR id=8171848 OR id=80152264 OR id=78616680 OR id=80098122 OR id=22882409 OR id=77242219 OR id=3124519 OR id=60865422 OR id=43164198 OR id=43256621 OR id=73261157 OR id=12541949 OR id=49780175 OR id=23167183 OR id=10509251 OR id=41809106 OR id=25655902 OR id=6752559 OR id=39850293 OR id=50992519 OR id=40061483 OR id=84526968 OR id=93056718 OR id=53267125 OR id=53914467 OR id=39404926 OR id=83672449 OR id=21484465 OR id=34147538 OR id=13437853 OR id=74079093 OR id=50400032 OR id=85705998 OR id=7557614 OR id=10300505 OR id=79264856 OR id=65669946 OR id=23899714 OR id=53506926 OR id=36081544 OR id=11113765 OR id=65755643 OR id=5826515 OR id=60392667 OR id=55562374 OR id=98132987 OR id=80904530 OR id=92663352 OR id=7283593 OR id=3709276 OR id=52078745 OR id=84847057 OR id=34235334 OR id=63889320 OR id=70036669 OR id=58603533 OR id=27394053 OR id=54766781 OR id=50920854 OR id=80202681 OR id=67618417 OR id=82912294 OR id=20150728 OR id=20042189 OR id=86403320 OR id=38738266 OR id=58393070 OR id=50887299 OR id=12170654 OR id=16212895 OR id=37361223 OR id=13677457 OR id=19503506 OR id=20213757 OR id=84240441 OR id=39618969 OR id=26401150 OR id=47937678 OR id=55871130 OR id=79189571 OR id=5717133 OR id=12444503 OR id=95283334 OR id=14827147 OR id=22008485 OR id=56345882 OR id=43237192 OR id=56980197 OR id=68699371 OR id=46407250 OR id=72120555 OR id=70694039 OR id=46438829 OR id=17774982 OR id=36484024 OR id=138767 OR id=89563532 OR id=54847019 OR id=7815592 OR id=44909604 OR id=50479084 OR id=17462504 OR id=96594465 OR id=58317102 OR id=92426225 OR id=91894699 OR id=4501659 OR id=43315607 OR id=9442814 OR id=19705166 OR id=87751308 OR id=95588126 OR id=92372510 OR id=20281564 OR id=19251355 OR id=10321183 OR id=34573093 OR id=19074704 OR id=84678191 OR id=24383998 OR id=27670253 OR id=50223562 OR id=34091936 OR id=99304371 OR id=32477827 OR id=54273037 OR id=86525073 OR id=73253547 OR id=33316827 OR id=6724062 OR id=76707318 OR id=78171148 OR id=44729510 OR id=16697684 OR id=68966388 OR id=57448392 OR id=51380186 OR id=35344477 OR id=98153122 OR id=51825492 OR id=27202774 OR id=26901641 OR id=37527637 OR id=88241695 OR id=15100257 OR id=30418000 OR id=21821200 OR id=95511035 OR id=9289513 OR id=83870196 OR id=54628801 OR id=39402988 OR id=88345504 OR id=84232433 OR id=13925255 OR id=70816934 OR id=6822742 OR id=14400466 OR id=430652 OR id=87397095 OR id=89773413 OR id=10883914 OR id=89939310 OR id=39597573 OR id=49356789 OR id=62857680 OR id=93292662 OR id=55644642 OR id=81922551 OR id=94304087 OR id=63705961 OR id=137763 OR id=22392805 OR id=65195561 OR id=39498904 OR id=22576234 OR id=59467794 OR id=46389072 OR id=66341462 OR id=44602153 OR id=18204976 OR id=45366397 OR id=3880945 OR id=98231882 OR id=27999162 OR id=38209350 OR id=10599910 OR id=77139550 OR id=35114264 OR id=57109708 OR id=93064441 OR id=34801782 OR id=24938667 OR id=84955486 OR id=53018874 OR id=37969943 OR id=64372852 OR id=69596670 OR id=21288762 OR id=12774121 OR id=97588451 OR id=23575359 OR id=10954061 OR id=50363988 OR id=56263940 OR id=61520763 OR id=85096643 OR id=36250068 OR id=19807406 OR id=20984386 OR id=24520668 OR id=44631794 OR id=62587890 OR id=44963362 OR id=7663521 OR id=78505677 OR id=98442373 OR id=90280978 OR id=14494324 OR id=16069861 OR id=11397153 OR id=87726305 OR id=26133866 OR id=42024935 OR id=93393929 OR id=72575268 OR id=76384597 OR id=42272046 OR id=81658814 OR id=40811718 OR id=86054463 OR id=35997739 OR id=51075676 OR id=62839927 OR id=68179261 OR id=19292480 OR id=10464999 OR id=6342696 OR id=75842285 OR id=28671096 OR id=30029838 OR id=19617648 OR id=94667632 OR id=75855376 OR id=83477767 OR id=456684 OR id=81197213 OR id=1961395 OR id=79590898 OR id=470693 OR id=64786459 OR id=90138714 OR id=30486571 OR id=75566704 OR id=64467558 OR id=21380112 OR id=17742907 OR id=7733647 OR id=92017 OR id=64615799 OR id=72272722 OR id=66873854 OR id=77198963 OR id=35594848 OR id=42694993 OR id=12431322 OR id=2247181 OR id=11020746 OR id=42416726 OR id=19127785 OR id=95444937 OR id=36842133 OR id=4203521 OR id=48149533 OR id=45322440 OR id=59710953 OR id=38250773 OR id=31370132 OR id=26889920 OR id=45927952 OR id=55298246 OR id=31197238 OR id=44744953 OR id=35531670 OR id=38850041 OR id=29759177 OR id=76433451 OR id=33696500 OR id=2823716 OR id=68574340 OR id=68889919 OR id=35744793 OR id=64772909 OR id=41562277 OR id=72606631 OR id=54617176 OR id=76086087 OR id=61060196 OR id=1593669 OR id=4666059 OR id=44201567 OR id=97015910 OR id=51039786 OR id=47534369 OR id=36899420 OR id=95163693 OR id=34278055 OR id=24361819 OR id=93200909 OR id=29991418 OR id=63172824 OR id=53644148 OR id=61454424 OR id=44726508 OR id=64910883 OR id=31088636 OR id=14005026 OR id=83267869 OR id=28497493 OR id=12406441 OR id=34686539 OR id=70646963 OR id=7687253 OR id=23115957 OR id=64556990 OR id=49701688 OR id=76843379 OR id=22370877 OR id=11199132 OR id=15492661 OR id=72101877 OR id=47154152 OR id=54969058 OR id=96696025 OR id=33567129 OR id=95788960 OR id=13301506 OR id=38695877 OR id=52992551 OR id=37817234 OR id=82136809 OR id=28111091 OR id=84977065 OR id=93404791 OR id=56350318 OR id=27576451 OR id=84170153 OR id=37381626 OR id=22432144 OR id=35119973 OR id=23922989 OR id=98961080 OR id=14336913 OR id=49612713 OR id=47410677 OR id=41559348 OR id=64216475 OR id=75502736 OR id=16203656 OR id=81726720 OR id=64541981 OR id=82181762 OR id=95869963 OR id=1086041 OR id=76856852 OR id=99484886 OR id=47292021 OR id=99746735 OR id=79082859 OR id=67416188 OR id=46391963 OR id=58631281 OR id=80994168 OR id=9464550 OR id=5851058 OR id=16534935 OR id=63307701 OR id=91875109 OR id=18716507 OR id=15870646 OR id=6003995 OR id=836024 OR id=35610568 OR id=39574140 OR id=76244639 OR id=83403189 OR id=51252728 OR id=6516065 OR id=94907007 OR id=81605606 OR id=40398075 OR id=40258386 OR id=6692981 OR id=50852074 OR id=2869416 OR id=97682971 OR id=44427361 OR id=9608914 OR id=58464559 OR id=81806036 OR id=20047387 OR id=66264452 OR id=58063775 OR id=54179837 OR id=48463792 OR id=17877188 OR id=31718426 OR id=64192249 OR id=35574859 OR id=3671766 OR id=88905164 OR id=78137697 OR id=46929619 OR id=21063327 OR id=83078770 OR id=93293821 OR id=41618319 OR id=3832324 OR id=91310612 OR id=79854291 OR id=68734227 OR id=8826717 OR id=80881657 OR id=95208907 OR id=7079422 OR id=30037415 OR id=5494004 OR id=44809486 OR id=97620027 OR id=35689182 OR id=13120783 OR id=26108678 OR id=1537176 OR id=16538727 OR id=50841024 OR id=36515680 OR id=82635278 OR id=11112660 OR id=16276555 OR id=72997511 OR id=93487848 OR id=88201238 OR id=53997085 OR id=15198916 OR id=61214583 OR id=78412499 OR id=3585265 OR id=1402827 OR id=56445518 OR id=47661453 OR id=25615629 OR id=58263458 OR id=62155263 OR id=46608555 OR id=15822703 OR id=82285214 OR id=76021596 OR id=84571697 OR id=45999350 OR id=40074628 OR id=8219220 OR id=5429523 OR id=74024203 OR id=22354037 OR id=17605466 OR id=60436920 OR id=52777032 OR id=65801717 OR id=43656316 OR id=10424270 OR id=48035786 OR id=29493228 OR id=83897372 OR id=62101275 OR id=84793857 OR id=56894828 OR id=70636689 OR id=72497148 OR id=67388694 OR id=68146510 OR id=64298548 OR id=97117498 OR id=25553211 OR id=54226533 OR id=90395845 OR id=24172623 OR id=91712292 OR id=98280822 OR id=54042497 OR id=25032894 OR id=6833135 OR id=39011254 OR id=9837753 OR id=63507766 OR id=26747954 OR id=45941264 OR id=99955245 OR id=80051546 OR id=78510759 OR id=71322333 OR id=92407609 OR id=95809491 OR id=18999217 OR id=23430377 OR id=11861293 OR id=42583098 OR id=24163209 OR id=11358738 OR id=3237302 OR id=3176665 OR id=87151132 OR id=2789150 OR id=63905882 OR id=59864282 OR id=3673596 OR id=19570439 OR id=22883042 OR id=72375525 OR id=51614404 OR id=47526636 OR id=98443133 OR id=99140135 OR id=33855918 OR id=28333489 OR id=81416033 OR id=2670097 OR id=4897577 OR id=24439616 OR id=36643479 OR id=40817600 OR id=76022791 OR id=40072872 OR id=95193435 OR id=96967607 OR id=24983145 OR id=49883271 OR id=94602753 OR id=83555050 OR id=85455145 OR id=34563229 OR id=72328311 OR id=12002151 OR id=71481181 OR id=72998351 OR id=1489188 OR id=38426973 OR id=91893116 OR id=61594591 OR id=89693630 OR id=6268166 OR id=20056665 OR id=62169880 OR id=17143472 OR id=35103925 OR id=22452590 OR id=54272289 OR id=34236829 OR id=78028543 OR id=84474414 OR id=40386926 OR id=50550952 OR id=49413559 OR id=48781941 OR id=22927237 OR id=44447815 OR id=29960478 OR id=47578119 OR id=10192558 OR id=87733936 OR id=88699383 OR id=38808712 OR id=79944807 OR id=84014713 OR id=31865463 OR id=72617685 OR id=19557568 OR id=47865990 OR id=39069638 OR id=20086122 OR id=1777562 OR id=29018078 OR id=78358083 OR id=94561719 OR id=46281152 OR id=99789008 OR id=86929490 OR id=16534451 OR id=55989144 OR id=52455669 OR id=54561585 OR id=97379646 OR id=20416183 OR id=87617750 OR id=76115505 OR id=3282482 OR id=8383619 OR id=45456319 OR id=29576432 OR id=67750627 OR id=61736333 OR id=33745442 OR id=51502165 OR id=35349384 OR id=78106651 OR id=23232822 OR id=94851387 OR id=78254073 OR id=82406754 OR id=10317954 OR id=70125940 OR id=45067526 OR id=27061875 OR id=25640164 OR id=52574899 OR id=93819227 OR id=93789607 OR id=96122951 OR id=31673246 OR id=70431904 OR id=54067896 OR id=37146857 OR id=37817889 OR id=14058940 OR id=60710246 OR id=64844350 OR id=91604383 OR id=71972005 OR id=13888349 OR id=19093493 OR id=27397281 OR id=61085409 OR id=66529387 OR id=82761299 OR id=72236310 OR id=19277077 OR id=96599501 OR id=68304096 OR id=48292937 OR id=97503321 OR id=88011133 OR id=29224803 OR id=79782945 OR id=79965966 OR id=83716914 OR id=90432214 OR id=48938902 OR id=12498489 OR id=30246261 OR id=91624049 OR id=68652396 OR id=23677785 OR id=44084687 OR id=3865123 OR id=37823170 OR id=45287730 OR id=38784682 OR id=28058351 OR id=68226368 OR id=61569897 OR id=44737876 OR id=70575908 OR id=25568463 OR id=24668386 OR id=88650569 OR id=35559584 OR id=1897737 OR id=77844785 OR id=29780669 OR id=84004602 OR id=29029776 OR id=91003545 OR id=48058106 OR id=9463847; 测试结果如下：第一种情况，ID列为主键的情况，4组测试执行计划一样，执行的时间也基本没有区别。A组or和in的执行时间： or的执行时间为：0.002s &nbsp; &nbsp; in的执行时间为：0.002sB组or和in的执行时间： or的执行时间为：0.004s &nbsp; &nbsp; in的执行时间为：0.004sC组or和in的执行时间： or的执行时间为：0.006s &nbsp; &nbsp; in的执行时间为：0.005sD组or和in的执行时间： or的执行时间为：0.018s &nbsp; &nbsp; in的执行时间为：0.014s第二种情况，ID列为一般索引的情况，4组测试执行计划一样，执行的时间也基本没有区别。A组or和in的执行时间： or的执行时间为：0.002s &nbsp; &nbsp; in的执行时间为：0.002sB组or和in的执行时间： or的执行时间为：0.006s &nbsp; &nbsp; in的执行时间为：0.005s &nbsp;C组or和in的执行时间： or的执行时间为：0.008s &nbsp; &nbsp; in的执行时间为：0.008sD组or和in的执行时间： or的执行时间为：0.021s &nbsp; &nbsp; in的执行时间为：0.020s &nbsp;第三种情况，ID列没有索引的情况，4组测试执行计划一样，执行的时间有很大的区别。A组or和in的执行时间： or的执行时间为：5.016s &nbsp; &nbsp; &nbsp;in的执行时间为：5.071sB组or和in的执行时间： or的执行时间为：1min 02s &nbsp; &nbsp; in的执行时间为：5.018sC组or和in的执行时间： or的执行时间为：1min 55s &nbsp; &nbsp; in的执行时间为：5.018sD组or和in的执行时间： or的执行时间为：6min 17s &nbsp; &nbsp; in的执行时间为：5.057s 结论：从上面的测试结果，可以看出如果in和or所在列有索引或者主键的话，or和in没啥差别，执行计划和执行时间都几乎一样。如果in和or所在列没有索引的话，性能差别就很大了。在没有索引的情况下，随着in或者or后面的数据量越多，in的效率不会有太大的下降，但是or会随着记录越多的话性能下降非常厉害，从第三种测试情况中可以很明显地看出了，基本上是指数级增长。因此在给in和or的效率下定义的时候，应该再加上一个条件，就是所在的列是否有索引或者是否是主键。如果有索引或者主键性能没啥差别，如果没有索引，性能差别不是一点点！ 模糊查询like模糊查询又被称为模糊匹配，在实际开发中使用较多，比如：查询公司中所有姓张的，查询岗位中带有经理两个字的职位等等，这些都需要使用模糊查询。模糊查询的语法格式如下： 1select .. from .. where 字段 like '通配符表达式'; 在模糊查询中，通配符主要包括两个：一个是%，一个是下划线_。其中%代表任意多个字符。下划线_代表任意一个字符。案例1：查询员工名字以’S’开始的员工姓名 1select ename from emp where ename like 'S%'; 案例2：查询员工名字以’T’结尾的员工姓名 1select ename from emp where ename like '%T'; 案例3：查询员工名字中含有’O’的员工姓名 1select ename from emp where ename like '%O%'; 案例4：查询员工名字中第二个字母是’A’的员工姓名 1select ename from emp where ename like '_A%'; 案例5：查询学员名字中含有下划线的。执行以下SQL语句，先准备测试数据： 123456789drop table if exists student;create table student( id int, name varchar(255));insert into student(id,name) values(1, 'susan');insert into student(id,name) values(2, 'lucy');insert into student(id,name) values(3, 'jack_son');select * from student; 查询学员名字中含有下划线的，执行以下SQL试试： 1select * from student where name like '%_%'; 显然这个查询结果不是我们想要的，以上SQL之所以将所有数据全部显示了，因为下划线代表任意单个字符，如果你想让这个下划线变成一个普通的下划线字符，就要使用转义字符了，在mysql当中转义字符是“\\”，这个和java语言中的转义字符是一样的： 1select * from student where name like '%\\_%'; 排序操作排序操作很常用，比如查询学员成绩，按照成绩降序排列。排序的SQL语法： 1select .. from .. order by 字段 asc/desc 单一字段升序查询员工的编号、姓名、薪资，按照薪资升序排列。 1select empno,ename,sal from emp order by sal asc; 单一字段降序查询员工的编号、姓名、薪资，按照薪资降序排列。 1select empno,ename,sal from emp order by sal desc; 默认采用升序查询员工的编号、姓名、薪资，按照薪资升序排列。 1select empno,ename,sal from emp order by sal; 查询员工的编号、姓名，按照姓名升序排列。 1select empno,ename from emp order by ename; 多个字段排序查询员工的编号、姓名、薪资，按照薪资升序排列，如果薪资相同的，再按照姓名升序排列。 1select empno,ename,sal from emp order by sal asc, ename asc; where和order by的位置找出岗位是MANAGER的员工姓名和薪资，按照薪资升序排列。 1select ename,sal from emp where job = 'MANAGER' order by sal asc; 通过这个例子主要是想告诉大家：where先执行，order by语句是最后执行的。 distinct去重查询工作岗位 1select job from emp; 可以看到工作岗位中有重复的记录，如何在显示的时候去除重复记录呢？在字段前添加distinct关键字。 1select distinct job from emp; 注意：这个去重只是将显示的结果去重，原表数据不会被更改。接下来测试一下，在distinct关键字前添加其它字段是否可以？ 1select ename, distinct job from emp; 分析一下：ename是14条记录，distinct job是5条记录，可以同时显示吗？报错了，通过测试得知，distinct只能出现在所有字段的最前面。当distinct出现后，后面多个字段一定是联合去重的，我们来做两个练习就知道了：练习1：找出公司中所有的工作岗位。 练习2：找出公司中不同部门的不同工作岗位。 数据处理函数关于select语句，我们之前都是这样写：select 字段名 from 表名; 其实，这里的字段名可以看做“变量”，select后面既然可以跟变量，那么可以跟常量吗，尝试一下：通过以上sql的测试得知，select后面既可以跟变量，又可以跟常量。以上三条SQL中前两条中100和’abc’都是常量，最后一条SQL的abc没有添加单引号，它会被当做某个表的字段名，因为没有这个字段所以报错。 字符串相关转大写upper和ucase12# 查询所有员工名字，以大写形式展现select upper(ename) as ename from emp; 还有一个和upper函数功能相同的函数ucase，也可以转大写，了解一下即可： 12# 查询所有员工姓名，以大写形式展现select ucase(ename) as ename from emp; 12# 查询员工smith的岗位、薪资（假如你不知道数据库表中的人名是大写、小写还是大小写混合）select ename, job, sal from emp where upper(ename) = 'SMITH'; 转小写lower和lcase很简单，不再赘述，直接上代码： 123# 查询员工姓名，以小写形式展现select lower(ename) as ename from emp;select lcase(ename) as ename from emp; 截取字符串substr语法：substr(‘被截取的字符串’, 起始下标, 截取长度)有两种写法：第一种：substr(‘被截取的字符串’, 起始下标, 截取长度)第二种：substr(‘被截取的字符串’, 起始下标)，当第三个参数“截取长度”缺失时，截取到字符串末尾注意：起始下标从1开始，不是从0开始。（1表示从左侧开始的第一个位置，-1表示从右侧开始的第一个位置。） 练习：找出员工名字中第二个字母是A的 1select ename from emp where substr(ename, 2, 1) = 'A'; 获取字符串长度length注意：一个汉字是2个长度。 获取字符的个数char_length 字符串拼接语法：concat(‘字符串1’, ‘字符串2’, ‘字符串3’….)拼接的字符串数量没有限制。注意：在mysql8之前，双竖线||也是可以完成字符串拼接的。但在mysql8之后，||只作为逻辑运算符，不能再进行字符串拼接了。 1select 'abc' || 'def' || 'xyz'; mysql8之后，|| 只作为“或者”运算符，例如：找出工资高于3000或者低于900的员工姓名和薪资： 1select ename, sal from emp where sal &gt; 3000 || sal &lt; 900; mysql中可以使用+进行字符串的拼接吗？不可以，在mysql中+只作加法运算，在进行加法运算时，会将加号两边的数据尽最大的努力转换成数字再求和，如果无法转换成数字，最终运算结果通通是0 去除字符串前后空白trim1select concat(trim(' abc '), 'def'); 默认是去除前后空白，也可以去除指定的前缀后缀，例如：去除前置0 1select trim(leading '0' from '000111000'); 去除后置0 1select trim(trailing '0' from '000111000'); 前置0和后置0全部去除 1select trim(both '0' from '000111000'); 数字相关rand()和rand(x)rand()生成0到1的随机浮点数。rand(x)生成0到1的随机浮点数，通过指定整数x来确定每次获取到相同的浮点值。 round(x)和round(x,y)四舍五入round(x) 四舍五入，保留整数位，舍去所有小数round(x,y) 四舍五入，保留y位小数 truncate(x, y)舍去以上SQL表示保留两位小数，剩下的全部舍去。 ceil与floor数字处理函数除了以上的之外，还有ceil和floor函数： ceil函数：返回大于或等于数值x的最小整数 floor函数：返回小于或等于数值x的最大整数 空处理ifnull(x, y)，空处理函数，当x为NULL时，将x当做y处理。ifnull(comm, 0)，表示如果员工的津贴是NULL时当做0处理。在SQL语句中，凡是有NULL参与的数学运算，最终的计算结果都是NULL：看这样一个需求：查询每个员工的年薪。（年薪 = (月薪 + 津贴) * 12个月。注意：有的员工津贴comm是NULL。） 以上查询结果中显示SMITH等人的年薪是NULL，这是为什么，这是因为SMITH等人的津贴comm是NULL，有NULL参与的数学运算，最终结果都是NULL，显然这个需要空处理，此时就用到了ifnull函数： 日期和时间相关函数获取当前日期和时间now()和sysdate()的区别： now()：获取的是执行select语句的时刻。 sysdate()：获取的是执行sysdate()函数的时刻。 获取当前日期获取当前日期有三种写法，掌握任意一种即可： curdate() current_date() current_date 获取当前时间获取档期时间有三种写法，掌握其中一种即可： curtime() current_time() current_time 获取单独的年、月、日、时、分、秒注意：这些函数在使用的时候，需要传递一个日期参数给它，它可以获取到你给定的这个日期相关的年、月、日、时、分、秒的信息。一次性提取一个给定日期的“年月日”部分，可以使用date()函数，例如：一次性提取一个给定日期的“时分秒”部分，可以使用time()函数，例如： date_add函数date_add函数的作用：给指定的日期添加间隔的时间，从而得到一个新的日期。date_add函数的语法格式：date_add(日期, interval expr 单位)，例如：以’2023-01-03’为基准，间隔3天之后的日期：’2023-01-06’ 以’2023-01-03’为基准，间隔3个月之后的日期：’2023-04-03’详细解释一下这个函数的相关参数： 日期：一个日期类型的数据 interval：关键字，翻译为“间隔”，固定写法 expr：指定具体的间隔量，一般是一个数字。也可以为负数，如果为负数，效果和date_sub函数相同。 单位： year：年 month：月 day：日 hour：时 minute：分 second：秒 microsecond：微秒（1秒等于1000毫秒，1毫秒等于1000微秒） week：周 quarter：季度 请分析下面这条SQL语句所表达的含义：以上SQL表示：以2022-10-01 10:10:10为基准，在这个时间基础上添加-1微秒，也就是减去1微秒。以上SQL也可以采用date_sub函数完成，例如：另外，单位也可以采用复合型单位，例如： SECOND_MICROSECOND MINUTE_MICROSECOND MINUTE_SECOND：几分几秒之后 HOUR_MICROSECOND HOUR_SECOND HOUR_MINUTE：几小时几分之后 DAY_MICROSECOND DAY_SECOND DAY_MINUTE DAY_HOUR：几天几小时之后 YEAR_MONTH：几年几个月之后 如果单位采用复合型的话，expr该怎么写呢？例如单位采用：day_hour，假设我要表示3天2小时之后，怎么写？‘3,2’这个应该很好理解，表示3天2个小时之后。’3,2’和day_hour是对应的。 date_format日期格式化函数将日期转换成具有某种格式的日期字符串，通常用在查询操作当中。（date类型转换成char类型）语法格式：date_format(日期, ‘日期格式’)该函数有两个参数： 第一个参数：日期。这个参数就是即将要被格式化的日期。类型是date类型。 第二个参数：指定要格式化的格式字符串。 %Y：四位年份 %y：两位年份 %m：月份（1..12） %d：日（1..30） %H：小时（0..23） %i：分（0..59） %s：秒（0..59） 例如：获取当前系统时间，让其以这个格式展示：2000-10-11 20:15:30注意：在mysql当中，默认的日期格式就是：%Y-%m-%d %H:%i:%s，所以当你直接输出日期数据的时候，会自动转换成该格式的字符串： str_to_date函数该函数的作用是将char类型的日期字符串转换成日期类型date，通常使用在插入和修改操作当中。（char类型转换成date类型）假设有一个学生表t_student，学生有一个生日的字段，类型是date类型： 123456drop table if exists t_student;create table t_student( name varchar(255), birth date);desc t_student; 我们要给这个表插入一条数据：姓名zhangsan，生日85年10月1日，执行以下insert语句：错误原因：日期值不正确。意思是：birth字段需要一个日期，你给的这个字符串’10/01/1985’我识别不了。这种情况下，我们就可以使用str_to_date函数进行类型转换：当然，如果你提供的日期字符串格式能够被mysql解析，str_to_date函数是可以省略的，底层会自动调用该函数进行类型转换：如果日期格式符合以上的几种格式，mysql都会自动进行类型转换的。 dayofweek、dayofmonth、dayofyear函数dayofweek：一周中的第几天（17），周日是1，周六是7。dayofmonth：一个月中的第几天（131）dayofyear：一年中的第几天（1~366) last_day函数获取给定日期所在月的最后一天的日期： datediff函数计算两个日期之间所差天数：时分秒不算，只计算日期部分相差的天数。 timediff函数计算两个日期所差时间，例如日期1和日期2所差10:20:30，表示差10小时20分钟30秒。 if函数如果条件为TRUE则返回“YES”，如果条件为FALSE则返回“NO”： 1SELECT IF(500&lt;1000, \"YES\", \"NO\"); 例如：如果工资高于3000，则输出1，反之则输出0再例如：如果名字是SMITH的，工资上调10%，其他员工工资正常显示。再例如：工作岗位是MANAGER的工资上调10%，是SALESMAN的工资上调20%，其他岗位工资正常。上面这个需求也可以使用：case.. when.. then.. when.. then.. else.. end来完成： cast函数cast函数用于将值从一种数据类型转换为表达式中指定的另一种数据类型语法：cast(值 as 数据类型)例如：cast(‘2020-10-11’ as date)，表示将字符串’2020-10-11’转换成日期date类型。在使用cast函数时，可用的数据类型包括： date：日期类型 time：时间类型 datetime：日期时间类型 signed：有符号的int类型（有符号指的是正数负数） char：定长字符串类型 decimal：浮点型 加密函数md5函数，可以将给定的字符串经过md5算法进行加密处理，字符串经过加密之后会生成一个固定长度32位的字符串，md5加密之后的密文通常是不能解密的： 分组函数分组函数的执行原则：先分组，然后对每一组数据执行分组函数。如果没有分组语句group by的话，整张表的数据自成一组。分组函数包括五个： max：最大值 min：最小值 avg：平均值 sum：求和 count：计数 max找出员工的最高薪资 1select max(sal) from emp; min找出员工的最低工资 1select min(sal) from emp; avg计算员工的平均薪资 1select avg(sal) from emp; sum计算员工的工资和 1select sum(sal) from emp; 计算员工的津贴之和 1select sum(comm) from emp; 重点：所有的分组函数都是自动忽略NULL的。 count统计员工人数 123select count(ename) from emp;select count(*) from emp;select count(1) from emp; count(*)和count(1)的效果一样，统计该组中总记录行数。count(ename)统计的是这个ename字段中不为NULL个数总和。例如：count(comm) 结果是 4，而不是14 1select count(comm) from emp; 统计岗位数量 1select count(distinct job) from emp; 分组函数组合使用select count(*),max(sal),min(sal),avg(sal),sum(sal) from emp; 分组函数注意事项分组函数不能直接使用在where子句当中select ename,job from emp where sal &gt; avg(sal); 这个会报错的原因：分组的行为是在where执行之后才开始的。 分组查询group by按照某个字段分组，或者按照某些字段联合分组。注意：group by的执行是在where之后执行。语法：group by 字段group by 字段1,字段2,字段3….找出每个岗位的平均薪资 1select job, avg(sal) from emp group by job; 找出每个部门最高工资 1select deptno,max(sal) from emp group by deptno; 找出每个部门不同岗位的平均薪资 1select deptno,job,avg(sal) from emp group by deptno,job; 当select语句中有group by的话，select后面只能跟分组函数或参加分组的字段 1select ename,deptno,avg(sal) from emp group by deptno; // 这个SQL执行后会报错。 havinghaving写在group by的后面，当你对分组之后的数据不满意，可以继续通过having对分组之后的数据进行过滤。where的过滤是在分组前进行过滤。使用原则：尽量在where中过滤，实在不行，再使用having。越早过滤效率越高。 找出除20部分之外，其它部门的平均薪资。 12select deptno,avg(sal) from emp where deptno&lt;&gt;20 group by deptno; // 建议select deptno,avg(sal) from emp group by deptno having deptno &lt;&gt; 20; // 不建议 查询每个部门平均薪资，找出平均薪资高于2000的。 1select deptno,avg(sal) from emp group by deptno having avg(sal) &gt; 2000; 组内排序案例：找出每个工作岗位的工资排名在前两名的。substring_index函数的使用：group_concat函数的使用：学习了这两个函数之后，自己可以尝试写出来吗？ 总结单表的DQL语句select …5from …1where …2group by …3having …4order by …6重点掌握一个完整的DQL语句执行顺序。 连接查询什么是连接查询 从一张表中查询数据称为单表查询。 从两张或更多张表中联合查询数据称为多表查询，又叫做连接查询。 什么时候需要使用连接查询？ 比如这样的需求：员工表中有员工姓名，部门表中有部门名字，要求查询每个员工所在的部门名字，这个时候就需要连接查询。连接查询的分类 根据语法出现的年代进行分类： SQL92（这种语法很少用，可以不用学。） SQL99（我们主要学习这种语法。） 根据连接方式的不同进行分类： 内连接 等值连接 非等值连接 自连接 外连接 左外连接（左连接） 右外连接（右连接） 全连接 笛卡尔积现象 当两张表进行连接查询时，如果没有任何条件进行过滤，最终的查询结果条数是两张表条数的乘积。为了避免笛卡尔积现象的发生，需要添加条件进行筛选过滤。 需要注意：添加条件之后，虽然避免了笛卡尔积现象，但是匹配的次数没有减少。 为了SQL语句的可读性，为了执行效率，建议给表起别名。内连接什么叫内连接满足条件的记录才会出现在结果集中。 内连接之等值连接连接时，条件为等量关系。案例：查询每个员工所在的部门名称，要求显示员工名、部门名。 12345678select e.ename,d.dnamefrom emp einner join dept don e.deptno = d.deptno; 注意：inner可以省略。 内连接之非等值连接连接时，条件是非等量关系。案例：查询每个员工的工资等级，要求显示员工名、工资、工资等级。 12345678select e.ename,e.sal,s.gradefrom emp ejoin salgrade son e.sal between s.losal and s.hisal; 内连接之自连接连接时，一张表看做两张表，自己和自己进行连接。案例：找出每个员工的直属领导，要求显示员工名、领导名。 12345678select e.ename 员工名, l.ename 领导名from emp ejoin emp lon e.mgr = l.empno; 思路：将emp表当做员工表 e将emp表当做领导表 l可以发现连接条件是：e.mgr = l.empno（员工的领导编号=领导的员工编号)注意：KING这个员工没有查询出来。如果想将KING也查询出来，需要使用外连接。 外连接什么叫外连接内连接是满足条件的记录查询出来。也就是两张表的交集。外连接是除了满足条件的记录查询出来，再将其中一张表的记录全部查询出来，另一张表如果没有与之匹配的记录，自动模拟出NULL与其匹配。左外连接：右外连接： 外连接之左外连接（左连接）案例：查询所有部门信息，并且找出每个部门下的员工。 12345678select d.*,e.enamefrom dept dleft outer join emp eon d.deptno = e.deptno; 注意：outer可以省略。任何一个左连接都可以写作右连接。 外连接之右外连接（右连接）还是上面的案例，可以写作右连接。 12345678select d.*,e.enamefrom emp eright outer join dept don d.deptno = e.deptno; 案例：找出所有员工的上级领导，要求显示员工名和领导名。 12345678select e.ename 员工名,l.ename 领导名 from emp e left join emp l on e.mgr = l.empno; 12345678select e.ename 员工名,l.ename 领导名 from emp l right join emp e on e.mgr = l.empno; 全连接什么是全连接？MySQL不支持full join。oracle数据库支持。两张表数据全部查询出来，没有匹配的记录，各自为对方模拟出NULL进行匹配。客户表：t_customer订单表：t_order案例：查询所有的客户和订单。 12345678select c.*,o.* from t_customer c full join t_order o on c.cid = o.cid; 多张表连接三张表甚至更多张表如何进行表连接案例：找出每个员工的部门，并且要求显示每个员工的薪资等级。 123456789101112select e.ename,d.dname,s.grade from emp e join dept d on e.deptno = d.deptno join salgrade s on e.sal between s.losal and s.hisal; 子查询什么是子查询 select语句中嵌套select语句就叫做子查询。 select语句可以嵌套在哪里？ where后面、from后面、select后面都是可以的。 123select ..(select)..from ..(select)..where ..(select).. where后面使用子查询案例：找出高于平均薪资的员工姓名和薪资。错误的示范： 1select ename,sal from emp where sal &gt; avg(sal); 错误原因：where后面不能直接使用分组函数。可以使用子查询： 1select ename,sal from emp where sal &gt; (select avg(sal) from emp); from后面使用子查询小窍门：from后面的子查询可以看做一张临时表。案例：找出每个部门的平均工资的等级。第一步：先找出每个部门平均工资。 1select deptno, avg(sal) avgsal from emp group by deptno; 第二步：将以上查询结果当做临时表t，t表和salgrade表进行连接查询。条件：t.avgsal between s.losal and s.hisal 1select t.*,s.grade from (select deptno, avg(sal) avgsal from emp group by deptno) t join salgrade s on t.avgsal between s.losal and s.hisal; select后面使用子查询1select e.ename,(select d.dname from dept d where e.deptno = d.deptno) as dname from emp e; exists、not exists在 MySQL 数据库中，EXISTS（存在）用于检查子查询的查询结果行数是否大于0。如果子查询的查询结果行数大于0，则 EXISTS 条件为真。（即存在查询结果则是true。） 主要应用场景： EXISTS 可以与 SELECT、UPDATE、DELETE 一起使用，用于检查另一个查询是否返回任何行； EXISTS 可以用于验证条件子句中的表达式是否存在； EXISTS 常用于子查询条件过滤，例如查询有订单的用户等。 1234567891011121314151617181920212223242526drop table if exists t_customer;drop table if exists t_order;create table t_customer( customer_id int, customer_name varchar(32));create table t_order( order_id int, order_price decimal(5,1), customer_id int);insert into t_customer(customer_id,customer_name) values(1,'zhangsan');insert into t_customer(customer_id,customer_name) values(2,'lisi');insert into t_customer(customer_id,customer_name) values(3,'wangwu');insert into t_order(order_id, order_price, customer_id) values(10, 1000.0, 1);insert into t_order(order_id, order_price, customer_id) values(20, 2000.0, 1);insert into t_order(order_id, order_price, customer_id) values(30, 3000.0, 2);insert into t_order(order_id, order_price, customer_id) values(40, 4000.0, 2);commit;select * from t_customer;select * from t_order; 现在我们来看一个简单的案例，假设我们要查询先前有过订单的顾客，而订单信息保存在 t_order 表中，顾客信息保存在 t_customer 表中。我们可以使用以下 sql 语句： 1select * from t_customer c where exists(select * from t_order o where o.customer_id=c.customer_id); 在这个查询语句中，子查询用于检查是否有订单与每个客户相关联。如果子查询返回至少一行，则表示该顾客已经下过订单，并返回此客户的所有信息，否则该顾客将不被包含在结果中。 以下是这个查询语句的执行过程： 首先查询表 t_customer 中的所有顾客信息（以下简称为顾客表）； 对于顾客表中的每一行，都执行一次子查询，子查询查询该顾客有没有订单，如果有，则在结果集中保留该顾客信息；如果没有，则将该顾客排除； 最终返回有订单顾客的所有信息。 除了 EXISTS，也可以使用 NOT EXISTS 条件从 SELECT、UPDATE、DELETE 语句中获取子查询的返回结果。NOT EXISTS 用于检查一个子查询是否返回任何行，如果没有行返回，那么 NOT EXISTS 将返回 true。 例如，我们想要查找所有没有下过订单的顾客，可以使用以下 sql 语句： 1select * from t_customer c where not exists(select * from t_order o where o.customer_id=c.customer_id); 在这个查询语句中，如果没有任何与顾客相关联的订单，则 NOT EXISTS 子查询将返回一个空结果集，这时候 WHERE 条件为 true，并将返回所有顾客信息。如果顾客有订单，则 NOT EXISTS 子查询的结果集将不为空，WHERE 条件为 false，则不会返回该顾客的信息。 总之，无论是 EXISTS 还是 NOT EXISTS，都是非常有用的 SQL 工具。可以通过它们来结合子查询来动态过滤查询结果，使 SQL 查询变得更加灵活和高效。 in和exists区别IN 和 EXISTS 都是用于关系型数据库查询的操作符。不同之处在于： IN 操作符是根据指定列表中的值来判断是否满足条件，而 EXISTS 操作符则是根据子查询的结果是否有返回记录集来判断。 EXISTS 操作符通常比 IN 操作符更快，尤其是在子查询返回记录数很大的情况下。因为 EXISTS 只需要判断是否存在符合条件的记录，而 IN 操作符需要比对整个列表，因此执行效率相对较低。 IN 操作符可同时匹配多个值，而 EXISTS 只能匹配一组条件。 下面是一个简单的示例，用于演示 IN 和 EXISTS 之间的区别。假设我们有两个表 orders 和 products，orders 表中记录了订单信息，products 表中记录了商品信息。现在我们想查询所有“手机”和“平板电脑”这两种商品中，至少有一笔订单销售了 $1000 以上的商品： 使用 IN 操作符： 12345678SELECT *FROM productsWHERE product_name IN ('手机', '平板电脑')AND product_id IN ( SELECT product_id FROM orders WHERE order_amount &gt; 1000); 使用 EXISTS 操作符： 123456789SELECT *FROM productsWHERE product_name IN ('手机', '平板电脑')AND EXISTS ( SELECT * FROM orders WHERE orders.product_id = products.product_id AND order_amount &gt; 1000); 总之，IN 和 EXISTS 都是用于条件过滤的操作符，但其实现方式和性能特点都不同，需要根据具体情况进行选择和使用。 union&amp;union all不管是union还是union all都可以将两个查询结果集进行合并。union会对合并之后的查询结果集进行去重操作。union all是直接将查询结果集合并，不进行去重操作。（union all和union都可以完成的话，优先选择union all，union all因为不需要去重，所以效率高一些。）案例：查询工作岗位是MANAGER和SALESMAN的员工。 123select ename,sal from emp where job='MANAGER'union allselect ename,sal from emp where job='SALESMAN'; 以上案例采用or也可以完成，那or和union all有什么区别？考虑走索引优化之类的选择union all，其它选择or。两个结果集合并时，列数量要相同： limit limit作用：查询第几条到第几条的记录。通常是因为表中数据量太大，需要分页显示。 limit语法格式： limit 开始下标, 长度 案例：查询员工表前5条记录 1select ename,sal from emp limit 0, 5; 如果下标是从0开始，可以简写为： 1select ename,sal from emp limit 5; 查询工资排名在前5名的员工（limit是在order by执行之后才会执行的） 1select ename,sal from emp order by sal desc limit 5; 通用的分页sql 假设每页显示3条记录：pageSize = 3第1页：limit 0, 3第2页：limit 3, 3第3页：limit 6, 3第pageNo页：limit (pageNo - 1)*pageSize, pageSize 35个DQL练手题第1题 取得每个部门最高薪水的人员名称 第一步：取得每个部门最高薪水 1select deptno,max(sal) as maxsal from emp group by deptno; 第二步：将上面第一步的查询结果当做一张临时表t，进行表连接，条件是：t.deptno=e.deptno and t.maxsal=e.sal 1select e.ename,t.* from emp e join (select deptno,max(sal) as maxsal from emp group by deptno) t on e.deptno = t.deptno and e.sal = t.maxsal; 第2题 哪些人的薪水在部门的平均薪水之上 第一步：取得每个部门的平均薪水 1select deptno,avg(sal) as avgsal from emp group by deptno; 第二步：将上面的查询结果当做临时表t，让t和emp e表进行表连接，条件是：t.deptno=e.deptno and e.sal&gt;t.avgsal 1select e.ename,e.sal,t.* from emp e join (select deptno,avg(sal) as avgsal from emp group by deptno) t on t.deptno=e.deptno and e.sal&gt;t.avgsal; 第3题 取得每个部门平均薪水的等级 第一步：取得每个部门的平均薪水 1select deptno,avg(sal) as avgsal from emp group by deptno; 第二步：将上面的查询结果当做临时表t，然后t和salgrade s表进行连接，条件是：t.avgsal between s.losal and s.hisal 1select t.*,s.grade from (select deptno,avg(sal) as avgsal from emp group by deptno) t join salgrade s on t.avgsal between s.losal and s.hisal; 第4题 取得部门中（所有人的）平均的薪水等级 第一步：找出每个人的薪水等级 1select e.ename,e.sal,s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal; 第二步：在上面的查询结果当中继续按照部门编号进行分组，求平均值。（不需要将上面的查询结果当做临时表，继续基于它进行分组即可。） 12345678910select e.deptno,avg(s.grade) from emp e join salgrade s on e.sal between s.losal and s.hisal group by e.deptno; 第5题 不准用组函数（Max），取得最高薪水（给出两种解决方案） 第一种方案：按照薪资降序排列，取第一个。 1select sal from emp order by sal desc limit 1; 第二种方案：采用表的自连接方式。 1select ename,sal from emp where sal not in(select distinct a.sal from emp a join emp b on a.sal &lt; b.sal); 第6题 取得平均薪水最高的部门的部门编号（至少给出两种解决方案） 第一种方案：降序排列取第一个 1select deptno,avg(sal) as avgsal from emp group by deptno order by avgsal desc limit 1; 第二种方案：max函数 1select deptno,avg(sal) as avgsal from emp group by deptno having avg(sal)=(select max(t.avgsal) from (select avg(sal) as avgsal from emp group by deptno) t); 第7题 取得平均薪水最高的部门的部门名称 比上面的题目多一个表连接，和dept表连接，按照部门名称进行分组。 1select d.dname,avg(e.sal) as avgsal from emp e join dept d on e.deptno=d.deptno group by d.dname order by avgsal desc limit 1; 第8题 求平均薪水的等级最低的部门的部门名称 第一步：求每个部门的平均薪水 1select d.dname,avg(e.sal) as avgsal from emp e join dept d on e.deptno = d.deptno group by d.dname; 第二步：求每个部门的平均薪水等级（将以上的执行结果当做临时表t，t和salgrade s表进行连接，条件：t.avgsal between .s.losal and s.hisal） 1select t.*,s.grade from (select d.dname,avg(e.sal) as avgsal from emp e join dept d on e.deptno = d.deptno group by d.dname) t join salgrade s on t.avgsal between s.losal and s.hisal; 第三步：找到最低的部门名称（以上结果继续按照grade进行升序，然后limit 1） 1select t.*,s.grade from (select d.dname,avg(e.sal) as avgsal from emp e join dept d on e.deptno = d.deptno group by d.dname) t join salgrade s on t.avgsal between s.losal and s.hisal order by s.grade asc limit 1; 第9题 取得比普通员工(员工代码没有在mgr字段上出现的)的最高薪水还要高的领导人姓名 第一步：找出所有的普通员工的最高薪水 1select max(sal) from emp where empno not in(select mgr from emp where mgr is not null); 第二步：大于以上最高薪水的一定是要找的领导人。 1select ename,sal from emp where sal &gt; (select max(sal) from emp where empno not in(select mgr from emp where mgr is not null)); 第10题 取得薪水最高的前五名员工 1select ename,sal from emp order by sal desc limit 5; 第11题 取得薪水最高的第六到第十名员工 1select ename,sal from emp order by sal desc limit 5, 5; 第12题 取得最后入职的5名员工 1select ename,sal,hiredate from emp order by hiredate desc limit 5; 第13题 取得每个薪水等级有多少员工 第一步：找出每个员工的薪水等级 1select e.ename,s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal; 第二步：基于以上的记录继续根据等级分组，count即可。 1select s.grade,count(*) from emp e join salgrade s on e.sal between s.losal and s.hisal group by s.grade; 第14题 列出所有员工及领导的姓名 1select e.ename 员工名, l.ename 领导名 from emp e left join emp l on e.mgr = l.empno; 第15题 列出受雇日期早于其直接上级的所有员工的编号,姓名,部门名称 1select e.ename 员工名,e.hiredate, l.ename 领导名,l.hiredate,d.dname from emp e join emp l on e.mgr = l.empno join dept d on e.deptno = d.deptno where e.hiredate &lt; l.hiredate; 第16题 列出部门名称和这些部门的员工信息,同时列出那些没有员工的部门 1select d.dname,e.ename,e.sal from dept d left join emp e on d.deptno = e.deptno; 第17题 列出至少有5个员工的所有部门 1select deptno, count(*) from emp group by deptno having count(*) &gt;= 5; 第18题 列出薪金比”SMITH”多的所有员工信息 1select ename,sal from emp where sal &gt; (select sal from emp where ename = 'SMITH'); 第19题 列出所有”CLERK”(办事员)的姓名及其部门名称,部门的人数 1select t1.ename,t1.dname,t2.total from (select e.ename,d.dname,d.deptno from emp e join dept d on e.deptno = d.deptno where e.job = 'CLERK') t1 join (select count(*) as total,deptno from emp group by deptno) t2 on t1.deptno = t2.deptno; 第20题 列出最低薪金大于1500的各种工作及从事此工作的全部雇员人数 1select job,min(sal),count(*) from emp group by job having min(sal)&gt;1500; 第21题 列出在部门”SALES”&lt;销售部&gt;工作的员工的姓名,假定不知道销售部的部门编号 1select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno where d.dname='sales'; 第22题 列出薪金高于公司平均薪金的所有员工,所在部门,上级领导,雇员的工资等级 12345select e.ename 员工,l.ename 领导,d.dname,s.grade from emp e left join emp l on e.mgr = l.empno join dept d on e.deptno = d.deptno join salgrade s on e.sal between s.losal and s.hisal where e.sal &gt; (select avg(sal) from emp); 第23题 列出与”SCOTT”从事相同工作的所有员工及部门名称 1select e.ename,d.dname,e.job from emp e join dept d on e.deptno=d.deptno where job=(select job from emp where ename ='scott'); 第24题 列出薪金等于部门30中员工的薪金的其他员工的姓名和薪金 1select ename,sal,deptno from emp where sal in(select distinct sal from emp where deptno=30) and deptno &lt;&gt; 30; 第25题 列出薪金高于在部门30工作的所有员工的薪金的员工姓名和薪金.部门名称 1select e.ename,e.sal,d.dname from emp e join dept d on e.deptno = d.deptno where sal &gt; (select max(sal) from emp where deptno=30); 第26题 列出在每个部门工作的员工数量,平均工资和平均服务期限 1select avg(sal),count(*),deptno,avg(datediff(now(),hiredate)) as avgtime from emp group by deptno; 第27题 列出所有员工的姓名、部门名称和工资 1select e.ename,e.sal,d.dname from emp e join dept d on e.deptno = d.deptno; 第28题 列出所有部门的详细信息和人数 1select d.deptno,d.dname,d.loc,count(e.deptno) from emp e right join dept d on e.deptno=d.deptno group by d.deptno,d.dname,d.loc; 第29题 列出各种工作的最低工资及从事此工作的雇员姓名 1select t.job,t.minsal,e.ename from emp e join (select job,min(sal) as minsal from emp group by job) t on e.job=t.job and e.sal=t.minsal; 第30题 列出各个部门的MANAGER(领导)的最低薪金 1select deptno,min(sal) from emp where job='MANAGER' group by deptno 第31题 列出所有员工的年工资,按年薪从低到高排序 1select ename,(sal+ifnull(comm,0))*12 as yearsal from emp order by yearsal asc; 第32题 求出员工领导的薪水超过3000的员工名称与领导名称 1select e.ename 员工名, l.ename 领导名 from emp e join emp l on e.mgr = l.empno where l.sal&gt;3000; 第33题 求出部门名称中,带’S’字符的部门员工的工资合计、部门人数 1select d.dname,ifnull(sum(sal),0) as sumsal,count(e.ename) from emp e right join dept d on e.deptno=d.deptno where d.dname like '%S%' group by d.dname; 第34题 给任职日期超过30年的员工加薪10% 1update emp set sal=sal*1.1 where datediff(now(),hiredate)/365 &gt; 30; 第35题 某公司面试题 有3个表S（学生表），C（课程表），SC（学生选课表）S（SNO，SNAME）代表（学号，姓名）C（CNO，CNAME，CTEACHER）代表（课号，课名，教师）SC（SNO，CNO，SCGRADE）代表（学号，课号，成绩） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546CREATE TABLE SC( SNO VARCHAR(200), CNO VARCHAR(200), SCGRADE VARCHAR(200));CREATE TABLE S( SNO VARCHAR(200 ), SNAME VARCHAR(200));CREATE TABLE C( CNO VARCHAR(200), CNAME VARCHAR(200), CTEACHER VARCHAR(200));INSERT INTO C ( CNO, CNAME, CTEACHER ) VALUES ( '1', '语文', '张'); INSERT INTO C ( CNO, CNAME, CTEACHER ) VALUES ( '2', '政治', '王'); INSERT INTO C ( CNO, CNAME, CTEACHER ) VALUES ( '3', '英语', '李'); INSERT INTO C ( CNO, CNAME, CTEACHER ) VALUES ( '4', '数学', '赵'); INSERT INTO C ( CNO, CNAME, CTEACHER ) VALUES ( '5', '物理', '黎明'); commit; INSERT INTO S ( SNO, SNAME ) VALUES ( '1', '学生1'); INSERT INTO S ( SNO, SNAME ) VALUES ( '2', '学生2'); INSERT INTO S ( SNO, SNAME ) VALUES ( '3', '学生3'); INSERT INTO S ( SNO, SNAME ) VALUES ( '4', '学生4'); commit; INSERT INTO SC ( SNO, CNO, SCGRADE ) VALUES ( '1', '1', '40'); INSERT INTO SC ( SNO, CNO, SCGRADE ) VALUES ( '1', '2', '30'); INSERT INTO SC ( SNO, CNO, SCGRADE ) VALUES ( '1', '3', '20'); INSERT INTO SC ( SNO, CNO, SCGRADE ) VALUES ( '1', '4', '80'); INSERT INTO SC ( SNO, CNO, SCGRADE ) VALUES ( '1', '5', '60'); INSERT INTO SC ( SNO, CNO, SCGRADE ) VALUES ( '2', '1', '60'); INSERT INTO SC ( SNO, CNO, SCGRADE ) VALUES ( '2', '2', '60'); INSERT INTO SC ( SNO, CNO, SCGRADE ) VALUES ( '2', '3', '60'); INSERT INTO SC ( SNO, CNO, SCGRADE ) VALUES ( '2', '4', '60'); INSERT INTO SC ( SNO, CNO, SCGRADE ) VALUES ( '2', '5', '40'); INSERT INTO SC ( SNO, CNO, SCGRADE ) VALUES ( '3', '1', '60'); INSERT INTO SC ( SNO, CNO, SCGRADE ) VALUES ( '3', '3', '80'); commit; 问题：1，找出没选过“黎明”老师的所有学生姓名。 1select sname from s where sno not in(select sno from sc where cno=(select cno from c where cteacher='黎明')); 2，列出2门以上（含2门）不及格学生姓名及平均成绩。 1select a.*,b.avgscore from (select s.sno,s.sname,count(sc.scgrade) as num from sc join s on sc.sno=s.sno where sc.scgrade &lt; 60 group by s.sname,s.sno having count(sc.scgrade) &gt;= 2) a join (select sno,avg(scgrade) avgscore from sc group by sno) b on a.sno = b.sno; 3，既学过1号课程又学过2号课所有学生的姓名。 1select sc.sno,s.sname from sc join s on sc.sno=s.sno where sc.cno=1 and sc.sno in(select sno from sc where cno=2);","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://xiaofanshutu.github.io/categories/MySQL/"}],"tags":[]},{"title":"Java异常","slug":"动力节点Java/Chapter5_异常","date":"2025-06-25T22:56:00.318Z","updated":"2025-06-29T23:23:29.551Z","comments":true,"path":"posts/f495a96f.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/f495a96f.html","excerpt":"异常继承结构 所有的异常和错误都是可抛出的。都继承了Throwable类。 Error是无法处理的，出现后只有一个结果：JVM终止。 Exception是可以处理的。 Exception的分类： 所有的RuntimeException的子类：运行时异常/未检查异常(UncheckedException)/非受控异常 Exception的子类（除RuntimeException之外）：编译时异常/检查异常(CheckedException)/受控异常 编译时异常和运行时异常区别： 编译时异常特点：在编译阶段必须提前处理，如果不处理编译器报错。 运行时异常特点：在编译阶段可以选择处理，也可以不处理，没有硬性要求。 编译时异常一般是由外部环境或外在条件引起的，如网络故障、磁盘空间不足、文件找不到等 运行时异常一般是由程序员的错误引起的，并且不需要强制进行异常处理 注意：编译时异常并不是在编译阶段发生的异常，所有的异常发生都是在运行阶段的，因为每个异常发生都是会new异常对象的，new异常对象只能在运行阶段完成。那为什么叫做编译时异常呢？这是因为这种异常必须在编译阶段提前预处理，如果不处理编译器报错，因此而得名编译时异常。 异常的处理异常的处理包括两种方式： 声明异常：类似于推卸责任的处理方式 在方法定义时使用throws关键字声明异常，告知调用者，调用这个方法可能会出现异常。这种处理方式的态度是：如果出现了异常则会抛给调用者来处理。 捕捉异常：真正的处理捕捉异常 在可能出现异常的代码上使用try..catch进行捕捉处理。这种处理方式的态度是：把异常抓住。其它方法如果调用这个方法，对于调用者来说是不知道这个异常发生的。因为这个异常被抓住并处理掉了。 异常在处理的整个过程中应该是：声明和捕捉联合使用。 什么时候捕捉？什么时候声明？如果异常发生后需要调用者来处理的，需要调用者知道的，则采用声明方式。否则采用捕捉。 声明异常(throws 关键字) 如果一个异常发生后希望调用者来处理的，使用声明异常（俗话说：交给上级处理） public void m() throws AException, BException... {} 如果AException和BException都继承了XException，那么也可以这样写： public void m() throws XException{} 调用者在调用m()方法时，编译器会检测到该方法上用throws声明了异常，表示可能会抛出异常，编译器会继续检测该异常是否为编译时异常，如果为编译时异常则必须在编译阶段进行处理，如果不处理编译器就会报错。 如果所有位置都采用throws，包括main方法的处理态度也是throws，如果运行时出现了异常，最终异常是抛给了main方法的调用者（JVM），JVM则会终止程序的执行。因此为了保证程序在出现异常后不被中断，至少main方法不要再使用throws进行声明了。 发生异常后，在发生异常的位置上，往下的代码是不会执行的，除非进行了异常的捕捉。 捕捉异常 (try…catch…关键字)","text":"异常继承结构 所有的异常和错误都是可抛出的。都继承了Throwable类。 Error是无法处理的，出现后只有一个结果：JVM终止。 Exception是可以处理的。 Exception的分类： 所有的RuntimeException的子类：运行时异常/未检查异常(UncheckedException)/非受控异常 Exception的子类（除RuntimeException之外）：编译时异常/检查异常(CheckedException)/受控异常 编译时异常和运行时异常区别： 编译时异常特点：在编译阶段必须提前处理，如果不处理编译器报错。 运行时异常特点：在编译阶段可以选择处理，也可以不处理，没有硬性要求。 编译时异常一般是由外部环境或外在条件引起的，如网络故障、磁盘空间不足、文件找不到等 运行时异常一般是由程序员的错误引起的，并且不需要强制进行异常处理 注意：编译时异常并不是在编译阶段发生的异常，所有的异常发生都是在运行阶段的，因为每个异常发生都是会new异常对象的，new异常对象只能在运行阶段完成。那为什么叫做编译时异常呢？这是因为这种异常必须在编译阶段提前预处理，如果不处理编译器报错，因此而得名编译时异常。 异常的处理异常的处理包括两种方式： 声明异常：类似于推卸责任的处理方式 在方法定义时使用throws关键字声明异常，告知调用者，调用这个方法可能会出现异常。这种处理方式的态度是：如果出现了异常则会抛给调用者来处理。 捕捉异常：真正的处理捕捉异常 在可能出现异常的代码上使用try..catch进行捕捉处理。这种处理方式的态度是：把异常抓住。其它方法如果调用这个方法，对于调用者来说是不知道这个异常发生的。因为这个异常被抓住并处理掉了。 异常在处理的整个过程中应该是：声明和捕捉联合使用。 什么时候捕捉？什么时候声明？如果异常发生后需要调用者来处理的，需要调用者知道的，则采用声明方式。否则采用捕捉。 声明异常(throws 关键字) 如果一个异常发生后希望调用者来处理的，使用声明异常（俗话说：交给上级处理） public void m() throws AException, BException... {} 如果AException和BException都继承了XException，那么也可以这样写： public void m() throws XException{} 调用者在调用m()方法时，编译器会检测到该方法上用throws声明了异常，表示可能会抛出异常，编译器会继续检测该异常是否为编译时异常，如果为编译时异常则必须在编译阶段进行处理，如果不处理编译器就会报错。 如果所有位置都采用throws，包括main方法的处理态度也是throws，如果运行时出现了异常，最终异常是抛给了main方法的调用者（JVM），JVM则会终止程序的执行。因此为了保证程序在出现异常后不被中断，至少main方法不要再使用throws进行声明了。 发生异常后，在发生异常的位置上，往下的代码是不会执行的，除非进行了异常的捕捉。 捕捉异常 (try…catch…关键字) 如果一个异常发生后，不需要调用者知道，也不需要调用者来处理，选择使用捕捉方式处理。 try{ // 尝试执行可能会出现异常的代码 // try块中的代码如果执行出现异常，出现异常的位置往下的代码是不会执行的，直接进入catch块执行 }catch(AException e){ // 如果捕捉到AException类型的异常，在这里处理 }catch(BException e){ // 如果捕捉到BException类型的异常，在这里处理 }catch(XException e){ // 如果捕捉到XException类型的异常，在这里处理} // 当try..catch..将所有发生的异常捕捉后，这里的代码是会继续往下执行的。 catch可以写多个。并且遵循自上而下，从小到大。 Java7新特性：catch后面小括号中可以编写多个异常，使用运算符“|”隔开。 异常的常用方法 获取异常的简单描述信息： exception.getMessage(); 获取的message是通过构造方法创建异常对象时传递过去的message。 打印异常堆栈信息： exception.printStackTrace(); 要会看异常的堆栈信息： 异常信息的打印是符合栈数据结构的。 看异常信息主要看最开始的描述信息。看栈顶信息。 finally语句块概念 finally语句块中的代码是一定会执行的。 finally语句块不能单独使用，至少需要配合try语句块一起使用： try…finally try…catch…finally 资源释放的工作比较重要，如果资源没有释放会一直占用内存。 为了保证资源的关闭，也就是说：不管程序是否出现异常，关闭资源的代码一定要保证执行。 因此在finally语句块中通常进行资源的释放。 final、finally、finalize分别是什么？ final是一个关键字，修饰的类无法继承，修饰的方法无法覆盖，修饰的变量不能修改。 finally是一个关键字，和try一起使用，finally语句块中的代码一定会执行。 finalize是一个标识符，它是Object类中的一个方法名。 练习以下程序的执行结果？ 以下程序的执行结果？ 方法覆盖与异常方法重写之后，不能比父类方法抛出更多的异常，可以更少。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaofanshutu.github.io/categories/Java/"}],"tags":[]},{"title":"Java数组","slug":"动力节点Java/Chapter4_数组","date":"2025-06-19T13:25:52.900Z","updated":"2025-06-25T22:53:49.990Z","comments":true,"path":"posts/e3345db4.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/e3345db4.html","excerpt":"数组概述 什么是数组？ 在Java中，数组是一种用于存储多个相同数据类型元素的容器。 例如一个存储整数的数组：int[] nums = {100, 200, 300}; 例如一个存储字符串的数组：String[] names = {“jack”,“lucy”,“lisi”}; 数组是一种引用数据类型，隐式继承Object。因此数组也可以调用Object类中的方法。 数组对象存储在堆内存中。 数组的分类？ 根据维数进行分类：一维数组，二维数组，三维数组，多维数组。 根据数组中存储的元素类型分类：基本类型数组，引用类型数组。 根据数组初始化方式不同分类：静态数组，动态数组。 Java数组存储元素的特点？ 数组长度一旦确定不可变。 数组中元素数据类型一致，每个元素占用空间大小相同。 数组中每个元素在空间存储上，内存地址是连续的。 每个元素有索引，首元素索引0，以1递增。 以首元素的内存地址作为数组对象在堆内存中的地址。 所有数组对象都有length属性用来获取数组元素个数。末尾元素下标：length-1 数组优点？ 根据下标查询某个元素的效率极高。数组中有100个元素和有100万个元素，查询效率相同。时间复杂度O(1)。也就是说在数组中根据下标查询某个元素时，不管数组的长短，耗费时间是固定不变的。 原因：知道首元素内存地址，元素在空间存储上内存地址又是连续的，每个元素占用空间大小相同，只要知道下标，就可以通过数学表达式计算出来要查找元素的内存地址。直接通过内存地址定位元素。 数组缺点？ 随机增删元素的效率较低。因为随机增删元素时，为了保证数组中元素的内存地址连续，就需要涉及到后续元素的位移问题。时间复杂度O(n)。O(n)表示的是线性阶，随着问题规模n的不断增大，时间复杂度不断增大，算法的执行效率越低。（不过需要注意的是：对数组末尾元素的增删效率是不受影响的。） 无法存储大量数据，因为很难在内存上找到非常大的一块连续的内存。 一维数组 一维数组是线性结构。二维数组，三维数组，多维数组是非线性结构。 如何静态初始化一维数组？ 第一种：int[] arr = {55,67,22}; 或者 int arr[] = {55,67,22}; 第二种：int[] arr = new int[]{55,67,22}; 如何访问数组中的元素？ ​ 通过下标来访问。注意ArrayIndexOutOfBoundsException异常的发生。 如何遍历数组？ ​ 普通for循环遍历 ​ for-each遍历（优点是代码简洁。缺点是没有下标。） 如何动态初始化一维数组？ ​ int[] arr = new int[4]; ​ Object[] objs = new Object[5]; ​ 数组动态初始化的时候，确定长度，并且数组中每个元素采用默认值。 一维数组中存储引用时的内存图 关于main方法的形参args？ 接收命令行参数 在DOS命令窗口中怎么传？在IDEA中怎么传？ 关于方法的可变长度参数？ 可变长参数只能出现在形参列表中的最后一个位置。 可变长参数可以当做数组来处理。","text":"数组概述 什么是数组？ 在Java中，数组是一种用于存储多个相同数据类型元素的容器。 例如一个存储整数的数组：int[] nums = {100, 200, 300}; 例如一个存储字符串的数组：String[] names = {“jack”,“lucy”,“lisi”}; 数组是一种引用数据类型，隐式继承Object。因此数组也可以调用Object类中的方法。 数组对象存储在堆内存中。 数组的分类？ 根据维数进行分类：一维数组，二维数组，三维数组，多维数组。 根据数组中存储的元素类型分类：基本类型数组，引用类型数组。 根据数组初始化方式不同分类：静态数组，动态数组。 Java数组存储元素的特点？ 数组长度一旦确定不可变。 数组中元素数据类型一致，每个元素占用空间大小相同。 数组中每个元素在空间存储上，内存地址是连续的。 每个元素有索引，首元素索引0，以1递增。 以首元素的内存地址作为数组对象在堆内存中的地址。 所有数组对象都有length属性用来获取数组元素个数。末尾元素下标：length-1 数组优点？ 根据下标查询某个元素的效率极高。数组中有100个元素和有100万个元素，查询效率相同。时间复杂度O(1)。也就是说在数组中根据下标查询某个元素时，不管数组的长短，耗费时间是固定不变的。 原因：知道首元素内存地址，元素在空间存储上内存地址又是连续的，每个元素占用空间大小相同，只要知道下标，就可以通过数学表达式计算出来要查找元素的内存地址。直接通过内存地址定位元素。 数组缺点？ 随机增删元素的效率较低。因为随机增删元素时，为了保证数组中元素的内存地址连续，就需要涉及到后续元素的位移问题。时间复杂度O(n)。O(n)表示的是线性阶，随着问题规模n的不断增大，时间复杂度不断增大，算法的执行效率越低。（不过需要注意的是：对数组末尾元素的增删效率是不受影响的。） 无法存储大量数据，因为很难在内存上找到非常大的一块连续的内存。 一维数组 一维数组是线性结构。二维数组，三维数组，多维数组是非线性结构。 如何静态初始化一维数组？ 第一种：int[] arr = {55,67,22}; 或者 int arr[] = {55,67,22}; 第二种：int[] arr = new int[]{55,67,22}; 如何访问数组中的元素？ ​ 通过下标来访问。注意ArrayIndexOutOfBoundsException异常的发生。 如何遍历数组？ ​ 普通for循环遍历 ​ for-each遍历（优点是代码简洁。缺点是没有下标。） 如何动态初始化一维数组？ ​ int[] arr = new int[4]; ​ Object[] objs = new Object[5]; ​ 数组动态初始化的时候，确定长度，并且数组中每个元素采用默认值。 一维数组中存储引用时的内存图 关于main方法的形参args？ 接收命令行参数 在DOS命令窗口中怎么传？在IDEA中怎么传？ 关于方法的可变长度参数？ 可变长参数只能出现在形参列表中的最后一个位置。 可变长参数可以当做数组来处理。 一维数组的扩容 数组长度一旦确定不可变。 那数组应该如何扩容？ 只能创建一个更大的数组将原数组中的数据全部拷贝到新数组中 可以使用System.arraycopy()方法完成数组的拷贝。 数组扩容会影响程序的执行效率，因此尽可能预测数据量，创建一个接近数量的数组，减少扩容次数 二维数组 二维数组是一个特殊的一维数组，特殊在：这个一维数组中每个元素是一个一维数组。 二维数组的静态初始化 int[][] arr = new int[][]{{},{},{}}; int[][] arr = {{},{},{}}; 二维数组的动态初始化(等长) int[][] arr = new int[3][4]; 二维数组的动态初始化（不等长） int[][] arr = new int[3][]; 二维数组中元素的访问 第一个元素：arr[0][0] 最后一个元素：arr[arr.length-1][arr[arr.length-1].length-1] 二维数组中元素的遍历 IDEA中的Debug调试 在可能出现问题的代码附近添加断点。一般是将断点添加在方法体的某一行代码上。 断点可以添加多个。点一次添加一个断点。再点一次断点则消失。 添加断点后，如果想让程序运行到断点处停下来，需要使用Debug模式运行程序。 Debug窗口中的按钮 给断点添加条件 Debug窗口中的隐藏按钮 数据结构与算法数据结构概述 数据结构概述数据结构是指用来存储和组织数据的一种方式，就像在生活中我们用文件柜、书架、衣柜等来整理我们的物品一样，数据结构也可以帮助我们整理和管理程序中的数据。 数据结构分为：数据的逻辑结构、数据的物理结构 逻辑结构是指数据元素之间的逻辑关系，它是从抽象的角度描述数据元素之间的关系，不涉及具体的存储方式或实现细节。逻辑结构主要关注问题的本质、特点和抽象模型，是数据结构的逻辑表示。 物理结构是指数据结构在计算机内存中实际存储和组织的方式。它是从具体的角度描述数据结构的实现方式和存储结构，包括数据元素在内存中的存储分布和访问方式等。物理结构主要关注问题的具体实现和操作。 因此，逻辑结构与物理结构的区别在于：逻辑结构是从抽象的角度描述数据元素之间的关系，物理结构是从具体的角度描述内存中数据元素的存储方式和组织形式。逻辑结构主要关注问题的本质和特点，物理结构主要关注问题的具体实现和操作。 逻辑结构的划分？ 集合结构：数据结构中的元素之间除了在“同属一个集合”的关系外，别无其它关系； 线性结构：数据结构中的元素存在“一对一”的线性关系，例如冰糖葫芦； 树形结构：数据结构中的元素存在“一对多”的层次关系，例如公司组织架构； 图形结构或网状结构：数据结构中的元素存在“多对多”的任意关系，例如地图。 物理结构的划分？ 顺序存储结构：用一组连续的存储空间单元来依次的存储数据元素，例如数组。 链式存储结构：用一组任意的存储单元来存储元素，通过保存地址找到相关联的元素，元素之间的逻辑关系用引用来表示，例如链表。 散列存储结构：根据节点key计算出该节点的存储地址。例如：java集合中的HashMap采用了散列存储结构，添加、查询速度都很快。 算法概述 什么是算法？ 算法就是解决问题的方法和步骤，可以让计算机完成特定任务，并提高计算机系统的效率和性能。就像烹饪食品需要遵循一定的步骤和配方一样，例如，做牛排需要选择牛排肉、煎炸的方式、烹饪的时间等，按照一定的步骤最终会有一个好的成品。一个良好的算法可以提高程序的执行效率。 怎么评价一个算法好不好？ 如何计算1+2+3+…+100的结果？ 算法1：通过循环，依次累加来实现。耗费时间 算法2：使用递归来实现。耗费内存 算法3：高斯算法。(1 + 100)*50。既节省时间，又节省空间。 同一问题可用不同的算法来解决，而一个算法的质量优劣将影响到算法乃至程序的效率。因此，我们学习算法目的在于选择合适算法和改进算法，一个算法的评价主要从时间复杂度和空间复杂度来考虑。 时间复杂度：评估执行程序所需的时间，可以估算出程序对处理器的使用程度。 空间复杂度：评估执行程序所需的存储空间，可以估算出程序对计算机内存的使用程度。 数组的排序算法冒泡排序核心思想 相邻两个元素做比较大小，如果前一个元素大于后一个元素，则交换位置 12345678910111213private static void bubbleSort(int[] arr) { for (int i = 0; i &lt; arr.length - 1; i++) { for (int j = 0; j &lt; arr.length - 1 - i; j++) { System.out.println(\"============================\"); // 两个两个进行比较 if(arr[j] &gt; arr[j+1]) { int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } }} 结果： 1234567891011========================================================================================================================================================================================================================================================================================[1, 2, 3, 4, 5] 12345678910111213141516171819202122/** * 冒泡排序算法的优化。*/private static void bubbleSort(int[] arr) { for (int i = arr.length - 1; i &gt;= 0; i--) { // 默认是排好序的。 boolean flag = true; for (int j = 0; j &lt; i; j++) { System.out.println(\"=======================\"); // 两个两个进行比较 if(arr[j] &gt; arr[j+1]) { int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; flag = false; } } if(flag){ break; } }} 结果： 12345============================================================================================[1, 2, 3, 4, 5] 选择排序核心思想 在未排序的序列中，把未排序第一个元素和未排序的最小元素交换位置。 123456789101112131415161718/** * 选择排序： * 核心原理：找出参与比较的这些数据中最小的，然后拿着这个最小的数据和参与比较的这堆数据中最左边的元素交换位置。 * 优点：交换的次数比冒泡排序的少。执行效率比冒泡排序高。（冒泡排序中的元素每一次比完之后就交换，这个交换有时是没必要的。） * * 原理： * (1)参与比较的数据：3, 2, 7, 6, 1 * 第一次循环之后的结果：1, 2, 7, 6, 3 * * (2)参与比较的数据：x, 2, 7, 6, 3 * 第二次循环之后的结果：1, 2, 7, 6, 3 * * (3)参与比较的数据：x, x, 7, 6, 3 * 第三次循环之后的结果：1, 2, 3, 6, 7 * * (4)参与比较的数据：x, x, x, 6, 7 * 第四次循环之后的结果：1, 2, 3, 6, 7 */ 1234567891011121314151617181920212223public static void main(String[] args) { int[] arr = {3, 2, 7, 6, 1, 100, 200, 80, 870}; selectSort(arr); System.out.println(Arrays.toString(arr));}private static void selectSort(int[] arr) { for (int i = 0; i &lt; arr.length - 1; i++) { // 假定参与比较的这些数据中最左边的是最小的。 int min = i; for(int j = i+1; j &lt; arr.length; j++){ if (arr[j] &lt; arr[min]) { min = j; } } if(min != i){ // 说明有更小的值 // 交换位置（拿着当下的最小值和参与比较的这些数据中最前面的值交换位置） int temp = arr[min]; arr[min] = arr[i]; arr[i] = temp; } }} 1[1, 2, 3, 6, 7, 80, 100, 200, 870] 数组的查找算法线性查找①线性查找是一种最简单粗暴的查找法了，采用逐一比对的方式进行对数组的遍历，如果发现了匹配值，返回数组下标即可。 ②线性查找，优点是查找数组无需有序；其缺点是查找的次数多，效率低下。 12345678910111213141516public static void main(String[] args) { int[] arr = {102,3,4,54,5,6,67,7,78,8,8,87,67,6}; // 找出以上数组中67元素的下标（67元素第一次出现处的下标） int num = 67; int index = search(arr, num); System.out.println(index &gt;= 0 ? num + \" first occur at: \" + index : \"don't have this data\");}private static int search(int[] arr, int num) { for (int i = 0; i &lt; arr.length; i++) { if(num == arr[i]){ return i; } } return -1;} 167 first occur at: 6 二分法查找①二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好；缺点是要求待查数组必须排序，且执行插入和删除操作困难。因此，折半查找方法适用于不经常变动而查找频繁的数组。 ②查找思路： 假设查找的数组为升序排序，则首先定义两个变量，分别用于保存查找元素（value）所在范围的最小索引值（min）和最大索引值（max）。 然后开启二分查找，每次查找前都定义一个mid变量，并设置该变量的初始值为：(max + min)/2。在查找的过程中，发生以下三种情况，则做对应的处理。 如果arr[mid]大于value，则证明查找的元素在mid的左侧，那么更新max的值为：mid-1 如果arr[mid]小于value，则证明查找的元素在mid的右侧，那么更新min的值为：mid+1 如果arr[mid]等于value，则证明查找元素的索引值就是mid，返回mid的值即可！ 在以上的操作中，我们不停的更改min和max的值，如果发生min大于max的情况，则证明查找的元素不存在，那么返回-1（表示找不到）即可！ 12345678910111213141516171819202122public static void main(String[] args) { int[] arr = {1,20,50,77,80,99,101,256,666,888}; int num = 101; int index = binarySearch(arr, num); System.out.println(index &gt;= 0 ? num + \"'s index is: \" + index : \"can't find this data\");}private static int binarySearch(int[] arr, int num) { int begin = 0; int end = arr.length - 1; while(begin &lt;= end){ int mid = (begin + end) / 2; if(arr[mid] == num) { return mid; }else if(num &gt; arr[mid]){ begin = mid + 1; }else{ end = mid - 1; } } return -1;} 1101's index is: 6 Arrays工具类①Arrays.toString()方法：将数组转换成字符串 ②Arrays.deepToString()方法：可以将二维数组转换成字符串 ③Arrays.equals(int[] arr1, int[] arr2)方法：判断两个数组是否相等 ④Arrays.equals(Object[] arr1, Object[] arr2)方法 ⑤Arrays.deepEquals(Object[] arr1, Object[] arr2)方法：判断两个二维数组是否相等 ⑥Arrays.sort(int[] arr)方法：基于快速排序算法，适合小型数据量排序。 ⑦Arrays.sort(String[] arr)方法 ⑧Arrays.parallelSort(int[] arr)方法：基于分治的归并排序算法，支持多核CPU排序，适合大数据量排序。 ⑨int binarySearch(int[] arr, int elt)方法：二分法查找 ⑩Arrays.fill(int[] arr, int data)方法：填充数组 ⑪Arrays.fill(int[] a, int fromIndex, int toIndex, int val)方法 ⑫int[] Arrays.copyOf(int[] original, int newLength)方法：数组拷贝 ⑬int[] Arrays.copyOfRange(int[] original, int from, int to) ⑭Arrays.asList(T… data)方法：将一组数据转换成List集合。 12345678910@Testpublic void testToString() { int[] arr = {1, 2, 3, 34, 54}; System.out.println(arr); // [I@3d3fcdb0 System.out.println(Arrays.toString(arr)); // [1, 2, 3, 34, 54] String[] names = {\"zhangsan\", \"lisi\", \"wangwu\"}; System.out.println(names); // [Ljava.lang.String;@641147d0 System.out.println(Arrays.toString(names)); //[zhangsan, lisi, wangwu]} 1234567891011121314/** * Arrays.deepToString()作用是：适合于将多维数组转换成字符串。 */@Testpublic void testDeepToString() { // 适合于二维数组以及多维数组的。 int[][] arr = { {12, 2, 3, 3}, {4, 45, 5, 5}, {1, 1, 1, 1, 1, 1} }; System.out.println(Arrays.toString(arr)); // [[I@641147d0, [I@6e38921c, [I@64d7f7e0] System.out.println(Arrays.deepToString(arr)); // [[12, 2, 3, 3], [4, 45, 5, 5], [1, 1, 1, 1, 1, 1]]} 12345678910@Testpublic void testEquals() { int[] arr1 = {1, 2, 3}; int[] arr2 = {2, 1, 3}; System.out.println(Arrays.equals(arr1, arr2)); String[] names1 = new String[]{\"abc\", \"def\", \"xyz\"}; String[] names2 = new String[]{\"abc\", \"def\", \"xyz\"}; System.out.println(Arrays.equals(names1, names2));} Equals方法 12345678910@Testpublic void testEquals() { int[] arr1 = {1, 2, 3}; int[] arr2 = {2, 1, 3}; System.out.println(Arrays.equals(arr1, arr2)); //false String[] names1 = new String[]{\"abc\", \"def\", \"xyz\"}; String[] names2 = new String[]{\"abc\", \"def\", \"xyz\"}; System.out.println(Arrays.equals(names1, names2)); //true} Sort方法 123456789101112131415161718192021222324252627@Testpublic void testSort() { int[] arr = {1, 3, 45, 5, 6, 7, 87, 8}; Arrays.sort(arr); System.out.println(Arrays.toString(arr));//[1, 3, 5, 6, 7, 8, 45, 87] String[] strs = {\"a\", \"ac\", \"ab\", \"b\"}; // 应该是根据字典的顺序排序的。 Arrays.sort(strs); System.out.println(Arrays.toString(strs));//[a, ab, ac, b] // 能不能对Person数组排序 Person p1 = new Person(20); Person p2 = new Person(22); Person p3 = new Person(19); Person p4 = new Person(18); /* java.lang.ClassCastException: class com.powernode.javase.Person cannot be cast to class java.lang.Comparable 猜测，底层一定有这样一行代码： Comparable c = (Comparable)p1; 为什么会报这样的错误呢？也进一步说明了我们的Person类不是可比较的。 Comparable字面意思：可比较的。 */ Person[] persons = {p1, p2, p3, p4}; // 排序 Arrays.sort(persons); System.out.println(Arrays.toString(persons));//[Person{age=18}, Person{age=19}, Person{age=20}, Person{age=22}]} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 凡是自定义的类型要做比较的话，这个自定义类型必须实现一个接口：Comparable接口，并且实现compareTo方法，在这个方法中编写比较规则。public class Person implements Comparable { private int age; private String name; public Person() { } public Person(int age) { this.age = age; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Person{\" + \"age=\" + age + '}'; } @Override public int compareTo(Object o) { // 编写比较规则。 // 根据年龄进行比较 // p1.compareTo(p2) p1和p2之间进行比较。 // this是p1 // o是p2 // 当前对象的年龄 //this.age; // 另一个对象的年龄 Person person = (Person) o; //person.age; // 按照年龄进行比较。 return this.age - person.age; //return person.age - this.age; // 按照字符串进行比较。 // 升序 //return this.name.compareTo(person.name); // 降序 //return person.name.compareTo(this.name); }} Copyof方法 1234567891011@Testpublic void testCopyOf() { // 数组拷贝 int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9}; int[] newArr = Arrays.copyOf(arr, 3); System.out.println(Arrays.toString(newArr));//[1, 2, 3] // to不包含 int[] newArr2 = Arrays.copyOfRange(arr, 2, 4); System.out.println(Arrays.toString(newArr2));//[3, 4]}","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaofanshutu.github.io/categories/Java/"}],"tags":[]},{"title":"Java面向对象","slug":"动力节点Java/Chapter3_面向对象","date":"2025-06-08T22:12:58.052Z","updated":"2025-06-16T13:03:17.002Z","comments":true,"path":"posts/5f8d3e42.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/5f8d3e42.html","excerpt":"面向对象概述软件开发方法：面向过程和面向对象 面向过程：关注点在实现功能的步骤上。 PO：Procedure Oriented。代表语言：C语言 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。 例如开汽车：启动、踩离合、挂挡、松离合、踩油门、车走了。 再例如装修房子：做水电、刷墙、贴地砖、做柜子和家具、入住。 对于简单的流程是适合使用面向过程的方式进行的。复杂的流程不适合使用面向过程的开发方式。 面向对象：关注点在实现功能需要哪些对象的参与。 OO：Object Oriented 面向对象。包括OOA,OOD,OOP。OOA：Object Oriented Analysis 面向对象分析。OOD：Object Oriented Design 面向对象设计。OOP：Object Oriented Programming 面向对象编程。代表语言：Java、C#、Python等。 人类是以面向对象的方式去认知世界的。所以采用面向对象的思想更加容易处理复杂的问题。 面向对象就是分析出解决这个问题都需要哪些对象的参加，然后让对象与对象之间协作起来形成一个系统。 例如开汽车：汽车对象、司机对象。司机对象有一个驾驶的行为。司机对象驾驶汽车对象。 再例如装修房子：水电工对象，油漆工对象，瓦工对象，木工对象。每个对象都有自己的行为动作。最终完成装修。 面向对象开发方式耦合度低，扩展能力强。例如采用面向过程生产一台电脑，不会分CPU、内存和硬盘，它会按照电脑的工作流程一次成型。采用面向对象生产一台电脑，CPU是一个对象，内存条是一个对象，硬盘是一个对象，如果觉得硬盘容量小，后期是很容易更换的，这就是扩展性。 面向对象三大特征 封装（Encapsulation） 继承（Inheritance） 多态（Polymorphism） 类与对象 类 现实世界中，事物与事物之间具有共同特征，例如：刘德华和梁朝伟都有姓名、身份证号、身高等状态，都有吃、跑、跳等行为。将这些共同的状态和行为提取出来，形成了一个模板，称为类。 类实际上是人类大脑思考总结的一个模板，类是一个抽象的概念。 状态在程序中对应属性。属性通常用变量来表示。 行为在程序中对应方法。用方法来描述行为动作。 类 = 属性 + 方法。 对象 实际存在的个体。 对象又称为实例（instance）。 通过类这个模板可以实例化n个对象。（通过类可以创造多个对象） 例如通过“明星类”可以创造出“刘德华对象”和“梁朝伟对象”。 明星类中有一个属性姓名：String name;“ 刘德华对象”和“梁朝伟对象”由于是通过明星类造出来的，所以这两个都有name属性，但是值是不同的。因此这种属性被称为实例变量。 对象的创建和使用","text":"面向对象概述软件开发方法：面向过程和面向对象 面向过程：关注点在实现功能的步骤上。 PO：Procedure Oriented。代表语言：C语言 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。 例如开汽车：启动、踩离合、挂挡、松离合、踩油门、车走了。 再例如装修房子：做水电、刷墙、贴地砖、做柜子和家具、入住。 对于简单的流程是适合使用面向过程的方式进行的。复杂的流程不适合使用面向过程的开发方式。 面向对象：关注点在实现功能需要哪些对象的参与。 OO：Object Oriented 面向对象。包括OOA,OOD,OOP。OOA：Object Oriented Analysis 面向对象分析。OOD：Object Oriented Design 面向对象设计。OOP：Object Oriented Programming 面向对象编程。代表语言：Java、C#、Python等。 人类是以面向对象的方式去认知世界的。所以采用面向对象的思想更加容易处理复杂的问题。 面向对象就是分析出解决这个问题都需要哪些对象的参加，然后让对象与对象之间协作起来形成一个系统。 例如开汽车：汽车对象、司机对象。司机对象有一个驾驶的行为。司机对象驾驶汽车对象。 再例如装修房子：水电工对象，油漆工对象，瓦工对象，木工对象。每个对象都有自己的行为动作。最终完成装修。 面向对象开发方式耦合度低，扩展能力强。例如采用面向过程生产一台电脑，不会分CPU、内存和硬盘，它会按照电脑的工作流程一次成型。采用面向对象生产一台电脑，CPU是一个对象，内存条是一个对象，硬盘是一个对象，如果觉得硬盘容量小，后期是很容易更换的，这就是扩展性。 面向对象三大特征 封装（Encapsulation） 继承（Inheritance） 多态（Polymorphism） 类与对象 类 现实世界中，事物与事物之间具有共同特征，例如：刘德华和梁朝伟都有姓名、身份证号、身高等状态，都有吃、跑、跳等行为。将这些共同的状态和行为提取出来，形成了一个模板，称为类。 类实际上是人类大脑思考总结的一个模板，类是一个抽象的概念。 状态在程序中对应属性。属性通常用变量来表示。 行为在程序中对应方法。用方法来描述行为动作。 类 = 属性 + 方法。 对象 实际存在的个体。 对象又称为实例（instance）。 通过类这个模板可以实例化n个对象。（通过类可以创造多个对象） 例如通过“明星类”可以创造出“刘德华对象”和“梁朝伟对象”。 明星类中有一个属性姓名：String name;“ 刘德华对象”和“梁朝伟对象”由于是通过明星类造出来的，所以这两个都有name属性，但是值是不同的。因此这种属性被称为实例变量。 对象的创建和使用 类的定义语法格式： [修饰符列表] class 类名 { ​ // 属性（描述状态） ​ // 方法（描述行为动作） } 12345678910public class Student { // 姓名 String name; // 实例变量 // 年龄 int age; // 性别 boolean gender; // 学习 public void study(){ System.out.println(“正在学习”); } // 实例方法（实例方法又叫对象方法）} 对象的创建 Student s = new Student(); 在Java中，使用class定义的类，属于引用数据类型。所以Student属于引用数据类型。类型名为：Student。 Student s; 表示定义一个变量。数据类型是Student。变量名是s。 对象的使用 读取属性值：s.name 修改属性值：s.name = “jackson”; 通过一个类可以实例化多个对象 Student s1 = new Student(); Student s2 = new Student(); 对象的内存分析（对象与引用） new运算符会在JVM的堆内存中分配空间用来存储实例变量。new分配的空间就是Java对象。 在JVM中对象创建后会有对应的内存地址，将内存地址赋值给一个变量，这个变量被称为引用。 Java中的GC主要针对的是JVM的堆内存。 空指针异常是如何发生的？ 程序计数器 虚拟机栈 堆 方法区 运行时常量池 本地方法区 方法调用时参数是如何传递的？将变量中保存的值复制一份传递过去。 初次认识this关键字：出现在实例方法中，代表当前对象。“this.”大部分情况下可以省略。this存储在实例方法栈帧的局部变量表的0号槽位上。任何一个实例方法，局部变量表0号槽位放的是this。 this.用来区分局部变量和实例变量的时候不能省略。 传递的是u变量保存的那个地址 面向对象的封装特性什么是封装？ ​ 封装是一种将数据和方法加以包装，使之成为一个独立的实体，并且把它与外部对象隔离开来的机制。具体来说，封装是将一个对象的所有“状态（属性）”以及“行为（方法）”统一封装到一个类中，从而隐藏了对象内部的具体实现细节，向外界提供了有限的访问接口，以实现对对象的保护和隔离。 实现封装的步骤： 第一步：属性私有化 第二步：对外提供getter setter方法 封装保证安全性，提高复用性 实例方法中调用实例方法 构造方法Constructor(构造器)的语法 构造方法有什么作用？ 构造方法的执行分为两个阶段：对象的创建和对象的初始化。这两个阶段不能颠倒，也不可分割。 在Java中，当我们使用关键字new时，就会在内存中创建一个新的对象，虽然对象已经被创建出来了，但还没有被初始化。而初始化则是在执行构造方法体时进行的。 构造方法如何定义？ [修饰符列表] 构造方法名(形参){} 构造方法如何调用？ new 构造方法名(实参); 关于无参数构造方法： 如果一个类没有显示的定义任何构造方法，系统会默认提供一个无参数构造方法，也被称为缺省构造器。一旦显示的定义了构造方法，则缺省构造器将不存在。为了方便对象的创建，建议将缺省构造器显示的定义出来。 构造方法支持重载机制。 关于构造代码块。对象的创建和初始化过程梳理： new的时候在堆内存中开辟空间，给所有属性赋默认值 执行构造代码块进行初始化 执行构造方法体进行初始化 构造方法执行结束，对象初始化完毕。 构造方法/Constructor/构造器 构造方法有什么作用？ 作用1：对象的创建（通过调用构造方法可以完成对象的创建） 作用2：对象的初始化（给对象的所有属性赋值就是对象的初始化） 怎么定义构造方法呢？ 123[修饰符列表] 构造方法名(形参列表){ 构造方法体;} 注意： 构造方法名必须和类名一致。 构造方法不需要提供返回值类型。 如果提供了返回值类型，那么这个方法就不是构造方法了，就变成普通方法了。 构造方法怎么调用呢？ 使用new运算符来调用。 语法：new 构造方法名(实参); 注意：构造方法最终执行结束之后，会自动将创建的对象的内存地址返回。但构造方法体中不需要提供“return 值;”这样的语句。 在java语言中，如果一个类没有显示的去定义构造方法，系统会默认提供一个无参数的构造方法。（通常把这个构造方法叫做缺省构造器。） 一个类中如果显示的定义了构造方法，系统则不再提供缺省构造器。所以，为了对象创建更加方便，建议把无参数构造方法手动的写出来。 在java中，一个类中可以定义多个构造方法，而且这些构造方法自动构成了方法的重载(overload)。 构造方法中给属性赋值了？为什么还需要单独定义set方法给属性赋值呢？ 在构造方法中赋值是对象第一次创建时属性赋的值。set方法可以在后期的时候调用，来完成属性值的修改。 时机不一样 set方法是出生之后想改内容，调用构造方法 构造方法里面设置属性内容是在创建对象的时候给属性赋值 构造方法执行原理？ 构造方法执行包括两个重要的阶段： 第一阶段：对象的创建 第二阶段：对象的初始化 对象在什么时候创建的？ new的时候，会直接在堆内存中开辟空间。然后给所有属性赋默认值，完成对象的创建。（这个过程是在构造方法体执行之前就完成了。） 对象初始化在什么时候完成的？ 构造方法体开始执行，标志着开始进行对象初始化。构造方法体执行完毕，表示对象初始化完毕。 构造代码块？ 1234//语法格式{ //构造代码块} 123{构造代码块：new一次就会执行一次这个，每次执行构造方法前会执行一次（构造代码块执行之前对象已经创建好了）} 构造代码块什么时候执行，执行几次？ 每一次在new的时候，都会先执行一次构造代码块。 构造代码块是在构造方法执行之前执行的。 构造代码块有什么用？ 如果所有的构造方法在最开始的时候有相同的一部分代码，不妨将这个公共的代码提取到构造代码块当中，这样代码可以得到复用。 this关键字 this是一个关键字 this出现在实例方法中，代表当前对象。语法是：this. this本质上是一个引用，该引用保存当前对象的内存地址。 通过“this.”可以访问实例变量，可以调用实例方法。 this存储在：栈帧的局部变量表的第0个槽位上。 this. 大部分情况下可以省略，用于区分局部变量和实例变量时不能省略。 this不能出现在静态方法中。 “this(实参)”语法： 只能出现在构造方法的第一行。 通过当前构造方法去调用本类中其他的构造方法。 作用是：代码复用。 1234this(实参)：1. 通过这种语法可以在构造方法中调用本类中其他的构造方法。2. 作用：代码复用。3. this(实参); 只能出现在构造方法第一行。 123456789101112131415161718192021public Date() { /* this.year = 1970; this.month = 1; this.day = 1; */ // 不要这么写，这样会导致再创建一个新的对象。 //new Date(1970,1,1); // 不会创建新对象。只是通过一个构造方法去调用另一个构造方法。 this(1970,1,1); System.out.println(\"日期创建成功！~\");}public Date(int year, int month, int day) { this.year = year; this.month = month; this.day = day;} static关键字 static是一个关键字，翻译为：静态的。 static修饰的变量叫做静态变量。当所有对象的某个属性的值是相同的，建议将该属性定义为静态变量，来节省内存的开销。 静态变量在类加载时初始化，存储在堆中。 static修饰的方法叫做静态方法。 所有静态变量和静态方法，统一使用“类名.”调用。虽然可以使用“引用.”来调用，但实际运行时和对象无关，所以不建议这样写，因为这样写会给其他人造成疑惑。 使用“引用.”访问静态相关的，即使引用为null，也不会出现空指针异常。 静态方法中不能使用this关键字。因此无法直接访问实例变量和调用实例方法。 静态代码块在类加载时执行，一个类中可以编写多个静态代码块，遵循自上而下的顺序依次执行。 静态代码块代表了类加载时刻，如果你有代码需要在此时刻执行，可以将该代码放到静态代码块中。 1234567891011121314/** * static关键字： * 1. static翻译为静态的 * 2. static修饰的变量：静态变量 * 3. static修饰的方法：静态方法 * 4. 所有static修饰的，访问的时候，直接采用“类名.”，不需要new对象。 * 5. 什么情况下把成员变量定义为静态成员变量？ * 当一个属性是对象级别的，这个属性通常定义为实例变量。（实例变量是一个对象一份。100个对象就应该有100个空间） * 当一个属性是类级别的（所有对象都有这个属性，并且这个属性的值是一样的），建议将其定义为静态变量，在内存空间上只有一份。节省内存开销。 * 这种类级别的属性，不需要new对象，直接通过类名访问。 * 6. 静态变量存储在哪里？静态变量在什么时候初始化？（什么时候开辟空间） * JDK8之后：静态变量存储在堆内存当中。 * 类加载时初始化。 */ 静态变量的内存图 类加载的时候会去检查类中有没有静态变量，有静态变量的话就将其放在类的静态变量中 类加载是在main方法执行之前执行的 空指针异常何时发生实例相关：实例变量 实例方法 静态代码块i可以访问，j不能访问 123456789101112131415161718/** * static关键字还可以定义静态代码块： * * 1.语法格式： * static { * * } * * 2. 静态代码块什么时候执行？执行几次？ * 静态代码块在类加载时执行，并且只执行一次。 * * 3. 静态代码块可以编写多个，并且遵循自上而下的顺序依次执行。 * * 4. 静态代码块什么时候使用？ * 本质上，静态代码块就是为程序员预留的一个特殊的时间点：类加载时刻 * 如果你需要再类加载时刻执行一段程序的话，这段代码就可以写到静态代码块当中。 * 例如，有这样一个需求：请在类加载时，记录日志。那么记录日志的代码就可以编写到静态代码块当中。 */ Java虚拟机规范JVM对应了一套规范（Java虚拟机规范），它可以有不同的实现JVM规范是一种抽象的概念，它可以有多种不同的实现。例如： HotSpot：HotSpot 由 Oracle 公司开发，是目前最常用的虚拟机实现，也是默认的 Java 虚拟机，默认包含在 Oracle JDK 和 OpenJDK 中 JRockit：JRockit 也是由 Oracle 公司开发。它是一款针对生产环境优化的 JVM 实现，能够提供高性能和可伸缩性 IBM JDK：IBM JDK 是 IBM 公司开发的 Java 环境，采用了与 HotSpot 不同的 J9 VM，能够提供更小的内存占用和更迅速的启动时间 Azul Zing：Azul Zing 是针对生产环境优化的虚拟机实现，能够提供高性能和实时处理能力，适合于高负载的企业应用和实时分析等场景 OpenJ9：OpenJ9 是由 IBM 开发的优化的 Java 虚拟机实现，支持高度轻量级、低时延的 GC、优化的 JIT 编译器和用于健康度测试的可观察性仪表板 Oracle官网上Java虚拟机规范的一部分 运行时数据区 The pc Register（程序计数器） 是一块较小的内存空间，此计数器记录的是正在执行的虚拟机字节码指令的地址； Java Virtual Machine Stacks（Java虚拟机栈） Java虚拟机栈用于存储栈帧。栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。 Heap（堆） 是Java虚拟机所管理的最大的一块内存。堆内存用于存放Java对象实例以及数组。堆是垃圾收集器收集垃圾的主要区域。 Method Area（方法区） 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 规范上静态变量在方法区，但是实际上在堆中 Run-Time Constant Pool（运行时常量池） 是方法区的一部分，用于存放编译期生成的各种字面量与符号引用。 符号引用：类名，方法名，属性名，字面量，都存在于运行时常量池 Native Method Stacks（本地方法栈） 在本地方法的执行过程中，会使用到本地方法栈。和 Java 虚拟机栈十分相似。 压栈是给本地方法栈压。 总结：这些运行时数据区虽然在功能上有所区别，但在整个 Java 虚拟机启动时都需要被创建，并且在虚拟机运行期间始终存在，直到虚拟机停止运行时被销毁。同时，不同的 JVM 实现对运行时数据区的分配和管理方式也可能不同，会对性能和功能产生影响。 JVM体系结构图（该图属于JVM规范，不是具体的实现） JVM规范的实现：HotSpot（Oracle JDK/Open JDK内部使用的JVM就是HotSpot）JDK6的HotSpot 年轻代：刚new出来的对象放在这里。 老年代：经过垃圾回收之后仍然存活的对象。 符号引用：类全名，字段全名，方法全名等。 这个时期的永久代和堆是相邻的，使用连续的物理内存，但是内存空间是隔离的。 永久代的垃圾收集是和老年代捆绑在一起的，因此无论谁满了，都会触发永久代和老年代的垃圾收集。 JDK7的HotSpot这是一个过渡的版本，该版本相对于JDK6来说，变化如下： 类的静态变量转移到堆中了 字符串常量池转移到堆中了 运行时常量池中的符号引用转移到本地内存了 JDK8及更高版本的HotSpot相对于JDK7来说发生了如下变化： 彻底删除永久代（为了避免OOM错误的发生） 将方法区的实现转移到本地内存 将符号引用重新放回运行时常量池 单例模式设计模式概述 什么是设计模式？ 设计模式（Design Pattern）是一套被广泛接受的、经过试验验证的、可反复使用的基于面向对象的软件设计经验总结，它是软件开发人员在软件设计中，对常见问题的解决方案的总结和抽象。设计模式是针对软件开发中常见问题和模式的通用解决方案 设计模式有哪些？ GoF设计模式：《Design Patterns: Elements of Reusable Object-Oriented Software》（即后述《设计模式》一书），由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著（Addison-Wesley，1995）。这几位作者常被称为四人组（Gang of Four）。 架构设计模式（Architectural Pattern）：主要用于软件系统的整体架构设计，包括多层架构、MVC架构、微服务架构、REST架构和大数据架构等。 企业级设计模式（Enterprise Pattern）：主要用于企业级应用程序设计，包括基于服务的架构（SOA）、企业集成模式（EIP）、业务流程建模（BPM）和企业规则引擎（BRE）等。 领域驱动设计模式（Domain Driven Design Pattern）：主要用于领域建模和开发，包括聚合、实体、值对象、领域事件和领域服务等。 并发设计模式（Concurrency Pattern）：主要用于处理并发性问题，包括互斥、线程池、管道、多线程算法和Actor模型等。 数据访问模式（Data Access Pattern）：主要用于处理数据访问层次结构，包括数据访问对象（DAO）、仓库模式和活动记录模式等。 GoF设计模式的分类？ 创建型：主要解决对象的创建问题 结构型：通过设计和构建对象之间的关系，以达到更好的重用性、扩展性和灵活性 行为型：主要用于处理对象之间的算法和责任分配 单例模式单例模式（GoF23种设计模式之一，最简单的设计模式：保证某种类型的对象只创建一个） 饿汉式:类加载时就创建对象。1234567public class Singleton { private static Singleton instance = new Singleton(); // 在类加载的时候就创建实例 private Singleton() {} // 将构造方法设为私有化 public static Singleton getInstance() { // 提供一个公有的静态方法，以获取实例 return instance; }} 懒汉式：第一次调用get方法时才会创建对象。12345678910public class Singleton { private static Singleton instance; // 声明一个静态的、私有的该类类型的变量，用于存储该类的实例 private Singleton() {} // 将构造方法设为私有化 public static Singleton getInstance() { // 提供一个公有的静态方法，以获取实例 if (instance == null) { // 第一次调用该方法时，才真正创建实例 instance = new Singleton(); // 创建实例 } return instance; }} 继承 面向对象三大特征之一：继承 继承作用？ 基本作用：代码复用 重要作用：有了继承，才有了方法覆盖和多态机制。 继承在java中如何实现？ [修饰符列表] class 类名 extends 父类名{} extends翻译为扩展。表示子类继承父类后，子类是对父类的扩展。 继承相关的术语：当B类继承A类时 A类称为：父类、超类、基类、superclass B类称为：子类、派生类、subclass Java只支持单继承，一个类只能直接继承一个类。 Java不支持多继承，但支持多重继承（多层继承）。 子类继承父类后，除私有的不支持继承、构造方法不支持继承。其它的全部会继承。 一个类没有显示继承任何类时，默认继承java.lang.Object类。 方法覆盖(override)/方法重写(overwrite) 什么情况下考虑使用方法覆盖？ 当从父类中继承过来的方法无法满足当前子类的业务需求时。 发生方法覆盖的条件？ 具有继承关系的父子类之间 相同的返回值类型，相同的方法名，相同的形式参数列表 访问权限不能变低，可以变高。 抛出异常不能变多，可以变少。 返回值类型可以是父类方法返回值类型的子类。 方法覆盖的小细节： @Override注解标注的方法会在编译阶段检查该方法是否重写了父类的方法。 私有方法不能继承，所以不能覆盖。 构造方法不能继承，所以不能覆盖。 静态方法不存在方法覆盖，方法覆盖针对的是实例方法。 方法覆盖说的实例方法，和实例变量无关。 多态多态的基础语法 什么是向上转型和向下转型？ java允许具有继承关系的父子类型之间的类型转换。 向上转型（upcasting）：子–&gt;父 子类型的对象可以赋值给一个父类型的引用。 向下转型（downcasting）：父–&gt;子 父类型的引用可以转换为子类型的引用。但是需要加强制类型转换符。 无论是向上转型还是向下转型，前提条件是：两种类型之间必须存在继承关系。这样编译器才能编译通过。 什么是多态？ 父类型引用指向子类对象。Animal a = new Cat(); a.move(); 程序分为编译阶段和运行阶段： 编译阶段：编译器只知道a是Animal类型，因此去Animal类中找move()方法，找到之后，绑定成功，编译通过。这个过程通常被称为静态绑定。 运行阶段：运行时和JVM堆内存中的真实Java对象有关，所以运行时会自动调用真实对象的move()方法。这个过程通常被称为动态绑定。 多态指的是：多种形态，编译阶段一种形态，运行阶段另一种形态，因此叫做多态。 向下转型我们需要注意什么？ 向下转型时，使用不当，容易发生类型转换异常：ClassCastException。 在向下转型时，一般建议使用instanceof运算符进行判断来避免ClassCastException的发生。 instanceof运算符的使用 语法格式：(引用 instanceof 类型) 执行结果是true或者false 例如：(a instanceof Cat) 如果结果是true：表示a引用指向的对象是Cat类型的。 如果结果是false：表示a引用指向的对象不是Cat类型的。 软件开发七大原则 软件开发原则旨在引导软件行业的从业者在代码设计和开发过程中，遵循一些基本原则，以达到高质量、易维护、易扩展、安全性强等目标。软件开发原则与具体的编程语言无关的，属于软件设计方面的知识。 软件开发七大原则？ 开闭原则 (Open-Closed Principle，OCP)：一个软件实体应该对扩展开放，对修改关闭。即在不修改原有代码的基础上，通过添加新的代码来扩展功能。（最基本的原则，其它原则都是为这个原则服务的。） 单一职责原则：一个类只负责单一的职责，也就是一个类只有一个引起它变化的原因。 里氏替换原则：子类对象可以替换其基类对象出现的任何地方，并且保证原有程序的正确性。 接口隔离原则：客户端不应该依赖它不需要的接口。 依赖倒置原则：高层模块不应该依赖底层模块，它们都应该依赖于抽象接口。换言之，面向接口编程。 迪米特法则：一个对象应该对其它对象保持最少的了解。即一个类应该对自己需要耦合或调用的类知道得最少。 合成复用原则：尽量使用对象组合和聚合，而不是继承来达到复用的目的。组合和聚合可以在获取外部对象的方法中被调用，是一种运行时关联，而继承则是一种编译时关联。 多态在开发中的作用 降低程序的耦合度，提高程序的扩展力。 尽量使用多态，面向抽象编程，不要面向具体编程。 super关键字 super关键字和this关键字对比来学习。this代表的是当前对象。super代表的是当前对象中的父类型特征。 super不能使用在静态上下文中。 “super.”大部分情况下是可以省略的。什么时候不能省略？ 当父类和子类中定义了相同的属性（实例变量）或者相同方法（实例方法）时，如果需要在子类中访问父类的属性或方法时，super.不能省略。 this可以单独输出，super不能单独输出。 super(实参); 通过子类的构造方法调用父类的构造方法，目的是为了完成父类型特征的初始化。当一个构造方法第一行没有显示的调用“super(实参);”，也没有显示的调用“this(实参)”，系统会自动调用super()。因此一个类中的无参数构造方法建议显示的定义出来。 super(实参); 这个语法只能出现在构造方法第一行。 在Java语言中只要new对象，Object的无参数构造方法一定会执行。 final关键字 final修饰的类不能被继承 final修饰的方法不能被覆盖 final修饰的变量，一旦赋值不能重新赋值 final修饰的实例变量必须在对象初始化时手动赋值 final修饰的实例变量一般和static联合使用：称为常量 final修饰的引用，一旦指向某个对象后，不能再指向其它对象。但指向的对象内部的数据是可以修改的。 抽象类 什么时候考虑将类定义为抽象类？ 如果类中有些方法无法实现或者没有意义，可以将方法定义为抽象方法，类定义为抽象类。这样在抽象类中只提供公共代码，具体的实现强行交给子类去做。 比如一个Person类有一个问候的方法greet()，但是不同国家的人问候的方式不同，因此greet()方法具体实现应该交给子类。再比如主人喂养宠物的例子中的宠物Pet，Pet中的eat()方法的方法体就是没有意义的。 抽象类如何定义？ abstract class 类名{} 抽象类有构造方法，但无法实例化。抽象类的构造方法是给子类使用的。 抽象方法如何定义？ abstract 方法返回值类型 方法名(形参); 抽象类中不一定有抽象方法，但如果有抽象方法那么类要求必须是抽象类。 一个非抽象的类继承抽象类，要求必须将抽象方法进行实现/重写。 abstract关键字不能和private，final，static关键字共存。 接口接口的基础语法 接口（interface）在Java中表示一种规范或契约，它定义了一组抽象方法和常量，用来描述一些实现这个接口的类应该具有哪些行为和属性。接口和类一样，也是一种引用数据类型。 接口怎么定义？[修饰符列表] interface 接口名{} 抽象类是半抽象的，接口是完全抽象的。接口没有构造方法，也无法实例化。 接口中只能定义：常量+抽象方法。接口中的常量的static final可以省略。接口中的抽象方法的abstract可以省略。接口中所有的方法和变量都是public修饰的。 接口和接口之间可以多继承。 类和接口的关系我们叫做实现（这里的实现也可以等同看做继承）。使用implements关键字进行接口的实现。 一个非抽象的类实现接口必须将接口中所有的抽象方法全部实现。 一个类可以实现多个接口。语法是：class 类 implements 接口A,接口B{} Java8之后，接口中允许出现默认方法和静态方法(JDK8新特性) 引入默认方式是为了解决接口演变问题：接口可以定义抽象方法，但是不能实现这些方法。所有实现接口的类都必须实现这些抽象方法。这会导致接口升级的问题：当我们向接口添加或删除一个抽象方法时，这会破坏该接口的所有实现，并且所有该接口的用户都必须修改其代码才能适应更改。这就是所谓的”接口演变”问题。 引入的静态方法只能使用本接口名来访问，无法使用实现类的类名访问。 JDK9之后允许接口中定义私有的实例方法（为默认方法服务的）和私有的静态方法（为静态方法服务的）。 所有的接口隐式的继承Object。因此接口也可以调用Object类的相关方法。 接口的作用 面向接口调用的称为：接口调用者 面向接口实现的称为：接口实现者 调用者和实现者通过接口达到了解耦合。也就是说调用者不需要关心具体的实现者，实现者也不需要关心具体的调用者，双方都遵循规范，面向接口进行开发。 面向抽象编程，面向接口编程，可以降低程序的耦合度，提高程序的扩展力。 定义一个Usb接口，提供read()和write()方法，通过read()方法读，通过write()方法写： 定义一个电脑类Computer，它是调用者，面向Usb接口来调用。 Usb接口的实现可以有很多，例如：打印机（Printer），硬盘（HardDrive）。 123456public class Computer{ public void conn(Usb usb){ usb.read(); usb.write(); }} 再想想，我们平时去饭店吃饭，这个场景中有没有接口呢？食谱菜单就是接口。顾客是调用者。厨师是实现者。 接口与抽象类如何选择 抽象类和接口虽然在代码角度都能达到同样的效果，但适用场景不同： 抽象类主要适用于公共代码的提取。当多个类中有共同的属性和方法时，为了达到代码的复用，建议为这几个类提取出来一个父类，在该父类中编写公共的代码。如果有一些方法无法在该类中实现，可以延迟到子类中实现。这样的类就应该使用抽象类。 接口主要用于功能的扩展。例如有很多类，一些类需要这个方法，另外一些类不需要这个方法时，可以将该方法定义到接口中。需要这个方法的类就去实现这个接口，不需要这个方法的就可以不实现这个接口。接口主要规定的是行为。 UML UML（Unified Modeling Language，统一建模语言）是一种用于面向对象软件开发的图形化的建模语言。它由Grady Booch、James Rumbaugh和Ivar Jacobson等三位著名的软件工程师所开发，并于1997年正式发布。UML提供了一套通用的图形化符号和规范，帮助开发人员以图形化的形式表达软件设计和编写的所有关键方面，从而更好地展示软件系统的设计和实现过程。 UML是一种图形化的语言，类似于现实生活中建筑工程师画的建筑图纸，图纸上有特定的符号代表特殊的含义。 UML不是专门为java语言准备的。只要是面向对象的编程语言，开发前的设计，都需要画UML图进行系统设计。（设计模式、软件开发七大原则等同样也不是只为java语言准备的。） UML图包括： 类图（Class Diagram）：描述软件系统中的类、接口、关系和其属性等； 用例图（Use Case Diagram）：描述系统的功能需求和用户与系统之间的关系； 序列图（Sequence Diagram）：描述对象之间的交互、消息传递和时序约束等； 状态图（Statechart Diagram）：描述类或对象的生命周期以及状态之间的转换； 对象图（Object Diagram）：表示特定时间的系统状态，并显示其包含的对象及其属性； 协作图（Collaboration Diagram）：描述对象之间的协作，表示对象之间相互合作来完成任务的关系； 活动图（Activity Diagram）：描述系统的动态行为和流程，包括控制流和对象流； 部署图（Deployment Diagram）：描述软件或系统在不同物理设备上部署的情况，包括计算机、网络、中间件、应用程序等。 常见的UML建模工具有：StarUML，Rational Rose等。 类之间的关系 泛化关系（is a） 实现关系（is like a） 关联关系（has a） 聚合关系 聚合关系指的是一个类包含、合成或者拥有另一个类的实例，而这个实例是可以独立存在的。 聚合关系是一种弱关联关系，表示整体与部分之间的关系。 例如一个教室有多个学生 组合关系（Composition） 组合关系是聚合关系的一种特殊情况，表示整体与部分之间的关系更加强烈。 组合关系指的是一个类包含、合成或者拥有另一个类的实例，而这个实例只能同时存在于一个整体对象中。如果整体对象被销毁，那么部分对象也会被销毁。 例如一个人对应四个肢体。 依赖关系（Dependency） 依赖关系是一种临时性的关系，当一个类使用另一个类的功能时，就会产生依赖关系。 如果一个类的改变会影响到另一个类的功能，那么这两个类之间就存在依赖关系。 依赖关系是一种较弱的关系，可以存在多个依赖于同一个类的对象。 例如A类中使用了B类，但是B类作为A类的方法参数或者局部变量等。 访问控制权限 private：私有的，只能在本类中访问。 缺省：默认的，同一个包下可以访问。 protected：受保护的，子类中可以访问。（受保护的通常就是给子孙用的。） public：公共的，在任何位置都可以访问。 a. 类中的属性和方法访问权限共有四种：private、缺省、protected和public。b. 类的访问权限只有两种：public和 缺省。 c. 访问权限控制符不能修饰局部变量。 Object类 java.lang.Object是所有类的超类。java中所有类都实现了这个类中的方法。 Object类是我们学习JDK类库的第一个类。通过这个类的学习要求掌握会查阅API帮助文档。 现阶段Object类中需要掌握的方法： toString：将java对象转换成字符串。 equals：判断两个对象是否相等。 现阶段Object类中需要了解的方法： hashCode：返回一个对象的哈希值，通常作为在哈希表中查找该对象的键值。Object类的默认实现是根据对象的内存地址生成一个哈希码（即将对象的内存地址转换为整数作为哈希值）。hashCode()方法是为了HashMap、Hashtable、HashSet等集合类进行优化而设置的，以便更快地查找和存储对象。 finalize：当java对象被回收时，由GC自动调用被回收对象的finalize方法，通常在该方法中完成销毁前的准备。 clone：对象的拷贝。（浅拷贝，深拷贝）protected修饰的只能在同一个包下或者子类中访问。只有实现了Cloneable接口的对象才能被克隆。 内部类 什么是内部类？ 定义在一个类中的类。 什么时候使用内部类？ 一个类用到了另外一个类，而这两个类的联系比较密切，但是如果把这两个类定义为独立的类，不但增加了类的数量，也不利于代码的阅读和维护。 内部类可以访问外部类的私有成员，这样可以将相关的类和接口隐藏在外部类的内部，从而提高封装性。 匿名内部类是指没有名字的内部类，通常用于定义一个只使用一次的类，比如在事件处理中。 内部类包括哪几种？ 静态内部类：和静态变量一个级别 静态内部类如何实例化：OuterClass.StaticInnerClass staticInnerClass = new OuterClass.StaticInnerClass(); 无法直接访问外部类中实例变量和实例方法。 实例内部类：和实例变量一个级别 实例内部类如何实例化：OuterClass.InnerClass innerClass = new OuterClass().new InnerClass(); 可以直接访问外部类中所有的实例变量，实例方法，静态变量，静态方法。 局部内部类：和局部变量一个级别 局部内部类方外类外部的局部变量时，局部变量需要被final修饰。 从JDK8开始，不需要手动添加final了，但JVM会自动添加。 匿名内部类：特殊的局部内部类，没有名字，只能用一次。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaofanshutu.github.io/categories/Java/"}],"tags":[]},{"title":"Java基础语法","slug":"动力节点Java/Chapter2_Java基础语法","date":"2025-06-08T22:12:37.686Z","updated":"2025-06-08T23:23:09.087Z","comments":true,"path":"posts/ea538f2a.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/ea538f2a.html","excerpt":"标识符什么是标识符 在Java中，程序员有权利自己取名的就是标识符。标识符是用来给变量、方法、类和包等命名的字符序列。 标识符的长度没有限制，但是建议使用有意义的、简洁的标识符，以提高代码的可读性和可维护性。 标识符可以标识什么 变量名 方法名 类名、接口名、枚举名、注解名 包名 常量名 其他…… 标识符命名规则 标识符可以由字母、数字、下划线(_)和美元符号($)组成，不能含有其他符号。（java支持全球所有语言，所以这里的 字母 指的是任何一个国家的文字都可以） 标识符不能以数字开头。 标识符不能是Java中的关键字，如public、class、void等。 标识符是区分大小写的，即Foo和foo是两个不同的标识符。 标识符的长度没有限制，但是Java建议使用有意义的、简短的标识符。 标识符命名规范","text":"标识符什么是标识符 在Java中，程序员有权利自己取名的就是标识符。标识符是用来给变量、方法、类和包等命名的字符序列。 标识符的长度没有限制，但是建议使用有意义的、简洁的标识符，以提高代码的可读性和可维护性。 标识符可以标识什么 变量名 方法名 类名、接口名、枚举名、注解名 包名 常量名 其他…… 标识符命名规则 标识符可以由字母、数字、下划线(_)和美元符号($)组成，不能含有其他符号。（java支持全球所有语言，所以这里的 字母 指的是任何一个国家的文字都可以） 标识符不能以数字开头。 标识符不能是Java中的关键字，如public、class、void等。 标识符是区分大小写的，即Foo和foo是两个不同的标识符。 标识符的长度没有限制，但是Java建议使用有意义的、简短的标识符。 标识符命名规范 见名知意 驼峰式命名方式 类名、接口名、枚举、注解：首字母大写，后面每个单词首字母大写。（StudentService，UserService） 变量名和方法名：首字母小写，后面每个单词首字母大写。（doSome，doOther） 常量名：全部大写，每个单词用下划线连接。（LOGIN_SUCCESS，SYSTEM_ERROR） 包名：全部小写 关键字什么是关键字 Java关键字是Java编程语言中预定义的具有特殊含义的单词，这些单词不能被用作标识符，而是在语法中有特定的用法和限制。 Java关键字都是小写的。 Java关键字有哪些 abstract, assert, boolean, break, byte, case, catch, char, class, continue, default, do, double, else, enum, extends, final, finally, float, for, if, implements, import, instanceof, int, interface, long, native, new, package, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, throws, transient, try, void, volatile, while 保留字：goto，const 字面量什么是字面量 字面量指的是在程序中直接使用的数据。 字面量是Java中最基本的表达式，不需要进行计算或转换，直接使用即可。 Java中有哪些字面量 整数型：10、-5、0、100 浮点型：3.14、-0.5、1.0 布尔型：true、false 字符型：’a’、’b’、’c’、’1’、’2’、’国’ 字符串型：”Hello”、”World”、”Java”、”你好呀” 加号运算符 + 作用1：求和（当加号两边都是数字时进行求和运算） 作用2：字符串拼接（当加号两边有任意一边是字符串类型时会进行字符串拼接，结果还是一个字符串） 变量什么是变量？ 变量是内存当中的一块空间。是计算机中存储数据最基本的单元。 变量三要素： 数据类型（决定空间大小）【int, double, String】 变量名（只要是合法的标识符即可） 变量值（变量中具体存储的数据） 变量的声明、赋值、访问 int i; // 声明一个整数型的变量，起名i i = 100; // 给变量i赋值100 System.out.println(i); // 访问i变量：读操作 i = 200; // 访问i变量：改操作【给变量i重新赋值200】 变量的作用 变量的存在会让程序更加便于维护。 变量的存在可以增强程序的可读性。 变量的小细节 变量必须先声明，再赋值，才能访问 方法体当中的代码遵循自上而下的顺序依次逐行执行，变量先访问，再声明肯定是不行的 一行代码上可以同时声明多个变量 在同一个作用域当中，变量名不能重名，可以重新赋值 变量值的数据类型必须和变量的数据类型一致，这样是不允许的：String name = 100; 变量的作用域 作用域就是变量的有效范围。变量的作用域是怎样的呢？用一句大白话就可以概括了：出了大括号就不认识了。 作用域的不同主要是因为声明在不同位置的变量具有不同的生命周期。所谓的生命周期是：从内存开辟到内存释放。 Java遵循就近原则 变量的分类 局部变量 成员变量 静态变量 实例变量 二进制123456//二进制字面量是以ob开始的System.out.println(0b10011011);//155//八进制字面量是以0开始的System.out.println(0123);//83//十六进制字面量是以0x开始的System.out.println(0x1A3F);//6719 二进制概述 计算机底层只能识别二进制。 计算机底层只识别二进制是因为计算机内部的电子元件只能识别两种状态，即开和关，或者高电平和低电平。二进制正好可以用两种状态来表示数字和字符，因此成为了计算机最基本的表示方法。 在计算机内部，所有的数据都被转化为二进制形式进行处理和存储。 虽然计算机可以通过不同的编程语言和程序来处理不同的数据类型和格式，但最终都需要将其转化为二进制形式才能被计算机底层识别和处理。 什么是二进制 十进制：满十进一 二进制：满二进一 十进制转换为二进制 将十进制数除以2，得到商和余数。 将余数记录下来，然后将商作为新的十进制数，重复步骤1，直到商为0为止。 将记录的余数从下往上排列，得到的就是对应的二进制数。 二进制转换为十进制 将二进制数每一位权值找出来，然后每个权值与对应二进制位相乘，最后将它们相加，即可得到十进制数。 什么是权值？ 在二进制中，权值指的是每个位所代表的数值大小，即二进制中每个位的位置所代表的数值大小。 例如，在二进制数1101中，最高位的权值为8，次高位的权值为4，第三位的权值为2，最低位的权值为1。 二进制数1101转换为十进制数的计算过程如下： 1×2³ + 1×2² + 0×2¹ + 1×2⁰ = 8 + 4 + 0 + 1 = 13 八进制与十六进制八进制是满8进1 十六进制是满十六进1 十进制转为八进制（或十六进制）与二进制相同。 八进制（或十六进制）转为十进制的原理与二进制相同。 二进制转为十六进制 将二进制数从右往左每四位一组，不足四位则在左侧补0，得到若干个四位二进制数。 将每个四位二进制数转换为对应的十六进制数 十六进制转为二进制 将十六进制中的每个数字转换成4个二进制位 原码反码补码byte与bit byte（字节）是计算机存储和处理数据的基本单位，通常由8个比特（bit）组成。每个比特（bit）是计算机中最小的存储单位，只能存储0或1两个状态。因此，一个字节（byte）可以存储8个比特（bit）的数据。 两者之间的关系是，1 byte = 8 bit，即8个比特（bit）组成一个字节（byte）。 在计算机中，数据通常以字节（byte）为单位进行存储和传输，而比特（bit）则是用来表示数据的最小单位。 1KB = 1024byte 1MB = 1024KB 1GB = 1024MB 1TB = 1024GB 原码反码补码 原码反码补码是计算机二进制的三种表示形式。 计算机在底层都是采用二进制补码形式表示的。 二进制位最高位称为符号位，0为正数，1为负数。 正数的原码反码补码 正数的原码反码补码是相同的。 127的原码反码补码分别是多少？都是0111 1111 负数的原码反码补码 负数的原码运算规则：将绝对值转换为二进制后，最高位改为1。 -5的原码：10000101 -5的反码：11111010（原则是：以原码作为参考，符号位不变，其他位取反。） -5的补码：11111011（原则是：以反码作为参考，符号位不变，加1） -20的原码反码补码是多少？ -128的原码反码补码是多少？ -128的原码和补码都是1000 0000 已知负数补码怎么得到原码 虽然计算机底层是采用补码的形式存储的，但最终显示给人类的时候是以原码的形式显示的。 将负数的补码形式除符号位外的所有位按位取反，再加1即可得到原码。 已知补码：10000001 它的原码是：11111111 结果是：-127 通过这个可以得出，对于一个字节来说，最大值127，最小值-128。 计算机底层为什么采用补码 可以简化电路设计：采用补码形式可以将加减法运算转化为相同的操作，从而简化电路设计。 解决了0的正负问题：在原码中，0有两个表示，+0和-0，这样会导致计算结果不唯一，而在补码中，0只有一种表示，即全0，可以避免这个问题。 解决了负数溢出问题：在原码中，负数的表示范围比正数少1，这样在进行减法运算时容易出现负数溢出的情况，而在补码中，负数的表示范围与正数相同，可以避免负数溢出的问题。 方便计算机进行运算：补码形式可以方便计算机进行加减法运算，而且可以使用相同的电路进行运算，从而提高了计算机的运算效率。 可以计算一下 -3 + 2，看看能不能理解。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaofanshutu.github.io/categories/Java/"}],"tags":[]},{"title":"Java开发环境搭建","slug":"动力节点Java/Chapter1_Java开发环境搭建","date":"2025-06-08T21:33:49.327Z","updated":"2025-06-08T23:23:09.086Z","comments":true,"path":"posts/77a3ba8f.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/77a3ba8f.html","excerpt":"常用的windows组合键 win + D 回到桌面 win + E 打开资源管理器 win + R 打开运行窗口 win + L 锁屏 alt + tab 应用之间的切换 常用的DOS命令 打开DOS命令窗口 win + R，输入cmd cmd是commond单词的缩写。 怎么在DOS命令窗口中完成复制和粘贴？ 鼠标左键选中要复制的内容，再点击鼠标右键 在任意空白处，鼠标右键，即可粘贴 什么是当前路径？ 假设进入DOS命令窗口时显示的是：C:\\Users\\Administrator&gt;。那么当前路径就是：C:\\Users\\Administrator 常用DOS命令： dir：列出当前路径下所有的文件以及目录。 cls：clear screen清屏。 exit：退出DOS命令窗口。 切换盘符：c: 或者 d: 或者e: del：删除一个文件或者多个文件。del Test.java del *.java ipconfig以及ipconfig /all：查看网卡的相关信息，例如ip地址，mac地址等。 ping命令：查看两台计算机之间是否可以正常通信 ping 192.168.137.101 ping 192.168.137.101 -t ping www.baidu.com ping www.baidu.com -t 终止DOS命令窗口中某个命令的执行：ctrl + c mkdir：创建目录 mkdir abc，表示在当前目录下新建一个目录：abc rd：删除目录 rd abc，表示删除当前路径下的abc目录 ren：重命名 ren abc xyz，表示将当前路径下的abc目录名修改为xyz cd命令： 作用是：切换目录。change directory cd命令的用法：cd 路径 路径包括： 相对路径：相对路径一定是相对于当前路径而言的，以当前路径为基准，从当前所在的位置开始找。 绝对路径：在windows当中，路径开始的时候，是以盘符开始的，都是绝对路径。例如：C:\\Users\\Administrator\\xyz\\abc\\def cd .. 回到上级目录 （在windows系统中两个点.. 代表的是一个上级目录。扩展：其实还有一个路径叫做一个点 . 一个点代表的是当前路径。） cd / 回到跟目录 注意：路径在windows当中自动补全：使用tab键。 定时关机： shutdown -s -t 3600 一小时之后自动关机。 批处理文件 my.bat文件 123cd C:\\Users\\Administrator\\xyz\\abc\\defc:del *.java 作用：切换到C:\\Users\\Administrator\\xyz\\abc\\def目录下，删除这个目录中所有的java文件。 通用的文本编辑快捷键ctrl+c 复制 ctrl+v 粘贴 ctrl+x 剪切 ctrl+s 保存","text":"常用的windows组合键 win + D 回到桌面 win + E 打开资源管理器 win + R 打开运行窗口 win + L 锁屏 alt + tab 应用之间的切换 常用的DOS命令 打开DOS命令窗口 win + R，输入cmd cmd是commond单词的缩写。 怎么在DOS命令窗口中完成复制和粘贴？ 鼠标左键选中要复制的内容，再点击鼠标右键 在任意空白处，鼠标右键，即可粘贴 什么是当前路径？ 假设进入DOS命令窗口时显示的是：C:\\Users\\Administrator&gt;。那么当前路径就是：C:\\Users\\Administrator 常用DOS命令： dir：列出当前路径下所有的文件以及目录。 cls：clear screen清屏。 exit：退出DOS命令窗口。 切换盘符：c: 或者 d: 或者e: del：删除一个文件或者多个文件。del Test.java del *.java ipconfig以及ipconfig /all：查看网卡的相关信息，例如ip地址，mac地址等。 ping命令：查看两台计算机之间是否可以正常通信 ping 192.168.137.101 ping 192.168.137.101 -t ping www.baidu.com ping www.baidu.com -t 终止DOS命令窗口中某个命令的执行：ctrl + c mkdir：创建目录 mkdir abc，表示在当前目录下新建一个目录：abc rd：删除目录 rd abc，表示删除当前路径下的abc目录 ren：重命名 ren abc xyz，表示将当前路径下的abc目录名修改为xyz cd命令： 作用是：切换目录。change directory cd命令的用法：cd 路径 路径包括： 相对路径：相对路径一定是相对于当前路径而言的，以当前路径为基准，从当前所在的位置开始找。 绝对路径：在windows当中，路径开始的时候，是以盘符开始的，都是绝对路径。例如：C:\\Users\\Administrator\\xyz\\abc\\def cd .. 回到上级目录 （在windows系统中两个点.. 代表的是一个上级目录。扩展：其实还有一个路径叫做一个点 . 一个点代表的是当前路径。） cd / 回到跟目录 注意：路径在windows当中自动补全：使用tab键。 定时关机： shutdown -s -t 3600 一小时之后自动关机。 批处理文件 my.bat文件 123cd C:\\Users\\Administrator\\xyz\\abc\\defc:del *.java 作用：切换到C:\\Users\\Administrator\\xyz\\abc\\def目录下，删除这个目录中所有的java文件。 通用的文本编辑快捷键ctrl+c 复制 ctrl+v 粘贴 ctrl+x 剪切 ctrl+s 保存 ctrl+z 撤销 ctrl+y 重做 ctrl+a 全选 home 光标回到行首 end 光标回到行尾 ctrl + home 光标回到文章开始 ctrl + end 光标回到文章末尾 shift + home 或 end 选中一行 鼠标双击 （选中一个单词） ctrl + shift + 右箭头或左箭头 （选中一个单词） ctrl + f 查找 Java语言概述Java SE（Java Standard Edition）是Java的标准版，它包含了Java语言的核心部分，包括基础类库、虚拟机和开发工具等。Java SE主要用于开发桌面应用程序、控制台程序和小型服务器端应用程序等。 Java EE（Java Enterprise Edition）是Java的企业版，它是在Java SE的基础上扩展而来，主要用于开发大型企业级应用程序，如电子商务系统、ERP系统和CRM系统等。Java EE包含了许多企业级技术，如Servlet、JSP、EJB、JMS、JTA等。 Java ME（Java Micro Edition）是Java的微型版，它主要用于嵌入式设备和移动设备上的应用程序开发，如手机、平板电脑、数码相机、路由器等。Java ME的特点是体积小、速度快、资源占用少，可以在较小的内存和处理能力的设备上运行。 Java语言特点简单易学：Java语言的语法和C语言很相似，但是它去掉了C中的复杂的指针和多重继承等特性，使得Java语言更加简单易学。 面向对象：Java语言是一种纯面向对象的编程语言，它支持对象的封装、继承和多态等面向对象的特性。 平台无关性&gt;（跨平台性：一次编译，到处运行）：Java语言的程序可以在不同的操作系统和硬件平台上运行，这是因为Java程序被编译成字节码，而不是机器码，字节码可以在任何支持Java虚拟机的平台上运行。 实现原理：不同的操作系统上安装属于自己的Java虚拟机，而Java虚拟机屏蔽了各个操作系统之间的差异，从而做到跨平台。 安全性：Java语言具有很高的安全性，它提供了一系列的安全措施来保护程序不受恶意攻击和病毒侵害。 高性能：Java语言具有很高的性能，它采用了一系列优化措施来提高程序的执行速度和内存使用效率。 多线程支持：Java语言具有很好的多线程支持，它提供了一系列的线程控制机制，使得程序可以更好地利用计算机的多核处理能力。 自动垃圾回收机制：Java语言采用的是垃圾回收机制（Garbage Collection，简称GC），也就是自动内存管理机制。在传统的编程语言中，程序员需要手动分配和释放内存，容易出现内存泄漏和悬挂指针等问题。而Java语言采用的垃圾回收机制可以自动分配和释放内存，避免了内存泄漏和悬挂指针等问题。 JDK的加载与执行原理 包含两个阶段：编译阶段和运行阶段。Java既是编译型语言，又是解释型语言 编译阶段和运行阶段可以在不同的操作系统上完成。 编译后删除java源程序，不会影响程序的执行。 生成的class文件如果是A.class，则类名为A。如果是Hello.class，则类名为Hello。 javac是负责编译的命令（检查语法规则），java是负责运行的命令。 class文件不是机器码，操作系统无法直接执行。只有JVM才能看懂。 JVM会把class字节码解释为机器码，这样操作系统才能看懂。 JDK(Java Development Kit)、JRE(Java Runtime Environment)、JVM(Java Virtual Machine)分别是什么？他们的关系是什么？ JDK包含JRE，JRE里面有JVM JVM其实就是一个规范 第一个Java程序JDK的下载与安装 环境变量PATH的配置 JDK的重点目录介绍 ​ bin：该目录主要存放命令 ​ lib：该目录主要存放JDK的类库 ​ lib/src.zip：JDK源码 第一个Java程序的编写 第一个Java程序的编译 ​ javac命令的使用：javac 后面可以跟相对路径或者绝对路径（有盘符就是绝对路径） 第一个Java程序的运行 ​ java命令的使用 理解环境变量CLASSPATH ​ 类加载器（ClassLoader） ​ CLASSPATH是给Java的类加载器指路的 PATH环境变量 path环境变量不是java的，隶属于windows操作系统 path环境变量的作用是什么？ 在path中有很多路径，路径和路径之间采用 分号（;） 隔开 在DOS命令窗口中输入一个DOS命令之后，windows会先从当前路径下找这个命令，如果找不到，则会去环境变量PATH的路径中查找该命令，找到则执行，找不到，则报错。 PATH环境变量实际上就是给windows操作系统指路的。 编写第一个Java程序在硬盘的任何位置，新建一个java源文件，起名：HelloWorld.java 12345public class HelloWorld { public static void main(String[] args){ System.out.println(\"Hello World!\"); }} 编译第一个java程序 使用javac命令来编译。首先确保javac命令能用。 javac命令怎么用，语法是什么？ javac java源文件的路径 javac java源文件的相对路径 javac java源文件的绝对路径 运行第一个Java程序 使用java命令来运行程序，首先确保java命令可以用。 java命令怎么用？语法格式是什么？ java 类名（比如：java HelloWorld） 切记切记切记~！！！！！！！！！ java命令后面跟的不是文件路径。java命令后面跟的是类名 什么是类名？ A.class，类名是A HelloWorld.class，类名是HelloWorld Test.class，类名是：Test 要使用java命令，首先DOS命令窗口中的当前路径必须切换到class文件所在的位置。 掌握环境变量CLASSPATH classpath环境变量是隶属于Java语言的。不是windows操作系统的。和PATH环境变量完全不同。 classpath环境变量是给classloader（类加载器）指路的。 java A。执行后。先启动JVM，JVM启动classloader，classloader去硬盘上通过classpath找A.class文件。找到则执行，找不到则报错。 如果classpath没有配置的话，默认从当前路径下找class字节码文件。 如果classpath配置了，例如配置到桌面上了：C:\\Users\\Administrator\\Desktop，那么classloader以后就只会去桌面上找字节码文件了，不再从当前路径下找了。 注意，如果classpath配置为：classpath=.;C:\\Users\\Administrator\\Desktop 是什么意思呢？ 先让类加载器从当前路径下找，如果找不到的话，去C:\\Users\\Administrator\\Desktop找。 关于编译时的乱码问题 当java源文件中有中文时，用EditPlus工具写代码，最后会出现中文乱码问题，为什么？ EditPlus默认是简体中文GBK。 java21的javac编译器采用的是UTF-8的编码方式进行编译。 编码不一致，所以乱码了。 怎么解决？ 第一种方案：编译的时候用特定字符集编译 javac -encoding GBK HelloWorld2.java 第二种方案： 将editplus的字符集修改为UTF-8 java中的三种注释123// 单行注释// 单行注释// 单行注释 1234/* 多行注释 多行注释*/ 123456/*** javadoc注释，可以给javadoc命令解析提取并生成帮助文档* @author qingya* @version 1.0* @since 1.0*/ 使用以下命令可以提取生成帮助文档： 1javadoc -d docs -author -version -encoding utf-8 HelloWorld.java public class与class的区别1234561. 一个Java源文件中可以定义多个class2. 编译之后，一个class就会对应生成一个class字节码文件3. 如果一个类是public的，类名必须和源文件名保持一致。4. public的类可以没有。如果有的话，也只能有一个。5. 每个类中都可以编写入口main方法。想执行X类的main方法怎么办？java X6. 在实际的开发中，对于一个软件来说，一般入口只有1个。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaofanshutu.github.io/categories/Java/"}],"tags":[]},{"title":"","slug":"《疯狂Java讲义》/《疯狂Java讲义》 第一章","date":"2025-05-09T00:22:18.937Z","updated":"2025-06-08T23:23:09.088Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/0.html","excerpt":"《疯狂Java讲义》 第一章 第一个HelloWorld程序 javac -d . HelloWorld.java(javac -d destdir srcdir) destdir是.的时候表示将字节码生成到java文件所在的路径下。 java是区分大小写的","text":"《疯狂Java讲义》 第一章 第一个HelloWorld程序 javac -d . HelloWorld.java(javac -d destdir srcdir) destdir是.的时候表示将字节码生成到java文件所在的路径下。 java是区分大小写的","categories":[],"tags":[]},{"title":"IDEA常用快捷键","slug":"动力节点Java/IDEA快捷键 - 副本","date":"2025-04-12T10:43:43.493Z","updated":"2025-04-10T00:10:05.718Z","comments":true,"path":"posts/566321e7.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/566321e7.html","excerpt":"IDEA常用快捷键 单行注释：ctrl + / 多行注释：ctrl + shift + / 查看源码：按ctrl别松手，鼠标移动到对应的类名下方，出现下划线，点击过去，可以查看类源码。 多行编辑：按alt别松手，鼠标拖动多行，完成多行编辑。 怎么快速生成创建对象语句：类名.new.var 怎么快速生成if语句：布尔类型值.if 怎么快速生成setter和getter方法：alt + insert，然后选择setter and getter生成。 怎么快速生成构造方法：alt + insert，然后选择Constructor。 在IDEA当中如何自动纠错：将光标移动到错误的位置，按atl + enter。会有提示，根据提示进行纠错。 移动代码到上一行：alt + shift + 上/下方向 怎么快速重写方法？alt + insert，选择Override…. 怎么快速重写方法？ctrl + o 快速向下转型，并同时生成变量名：变量名.castvar 快速查看方法的参数：ctrl + p 返回上一步：ctrl + alt + 左方向键。 下一步：ctrl + alt + 右方向键。 代码格式化：ctrl + alt + L 查看继承结构：ctrl + H 自动代码包裹：ctrl + alt + t 快速运行程序 ctrl + shift + F10","text":"IDEA常用快捷键 单行注释：ctrl + / 多行注释：ctrl + shift + / 查看源码：按ctrl别松手，鼠标移动到对应的类名下方，出现下划线，点击过去，可以查看类源码。 多行编辑：按alt别松手，鼠标拖动多行，完成多行编辑。 怎么快速生成创建对象语句：类名.new.var 怎么快速生成if语句：布尔类型值.if 怎么快速生成setter和getter方法：alt + insert，然后选择setter and getter生成。 怎么快速生成构造方法：alt + insert，然后选择Constructor。 在IDEA当中如何自动纠错：将光标移动到错误的位置，按atl + enter。会有提示，根据提示进行纠错。 移动代码到上一行：alt + shift + 上/下方向 怎么快速重写方法？alt + insert，选择Override…. 怎么快速重写方法？ctrl + o 快速向下转型，并同时生成变量名：变量名.castvar 快速查看方法的参数：ctrl + p 返回上一步：ctrl + alt + 左方向键。 下一步：ctrl + alt + 右方向键。 代码格式化：ctrl + alt + L 查看继承结构：ctrl + H 自动代码包裹：ctrl + alt + t 快速运行程序 ctrl + shift + F10","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaofanshutu.github.io/categories/Java/"}],"tags":[]},{"title":"集合","slug":"动力节点Java/Chapter7_集合","date":"2025-04-11T12:10:19.347Z","updated":"2025-04-29T14:08:56.210Z","comments":true,"path":"posts/d366874c.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/d366874c.html","excerpt":"集合概述 Java集合中存储的是引用，存的不是堆中的对象。堆中的对象的地址存储到了集合中。 默认情况下，如果不使用泛型，集合中可以存储任何类型的引用。（只要是Object类的子类都可以存储） Java集合框架相关的类都在java.util包下。 Java集合框架分为两部分： Collection结构：元素以单个形式存储。 Map结构：元素以键值对的映射关系存储。 Collection继承结构 上图6个蓝色的实现类中，只有HashSet是无序集合，其他都是有序集合。 有序集合：集合中存储的元素有下标 或者 集合中存储的元素是可排序的 无序集合： 集合中存储的元素没有下标 并且 集合中存储的元素也没有排序 每个集合实现类对应的数据结构： 集合类型 数据结构 描述 ArrayList 数组 一种可以动态增长和缩减的索引序列 LinkedList 双向链表（不是队列结构，但是可以用它模拟队列） 一种可以在任何位置进行高效插入和删除操作的有序序列 Vector 数组（线程安全） HashSet 哈希表 一种没有重复元素的无序集合 LinkedHashSet 双向链表+哈希表 一种可以记住元素插入次序的集 TreeSet 红黑树 一种有序集 List集合中存储的元素可以重复，Set集合中的元素不可重复。 Collection接口的常用方法 方法 描述 boolean add(E e); 向集合中添加元素 int size(); 获取集合中元素个数 boolean addAll(Collection c); 将参数集合中所有元素全部加入当前集合 boolean contains(Object o); 判断集合中是否包含对象o boolean remove(Object o); 从集合中删除对象o void clear(); 清空集合 boolean isEmpty(); 判断集合中元素个数是否为0 Object[] toArray(); 将集合转换成一维数组","text":"集合概述 Java集合中存储的是引用，存的不是堆中的对象。堆中的对象的地址存储到了集合中。 默认情况下，如果不使用泛型，集合中可以存储任何类型的引用。（只要是Object类的子类都可以存储） Java集合框架相关的类都在java.util包下。 Java集合框架分为两部分： Collection结构：元素以单个形式存储。 Map结构：元素以键值对的映射关系存储。 Collection继承结构 上图6个蓝色的实现类中，只有HashSet是无序集合，其他都是有序集合。 有序集合：集合中存储的元素有下标 或者 集合中存储的元素是可排序的 无序集合： 集合中存储的元素没有下标 并且 集合中存储的元素也没有排序 每个集合实现类对应的数据结构： 集合类型 数据结构 描述 ArrayList 数组 一种可以动态增长和缩减的索引序列 LinkedList 双向链表（不是队列结构，但是可以用它模拟队列） 一种可以在任何位置进行高效插入和删除操作的有序序列 Vector 数组（线程安全） HashSet 哈希表 一种没有重复元素的无序集合 LinkedHashSet 双向链表+哈希表 一种可以记住元素插入次序的集 TreeSet 红黑树 一种有序集 List集合中存储的元素可以重复，Set集合中的元素不可重复。 Collection接口的常用方法 方法 描述 boolean add(E e); 向集合中添加元素 int size(); 获取集合中元素个数 boolean addAll(Collection c); 将参数集合中所有元素全部加入当前集合 boolean contains(Object o); 判断集合中是否包含对象o boolean remove(Object o); 从集合中删除对象o void clear(); 清空集合 boolean isEmpty(); 判断集合中元素个数是否为0 Object[] toArray(); 将集合转换成一维数组 这里有疑问：为什么col.toArray()返回的是地址？？？ add(E e) &amp; size() &amp; toArray()12345678910Collection col = new ArrayList();//add(E e)col.add(\"zhangsan\");col.add(123);col.add(true);System.out.println(col); // [zhangsan, 123, true]System.out.println(col.toArray());// [Ljava.lang.Object;@1b6d3586//size()System.out.println(col.size());// 3 addAll(Collection c)123456//addAll(Collection c)Collection col2 = new ArrayList();col2.add(\"好好学习，天天向上\");col2.add(\"you are the best~\");col.addAll(col2); // 将col2中的元素添加到col中System.out.println(col); 遇到问题：控制台中文乱码 12345//addAll(Collection c)Collection col2 = new ArrayList();col2.add(\"hello~\");col.addAll(col2); // 将col2中的元素添加到col中System.out.println(col);// [zhangsan, 123, true, hello~] contains(Object o)123//contains(Object o)System.out.println(col.contains(\"zhangsan\")); // trueSystem.out.println(col.contains(new String(\"zhangsan\"))); // true remove(Object o)123System.out.println(col);//[zhangsan, 123, true, hello~]col.remove(\"zhangsan\"); // 删除元素System.out.println(col);//[123, true, hello~] clear() &amp; isEmpty()1234System.out.println(col);// [123, true, hello~]col.clear();System.out.println(col);// []System.out.println(col.isEmpty()); // true Collection集合的遍历第一步：获取当前集合依赖的迭代器对象 ​ Iterator it = collection.iterator(); 第二步：编写循环，循环条件：当前光标指向的位置是否存在元素。 ​ while(it.hasNext()){} 第三步：如果有，将光标指向的当前元素返回，并且将光标向下移动一位。 ​ Object obj = it.next(); 泛型 泛型是Java5的新特性，属于编译阶段的功能。 泛型可以让开发者在编写代码时指定集合中存储数据的数据类型。 泛型作用： 类型安全：指定类型后，编译期会在编译阶段进行类型检查。如果尝试将错误的类型加入集合中，则会在编译阶段报错。避免了在运行时出现类型错误的问题。 代码简洁：使用泛型后可以简化代码，避免了繁琐的类型转换操作。没有泛型的时候，需要使用Object类型来保存集合中的元素，在使用时需要强制类型转换成实际类型。 在集合中使用泛型 12Collection&lt;String&gt; strs = new ArrayList&lt;String&gt;();//这就表示该集合只能存储字符串，存储其它类型时编译器报错。并且以上代码使用泛型后，避免了繁琐的类型转换，集合中的元素可以直接调用String类特有的方法。 Java7的新特性：钻石表达式 1Collection&lt;String&gt; strs = new ArrayList&lt;&gt;(); 泛型擦除与补偿 泛型的出现提高了编译时的安全性，正因为编译时对添加的数据做了检查，则程序运行时才不会抛出类型转换异常。因此泛型本质上是编译时期的技术，是专门给编译器用的。加载类的时候，会将泛型擦除掉（擦除之后的类型为Object类型），这个称为泛型擦除。 为什么要有泛型擦除呢？其本质是为了让JDK1.4和JDK1.5能够兼容同一个类加载器。在JDK1.5版本中，程序编译时期会对集合添加的元素进行安全检查，如果检查完是安全的、没有错误的，那么就意味着添加的元素都属于同一种数据类型，则加载类时就可以把这个泛型擦除掉，将泛型擦除后的类型就是Object类，这样擦除之后的代码就与JDK1.4的代码一致。 由于加载类的时候，会默认将类中的泛型擦除为Object类型，所以添加的元素就被转化为Object类型，同时取出的元素也默认为Object类型。而我们获得集合中的元素时，按理说取出的元素应该是Object类型，为什么取出的元素却是实际添加的元素类型呢？ 这是因为这里又做了一个默认的操作，我们称之为泛型的补偿。在程序运行时，通过获取元素的实际类型进行强转，这就叫做泛型补偿（不必手动实现强制转换）。获得集合中的元素时，虚拟机会根据获得元素的实际类型进行向下转型，也就是会恢复获得元素的实际类型，因此我们就无需手动执行向下转型操作，从本质上避免了抛出类型转换异常。 泛型的使用在类上定义泛型123456789101112131415161718192021222324252627282930313233343536package com.powernode.javase.collection.Summer;public class MyAnimal&lt;String, Integer&gt; { private String name; private int age; public MyAnimal(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public java.lang.String toString() { return \"MyAnimal{\" + \"name=\" + name + \", age=\" + age + '}'; }} 1234567//这种可以直接调用String或者Integer类特有的方法（因为声明泛型的时候直接指定了泛型类型是String和Object）MyAnimal&lt;String, Integer&gt; myAnimal = new MyAnimal&lt;&gt;(\"dog\", 2);System.out.println(myAnimal.getName().charAt(1));//这种的不能直接调用String或者Integer类特有的方法MyAnimal&lt;Object, Object&gt; myAnimal1 = new MyAnimal&lt;&gt;(\"cat\", 0);//myAnimal1.getName().charAt(1); 调用不了这个方法 在静态方法上定义泛型 在类上定义的泛型，在静态方法中无法使用。 如果在静态方法中使用泛型，则需要在方法返回值类型前面进行泛型的声明。 语法格式：&lt;泛型1, 泛型2, 泛型3, …&gt; 返回值类型 方法名(形参列表) {} 12345678910111213141516171819public class A { private static &lt;T&gt; void print(T[] t) { for (T t1 : t) { System.out.println(t1); } } public static void main(String[] args) { String[] strs = {\"a\", \"b\", \"c\"}; Integer[] ints = {1, 2, 3}; Double[] doubles = {1.1, 2.2, 3.3}; A.print(strs); System.out.println(\"==========\"); A.print(ints); System.out.println(\"==========\"); A.print(doubles); }} 结果： 1234567891011abc==========123==========1.12.23.3 在接口上定义泛型语法格式：interface 接口名&lt;泛型1,泛型2,…&gt; {} 例如：public interface Flayable &lt;T&gt; {} 实现接口时，如果知道具体的类型，则：public class MyClass implements Flyable &lt;Bird&gt; {} 实现接口时，如果不知道具体的类型，则：public class MyClass &lt;T&gt; implements Flyable &lt;T&gt; {} 123456/* 定义一个泛型接口*/public interface MyFlyable&lt;T&gt; { void fly(T t);} 123456789/* B类实现接口时，指定具体类型为Bird*/public class B implements MyFlyable&lt;Bird&gt; { @Override public void fly(Bird bird) { System.out.println(\"Bird \" + bird.getName() + \" is flying.\"); }} ​ 123456789101112131415/* C类实现接口时，未指定具体类型*/class C&lt;T&gt; implements MyFlyable&lt;T&gt; { @Override public void fly(T t) { if (t instanceof Bird) { System.out.println(\"Bird \" + ((Bird) t).getName() + \" is flying.\"); } else if (t instanceof Dragon) { System.out.println(\"Dragon \" + ((Dragon) t).getName() + \" is flying.\"); } else { System.out.println(\"Unknown type is flying.\"); } }} 12345678910111213 public static void main(String[] args) { Bird bird = new Bird(\"xiaohuangli\"); Dragon dragon = new Dragon(\"xiaolongren\"); B b = new B(); b.fly(bird); //会报错,因为B类只接受Bird类型的参数// b.fly(dragon); C c = new C(); c.fly(dragon); c.fly(bird); } 结果： 123Bird xiaohuangli is flying.Dragon xiaolongren is flying.Bird xiaohuangli is flying. 泛型通配符(泛型的使用，不属于定义了) 无限定通配符，&lt;?&gt;，此处“？”可以为任意引用数据类型。 上限通配符，&lt;? extends Number&gt;，此处“？”必须为Number及其子类。 下限通配符，&lt;? super Number&gt;，此处“？”必须为Number及其父类。 123456789101112131415161718192021222324252627282930313233343536373839404142public class Test { public static void main(String[] args) { //什么类型都可以接收 print(new ArrayList&lt;String&gt;()); print(new ArrayList&lt;Object&gt;()); print(new ArrayList&lt;Integer&gt;()); //报错，这里需要的是BB或者BB的子类 //print2(new ArrayList&lt;AA&gt;()); print2(new ArrayList&lt;BB&gt;()); print2(new ArrayList&lt;CC&gt;()); print3(new ArrayList&lt;AA&gt;()); print3(new ArrayList&lt;BB&gt;()); //报错，这里需要的是BB或者BB的父类 //print3(new ArrayList&lt;CC&gt;()); } static void print(ArrayList&lt;?&gt; list){ System.out.println(list); } static void print2(ArrayList&lt;? extends BB&gt; list){ System.out.println(list); } static void print3(ArrayList&lt;? super BB&gt; list){ System.out.println(list); }}class AA{}class BB extends AA{}class CC extends BB{} 迭代时删除元素 迭代集合时删除元素 使用“集合对象.remove(元素)”：会出现ConcurrentModificationException异常。 使用“迭代器对象.remove()”：不会出现异常。 如何解决并发修改问题？答案：fail-fast机制 fail-fast机制又被称为“快速失败机制”。只要程序发现对集合进行了并发修改，就会立即让其失败，以防出错。 fail-fast机制是如何实现的？ 集合中设置了一个modCount属性，用来记录修改次数，使用集合对象执行增，删，改中任意一个操作时，modCount就会自动加1。 获取迭代器对象的时候，会给迭代器对象初始化一个expectedModCount属性。并且将expectedModCount初始化为modCount，即：int expectedModCount = modCount; 当使用集合对象删除元素时：modCount会加1。但是迭代器中的expectedModCount不会加1。而当迭代器对象的next()方法执行时，会检测expectedModCount和modCount是否相等，如果不相等，则抛出：ConcurrentModificationException异常。 当使用迭代器删除元素的时候：modCount会加1，并且expectedModCount也会加1。这样当迭代器对象的next()方法执行时，检测到的expectedModCount和modCount相等，则不会出现ConcurrentModificationException异常。 注意：虽然我们当前写的程序是单线程的程序，并没有使用多线程，但是通过迭代器去遍历的同时使用集合去删除元素，这个行为将被认定为并发修改。 结论：迭代集合时，删除元素要使用“迭代器对象.remove()”方法来删除，避免使用“集合对象.remove(元素)”。主要是为了避免ConcurrentModificationException异常的发生。注意：迭代器的remove()方法删除的是next()方法的返回的那个数据。remove()方法调用之前一定是先调用了next()方法，如果不是这样的，就会报错。 获取迭代器对象的时候，会给迭代器对象初始化一个expectedModCount属性。并且将expectedModCount初始化为modCount，即：int expectedModCount = modCount; ​ java.util.ArrayList#iterator 123456789101112131415161718public static void main(String[] args) { ArrayList&lt;Integer&gt; integers = new ArrayList&lt;&gt;(); integers.add(1); integers.add(2); integers.add(3); Iterator&lt;Integer&gt; iterator = integers.iterator(); while (iterator.hasNext()) { Integer integer = iterator.next(); if(integer == 2) { iterator.remove(); } } for (Integer integer : integers) { System.out.println(integer); }} 结果： 1213 123456789101112131415161718public static void main(String[] args) { ArrayList&lt;Integer&gt; integers = new ArrayList&lt;&gt;(); integers.add(1); integers.add(2); integers.add(3); Iterator&lt;Integer&gt; iterator = integers.iterator(); while (iterator.hasNext()) { Integer integer = iterator.next(); if(integer == 2) { integers.remove(integer);//没有异常，为什么 } } for (Integer integer : integers) { System.out.println(integer); }} List接口List接口常用方法 List集合存储的元素特点：有序可重复 List接口下的常见实现类： ArrayList：数组 Vector, Stack：数组（且线程安全） LinkedList：双向链表 List接口特有方法 序号 方法 描述 1 void add(int index, E element) 在指定索引处插入元素 2 E set(int index, E element) 修改索引处的元素 3 E get(int index) 根据索引获取元素（因为有这个方法，所以可以根据下标遍历List集合） 4 E remove(int index) 删除索引处的元素 5 int indexOf(Object o) 获取对象o在当前集合中第一次出现时的索引。 6 int lastIndexOf(Object o) 获取对象o在当前集合中最后一次出现时的索引。 7 List subList(int fromIndex, int toIndex) 截取子List集合生成一个新集合（对原集合无影响）。[fromIndex, toIndex) 8 static List of(E… elements) 静态方法，返回包含任意数量元素的不可修改列表。（获取的集合是只读的，不可修改的。） 测试1：在指定索引处添加元素 12345678910111213141516171819202122public class ListTest02 { public static void main(String[] args) { // 创建List集合对象 List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 添加元素 list.add(\"1\"); list.add(\"2\"); list.add(\"3\"); list.add(\"4\"); list.add(\"5\"); list.add(\"6\"); // 在指定位置添加元素 list.add(1, \"张三\"); Iterator&lt;String&gt; iterator = list.iterator(); while (iterator.hasNext()) { String next = iterator.next(); System.out.println(next); } }} 12345671张三23456 测试2和3 1234567891011121314151617181920212223public class ListTest02 { public static void main(String[] args) { // 创建List集合对象 List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 添加元素 list.add(\"1\"); list.add(\"2\"); list.add(\"3\"); list.add(\"4\"); list.add(\"5\"); list.add(\"6\"); //修改索引处的元素 list.set(1, \"李四\"); System.out.println(\"下标为2的元素是：\" + list.get(2)); Iterator&lt;String&gt; iterator = list.iterator(); while (iterator.hasNext()) { String next = iterator.next(); System.out.println(next); } }} 1234567下标为2的元素是：31李四3456 通过下标遍历List集合 12345678910111213public static void main(String[] args) { ArrayList&lt;String&gt; animals = new ArrayList&lt;&gt;(); animals.add(\"Dog\"); animals.add(\"Cat\"); animals.add(\"Bird\"); animals.add(\"Fish\"); animals.add(\"Lizard\"); for (int i = 0; i &lt; animals.size(); i++) { String animal = animals.get(i); System.out.println(animal); }} 结果： 12345DogCatBirdFishLizard 测试subList 12345678910111213141516public static void main(String[] args) { List&lt;String&gt; animals = new ArrayList&lt;&gt;(); animals.add(\"Dog\"); animals.add(\"Cat\"); animals.add(\"Bird\"); animals.add(\"Fish\"); animals.add(\"Lizard\"); List&lt;String&gt; newAnimals = new ArrayList&lt;&gt;(); newAnimals = animals.subList(2, 4); //实际获取到的是下标2和3的元素 ListIterator&lt;String&gt; listIterator = newAnimals.listIterator(); while (listIterator.hasNext()) { String next = listIterator.next(); System.out.println(next); }} 结果： 12BirdFish 测试of(E… elements) ❓疑问：这里为什么是? extends Serializable，这个代码是我的Idea自动生成的 1234List&lt;? extends Serializable&gt; hello = List.of(1, 3, 4, 5, \"hello\", true, 1.2f);for (Serializable s : hello) { System.out.println(s);} 结果： 12345671345hellotrue1.2 List接口特有迭代器 特有的迭代方式 方法 描述 ListIterator listIterator() 获取List集合特有的迭代器（该迭代器功能更加强大，但只适合于List集合使用） ListIterator listIterator(int index) 从列表中的指定位置开始，返回列表中元素的列表迭代器 ListIterator接口中常用方法 方法 描述 boolean hasNext() 判断光标当前指向的位置是否存在元素。 E next() 将当前光标指向的元素返回，然后将光标向下移动一位。 void remove() 删除上一次next()方法返回的那个数据(删除的是集合中的)。remove()方法调用的前提是：先调用next()方法。否则会报错。 void add(E e) 添加元素（将元素添加到光标指向的位置，然后光标向下移动一位。） boolean hasPrevious() 判断当前光标指向位置的上一个位置是否存在元素。 E previous() 获取上一个元素（将光标向上移动一位，然后将光标指向的元素返回） int nextIndex() 获取光标指向的那个位置的下标 int previousIndex() 获取光标指向的那个位置的上一个位置的下标 void set(E e) 修改的是上一次next()方法返回的那个数据（修改的是集合中的）。set()方法调用的前提是：先调用了next()方法。否则会报错。 hasNext()：判断光标当前指向的位置是否存在元素 12345678910111213List&lt;String&gt; animals = new ArrayList&lt;&gt;();animals.add(\"Dog\");animals.add(\"Cat\");animals.add(\"Bird\");animals.add(\"Fish\");animals.add(\"Lizard\");//测试hasNext()ListIterator&lt;String&gt; iterator = animals.listIterator();while (iterator.hasNext()) { String animal = iterator.next(); System.out.println(animal);} 结果： 12345DogCatBirdFishLizard nextIndex()：获取光标指向的那个位置的下标 previousIndex()：获取光标指向的那个位置的上一个位置的下标 12345678910111213List&lt;String&gt; animals = new ArrayList&lt;&gt;();animals.add(\"Dog\");animals.add(\"Cat\");animals.add(\"Bird\");animals.add(\"Fish\");animals.add(\"Lizard\");ListIterator&lt;String&gt; iterator = animals.listIterator();//测试nextIndex()System.out.println(\"Next index: \" + iterator.nextIndex());//0//测试previousIndex()System.out.println(\"Previous index: \" + iterator.previousIndex());//-1 remove()：删除上一次next()方法返回的那个数据(删除的是集合中的)。remove()方法调用的前提是：你先调用next()方法。不然会报错。 1234567891011List&lt;String&gt; animals = new ArrayList&lt;&gt;();animals.add(\"Dog\");animals.add(\"Cat\");animals.add(\"Bird\");animals.add(\"Fish\");animals.add(\"Lizard\");ListIterator&lt;String&gt; iterator = animals.listIterator();//测试remove()iterator.remove();//java.lang.IllegalStateException add(E e)：将元素添加到光标的位置，然后光标向下移动一位 12345678910111213141516List&lt;String&gt; animals = new ArrayList&lt;&gt;();animals.add(\"Dog\");animals.add(\"Cat\");animals.add(\"Bird\");animals.add(\"Fish\");animals.add(\"Lizard\");ListIterator&lt;String&gt; iterator = animals.listIterator();while (iterator.hasNext()) { String animal = iterator.next(); if(\"Bird\".equals(animal)){ iterator.remove(); }}System.out.println(animals);// [Dog, Cat, Bird, Butterfly, Fish, Lizard] set(E e)：修改的是上一次next()方法返回的那个数据（修改的是集合中的）。set()方法调用的前提是：你先调用了next()方法。不然会报错 1234567891011121314151617List&lt;String&gt; animals = new ArrayList&lt;&gt;();animals.add(\"Dog\");animals.add(\"Cat\");animals.add(\"Bird\");animals.add(\"Fish\");animals.add(\"Lizard\");ListIterator&lt;String&gt; iterator = animals.listIterator();while (iterator.hasNext()) { String animal = iterator.next(); if(\"Bird\".equals(animal)){ iterator.set(\"Butterfly\"); }}System.out.println(animals);// [Dog, Cat, Butterfly, Fish, Lizard] List接口使用Comparator排序数组中自定义类型是如何排序的让自定义类型实现java.lang.Comparable接口，接着重写compareTo方法。在compareTo方法中指定比较规则。 123456789101112131415161718192021222324252627public class User implements Comparable&lt;User&gt; { private String name; public User(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public int compareTo(User user) { return this.name.compareTo(user.name); } @Override public String toString() { return \"User{\" + \"name='\" + name + '\\'' + '}'; }} 1234567891011121314import java.util.Arrays;public class ArraySort { public static void main(String[] args) { User jack = new User(\"Jack\"); User tom = new User(\"Tom\"); User lucy = new User(\"Lucy\"); User[] users = new User[]{jack, tom, lucy}; Arrays.sort(users); for (User user : users) { System.out.println(user.getName()); } }} 结果： 123JackLucyTom List集合的排序对list集合排序可以调用 default void sort(Comparator&lt;? super E&gt; c) ​ sort方法参数：java.util.Comparator（我们把这个叫比较器，这是一个接口） 提供一个Comparator的实现类，重写compare方法 1234567891011121314151617181920212223242526public class ListSort { public static void main(String[] args) { Person zhangsan = new Person(\"zhangsan\", 20); Person lisi = new Person(\"lisi\", 25); Person wangwu = new Person(\"wangwu\", 30); Person zhaoliu = new Person(\"zhaoliu\", 35); ArrayList&lt;Person&gt; people = new ArrayList&lt;Person&gt;(); people.add(zhangsan); people.add(lisi); people.add(wangwu); people.add(zhaoliu); System.out.println(\"Before sorting:\"); for (Person person : people) { System.out.println(person.getName() + \" \" + person.getAge()); } // Sort the list using the custom comparator people.sort(new PersonComparator()); System.out.println(\"\\nAfter sorting by name:\"); for (Person person : people) { System.out.println(person.getName() + \" \" + person.getAge()); } }} ​ 123456789101112131415161718192021222324252627282930313233public class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; }} 结果： 1234567891011Before sorting:zhangsan 20lisi 25wangwu 30zhaoliu 35After sorting by name:lisi 25wangwu 30zhangsan 20zhaoliu 35 采用匿名内部类的方式提供Comparator的实现类 1234567891011121314151617181920212223242526272829303132333435import java.util.ArrayList;import java.util.Comparator;public class ListSort2 { public static void main(String[] args) { Person zhangsan = new Person(\"zhangsan\", 20); Person lisi = new Person(\"lisi\", 25); Person wangwu = new Person(\"wangwu\", 30); Person zhaoliu = new Person(\"zhaoliu\", 35); ArrayList&lt;Person&gt; people = new ArrayList&lt;Person&gt;(); people.add(zhangsan); people.add(lisi); people.add(wangwu); people.add(zhaoliu); System.out.println(\"Before sorting:\"); for (Person person : people) { System.out.println(person.getName() + \" \" + person.getAge()); } // Sort the list using an anonymous inner class people.sort(new Comparator&lt;Person&gt;() { @Override public int compare(Person o1, Person o2) { return o2.getName().compareTo(o1.getName()); } }); System.out.println(\"\\nAfter sorting by name:\"); for (Person person : people) { System.out.println(person.getName() + \" \" + person.getAge()); } }} ArrayList 底层采用了数组数据结构 优点：底层是数组，因此根据下标查找元素的时间复杂度是O(1)，检索效率高 缺点：随机增删元素效率低。注意：只要数组的容量没有满，对末尾元素进行增删时，效率不会受影响 适用场景：需要频繁检索元素，并且很少进行随机增删元素时建议使用ArrayList 默认初始化容量： 当调用无参构造方法时，初始化容量为0，当第一次调用add方法时，会将ArrayList容量初始化为10个长度 扩容策略 底层扩容会创建一个新数组，然后使用数组拷贝。扩容之后的新容量是原容量的1.5倍 1234567891011private Object[] grow(int minCapacity) { int oldCapacity = elementData.length; if (oldCapacity &gt; 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { int newCapacity = ArraysSupport.newLength(oldCapacity, minCapacity - oldCapacity, /* minimum growth */ oldCapacity &gt;&gt; 1 /* preferred growth */); return elementData = Arrays.copyOf(elementData, newCapacity); } else { return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)]; }} 12345678910111213public static int newLength(int oldLength, int minGrowth, int prefGrowth) { // preconditions not checked because of inlining // assert oldLength &gt;= 0 // assert minGrowth &gt; 0 int prefLength = oldLength + Math.max(minGrowth, prefGrowth); // might overflow if (0 &lt; prefLength &amp;&amp; prefLength &lt;= SOFT_MAX_ARRAY_LENGTH) { return prefLength; } else { // put code cold in a separate method return hugeLength(oldLength, minGrowth); }} 集合源码分析 属性分析 123456789//The array buffer into which the elements of the ArrayList are stored. transient Object[] elementData; // non-private to simplify nested class access/** * The size of the ArrayList (the number of elements it contains). * * @serial */private int size; 构造方法分析（使用ArrayList时，最好预测一下最大数量，给定初始化容量，减少扩容次数） 添加元素 看上面扩容策略处的代码 修改元素: 修改元素时会将修改前的值返回 1E set(int index, E element); 123456public E set(int index, E element) { Objects.checkIndex(index, size); E oldValue = elementData(index); elementData[index] = element; return oldValue;} 12345678910111213141516public class ListSort { public static void main(String[] args) { Person zhangsan = new Person(\"zhangsan\", 20); Person lisi = new Person(\"lisi\", 25); Person wangwu = new Person(\"wangwu\", 30); Person zhaoliu = new Person(\"zhaoliu\", 35); List&lt;Person&gt; people = new ArrayList&lt;&gt;(); people.add(zhangsan); people.add(lisi); people.add(wangwu); people.add(zhaoliu); System.out.println(people.set(2, zhaoliu)); //Person{name='wangwu', age=30} }} 插入元素 删除元素 Vector Vector底层也是数组，和ArrayList相同。 不同的是Vector几乎所有的方法都是同步的（被synchronized修饰：线程排队执行，不能并发），因此Vector是线程安全的，但是因为效率低，所以很少使用。控制线程安全有新的方式，所以这个很少用。 初始化容量：10 扩容策略：扩容之后的容量是原容量的2倍。 链表存储结构 单向链表 双向链表 环形链表 链表优点 因为链表节点在空间存储上，内存地址不是连续的。因此删除某个节点时不需要涉及到元素位移的问题。因此随机增删元素效率较高。时间复杂度O(1) 链表缺点 链表中元素在查找时，只能从某个节点开始顺序查找，因为链表节点的内存地址在空间上不是连续的。链表查找元素效率较低，时间复杂度O(n) 适用场景 ​ 需要频繁进行随机增删，但很少的查找的操作时。 LinkedList LinkedList是一个双向链表 源码分析 属性分析 1234567891011transient int size = 0;/** * Pointer to first node. */transient Node&lt;E&gt; first;/** * Pointer to last node. */transient Node&lt;E&gt; last; 构造方法分析 添加元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public void add(int index, E element) { checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index));}void linkLast(E e) { final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;}/** * Inserts element e before non-null Node succ. */void linkBefore(E e, Node&lt;E&gt; succ) { // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++;}Node&lt;E&gt; node(int index) { // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) { Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; } else { Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; }} 1234567public E set(int index, E element) { checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;} 修改元素 1234567public E set(int index, E element) { checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;} 插入元素 12345678public void add(int index, E element) { checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index));} 删除元素 123456789101112131415161718192021222324252627282930public E remove(int index) { checkElementIndex(index); return unlink(node(index));}E unlink(Node&lt;E&gt; x) { // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) { first = next; } else { prev.next = next; x.prev = null; } if (next == null) { last = prev; } else { next.prev = prev; x.next = null; } x.item = null; size--; modCount++; return element;} 手写单向链表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167/** * 自定义的单向链表 */public class MyLinked&lt;E&gt; { /** * 元素个数 */ private int size; /** * 单向链表的头结点 */ private Node&lt;E&gt; first; /** * 构建一个空链表 */ public MyLinked() { } /** * 获取集合中元素的个数 * * @return 个数 */ public int size() { return size; } /** * 向单向链表的末尾添加一个元素。 * * @param data 数据 */ public void add(E data) { //如果first是空，表示是一个空链表 if (first == null) { first = new Node&lt;&gt;(data, null); size++; return; } Node&lt;E&gt; last = findLast(); Node&lt;E&gt; newNode = new Node&lt;&gt;(data, null); last.next = newNode; size++; } /** * 找到单向链表的末尾结点 * * @return 末尾结点 */ private Node&lt;E&gt; findLast() { if (first == null) { //空链表 return null; } Node&lt;E&gt; last = first; while (last.next != null) { //把last.next看做是最后一个结点 last = last.next; } return last; } /** * 将元素添加到指定索引处 * * @param index 下标 * @param data 数据 */ public void add(int index, E data) { Node&lt;E&gt; oldNode = node(index); if (index == 0) { first = new Node&lt;&gt;(data, first); } else { Node&lt;E&gt; newNode = new Node&lt;&gt;(data, oldNode); Node&lt;E&gt; prev = node(index - 1); prev.next = newNode; } size++; } /** * 返回索引处的结点对象 * * @param index 索引 * @return 结点对象 */ private Node&lt;E&gt; node(int index) { //假设头结点是下一个结点 Node&lt;E&gt; next = first; for (int i = 0; i &lt; index; i++) { next = next.next; } return next; } /** * 删除指定索引处的元素 * * @param index 索引 */ public void remove(int index) { if (index == 0) { first = first.next; } else { Node&lt;E&gt; pre = node(index - 1); Node&lt;E&gt; cur = node(index); pre.next = cur.next; cur.next = null; cur.item = null; } size--; } /** * 修改指定索引处的数据 * * @param index 索引 * @param data 数据 */ public void set(int index, E data) { node(index).item = data; } /** * 根据下标获取数据 * * @param index 下标 * @return 数据 */ public E get(int index) { return node(index).item; } /** * 单向链表当中的结点（建议定义为静态内部类。） */ private static class Node&lt;E&gt; { /** * 数据 */ E item; /** * 下一个结点的内存地址 */ Node&lt;E&gt; next; /** * 构造一个结点对象 * * @param item 结点中的数据 * @param next 下一个结点的内存地址。 */ public Node(E item, Node&lt;E&gt; next) { this.item = item; this.next = next; } }} 12345678910111213141516171819202122232425262728293031323334353637383940package com.powernode.javase.collection.Summer;public class MyLinkedTest { public static void main(String[] args) { MyLinked&lt;String&gt; myLinked = new MyLinked&lt;&gt;(); myLinked.add(\"hello\"); myLinked.add(\"world\"); myLinked.add(\"java\"); //遍历 traverseCollection(myLinked); //删除 System.out.println(\"-----------------\"); myLinked.remove(1); traverseCollection(myLinked); //修改 System.out.println(\"-----------------\"); myLinked.set(0, \"hello~hello~\"); traverseCollection(myLinked); //新增 System.out.println(\"-----------------\"); myLinked.add(1, \"world~world~\"); traverseCollection(myLinked); //查询 System.out.println(\"-----------------\"); String s = myLinked.get(2); System.out.println(s); } private static void traverseCollection(MyLinked&lt;String&gt; myLinked) { for (int i = 0; i &lt; myLinked.size(); i++) { String s = myLinked.get(i); System.out.println(s); } }} 123456789101112131415helloworldjava-----------------hellojava-----------------hello~hello~java-----------------hello~hello~world~world~java-----------------java 栈数据结构 LIFO原则（Last In, First Out）：后进先出 可以用数组实现栈数据结构，也可以用双向链表来实现。 用数组实现栈数据结构的代表有：Stack、ArrayDeque Stack：Vetor的子类，实现了栈数据结构，除了具有Vetor的方法，还扩展了其它方法，完成了栈结构的模拟。不过在JDK1.6（Java6）之后就不建议使用了，因为它是线程安全的，太慢了。Stack中的方法如下： E push(E item)：压栈 E pop()：弹栈（将栈顶元素删除，并返回被删除的引用） int search(Object o)：查找栈中元素（返回值的意思是：以1为开始，从栈顶往下数第几个） E peek()：窥视栈顶元素（不会将栈顶元素删除，只是看看栈顶元素是什么。注意：如果栈为空时会报异常。） ArrayDeque E push(E item) E pop() 用链表实现的代表是：LinkedList E push(E item) E pop() 队列数据结构 概念 队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，队列是一种操作受限制的线性表。进行插入操作（入口）的端称为队尾，进行删除操作（出口）的端称为队头。 队列的插入操作只能在队尾操作，队列的删除操作只能在队头操作，因此队列是一种先进先出（First In First Out）的线性表，简称FIFO表。 Queue接口是一种基于FIFO（先进先出）的数据结构，而Deque接口则同时支持FIFO和LIFO（后进先出）两种操作。因此Deque接口也被称为“双端队列”。 Java集合框架中队列的实现： 链表实现方式：LinkedList 数组实现方式：ArrayDeque ![image-20250418214047976](https://raw.githubusercontent.com/growingbambi/typora/master/image-20250418214047976.png) LinkedList和ArrayDeque都实现了Queue、Deque接口，因此这两个类都具备队列和双端队列的特性。 LinkedList底层是基于双向链表实现的，因此它天然就是一个双端队列，既支持从队尾入队，从队头出队，也支持从队头入队，从队尾出队。用Deque的实现方式来说，就是它既实现了队列的offer()和poll()方法，也实现了双端队列的offerFirst()、offerLast()、pollFirst()和pollLast()方法等。 ArrayDeque底层是使用环形数组实现的，也是一个双端队列。它比LinkedList更加高效，因为在数组中随机访问元素的时间复杂度是O(1)，而链表中需要从头或尾部遍历链表寻找元素，时间复杂度是O(N)。循环数组：index = (start + i) % capacity Queue接口基于Collection扩展的方法 方法 描述 boolean offer(E e); 入队 E poll(); 出队，如果队列为空，返回null。 E remove(); 出队，如果队列为空，抛异常。 E peek(); 查看队头元素，如果为空则返回null。 E element(); 查看对头元素，如果为空则抛异常。 Deque接口基于Queen接口扩展的方法 可以模拟队列的方法 描述 boolean offerLast(E e); 从队尾入队 E pollFirst(); 从队头出队 可以模拟双端队列的方法 描述 boolean offerLast(E e); 从队尾入队 E pollFirst(); 从队头出队 boolean offerFirst(E e); 从队头入队 E pollLast(); 从队尾出队 另外offerLast+pollLast或者pollFirst+offerFirst可以模拟栈数据结构。或者也可以直接调用push/pop方法。 Map继承结构 Map集合以key和value的键值对形式存储。key和value存储的都是引用。 Map集合中key起主导作用。value是附属在key上的。 SequencedMap是Java21新增的。 LinkedHashMap和TreeMap都是有序集合。（key是有序的） HashMap，Hashtable，Properties都是无序集合。（key是无序的） Map集合的key都是不可重复的。key重复的话，value会覆盖。 HashSet集合底层是new了一个HashMap。往HashSet集合中存储元素实际上是将元素存储到HashMap集合的key部分。HashMap集合的key是无序不可重复的，因此HashSet集合就是无序不可重复的。HashMap集合底层是哈希表/散列表数据结构，因此HashSet底层也是哈希表/散列表。 TreeSet集合底层是new了一个TreeMap。往TreeSet集合中存储元素实际上是将元素存储到TreeMap集合的key部分。TreeMap集合的key是不可重复但可排序的，因此TreeSet集合就是不可重复但可排序的。TreeMap集合底层是红黑树，因此TreeSet底层也是红黑树。它们的排序通过java.lang.Comparable和java.util.Comparator均可实现。 LinkedHashSet集合底层是new了一个LinkedHashMap。LinkedHashMap集合只是为了保证元素的插入顺序，效率比HashSet低，底层采用的哈希表+双向链表实现。 根据源码可以看到向Set集合中add时，底层会向Map中put。value只是一个固定不变的常量，只是起到一个占位符的作用。主要是key。 Map接口的常用方法 方法 描述 V put(K key, V value); 添加键值对 void putAll(Map&lt;? extends K,? extends V&gt; m); 添加多个键值对 V get(Object key); 通过key获取value boolean containsKey(Object key); 是否包含某个key boolean containsValue(Object value); 是否包含某个value V remove(Object key); 通过key删除key-value void clear(); 清空Map int size(); 键值对个数 boolean isEmpty(); 判断是否为空Map Collection values(); 获取所有的value Set keySet(); 获取所有的key Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(); 获取所有键值对的Set视图 static &lt;K,V&gt; Map&lt;K,V&gt; of(K k1, V v1, K k2, V v2, K k3, V v3); 静态方法，使用key-value构造map HashMap","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaofanshutu.github.io/categories/Java/"}],"tags":[]},{"title":"常用类_String类","slug":"动力节点Java/Chapter6_常用类_String类","date":"2025-04-10T23:38:26.701Z","updated":"2025-04-11T12:11:43.308Z","comments":true,"path":"posts/6dd21eef.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/6dd21eef.html","excerpt":"String初识 java.lang.String Java中String属于引用数据类型，代表字符串。 Java在堆中为字符串准备了字符串常量池。（是一种缓存技术，提高程序执行效率） ​ 注：字符串字面量在编译的时候就已经确定了将其放到字符串常量池中。JVM启动时会立即将程序中带有双引号的字符串字面量全部放入字符串常量池。 Java8之后字符串常量池存放在堆中，Java8之前字符串常量池在永久代。 字符串一旦创建是不可变的。 12@Stable private final byte[] value; String的拼接 动态拼接后新的字符串不会自动放到字符串常量池。 12345String str1 = \"abc\"; //字符串常量池String str2 = \"def\"; //字符串常量池String str3 = \"abcdef\"; //字符串常量池String str4 = str1 + str2; //运行时才会创建对象, str4在堆内存中System.out.println(str3 == str4); //false 两个字符串字面量拼接会做编译阶段的优化，在编译阶段就会进行字符串的拼接。","text":"String初识 java.lang.String Java中String属于引用数据类型，代表字符串。 Java在堆中为字符串准备了字符串常量池。（是一种缓存技术，提高程序执行效率） ​ 注：字符串字面量在编译的时候就已经确定了将其放到字符串常量池中。JVM启动时会立即将程序中带有双引号的字符串字面量全部放入字符串常量池。 Java8之后字符串常量池存放在堆中，Java8之前字符串常量池在永久代。 字符串一旦创建是不可变的。 12@Stable private final byte[] value; String的拼接 动态拼接后新的字符串不会自动放到字符串常量池。 12345String str1 = \"abc\"; //字符串常量池String str2 = \"def\"; //字符串常量池String str3 = \"abcdef\"; //字符串常量池String str4 = str1 + str2; //运行时才会创建对象, str4在堆内存中System.out.println(str3 == str4); //false 两个字符串字面量拼接会做编译阶段的优化，在编译阶段就会进行字符串的拼接。 1234//在字符串常量池中只有一个abcdefString str3 = \"abcdef\"; //字符串常量池String str5 = \"abc\" + \"def\"; //字符串常量池System.out.println(str3 == str5); //true String类的常用构造方法 String(char[] value)： 根据字符数组创建一个新的字符串对象。 123char[] chars = new char[]{'a', 'b', 'c'};String s = new String(chars);System.out.println(s);//abc String(char[] value, int offset, int count)： 根据字符数组的指定部分创建一个新的字符串对象。 123char[] chars = new char[]{'a', 'b', 'c', 'd', 'e', 'f'};String s = new String(chars, 1, 3);System.out.println(s);//bcd String(byte[] bytes)： 根据字节数组创建一个新的字符串对象，默认使用平台默认的字符集进行解码。 String(byte[] bytes, int offset, int length)： 根据字节数组的指定部分创建一个新的字符串对象，默认使用平台默认的字符集进行解码。 123byte[] bytes = new byte[]{97, 98, 99, 100, 101, 102};String str = new String(chars, 2, 3);System.out.println(str);//cde String(byte[] bytes, Charset charset)：根据字节数组和指定的字符集创建一个新的字符串对象。 如果编码和解码用到的字符集不一致，则会出现乱码。 new String(bytes, Charset.defaultCharset()); 123byte[] bytesArr = new byte[]{97, 98, 99, 100, 101, 102};String s5 = new String(bytesArr, Charset.defaultCharset());System.out.println(s5);//abcdef 12345// 先将字符串转换成byte[]数组（这个过程是一个编码的过程）byte[] bytes1 = \"你好旧时光\".getBytes(StandardCharsets.UTF_8);// 将以上的byte[]数组转换成字符串（这个过程是一个解码的过程）String s6 = new String(bytes1, StandardCharsets.UTF_8);System.out.println(s6);//你好旧时光 12345678// 乱码的本质：在进行编码和解码的时候没有使用同一个字符编码方式。//如果编码和解码的字符集不一致，就会出现乱码。// 先将字符串转换成byte[]数组（这个过程是一个编码的过程）byte[] bytes1 = \"你好旧时光\".getBytes(StandardCharsets.UTF_8);// 将以上的byte[]数组转换成字符串（这个过程是一个解码的过程）String s6 = new String(bytes1, StandardCharsets.ISO_8859_1);System.out.println(s6); String(byte[] bytes, String charsetName)：根据字节数组和指定的字符集名称创建一个新的字符串对象。 12345// 编码byte[] bytes = \"淡然\".getBytes(\"GBK\");// 解码String s6 = new String(bytes, \"GBK\");System.out.println(s6);//淡然 String(String original)：通过复制现有字符串创建一个新的字符串对象。 这个方法被@IntrinsicCandidate标注，这个注解的作用是告诉编译器，该方法或构造函数是一个内在的候选方法,可以被优化和替换为更高效的代码。因此它是不建议使用的。 new String(“hello”); 这个代码会让常量池中有一个 “hello”，并且在堆中也有有一个String对象。 123456@IntrinsicCandidatepublic String(String original) { this.value = original.value; this.coder = original.coder; this.hash = original.hash;} 1String helloStr = new String(\"hello\"); String类的常用方法 byte[] getBytes(); 将字符串转换成字节数组。其实就是对字符串进行编码。默认按照系统默认字符集。 byte[] getBytes(String charsetName); 将字符串按照指定字符集的方式进行编码。 byte[] getBytes(Charset charset); char[] toCharArray(); 将字符串转换字符数组。 String toLowerCase(); 转小写 String toUpperCase(); 转大写 String concat(String str); 进行字符串的拼接操作。和 + 的区别？+ 既可以进行求和，也可以进行字符串的拼接，底层拼接时会创建StringBuilder对象进行拼接。+ 拼接null时不会出现空指针异常。 concat方法参数只能时字符串类型，拼接时不会创建StringBuilder对象，拼接完成后返回一个新的String对象。拼接null会出现空指针异常。 +使用较多。如果进行大量字符串拼接，这两个都不合适。 String substring(int beginIndex); 从指定下标beginIndex开始截取子字符串 String substring(int beginIndex, int endIndex); String trim(); 去除字符串前后空白（只能去除ASCII码中的空格和制表符） String strip(); 去除字符串前后空白（支持所有的编码形式的空白，可以将全角空格去除，\\u3000是全角空格，Java11新增） String stripLeading(); 去除前空白 String stripTrailing(); 去除后空白 String toString(); String intern(); 获取字符串常量池中的字符串，如果常量池中没有，则将字符串加入常量池并返回。 byte[] bytes = {97,98,99,100}; String s = new String(bytes); String s2 = s.intern(); // 将字符串 “abcd”放入字符串常量池并返回常量池中的字符串 “abcd” static String join(CharSequence d, CharSequence… elements); 将多个字符串以某个分隔符连接（Java8新增） static String join(CharSequence delimiter, Iterable&lt;? extends CharSequence&gt; elements); static String valueOf(boolean b); 以下所有的静态方法valueOf作用是将非字符串类型的数据转换为字符串形式。 static String valueOf(char c); static String valueOf(char[] data); static String valueOf(char[] data, int offset, int count); static String valueOf(double d); static String valueOf(float f); static String valueOf(int i); static String valueOf(long l); static String valueOf(Object obj); 正则表达式String类的面试题练习题","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaofanshutu.github.io/categories/Java/"}],"tags":[]},{"title":"IDEA常用","slug":"动力节点Java/IDEA快捷键","date":"2025-04-09T14:14:33.587Z","updated":"2025-06-08T23:04:47.582Z","comments":true,"path":"posts/566321e7.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/566321e7.html","excerpt":"IDEA常用快捷键 单行注释：ctrl + / 多行注释：ctrl + shift + / 查看源码：按ctrl别松手，鼠标移动到对应的类名下方，出现下划线，点击过去，可以查看类源码。 多行编辑：按alt别松手，鼠标拖动多行，完成多行编辑。 怎么快速生成创建对象语句：类名.new.var 怎么快速生成if语句：布尔类型值.if 怎么快速生成setter和getter方法：alt + insert，然后选择setter and getter生成。 怎么快速生成构造方法：alt + insert，然后选择Constructor。 在IDEA当中如何自动纠错：将光标移动到错误的位置，按atl + enter。会有提示，根据提示进行纠错。 移动代码到上一行：alt + shift + 上/下方向 怎么快速重写方法？alt + insert，选择Override…. 怎么快速重写方法？ctrl + o 快速向下转型，并同时生成变量名：变量名.castvar 快速查看方法的参数：ctrl + p 返回上一步：ctrl + alt + 左方向键。 下一步：ctrl + alt + 右方向键。 代码格式化：ctrl + alt + L 查看继承结构：ctrl + H（或者F4） 自动代码包裹：ctrl + alt + t 快速运行程序 ctrl + shift + F10 IDEA中文乱码 在 IntelliJ IDEA 中，可以通过以下步骤检查和设置文件编码：右键文件 -&gt; File Encoding -&gt; 选择 UTF-8。 设置 JVM 的字符编码：在运行配置中添加 JVM 参数，强制指定 UTF-8 编码：-Dfile.encoding=UTF-8在 IntelliJ IDEA 中：打开 Run/Debug Configurations。在 VM options 中添加上述参数。","text":"IDEA常用快捷键 单行注释：ctrl + / 多行注释：ctrl + shift + / 查看源码：按ctrl别松手，鼠标移动到对应的类名下方，出现下划线，点击过去，可以查看类源码。 多行编辑：按alt别松手，鼠标拖动多行，完成多行编辑。 怎么快速生成创建对象语句：类名.new.var 怎么快速生成if语句：布尔类型值.if 怎么快速生成setter和getter方法：alt + insert，然后选择setter and getter生成。 怎么快速生成构造方法：alt + insert，然后选择Constructor。 在IDEA当中如何自动纠错：将光标移动到错误的位置，按atl + enter。会有提示，根据提示进行纠错。 移动代码到上一行：alt + shift + 上/下方向 怎么快速重写方法？alt + insert，选择Override…. 怎么快速重写方法？ctrl + o 快速向下转型，并同时生成变量名：变量名.castvar 快速查看方法的参数：ctrl + p 返回上一步：ctrl + alt + 左方向键。 下一步：ctrl + alt + 右方向键。 代码格式化：ctrl + alt + L 查看继承结构：ctrl + H（或者F4） 自动代码包裹：ctrl + alt + t 快速运行程序 ctrl + shift + F10 IDEA中文乱码 在 IntelliJ IDEA 中，可以通过以下步骤检查和设置文件编码：右键文件 -&gt; File Encoding -&gt; 选择 UTF-8。 设置 JVM 的字符编码：在运行配置中添加 JVM 参数，强制指定 UTF-8 编码：-Dfile.encoding=UTF-8在 IntelliJ IDEA 中：打开 Run/Debug Configurations。在 VM options 中添加上述参数。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaofanshutu.github.io/categories/Java/"}],"tags":[]},{"title":"常用类_日期","slug":"动力节点Java/Chapter6_常用类_日期","date":"2025-04-09T13:56:08.600Z","updated":"2025-04-10T00:10:05.716Z","comments":true,"path":"posts/4f0359c2.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/4f0359c2.html","excerpt":"日期日期类 java.util.Date123public Date() { this(System.currentTimeMillis());} 123public Date(long date) { fastTime = date;} 日期格式化类 SimpleDateFormat日期转字符串字符串转日期日历类 java.util.Calendar获取当前时间的日历对象","text":"日期日期类 java.util.Date123public Date() { this(System.currentTimeMillis());} 123public Date(long date) { fastTime = date;} 日期格式化类 SimpleDateFormat日期转字符串字符串转日期日历类 java.util.Calendar获取当前时间的日历对象123//Gets a calendar using the default time zone and locale.Calendar instance = Calendar.getInstance();System.out.println(instance); 结果： 1java.util.GregorianCalendar[time=1744207975651,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"GMT+08:00\",offset=28800000,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2025,MONTH=3,WEEK_OF_YEAR=15,WEEK_OF_MONTH=2,DAY_OF_MONTH=9,DAY_OF_YEAR=99,DAY_OF_WEEK=4,DAY_OF_WEEK_IN_MONTH=2,AM_PM=1,HOUR=10,HOUR_OF_DAY=22,MINUTE=12,SECOND=55,MILLISECOND=651,ZONE_OFFSET=28800000,DST_OFFSET=0] 获取日历中某部分（年份/月份/星期等） 类型 描述 备注 Calendar.YEAR 获取年份 Calendar.MONTH 获取月份 0表示1月，1表示2月，…，11表示12月 Calendar.DAY_OF_MONTH 获取本月的第几天 Calendar.DAY_OF_YEAR 获取本年的第几天 Calendar.DAY_OF_WEEK 获取星期几 1表示星期日，…，7表示星期六 Calendar.HOUR_OF_DAY 小时，24小时制 Calendar.HOUR 小时，12小时制 Calendar.MINUTE 获取分钟 Calendar.SECOND 获取秒 Calendar.MILLISECOND 获取毫秒 12345678910111213Calendar instance = Calendar.getInstance();System.out.println(\"year: \" + instance.get(Calendar.YEAR));//2025System.out.println(\"month: \" + instance.get(Calendar.MONTH));//3: 四月System.out.println(\"the day of the month: \" + instance.get(Calendar.DAY_OF_MONTH));//9System.out.println(\"the day number within the current year: \" + instance.get(Calendar.DAY_OF_YEAR));//99System.out.println(\"the day of the week:\" + instance.get(Calendar.DAY_OF_WEEK));//4: 星期三//the hour of the day. HOUR_OF_DAY is used for the 24-hour clockSystem.out.println(\"the hour of the day. 24-hour clock: \" + instance.get(Calendar.HOUR_OF_DAY));//22//the hour of the morning or afternoon. HOUR is used for the 12-hour clock (0 - 11). Noon and midnight are represented by 0, not by 12.System.out.println(\"the hour of the day. 12-hour clock: \" + instance.get(Calendar.HOUR));//10System.out.println(\"minute: \" + instance.get(Calendar.MINUTE));//39System.out.println(\"second: \" + instance.get(Calendar.SECOND));//35System.out.println(\"millsecond: \" + instance.get(Calendar.MILLISECOND));//711 12//获取自1970年1月1日0时0分0秒到系统当前时间的总毫秒数。System.out.println(System.currentTimeMillis());//1744207198604 设置日历 set方法calendar.set(Calendar.YEAR, 2023)123Calendar calendar2 = Calendar.getInstance();calendar2.set(Calendar.YEAR, 2023);System.out.println(calendar2.get(Calendar.YEAR) + \"年\" + (calendar2.get(Calendar.MONTH) + 1) + \"月\" + calendar2.get(Calendar.DAY_OF_MONTH) + \"日\"); //2023年4月9日 calendar.set(2015, Calendar.SEPTEMBER,8)123Calendar calendar2 = Calendar.getInstance();calendar2.set(2015, Calendar.JULY, 26, 8, 30, 0);System.out.println(calendar2); 结果： 12015年7月26日 小点：最好用提供的常量 日历中各部分加减 add方法calendar.add(Calendar.YEAR, 1)123Calendar calendar2 = Calendar.getInstance();calendar2.add(Calendar.YEAR, 1);System.out.println(calendar2.get(Calendar.YEAR) + \"年\" + (calendar2.get(Calendar.MONTH) + 1) + \"月\" + calendar2.get(Calendar.DAY_OF_MONTH) + \"日\"); 结果： 12026年4月9日 让日历关联具体时间 setTime方法calendar.setTime(new Date())//年份偏移： Date 构造方法中的年份参数是基于 1900 的偏移量。例如，传入 2015 实际表示 1900 + 2015 = 3915 年。 1234Calendar calendar2 = Calendar.getInstance();calendar2.setTime(new Date(2015, Calendar.JULY, 15));System.out.println(calendar2.get(Calendar.YEAR) + \"年\" + (calendar2.get(Calendar.MONTH) + 1) + \"月\" + calendar2.get(Calendar.DAY_OF_MONTH) + \"日\"); //3915年7月15日 获取日历的具体时间 getTime方法Date time = calendar.getTime();IDEA小技巧： 自动提示忽略大小写，取消勾选Match Case checkbox","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaofanshutu.github.io/categories/Java/"}],"tags":[]},{"title":"Spring","slug":"Spring学习笔记","date":"2025-04-09T09:59:01.293Z","updated":"2025-04-09T10:24:39.383Z","comments":true,"path":"posts/6c92115f.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/6c92115f.html","excerpt":"通过如下代码，来分析几个开发原则（OCP开闭原则和DIP依赖倒置原则） 代码结构 1.Test类12345678910package com.xu.spring6.client;import com.xu.spring6.web.UserAction;public class Test { public static void main(String[] args) { UserAction userAction = new UserAction(); userAction.deleteUser(); }} 2.UserAction类123456789101112package com.xu.spring6.web;import com.xu.spring6.service.UserService;import com.xu.spring6.service.impl.UserServiceImpl;public class UserAction { private UserService userService = new UserServiceImpl(); public void deleteUser(){ userService.deleteUser(); }} 3.UserService接口和UserServiceImpl实现类12345package com.xu.spring6.service;public interface UserService { void deleteUser();}","text":"通过如下代码，来分析几个开发原则（OCP开闭原则和DIP依赖倒置原则） 代码结构 1.Test类12345678910package com.xu.spring6.client;import com.xu.spring6.web.UserAction;public class Test { public static void main(String[] args) { UserAction userAction = new UserAction(); userAction.deleteUser(); }} 2.UserAction类123456789101112package com.xu.spring6.web;import com.xu.spring6.service.UserService;import com.xu.spring6.service.impl.UserServiceImpl;public class UserAction { private UserService userService = new UserServiceImpl(); public void deleteUser(){ userService.deleteUser(); }} 3.UserService接口和UserServiceImpl实现类12345package com.xu.spring6.service;public interface UserService { void deleteUser();} 1234567891011121314package com.xu.spring6.service.impl;import com.xu.spring6.dao.UserDao;import com.xu.spring6.dao.impl.UserDaoImplForMySQL;import com.xu.spring6.service.UserService;public class UserServiceImpl implements UserService { private UserDao userDao = new UserDaoImplForMySQL(); @Override public void deleteUser() { userDao.deleteUser(); }} 4.UserDao接口和UserDaoImplForMySQL实现类12345package com.xu.spring6.dao;public interface UserDao { void deleteUser();} 1234567891011package com.xu.spring6.dao.impl;import com.xu.spring6.dao.UserDao;public class UserDaoImplForMySQL implements UserDao { @Override public void deleteUser() { System.out.println(\"正在删除用户信息~\"); }} 分析上述代码存在问题UserAction类中用到了private UserService userService = new UserServiceImpl(); UserServiceImpl实现类中用到了private UserDao userDao = new UserDaoImplForMySQL(); 如果现在，我想从MySQL（UserDaoImplForMySQL）切换到Oracle（UserDaoImplForOracle），那么我就必须修改UserServiceImpl类的代码，将声明成员变量userDao的代码改为如下： 1private UserDao userDao = new UserDaoImplForOracle(); 这个就违反了OCP开闭原则和DIP依赖倒置原则。 OCP开闭原则开闭原则(Open-Closed Principle)：简称OCP，在软件开发过程中应当对扩展开放，对修改关闭。也就是说，如果在进行功能扩展的时候，添加额外的类是没问题的，但因为功能扩展而修改之前运行正常的程序，这是不推荐的。因为一旦修改之前运行正常的程序，就会导致项目整体要进行全方位的重新测试。这是相当繁琐的过程。导致这个问题的主要原因是：代码和代码之间的耦合度太高。如下图所示： 上层是依赖下层的。UserAction依赖UserServiceImpl，而UserServiceImpl依赖UserDaoImplForMySQL，这样就会导致下面只要改动，上面必然会受牵连（跟着也会改），所谓牵一发而动全身。这个也同时违背了另一个开发原则：依赖倒置原则。 DIP依赖倒置原则依赖倒置原则(Dependence Inversion Principle)：简称DIP，主要倡导面向抽象编程，面向接口编程，不要面向具体编程，让上层不再依赖下层，下面改动了，上面的代码不会受到牵连。这样可以大大降低程序的耦合度，耦合度低了，扩展力就强了，同时代码复用性也会增强。（软件七大开发原则都是在为解耦合服务） 前面有问题的代码没有完全实现面向接口编程，因为代码中还是使用了接口的具体实现类。 下面这种才算是完全的面向接口编程","categories":[{"name":"Spring6","slug":"Spring6","permalink":"https://xiaofanshutu.github.io/categories/Spring6/"}],"tags":[]},{"title":"Injection","slug":"D4-注入","date":"2025-04-09T09:59:01.292Z","updated":"2025-04-09T10:24:39.383Z","comments":true,"path":"posts/13006ff7.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/13006ff7.html","excerpt":"1 IoC 控制反转 控制反转是一种思想。 控制反转，反转的是什么？ 将对象的创建权交出去，交给第三方容器负责。 将对象和对象之间关系的维护权交出去，交给第三方容器负责。 控制反转这种思想如何实现呢？ DI（Dependency Injection）：依赖注入 2 依赖注入 Spring是通过依赖注入的方式来完成Bean管理的。Bean管理指的是：Bean对象的创建，以及Bean对象中属性的赋值（或者叫做Bean对象之间关系的维护）。 依赖注入： 依赖指的是对象和对象之间的关联关系。 注入指的是一种数据传递行为，通过注入行为来让对象和对象产生关系。 依赖注入常见的实现方式包括两种： 第一种：set注入 第二种：构造注入 2.1 set注入","text":"1 IoC 控制反转 控制反转是一种思想。 控制反转，反转的是什么？ 将对象的创建权交出去，交给第三方容器负责。 将对象和对象之间关系的维护权交出去，交给第三方容器负责。 控制反转这种思想如何实现呢？ DI（Dependency Injection）：依赖注入 2 依赖注入 Spring是通过依赖注入的方式来完成Bean管理的。Bean管理指的是：Bean对象的创建，以及Bean对象中属性的赋值（或者叫做Bean对象之间关系的维护）。 依赖注入： 依赖指的是对象和对象之间的关联关系。 注入指的是一种数据传递行为，通过注入行为来让对象和对象产生关系。 依赖注入常见的实现方式包括两种： 第一种：set注入 第二种：构造注入 2.1 set注入set注入是基于set方法实现的，底层会通过反射机制调用属性对应的set方法然后给属性赋值。这种方式要求必须对外提供属性的set方法。 通过一个例子来学习set注入pom.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.xu&lt;/groupId&gt; &lt;artifactId&gt;spring6-002-dependency-injection&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--log4j2的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.20.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt; &lt;version&gt;2.20.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; UserService 1234567891011121314151617181920212223package com.xu.service;import com.xu.dao.UserDao;import com.xu.dao.VipDao;public class UserService { private UserDao userDao; private VipDao vipDao; public void save() { userDao.save(); vipDao.save(); } public void setUserDao(UserDao userDao) { this.userDao = userDao; } public void setVipDao(VipDao vipDao) { this.vipDao = vipDao; }} UserDao 123456789101112package com.xu.dao;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class UserDao { private static Logger LOGGER = LoggerFactory.getLogger(UserDao.class); public void save() { LOGGER.info(\"UserDao正在保存用户信息\"); }} VipDao 123456789101112package com.xu.dao;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class VipDao { private Logger LOGGER = LoggerFactory.getLogger(VipDao.class); public void save() { LOGGER.info(\"VipDao正在保存用户信息\"); }} log4j2.xml 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;loggers&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"log\"/&gt; &lt;/root&gt; &lt;/loggers&gt; &lt;appenders&gt; &lt;console name=\"log\" target=\"SYSTEM_OUT\"&gt; &lt;PatternLayout pattern=\"%d{yyyy-MM-dd HH:mm:ss SSS} [%t] %-3level %logger{1024} - %msg%n\"/&gt; &lt;/console&gt; &lt;/appenders&gt;&lt;/configuration&gt; spring.xml 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"userDao\" class=\"com.xu.dao.UserDao\"/&gt; &lt;bean id=\"vipDao\" class=\"com.xu.dao.VipDao\"/&gt; &lt;bean id=\"userService\" class=\"com.xu.service.UserService\"&gt; &lt;property name=\"userDao\" ref=\"userDao\"/&gt; &lt;property name=\"vipDao\" ref=\"vipDao\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类 123456789101112131415package com.xu.test;import com.xu.service.UserService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class SpringTest { @Test public void testIoC() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring.xml\"); UserService userService = applicationContext.getBean(\"userService\", UserService.class); userService.save(); }} 运行结果： 原理是什么？set注入的核心实现原理：通过反射机制调用set方法来给属性赋值，让两个对象之间产生关系。 举例验证： 1.将成员属性的属性名改为userhaha和viphaha，然后保持set方法的方法名不变，测试这种情况下，程序应该可以正常运行。不会报错。 12345678910111213141516171819202122package com.xu.service;import com.xu.dao.UserDao;import com.xu.dao.VipDao;public class UserService { private UserDao userhaha; private VipDao viphaha; public void save() { userhaha.save(); viphaha.save(); } public void setUserDao(UserDao userDao) { this.userhaha = userDao; } public void setVipDao(VipDao vipDao) { this.viphaha = vipDao; }} 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"userDao\" class=\"com.xu.dao.UserDao\"/&gt; &lt;bean id=\"vipDao\" class=\"com.xu.dao.VipDao\"/&gt; &lt;bean id=\"userService\" class=\"com.xu.service.UserService\"&gt; &lt;property name=\"userDao\" ref=\"userDao\"/&gt; &lt;property name=\"vipDao\" ref=\"vipDao\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 运行结果：成功 2.保持成员属性的属性名不变，将set方法的方法名改为setUserDaoHaHa和setVipDaoHaHa，测试这种情况下，程序应该会报错。 12345678910111213141516171819202122package com.xu.service;import com.xu.dao.UserDao;import com.xu.dao.VipDao;public class UserService { private UserDao userDao; private VipDao vipDao; public void save() { userDao.save(); vipDao.save(); } public void setUserDaoHaHa(UserDao userDao) { this.userDao = userDao; } public void setVipDaoHaHa(VipDao vipDao) { this.vipDao = vipDao; }} 如果property的name还是传的userDao和vipDao就会报错 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"userDao\" class=\"com.xu.dao.UserDao\"/&gt; &lt;bean id=\"vipDao\" class=\"com.xu.dao.VipDao\"/&gt; &lt;bean id=\"userService\" class=\"com.xu.service.UserService\"&gt; &lt;property name=\"userDao\" ref=\"userDao\"/&gt; &lt;property name=\"vipDao\" ref=\"vipDao\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 将property的name改为userDaoHaHa和vipDaoHaHa就成功了 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"userDao\" class=\"com.xu.dao.UserDao\"/&gt; &lt;bean id=\"vipDao\" class=\"com.xu.dao.VipDao\"/&gt; &lt;bean id=\"userService\" class=\"com.xu.service.UserService\"&gt; &lt;property name=\"userDaoHaHa\" ref=\"userDao\"/&gt; &lt;property name=\"vipDaoHaHa\" ref=\"vipDao\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 2.2 构造注入原理：通过调用构造方法来给属性赋值。 使用下标注入123456789101112package com.xu.dao;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class OrderDao { private static Logger LOGGER = LoggerFactory.getLogger(OrderDao.class); public void orderService() { LOGGER.info(\"服务已预约~\"); }} 123456789101112131415package com.xu.service;import com.xu.dao.OrderDao;public class OrderService { private OrderDao orderDao; public OrderService(OrderDao orderDao) { this.orderDao = orderDao; } public void order() { orderDao.orderService(); }} 12345678&lt;bean id=\"orderDao\" class=\"com.xu.dao.OrderDao\" /&gt;&lt;bean id=\"orderService\" class=\"com.xu.service.OrderService\"&gt; &lt;!--index=\"0\"表示构造方法的第一个参数，将orderDao对象传递给构造方法的第一个参数。--&gt; &lt;constructor-arg index=\"0\" ref=\"orderDao\"/&gt; &lt;!-- 如果有多个构造方法参数，则继续加index=\"1\" --&gt; &lt;!-- &lt;constructor-arg index=\"1\" ref=\"orderDao\"/&gt;--&gt;&lt;/bean&gt; 123456@Testpublic void testConstructorDI() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring.xml\"); OrderService orderService = applicationContext.getBean(\"orderService\", OrderService.class); orderService.order();} 运行结果如下： 使用构造方法参数名注入12345678910111213141516171819package com.xu.service;import com.xu.dao.UserDao;import com.xu.dao.VipDao;public class UserService2 { private UserDao userDao; private VipDao vipDao; public UserService2(UserDao userDao, VipDao vipDao) { this.userDao = userDao; this.vipDao = vipDao; } public void save() { userDao.save(); vipDao.save(); }} 123456@Testpublic void testConstructorDIByName() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); UserService2 userService2 = applicationContext.getBean(\"userService\", UserService2.class); userService2.save();} 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"userDao\" class=\"com.xu.dao.UserDao\"/&gt; &lt;bean id=\"vipDao\" class=\"com.xu.dao.VipDao\"/&gt; &lt;bean id=\"userService\" class=\"com.xu.service.UserService2\"&gt; &lt;constructor-arg name=\"userDao\" ref=\"userDao\"/&gt; &lt;constructor-arg name=\"vipDao\" ref=\"vipDao\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 即不指定下标，也不指定参数名，让Spring自行判断1234&lt;bean id=\"userServiceBean\" class=\"com.xu.service.UserService2\"&gt; &lt;constructor-arg ref=\"userDao\"/&gt; &lt;constructor-arg ref=\"vipDao\"/&gt;&lt;/bean&gt; 123456@Testpublic void testConstructorDIWithNothing() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); UserService2 userService = applicationContext.getBean(\"userServiceBean\", UserService2.class); userService.save();} 3 set注入专题3.1 注入外部Bean123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"userDaoBean\" class=\"com.powernode.spring6.dao.UserDao\"/&gt; &lt;bean id=\"userServiceBean\" class=\"com.powernode.spring6.service.UserService\"&gt; &lt;property name=\"userDao\" ref=\"userDaoBean\"/&gt; &lt;!-- 这个就叫做注入外部bean --&gt; &lt;/bean&gt;&lt;/beans&gt; 外部Bean的特点：bean定义在外面，在property标签中使用ref属性进行注入。这种方式比较常用。 3.2 注入内部Bean内部Bean的方式：在bean标签中嵌套bean标签。 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"userServiceBean\" class=\"com.powernode.spring6.service.UserService\"&gt; &lt;property name=\"userDao\"&gt; &lt;bean class=\"com.powernode.spring6.dao.UserDao\"/&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 3.3 注入简单类型12345678910111213141516171819202122package com.xu.entity;public class User { private String name; private int age; public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"User{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; }} 第二步：编写spring配置文件：spring-simple-di.xml 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"user\" class=\"com.xu.entity.User\"&gt; &lt;property name=\"name\" value=\"xu\"/&gt; &lt;property name=\"age\" value=\"22\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 第三步：编写测试程序 123456@Testpublic void testSimpleValue() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-simple-di.xml\"); User user = applicationContext.getBean(\"user\", User.class); System.out.println(user);} 第四步：运行测试程序 3.4 注入数组当数组中的元素是简单类型： 123456789101112131415161718package com.hilda;import java.util.Arrays;public class Person { private String[] favariteFoods; public void setFavariteFoods(String[] favariteFoods) { this.favariteFoods = favariteFoods; } @Override public String toString() { return \"Person{\" + \"favariteFoods=\" + Arrays.toString(favariteFoods) + '}'; }} 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"person\" class=\"com.hilda.Person\"&gt; &lt;property name=\"favariteFoods\"&gt; &lt;array&gt; &lt;value&gt;酸菜鱼&lt;/value&gt; &lt;value&gt;凉皮&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 123456@Testpublic void testArraySimple() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring.xml\"); Person person = applicationContext.getBean(\"person\", Person.class); System.out.println(person);} 1Person{favariteFoods=[酸菜鱼, 凉皮]} 当数组中的元素是非简单类型：一个订单中包含多个商品。 123456789101112131415161718192021222324252627package com.hilda;public class Goods { private String name; public Goods() { } public Goods(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"Goods{\" + \"name='\" + name + '\\'' + '}'; }} 12345678910111213141516171819202122232425package com.hilda;import java.util.Arrays;public class Order { private Goods[] goods; public Order() { } public Order(Goods[] goods) { this.goods = goods; } public void setGoods(Goods[] goods) { this.goods = goods; } @Override public String toString() { return \"Order{\" + \"goods=\" + Arrays.toString(goods) + '}'; }} 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"goods1\" class=\"com.hilda.Goods\"&gt; &lt;property name=\"name\" value=\"西瓜\"/&gt; &lt;/bean&gt; &lt;bean id=\"goods2\" class=\"com.hilda.Goods\"&gt; &lt;property name=\"name\" value=\"苹果\"/&gt; &lt;/bean&gt; &lt;bean id=\"order\" class=\"com.hilda.Order\"&gt; &lt;property name=\"goods\"&gt; &lt;array&gt; &lt;!--元素是非简单类型，使用ref标签--&gt; &lt;ref bean=\"goods1\"/&gt; &lt;ref bean=\"goods2\"/&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试程序： 123456@Testpublic void testArray(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring2.xml\"); Order order = applicationContext.getBean(\"order\", Order.class); System.out.println(order);} 1Order{goods=[Goods{name='西瓜'}, Goods{name='苹果'}]} 要点： 如果数组中是简单类型，使用value标签。 如果数组中是非简单类型，使用ref标签。 3.5 注入List集合List集合：有序可重复 123456789101112131415161718package com.hilda;import java.util.List;public class People { private List&lt;String&gt; names; public void setNames(List&lt;String&gt; names) { this.names = names; } @Override public String toString() { return \"People{\" + \"names=\" + names + '}'; }} 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"peopleBean\" class=\"com.hilda.People\"&gt; &lt;property name=\"names\"&gt; &lt;list&gt; &lt;value&gt;xu&lt;/value&gt; &lt;value&gt;hilda&lt;/value&gt; &lt;value&gt;halla&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 123456@Testpublic void testCollection(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-list.xml\"); People peopleBean = applicationContext.getBean(\"peopleBean\", People.class); System.out.println(peopleBean);} 1People{names=[xu, hilda, halla]} 注意：注入List集合的时候使用list标签，如果List集合中是简单类型使用value标签，反之使用ref标签。 3.7 注入Set集合Set集合：无序不可重复 1234567891011121314151617181920212223242526package com.hilda;import java.util.List;import java.util.Set;public class People { private List&lt;String&gt; names; private Set&lt;String&gt; phones; public void setPhones(Set&lt;String&gt; phones) { this.phones = phones; } public void setNames(List&lt;String&gt; names) { this.names = names; } @Override public String toString() { return \"People{\" + \"names=\" + names + \", phones=\" + phones + '}'; }} 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"peopleBean\" class=\"com.hilda.People\"&gt; &lt;property name=\"names\"&gt; &lt;list&gt; &lt;value&gt;xu&lt;/value&gt; &lt;value&gt;hilda&lt;/value&gt; &lt;value&gt;halla&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"phones\"&gt; &lt;set&gt; &lt;!--非简单类型可以使用ref，简单类型使用value--&gt; &lt;value&gt;1319336***1&lt;/value&gt; &lt;value&gt;1319336***2&lt;/value&gt; &lt;value&gt;1319336***3&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 123456@Testpublic void testSet(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-set.xml\"); People peopleBean = applicationContext.getBean(\"peopleBean\", People.class); System.out.println(peopleBean);} 执行结果： 1People{names=[xu, hilda, halla], phones=[1319336***1, 1319336***2, 1319336***3]} 要点： 使用标签 set集合中元素是简单类型的使用value标签，反之使用ref标签。 3.8 注入Map集合12345678910111213141516171819202122232425262728293031323334package com.hilda;import java.util.List;import java.util.Map;import java.util.Set;public class People { private List&lt;String&gt; names; private Set&lt;String&gt; phones; private Map&lt;Integer, String&gt; addrs; public void setAddrs(Map&lt;Integer, String&gt; addrs) { this.addrs = addrs; } public void setPhones(Set&lt;String&gt; phones) { this.phones = phones; } public void setNames(List&lt;String&gt; names) { this.names = names; } @Override public String toString() { return \"People{\" + \"names=\" + names + \", phones=\" + phones + \", addrs=\" + addrs + '}'; }} 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"peopleBean\" class=\"com.hilda.People\"&gt; &lt;property name=\"names\"&gt; &lt;list&gt; &lt;value&gt;xu&lt;/value&gt; &lt;value&gt;hilda&lt;/value&gt; &lt;value&gt;halla&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"phones\"&gt; &lt;set&gt; &lt;!--非简单类型可以使用ref，简单类型使用value--&gt; &lt;value&gt;1319336***1&lt;/value&gt; &lt;value&gt;1319336***2&lt;/value&gt; &lt;value&gt;1319336***3&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=\"addrs\"&gt; &lt;map&gt; &lt;!--如果key不是简单类型，使用 key-ref 属性--&gt; &lt;!--如果value不是简单类型，使用 value-ref 属性--&gt; &lt;entry key=\"1\" value=\"北京大兴区\"/&gt; &lt;entry key=\"2\" value=\"上海浦东区\"/&gt; &lt;entry key=\"3\" value=\"深圳宝安区\"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 123456@Testpublic void testMap(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-map.xml\"); People peopleBean = applicationContext.getBean(\"peopleBean\", People.class); System.out.println(peopleBean);} 执行结果： 1People{names=[xu, hilda, halla], phones=[1319336***1, 1319336***2, 1319336***3], addrs={1=北京大兴区, 2=上海浦东区, 3=深圳宝安区}} 要点： 使用标签 如果key是简单类型，使用 key 属性，反之使用 key-ref 属性。 如果value是简单类型，使用 value 属性，反之使用 value-ref 属性。 3.9 注入Propertiesjava.util.Properties继承java.util.Hashtable，所以Properties也是一个Map集合。 123456789101112131415161718192021222324252627282930313233343536373839404142package com.hilda;import java.util.List;import java.util.Map;import java.util.Properties;import java.util.Set;public class People { private List&lt;String&gt; names; private Set&lt;String&gt; phones; private Map&lt;Integer, String&gt; addrs; private Properties properties; public void setProperties(Properties properties) { this.properties = properties; } public void setAddrs(Map&lt;Integer, String&gt; addrs) { this.addrs = addrs; } public void setPhones(Set&lt;String&gt; phones) { this.phones = phones; } public void setNames(List&lt;String&gt; names) { this.names = names; } @Override public String toString() { return \"People{\" + \"names=\" + names + \", phones=\" + phones + \", addrs=\" + addrs + \", properties=\" + properties + '}'; }} 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"peopleBean\" class=\"com.hilda.People\"&gt; &lt;property name=\"names\"&gt; &lt;list&gt; &lt;value&gt;xu&lt;/value&gt; &lt;value&gt;hilda&lt;/value&gt; &lt;value&gt;halla&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"phones\"&gt; &lt;set&gt; &lt;!--非简单类型可以使用ref，简单类型使用value--&gt; &lt;value&gt;1319336***1&lt;/value&gt; &lt;value&gt;1319336***2&lt;/value&gt; &lt;value&gt;1319336***3&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=\"addrs\"&gt; &lt;map&gt; &lt;!--如果key不是简单类型，使用 key-ref 属性--&gt; &lt;!--如果value不是简单类型，使用 value-ref 属性--&gt; &lt;entry key=\"1\" value=\"北京大兴区\"/&gt; &lt;entry key=\"2\" value=\"上海浦东区\"/&gt; &lt;entry key=\"3\" value=\"深圳宝安区\"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=\"properties\"&gt; &lt;props&gt; &lt;prop key=\"driver\"&gt;com.mysql.cj.jdbc.Driver&lt;/prop&gt; &lt;prop key=\"url\"&gt;jdbc:mysql://localhost:3306/spring&lt;/prop&gt; &lt;prop key=\"username\"&gt;root&lt;/prop&gt; &lt;prop key=\"password\"&gt;123456&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 123456@Testpublic void testProperties(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-properties.xml\"); People peopleBean = applicationContext.getBean(\"peopleBean\", People.class); System.out.println(peopleBean);} 执行结果： 1People{names=[xu, hilda, halla], phones=[1319336***1, 1319336***2, 1319336***3], addrs={1=北京大兴区, 2=上海浦东区, 3=深圳宝安区}, properties={password=123456, driver=com.mysql.cj.jdbc.Driver, url=jdbc:mysql://localhost:3306/spring, username=root}} 要点： 使用标签嵌套标签完成。 3.10 注入null和空字符串注入空字符串使用： 或者 value=””注入null使用： 或者 不为该属性赋值 我们先来看一下，怎么注入空字符串。 12345678910111213141516package com.hilda;public class Vip { private String email; public void setEmail(String email) { this.email = email; } @Override public String toString() { return \"Vip{\" + \"email='\" + email + '\\'' + '}'; }} 12345678&lt;bean id=\"vipBean\" class=\"com.hilda.Vip\"&gt; &lt;!--空串的第一种方式--&gt; &lt;!--&lt;property name=\"email\" value=\"\"/&gt;--&gt; &lt;!--空串的第二种方式--&gt; &lt;property name=\"email\"&gt; &lt;value/&gt; &lt;/property&gt;&lt;/bean&gt; 123456@Testpublic void testNull(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring.xml\"); Vip vipBean = applicationContext.getBean(\"vipBean\", Vip.class); System.out.println(vipBean);} 执行结果： 怎么注入null呢？ 第一种方式：不给属性赋值 1&lt;bean id=\"vipBean\" class=\"com.hilda.Vip\"/&gt; 执行结果： 第二种方式：使用 12345&lt;bean id=\"vipBean\" class=\"com.hilda.Vip\"&gt; &lt;property name=\"email\"&gt; &lt;null/&gt; &lt;/property&gt;&lt;/bean&gt; 执行结果： 3.11 注入的值中含有特殊符号XML中有5个特殊字符，分别是：&lt;、&gt;、’、”、&amp;以上5个特殊符号在XML中会被特殊对待，会被当做XML语法的一部分进行解析，如果这些特殊符号直接出现在注入的字符串当中，会报错。 解决方案包括两种： 第一种：特殊符号使用转义字符代替。 第二种：将含有特殊符号的字符串放到： 当中。因为放在CDATA区中的数据不会被XML文件解析器解析。 5个特殊字符对应的转义字符分别是： 特殊字符 转义字符 &gt; &gt; &lt; &lt; ‘ ' “ \" &amp; &amp; 先使用转义字符来代替： 12345678910111213141516package com.hilda;public class Math { private String result; public void setResult(String result) { this.result = result; } @Override public String toString() { return \"Math{\" + \"result='\" + result + '\\'' + '}'; }} 123&lt;bean id=\"mathBean\" class=\"com.hilda.Math\"&gt; &lt;property name=\"result\" value=\"2 &amp;lt; 3\"/&gt;&lt;/bean&gt; 123456@Testpublic void testSpecial(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring.xml\"); com.hilda.Math mathBean = applicationContext.getBean(\"mathBean\", Math.class); System.out.println(mathBean);} 执行结果： 我们再来使用CDATA方式： 1234567&lt;bean id=\"mathBean\" class=\"com.hilda.Math\"&gt; &lt;!--&lt;property name=\"result\" value=\"2 &amp;lt; 3\"/&gt;--&gt; &lt;property name=\"result\"&gt; &lt;!--只能使用value标签--&gt; &lt;value&gt;&lt;![CDATA[3 &lt; 6]]&gt;&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; 注意：使用CDATA时，不能使用value属性，只能使用value标签。执行结果： 4 p命名空间注入目的：简化配置。使用p命名空间注入的前提条件包括两个： 第一：在XML头部信息中添加p命名空间的配置信息： 1xmlns:p=\"http://www.springframework.org/schema/p\" 第二：p命名空间注入是基于setter方法的，所以需要对应的属性提供setter方法。 12345678910111213141516171819202122package com.hilda;public class Customer { private String name; private int age; public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Customer{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; }} 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"customerBean\" class=\"com.hilda.Customer\" p:name=\"zhangsan\" p:age=\"20\"/&gt;&lt;/beans&gt; 123456@Testpublic void testP(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring.xml\"); Customer customerBean = applicationContext.getBean(\"customerBean\", Customer.class); System.out.println(customerBean);} 执行结果：把setter方法去掉：所以p命名空间实际上是对set注入的简化。 如果不引入p命名空间的话，会报错 4.1 c命名空间注入c命名空间是简化构造方法注入的。使用c命名空间的两个前提条件：第一：需要在xml配置文件头部添加信息： 1xmlns:c=\"http://www.springframework.org/schema/c\" 第二：需要提供构造方法。 12345678910111213141516171819202122package com.hilda;public class MyTime { private int year; private int month; private int day; public MyTime(int year, int month, int day) { this.year = year; this.month = month; this.day = day; } @Override public String toString() { return \"MyTime{\" + \"year=\" + year + \", month=\" + month + \", day=\" + day + '}'; }} 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:c=\"http://www.springframework.org/schema/c\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--两种方式都可以--&gt; &lt;!-- &lt;bean id=\"myTimeBean\" class=\"com.hilda.MyTime\" c:year=\"1909\" c:month=\"1\" c:day=\"13\"/&gt;--&gt; &lt;bean id=\"myTimeBean\" class=\"com.hilda.MyTime\" c:_0=\"2008\" c:_1=\"8\" c:_2=\"8\"/&gt;&lt;/beans&gt; 123456@Testpublic void testC(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-c.xml\"); MyTime myTimeBean = applicationContext.getBean(\"myTimeBean\", MyTime.class); System.out.println(myTimeBean);} 执行结果： 把构造方法注释掉： 所以，c命名空间是依靠构造方法的。注意：不管是p命名空间还是c命名空间，注入的时候都可以注入简单类型以及非简单类型。 4.2 util命名空间使用util命名空间可以让配置复用。使用util命名空间的前提是：在spring配置文件头部添加配置信息。如下： 123456789101112131415161718package com.hilda;import java.util.Properties;public class MyDataSource1 { private Properties properties; public void setProperties(Properties properties) { this.properties = properties; } @Override public String toString() { return \"MyDataSource1{\" + \"properties=\" + properties + '}'; }} 123456789101112131415161718package com.hilda;import java.util.Properties;public class MyDataSource2 { private Properties properties; public void setProperties(Properties properties) { this.properties = properties; } @Override public String toString() { return \"MyDataSource2{\" + \"properties=\" + properties + '}'; }} 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:util=\"http://www.springframework.org/schema/util\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\"&gt; &lt;util:properties id=\"prop\"&gt; &lt;prop key=\"driver\"&gt;com.mysql.cj.jdbc.Driver&lt;/prop&gt; &lt;prop key=\"url\"&gt;jdbc:mysql://localhost:3306/spring&lt;/prop&gt; &lt;prop key=\"username\"&gt;root&lt;/prop&gt; &lt;prop key=\"password\"&gt;123456&lt;/prop&gt; &lt;/util:properties&gt; &lt;bean id=\"dataSource1\" class=\"com.hilda.MyDataSource1\"&gt; &lt;property name=\"properties\" ref=\"prop\"/&gt; &lt;/bean&gt; &lt;bean id=\"dataSource2\" class=\"com.hilda.MyDataSource2\"&gt; &lt;property name=\"properties\" ref=\"prop\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 12345678910@Testpublic void testUtil(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-util.xml\"); MyDataSource1 dataSource1 = applicationContext.getBean(\"dataSource1\", MyDataSource1.class); System.out.println(dataSource1); MyDataSource2 dataSource2 = applicationContext.getBean(\"dataSource2\", MyDataSource2.class); System.out.println(dataSource2);} 执行结果： 4.3 基于XML的自动装配Spring还可以完成自动化的注入，自动化注入又被称为自动装配。它可以根据名字进行自动装配，也可以根据类型进行自动装配。 4.3.1 根据名称自动装配123456789101112131415package com.powernode.spring6.dao;/** * @author 动力节点 * @version 1.0 * @className UserDao * @since 1.0 **/public class UserDao { public void insert(){ System.out.println(\"正在保存用户数据。\"); }} 123456789101112131415161718192021222324package com.powernode.spring6.service;import com.powernode.spring6.dao.UserDao;/** * @author 动力节点 * @version 1.0 * @className UserService * @since 1.0 **/public class UserService { private UserDao aaa; // 这个set方法非常关键 public void setAaa(UserDao aaa) { this.aaa = aaa; } public void save(){ aaa.insert(); }} Spring的配置文件这样配置： 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"userService\" class=\"com.powernode.spring6.service.UserService\" autowire=\"byName\"/&gt; &lt;bean id=\"aaa\" class=\"com.powernode.spring6.dao.UserDao\"/&gt;&lt;/beans&gt; 这个配置起到关键作用： UserService Bean中需要添加autowire=”byName”，表示通过名称进行装配。 UserService类中有一个UserDao属性，而UserDao属性的名字是aaa，**对应的set方法是setAaa()**，正好和UserDao Bean的id是一样的。这就是根据名称自动装配。 123456@Testpublic void testAutowireByName(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-autowire.xml\"); UserService userService = applicationContext.getBean(\"userService\", UserService.class); userService.save();} 执行结果：我们来测试一下，byName装配是和属性名有关还是和set方法名有关系： 12345678910111213141516171819202122232425262728package com.powernode.spring6.service;import com.powernode.spring6.dao.UserDao;/** * @author 动力节点 * @version 1.0 * @className UserService * @since 1.0 **/public class UserService { // 这里没修改 private UserDao aaa; /*public void setAaa(UserDao aaa) { this.aaa = aaa; }*/ // set方法名变化了 public void setDao(UserDao aaa){ this.aaa = aaa; } public void save(){ aaa.insert(); }} 在执行测试程序：通过测试得知，aaa属性并没有赋值成功。也就是并没有装配成功。我们将spring配置文件修改以下： 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"userService\" class=\"com.powernode.spring6.service.UserService\" autowire=\"byName\"/&gt; &lt;!--这个id修改了--&gt; &lt;bean id=\"dao\" class=\"com.powernode.spring6.dao.UserDao\"/&gt; &lt;/beans&gt; 执行测试程序：这说明，如果根据名称装配(byName)，底层会调用set方法进行注入。例如：setAge() 对应的名字是age，setPassword()对应的名字是password，setEmail()对应的名字是email。 4.3.2 根据类型自动装配1234567891011121314package com.powernode.spring6.dao;/** * @author 动力节点 * @version 1.0 * @className AccountDao * @since 1.0 **/public class AccountDao { public void insert(){ System.out.println(\"正在保存账户信息\"); }} 12345678910111213141516171819202122package com.powernode.spring6.service;import com.powernode.spring6.dao.AccountDao;/** * @author 动力节点 * @version 1.0 * @className AccountService * @since 1.0 **/public class AccountService { private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) { this.accountDao = accountDao; } public void save(){ accountDao.insert(); }} 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--byType表示根据类型自动装配--&gt; &lt;bean id=\"accountService\" class=\"com.powernode.spring6.service.AccountService\" autowire=\"byType\"/&gt; &lt;bean class=\"com.powernode.spring6.dao.AccountDao\"/&gt;&lt;/beans&gt; 123456@Testpublic void testAutowireByType(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-autowire.xml\"); AccountService accountService = applicationContext.getBean(\"accountService\", AccountService.class); accountService.save();} 执行结果：我们把UserService中的set方法注释掉，再执行： 丹丹 todo： 这里是AccountService，不是UserService 可以看到无论是byName还是byType，在装配的时候都是基于set方法的。所以set方法是必须要提供的。提供构造方法是不行的，大家可以测试一下。这里就不再赘述。如果byType，根据类型装配时，如果配置文件中有两个类型一样的bean会出现什么问题呢？ 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"accountService\" class=\"com.powernode.spring6.service.AccountService\" autowire=\"byType\"/&gt; &lt;bean id=\"x\" class=\"com.powernode.spring6.dao.AccountDao\"/&gt; &lt;bean id=\"y\" class=\"com.powernode.spring6.dao.AccountDao\"/&gt;&lt;/beans&gt; 执行测试程序：测试结果说明了，当byType进行自动装配的时候，配置文件中某种类型的Bean必须是唯一的，不能出现多个。 4.4 Spring引入外部属性配置文件我们都知道编写数据源的时候是需要连接数据库的信息的，例如：driver url username password等信息。这些信息可以单独写到一个属性配置文件中吗，这样用户修改起来会更加的方便。当然可以。第一步：写一个数据源类，提供相关属性。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.powernode.spring6.beans;import javax.sql.DataSource;import java.io.PrintWriter;import java.sql.Connection;import java.sql.SQLException;import java.sql.SQLFeatureNotSupportedException;import java.util.logging.Logger;/** * @author 动力节点 * @version 1.0 * @className MyDataSource * @since 1.0 **/public class MyDataSource implements DataSource { @Override public String toString() { return \"MyDataSource{\" + \"driver='\" + driver + '\\'' + \", url='\" + url + '\\'' + \", username='\" + username + '\\'' + \", password='\" + password + '\\'' + '}'; } private String driver; private String url; private String username; private String password; public void setDriver(String driver) { this.driver = driver; } public void setUrl(String url) { this.url = url; } public void setUsername(String username) { this.username = username; } public void setPassword(String password) { this.password = password; } //......} 第二步：在类路径下新建jdbc.properties文件，并配置信息。 1234driver=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/springusername=rootpassword=root123 第三步：在spring配置文件中引入context命名空间。 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt;&lt;/beans&gt; 第四步：在spring中配置使用jdbc.properties文件。 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:property-placeholder location=\"jdbc.properties\"/&gt; &lt;bean id=\"dataSource\" class=\"com.powernode.spring6.beans.MyDataSource\"&gt; &lt;property name=\"driver\" value=\"${driver}\"/&gt; &lt;property name=\"url\" value=\"${url}\"/&gt; &lt;property name=\"username\" value=\"${username}\"/&gt; &lt;property name=\"password\" value=\"${password}\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试程序： 123456@Testpublic void testProperties(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-properties.xml\"); MyDataSource dataSource = applicationContext.getBean(\"dataSource\", MyDataSource.class); System.out.println(dataSource);} 执行结果： 丹丹 todo： 把properties里面的 参数名统一都改为jdbc.url, jdbc.username, jdbc.password等 上面这个图片usernamme是Administrator，因为 它 是取的windows变量","categories":[{"name":"Spring6","slug":"Spring6","permalink":"https://xiaofanshutu.github.io/categories/Spring6/"}],"tags":[]},{"title":"First Project","slug":"D3-first project","date":"2025-04-09T09:59:01.289Z","updated":"2025-04-09T10:24:39.383Z","comments":true,"path":"posts/358c4d47.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/358c4d47.html","excerpt":"项目结构 创建Empty Project 修改工程JDK创建完spring6的空工程之后，将这里改为JDK17。否则创建的module默认不是JDK17，就会报各种错误。 在空工程里面创建一个Module","text":"项目结构 创建Empty Project 修改工程JDK创建完spring6的空工程之后，将这里改为JDK17。否则创建的module默认不是JDK17，就会报各种错误。 在空工程里面创建一个Module 详细代码User类1234package com.xu.entity;public class User {} beans.xml配置文件注意： bean的id不能重复， 这个id就相当于是bean的身份证号。 123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"user\" class=\"com.xu.entity.User\"/&gt;&lt;/beans&gt; FirstTest测试类123456789101112131415package com.xu.test;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class FirstTest { @Test public void testFirst() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); Object user = applicationContext.getBean(\"user\"); System.out.println(user); //运行结果：com.xu.entity.User@7f0eb4b4 //说明Spring容器帮我们成功创建出来了User对象 }} 代码细节剖析1. 底层是如何创建的User对象?是通过反射机制调用的无参构造函数吗? 答:是 如何通过反射机制获取对象? 1234567package com.xu.entity;public class User { public User() { System.out.println(\"User类的无参构造方法执行了~\"); }} 123456789@Testpublic void testReflect() { try { Class&lt;?&gt; aClass = Class.forName(\"com.xu.entity.User\"); System.out.println(aClass.newInstance()); } catch (Exception e) { throw new RuntimeException(e); }} 运行结果： Spring beans.xml里面的class可以配置抽象类吗? 答:不可以 如何理解下面这句代码中的abstract=”true” 1&lt;bean id=\"abstractClass\" class=\"com.xu.entity.AbstractClass\" abstract=\"true\"/&gt; 在Spring的beans.xml配置文件中，标签的abstract属性用于定义一个抽象的bean。将abstract属性设置为true表示该bean是抽象的，不能直接实例化。具体含义如下:抽象的bean无法被直接实例化，它只作为其他非抽象bean的父类或模板，它可以提供一些通用的配置或方法，供子类或其他具体的bean继承和使用,抽象bean可以包含一些通用的属性或方法，但它们没有具体的实现，需要子类或具体的bean来提供实现。抽象bean可以被其他非抽象的bean继承，继承后的子类bean可以继承父类bean的属性和方法，并可以覆盖或补充父类的实现。通过定义抽象bean，可以实现代码的重用和封转通用逻辑的目的。它提供了一种模板化的方式，允许其他具体的bean来继承和扩展。在配置文件中，抽象bean的定义通常用于作为其他具体bean的基类或模板，而不能直接实例化为一个独立的bean。因此，抽象bean的abstract属性被设置为true，以标识它是一个抽象的概念, 而不是一个具体的可实例化的bean。 代码3.1中，getBean()方法返同的类型是Object。这个时候，如果我想要访问子类的特有属性和方法时，还需要向下转型，有其它办法可以优化这个问题吗? 代码3.1： 123456@Testpublic void testFirst() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); Object user = applicationContext.getBean(\"user\"); System.out.println(user);} 答：有，可以调用getBean的另外一种实现方式。请看代码3.2 代码3.2： UserDaoImplForMySQL类中有一个特有的方法getUserList 12345public class UserDaoImplForMySQL { public void getUserList(){ System.out.println(\"获取用户列表方法执行了~\"); }} 通过下面这种方式可以直接获取到UserDaoImplForMySQL类型的对象userDao 通过userDao可以直接访问UserDaoImplForMySQL类的特有方法getUserList 123456@Testpublic void test2() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); UserDaoImplForMySQL userDao = applicationContext.getBean(\"userDaoBean\", UserDaoImplForMySQL.class); userDao.getUserList();} 可以一次性读取多个bean的xml文件吗？ 答：可以 在beans.xml中声明一个id为user的bean，在spring.xml中声明一个id为vip的bean。通过如下代码同时读取两个配置文件。 1234567@Testpublic void test3(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\", \"spring.xml\"); User user = applicationContext.getBean(\"user\", User.class); Vip vip = applicationContext.getBean(\"vip\", Vip.class);} ClassPathXmlApplicationContext是从类路径中加载配置文件，如果配置文件不在类路径当中，又应该如何加载配置文件呢？ 12345@Testpublic void test4(){ ApplicationContext applicationContext = new FileSystemXmlApplicationContext(\"D:\\\\3_study\\\\1.coding\\\\external.xml\"); Object userDaoBean = applicationContext.getBean(\"userDaoBean\", UserDaoImplForMySQL.class);} ApplicationContext的超级父接口BeanFactory。 可以直接用BeanFactory来定义对象 123456@Testpublic void test5() { BeanFactory beanFactory = new ClassPathXmlApplicationContext(\"beans.xml\"); Object user = beanFactory.getBean(\"user\"); System.out.println(user); //com.xu.entity.User@5c33f1a9} 启用Log4j2日志框架引入Log4j2依赖1234567891011&lt;!--log4j2的依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt;&lt;/dependency&gt; 新建log4j2.xml文件（文件必须放到根路径下，名字固定为log4j2.xml）123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;loggers&gt; &lt;!-- level指定日志级别，从低到高的优先级： ALL &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF --&gt; &lt;root level=\"DEBUG\"&gt; &lt;appender-ref ref=\"spring6log\"/&gt; &lt;/root&gt; &lt;/loggers&gt; &lt;appenders&gt; &lt;!--输出日志信息到控制台--&gt; &lt;console name=\"spring6log\" target=\"SYSTEM_OUT\"&gt; &lt;!--控制日志输出的格式--&gt; &lt;PatternLayout pattern=\"%d{yyyy-MM-dd HH:mm:ss SSS} [%t] %-3level %logger{1024} - %msg%n\"/&gt; &lt;/console&gt; &lt;/appenders&gt;&lt;/configuration&gt; 使用日志框架1234567public class UserDaoImplForMySQL { Logger logger = LoggerFactory.getLogger(UserDaoImplForMySQL.class); public UserDaoImplForMySQL() { logger.info(\"UserDaoImplForMySQL类的无参构造方法执行了~~~\"); }}","categories":[{"name":"Spring6","slug":"Spring6","permalink":"https://xiaofanshutu.github.io/categories/Spring6/"}],"tags":[]},{"title":"控制反转","slug":"D2-引入控制反转思想","date":"2025-04-09T09:59:01.288Z","updated":"2025-04-09T10:24:39.383Z","comments":true,"path":"posts/424232bd.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/424232bd.html","excerpt":"引入控制反转概念将对象的创建权/管理权交出去了，不再使用硬编码的方式了。同时也把对象关系的管理权交出去了，也不再使用硬编码的方式了。像这种把对象的创建权交出去，把对象关系的管理权交出去，被称为控制反转。 控制反转IoC控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计思想，可以用来降低代码之间的耦合度，符合依赖倒置原则。IoC可以认为是一种全新的设计模式，但是理论和时间成熟相对较晚，并没有包含在GoF中。（GoF指的是23种设计模式）。Spring框架就是一个实现了IoC思想的框架。 控制反转思想的核心是：将对象的创建权交出去，将对象和对象之间关系的管理权交出去，由第三方容器来负责创建与维护。 控制反转常见的实现方式：依赖注入（Dependency Injection，简称DI）。通常，依赖注入的实现又包括两种方式： set方法注入 构造方法注入 Spring概述","text":"引入控制反转概念将对象的创建权/管理权交出去了，不再使用硬编码的方式了。同时也把对象关系的管理权交出去了，也不再使用硬编码的方式了。像这种把对象的创建权交出去，把对象关系的管理权交出去，被称为控制反转。 控制反转IoC控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计思想，可以用来降低代码之间的耦合度，符合依赖倒置原则。IoC可以认为是一种全新的设计模式，但是理论和时间成熟相对较晚，并没有包含在GoF中。（GoF指的是23种设计模式）。Spring框架就是一个实现了IoC思想的框架。 控制反转思想的核心是：将对象的创建权交出去，将对象和对象之间关系的管理权交出去，由第三方容器来负责创建与维护。 控制反转常见的实现方式：依赖注入（Dependency Injection，简称DI）。通常，依赖注入的实现又包括两种方式： set方法注入 构造方法注入 Spring概述Spring简介 Spring框架是一个开源的Java应用程序框架，它由Rod Johnson创建。它提供了一系列的模块来简化Java应用程序的开发。Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。Spring最初的出现是为了解决EJB臃肿的设计，以及难以测试等问题。Spring为简化开发而生，让程序员只需关注核心业务的实现，尽可能的不再关注非业务逻辑代码（事务控制，安全日志等）。 Spring常用模块注：在Spring5中新增了Webflux模块。 Spring Core: 这是Spring框架的核心模块，提供了IoC(Inversion of Control)容器的实现。loC容器负责管理和组织应用程序中的对象，通过依赖注入来管理对象之间的依赖关系。 Spring MVC 这是Spring框架的Web开发模块，提供了一个基于MVC(Model-View-Controller)架构的Web应用程序开发框架。它通过DispatcherServlet将请求分发给合适的处理器，并将处理结果返回给客户端。 Spring AOP 这是Spring框架的面向切面编程模块，提供了一种在应用程序中实现模切关注点的方式。通过AOP，可以将与业务逻辑无关的功能(如日志记录、性能监测、事务管理等)模块化并集中管理。（扩展1： Spring AOP通俗解释） Spring Web Spring Web模块提供了基于Servlet技术的Web应用程序开发支持。它包含了Spring MVC框架，用于构建基于MVC架构的Web应用程序。SpringMVC通过DispatcherServlet将请求分发给合适的处理器，并将处理结果返回给客户端。它还提供了一些注解和工具，用于处理URL映射、请求参数绑定、视图解析等。 Spring ORM 它可以与Hiberate、MyBatis等ORM框架集成，简化了数据访问层的开发。Spring ORM提供了一些模板类和注解，用于简化数据库操作、事务管理等操作。 Spring Context Spring Context模块是Spring框架的核心模块之一，提供了1oC容器的实现。loC容器负责管理和组织应用程序中的对象，通过依赖注入来管理对象之间的依赖关系。Spring Context模块还提供了一些高级特性，如面向切面编程(AOP)、事件传播、国际化支持等。 Spring DAO Spring DAO模块是Spring框架中的数据访问对象(DAO)支持模块。它提供了一种简化和统一的方式来访问和操作各种数据存储，如关系型数据库、NoSQL数据库、缓存等。Spring DAO模块可以与 ORM框架(如Hibernate.MyBatis)集成，也可以直接使用JDBC进行数据库操作。它提供了一些模板类和注解，用于简化数据库操作、事务管理等。 Spring Webflux Spring Webflux是Spring框架的响应式编程支持模块。它基于Reactive Streams规范，提供了一种非阻塞的、异步的编程模型，SpringWebflux可以用于构建响应式的Web应用程序和服务。它提供了一些注解和函数式编程的API，用于处理HTTP请求，处理数据流、处理异步操作等。与传统的Servlet容器相比，Spring Webflux可以处理更高的并发请求和更高的吞吐量。 还有其他几个常用模块，未在上图列出： Spring Data 这是Spring框架的数据访问模块，提供了对各种数据访问技术的集成支持。它简化了数据访问层的开发，提供了一种统一的API来访问和操作各种数据存储(如关系型数据库、NoSQL数据库、缓存等)。 Spring Security 这是Spring框架的安全模块，提供了身份验证和授权的支持。它可以集成到Spring应用程序中，为应用程序提供安全性保护，如用户认证、授权、密码加密等。 Spring特点 轻量 从大小与开销两方面而言Spring都是轻量的。完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布。并且Spring所需的处理开销也是微不足道的。 Spring是非侵入式的：Spring应用中的对象不依赖于Spring的特定类。（扩展2：非侵入式编程） 控制反转 Spring通过一种称作控制反转（IoC）的技术促进了松耦合。当应用了IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。你可以认为IoC与JNDI相反—不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。（扩展3：loC和JNDI的区别） 面向切面 Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。 容器 Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。然而，Spring不应该被混同于传统的重量级的EJB容器，它们经常是庞大与笨重的，难以使用。 框架 Spring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。Spring也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。 所有Spring的这些特征使你能够编写更干净、更可管理、并且更易于测试的代码。它们也为Spring中的各种模块提供了基础支持。 扩展1： Spring AOP通俗解释想象一下你正在画一幅画，画中有很多不同的元素，如人物、树、花等。画画时，你可能会有一些特别的需求，比如想要给画中的每个元素都添加一些相同的颜色或纹理。但是，你不想挨个给每个添加，因为那样会很麻烦。 这时，Spring AOP就像一个魔法笔，它可以帮助你在画画的过程中自动添加你想要的颜色或纹理，而无需手动去做。你只需要告诉魔法笔你想要添加的颜色或纹理，然后它会自动帮你完成。在编程中，我们经常需要在一些特定的地方(例如方法调用或特定的代码段)执行一些相同的操作，比如日志记录、性能监测或事务管理。Spring AOP就像这个魔法笔，它可以自动帮助我们在这些特定的地方添加这些通用操作，而无需手动去每个地方都编写相同的代码。所以，Spring AOP可以让我们更方便地在代码中添加一些通用的功能，而无需重复编写相同的代码。它是一种在编程中帮助我们实现代码重用和维护的魔法笔。 扩展2：非侵入式编程非侵入式编程是一种编程范式，它强调在开发应用程序时，不需要对现有代码进行修改或依赖于特定的框架或库。具体来说，非侵入式编程具有以下几个特点: 低依赖性:Spring框架的核心容器是一个轻量级的loC容器，它本身的依赖性非常低。这意味着您可以选择性地使用 Spring框架的各个模块，而不需要将整个应用程序都依赖于Spring。您可以根据需要选择性地引入Spring的功能，而不会对应用程序的其他部分产生强耦合。 面向接口编程:Spring框架鼓励使用接口进行编程，通过依赖注入将具体实现类与接口解耦。这种面向接口的编程方式使得应用程序的各个组件之间的耦合度降低，增加了代码的可维护性和可扩展性。 配置灵活性:Spring框架使用XML、注解和Java配置等方式来进行配置。这种灵活的配置方式使得您可以根据需要对应用程序进行灵活的配置和调整，而不需要修改应用程序的源代码。这种配置的灵活性使得您可以将Spring框架集成到现有的应用程序中，而不需要对原有代码进行大量的修改。 面向切面编程:Spring框架提供了面向切面编程(AOP)的支持，可以将与核心业务逻辑无关的横切关注点(如日志、事务管理)模块化并集中管理。这样可以将这些横切关注点与业务逻辑进行解耦，使得应用程序的代码更加清晰和可维护。 综上所述，Spring框架是非侵入式的，因为它可以与现有的应用程序进行集成，而不需要对应用程序进行大量的修改。它通过依赖注入、面向接口编程和配置的灵活性，使得应用程序的各个组件之间的耦合度降低，增加了代码的可维护性和可扩展性。 扩展3：loC和JNDI的区别loC(Inversion of Control)和JNDI(Java Naming and Directory Interface)是两个不同的概念，它们在思想上有以下区别: 控制反转(loC): loC是一种设计模式，也称为依赖注入(Dependency Injection)，它是一种通过外部容器来管理对象的创建和组装的方式。在loC中，应用程序不再负责创建和管理对象的依赖关系，而是将这些责任交给了一个外部的容器。容器根据配置文件或注解的定义，将对象之间的依赖关系注入到相应的对象中。这种方式将控制权反转给了容器，使得应用程序更加灵活、可扩展和易于维护。 loC是将对象的控制权交给框架，框架主动为用户提供对象，而不需要用户主动去申请。通过配置文件或注解，用户可以告诉框架需要哪些对象以及它们的依赖关系，然后框架负责创建和管理这些对象，并在需要的时候将它们注入到用户代码中。 JNDI 是Java平台提供的一种用于访问命名和目录服务的API。它提供了一种统一的方式来访问各种命名和目录服务，如LDAP(Lightweight DirectoryAccess Protocol)、DNS(Domain Name System)等。通过JNDI,应用程序可以在运行时动态地查找和获取命名和目录服务中的对象。JNDI的主要目的是为了实现应用程序与命名和目录服务的解耦，提供一种统一的访问方式。 JNDI是用户主动去获取对象的一种方式。用户通过JNDI API来访问命名和目录服务，根据对象的名称或其他标识符来查找和获取相应的对象。这种方式需要用户自己编写代码来处理对象的获取和使用。 综上所述，loC和JNDI在对象获取的方式上存在明显的差异。loC框架通过自动创建和管理对象来实现控制反转，而JNDI则需要用户自己编写代码来主动获取对象。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://xiaofanshutu.github.io/categories/Spring/"}],"tags":[]},{"title":"HTML5","slug":"HTML - 副本","date":"2024-01-17T22:55:32.103Z","updated":"2024-01-17T23:39:08.350Z","comments":true,"path":"posts/98f3a6d9.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/98f3a6d9.html","excerpt":"","text":"什么是HTMLHTML Hyper Text Markup Language(超文本标记语言) HTML的全称为超文本标记语言，是一种标记语言。它包括一系列标签．通过这些标签可以将网络上的文档格式统一，使分散的Internet资源连接为一个逻辑整体。HTML文本是由HTML命令组成的描述性文本，HTML命令可以说明文字，图形、动画、声音、表格、链接等。 W3C World Wide Web Consortium(万维网联盟) 万维网联盟创建于1994年，是Web技术领域最具权威和影响力的国际中立性技术标准机构。W3C已发布了200多项影响深远的Web技术标准及实施指南，如广为业界采用的超文本标记语言HTML（标准通用标记语言下的一个应用）、可扩展标记语言XML（标准通用标记语言下的一个子集）以及帮助残障人士有效获得Web信息的无障碍指南（WCAG）等，有效促进了Web技术的互相兼容，对互联网技术的发展和应用起到了基础性和根本性的支撑作用。 网页基本信息1234567891011121314151617&lt;!-- DOCTYPE: 告诉浏览器，我们要使用什么规范 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;!-- head: 代表网页头部 --&gt;&lt;head&gt; &lt;!-- meta: 描述性标签，用来描述我们网站的一些信息 --&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;!-- title: 网页标题 --&gt; &lt;title&gt;我的第一个HTML网页&lt;/title&gt;&lt;/head&gt;&lt;!-- body: 代表网页主体 --&gt;&lt;body&gt;你好，bambi&lt;/body&gt;&lt;/html&gt; 网页基本标签12345678910111213141516171819202122232425262728293031&lt;body&gt;&lt;!--标题标签--&gt;&lt;h1&gt;h1标题&lt;/h1&gt;&lt;h2&gt;h2标题&lt;/h2&gt;&lt;h3&gt;h2标题&lt;/h3&gt;&lt;h4&gt;h2标题&lt;/h4&gt;&lt;h5&gt;h2标题&lt;/h5&gt;&lt;h6&gt;h2标题&lt;/h6&gt;&lt;!--段落标签--&gt;&lt;p&gt; 这是一个段落标签&lt;/p&gt;&lt;!--换行标签--&gt;这是一个换行&lt;br&gt;标签&lt;!--水平线标签--&gt;&lt;hr&gt;&lt;!--字体样式标签-粗体--&gt;&lt;strong&gt;hope to see you on the top&lt;/strong&gt;&lt;!--字体样式标签-斜体--&gt;&lt;em&gt;boun prem&lt;/em&gt;&lt;!--特殊符号-空格--&gt;你&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;好&lt;!--特殊符号-大于--&gt;&amp;gt;&lt;!--特殊符号-小于--&gt;&amp;lt;&lt;!--特殊符号-版权所有--&gt;&amp;copy;&lt;/body&gt; 图像标签 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;HTML学习&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=\"resources/image/5.png\" title=\"海绵宝宝\" width=\"300\" height=\"300\" /&gt;&lt;/body&gt;&lt;/html&gt; 超链接标签及其应用文本超链接123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;HTML学习&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--href: 必填，表示要跳转到哪一个页面--&gt;&lt;!--target: 表示窗口在哪里打开--&gt;&lt;a href=\"test01.html\" target=\"_blank\"&gt;文本超链接&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 图像超链接12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;HTML学习&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"test01.html\" target=\"_blank\"&gt;&lt;img src=\"resources/image/5.png\" title=\"图片超链接\" width=\"300\" height=\"300\" /&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 锚链接123&lt;a id=\"bottom\"&gt;&lt;/a&gt;&lt;!--锚链接--&gt;&lt;a href=\"test01.html#bottom\"&gt;跳转到底部&lt;/a&gt; 功能性链接邮件链接12&lt;!--邮件链接--&gt;&lt;a href=\"mailto:15191434031@163.com\"&gt;邮件链接&lt;/a&gt; 块元素和行内元素 块元素 无论内容多少，该元素独占一行 (p, h1-h6) 行内元素 内容撑开宽度，左右都是行内元素的可以排在一行 (a, strong, em) 列表标签无序列表1234&lt;!--无序列表--&gt;&lt;ul&gt;a&lt;/ul&gt;&lt;ul&gt;b&lt;/ul&gt;&lt;ul&gt;c&lt;/ul&gt; 有序列表123456&lt;!--有序列表--&gt;&lt;ol&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;草莓&lt;/li&gt;&lt;/ol&gt; 自定义列表123456789&lt;!--自定义列表: 自定义列表一般用在网站底部--&gt;&lt;dl&gt; &lt;dt&gt;我的爱好 &lt;dd&gt;游泳&lt;/dd&gt; &lt;dd&gt;看书&lt;/dd&gt; &lt;dd&gt;听音乐&lt;/dd&gt; &lt;dd&gt;跑步&lt;/dd&gt; &lt;/dt&gt;&lt;/dl&gt; 表格标签1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;表格标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- tr:行 td:列 跨行:rowspan 跨列:colspan--&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td rowspan=\"3\"&gt;11&lt;/td&gt; &lt;td&gt;12&lt;/td&gt; &lt;td&gt;13&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;22&lt;/td&gt; &lt;td&gt;23&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt;33&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 媒体元素视频文件1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;媒体元素&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--controls:控制条autoplay:自动播放--&gt;&lt;video src=\"resources/video/02.mp4\" controls autoplay&gt;测试视频&lt;/video&gt;&lt;/body&gt;&lt;/html&gt; 视频能成功加载并且会自动播放 音频文件1&lt;audio src=\"resources/video/02.mp4\" controls autoplay&gt;&lt;/audio&gt; 页面结构分析 元素名 描述 header 标记头部区域的内容（用于页面或页面中的一块区域） footer 标记脚部区域的内容（用于整个页面或者页面的一块区域） section Web页面中的一块独立区域 article 独立的文章内容 aside 相关内容或应用（常用于侧边栏） nav 导航类辅助内容 iframe内联框架12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;内联框架&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;iframe src=\"test03.html\" name=\"mainFrame\"&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt; 初识表单post和get提交123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;提交表单&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"test01.html\" method=\"get\"&gt; &lt;p&gt;用户名：&lt;input type=\"text\"/&gt;&lt;/p&gt; &lt;p&gt;密 码：&lt;input type=\"password\"/&gt;&lt;/p&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;input type=\"reset\" value=\"重置\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 文本框和单选框 123456789101112131415161718&lt;!--文本输入框--&gt;文本输入框&lt;p&gt; &lt;input type=\"text\" name=\"name\"&gt;&lt;/p&gt;&lt;!--密码框--&gt;密码框&lt;p&gt; &lt;input type=\"password\"&gt;&lt;/p&gt;&lt;!--单选框，默认选中男checked--&gt;性别&lt;p&gt; &lt;input type=\"radio\" name=\"sex\" value=\"男\" checked&gt;男 &lt;input type=\"radio\" name=\"sex\" value=\"女\"&gt;女&lt;/p&gt; 按钮和多选框12345678910&lt;p&gt; &lt;input type=\"checkbox\" value=\"reading\" name=\"hobby\"&gt;阅读 &lt;input type=\"checkbox\" value=\"running\" name=\"hobby\" checked&gt;跑步 &lt;input type=\"checkbox\" value=\"yoga\" name=\"hobby\"&gt;瑜伽&lt;/p&gt;&lt;p&gt; &lt;input type=\"button\" value=\"按钮显示的文字\" name=\"btn1\"&gt; &lt;input type=\"image\" src=\"resources/image/5.png\" width=\"200\"&gt;&lt;/p&gt; 列表框文本域和文件域12345678910111213141516171819202122&lt;p&gt;下拉框 &lt;select name=\"水果天堂\"&gt; &lt;option value=\"banana\"&gt;香蕉&lt;/option&gt; &lt;option value=\"apple\" selected&gt;苹果&lt;/option&gt;&lt;!-- 苹果默认会是选中的 --&gt; &lt;option value=\"strawberry\"&gt;草莓&lt;/option&gt; &lt;/select&gt;&lt;/p&gt;&lt;p&gt;文本域 &lt;textarea name=\"remark\" cols=\"60\" rows=\"10\"&gt; 在这里写入备注内容 &lt;/textarea&gt;&lt;/p&gt;&lt;p&gt;文件域 &lt;input type=\"file\" name=\"file\"&gt; &lt;input type=\"button\" value=\"上传文件\" name=\"upload\"&gt;&lt;/p&gt; 搜索框滑块和简单验证123456789101112131415161718&lt;form&gt;&lt;p&gt;邮箱： &lt;input type=\"email\" name=\"email\"&gt;&lt;/p&gt;&lt;p&gt;URL： &lt;input type=\"url\" name=\"url\"&gt;&lt;/p&gt;&lt;p&gt;滑块： &lt;input type=\"range\" min=\"0\" max=\"100\" name=\"voice\" step=\"2\"&gt;&lt;/p&gt;&lt;p&gt;搜索： &lt;input type=\"search\" name=\"search\"&gt;&lt;/p&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 表单的应用 隐藏域hidden 只读readonly 禁用disable 表单初级验证 placeholder：提示信息 required：非空判断 pattern：正则表达式 123&lt;p&gt; 用户名：&lt;input type=\"text\" name=\"name\" required placeholder=\"请输入用户名\"&gt;&lt;/p&gt;","categories":[{"name":"HTML5","slug":"HTML5","permalink":"https://xiaofanshutu.github.io/categories/HTML5/"}],"tags":[],"author":"cutiebambi"},{"title":"Java","slug":"老韩Java","date":"2023-10-07T12:03:24.722Z","updated":"2024-01-17T23:38:15.521Z","comments":true,"path":"posts/df2849ec.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/df2849ec.html","excerpt":"","text":"Java概述如何快速学习一个知识点 转义字符1234567// 在控制台，输入 tab 键，可以实现命令补全 \\t ：一个制表位，实现对齐的功能\\n ：换行符\\\\ ：一个\\\\\" :一个\"\\' ：一个' \\r :一个回车 12345678910111213141516171819202122232425262728//转义字符练习public class App { //编写一个 main 方法 public static void main(String[] args) { //\\t ：一个制表位，实现对齐的功能 System.out.println(\"北京\\t天津\\t上海\"); // \\n ：换行符 System.out.println(\"jack\\nsmith\\nmary\"); // \\\\ ：一个\\ System.out.println(\"C:\\\\Windows\\\\System32\\\\cmd.exe\"); // \\\" :一个\" System.out.println(\"你好呀，\\\"bambi\\\"\"); // \\' ：一个' System.out.println(\"你好呀，\\'bambi\\'\"); // \\r :一个回车 System.out.println(\"你好呀\\r明天\"); // 解读 // 1. 输出 你好呀 // 2. \\r 表示回车 System.out.println(\"你好呀\\r明天\"); }} 12345678910d:\\desktop&gt;java App北京 天津 上海jacksmithmaryC:\\Windows\\System32\\cmd.exe你好呀，\"bambi\"你好呀，'bambi'明天呀明天呀 Java代码规范_行尾风格 DOS（Disk Operating System 磁盘操作系统）命令DOS介绍 相对路径 &amp; 绝对路径 常用DOC命令1234567891011121314151.查看当前目录是有什么内容 dir dir dir d:\\abc2\\test2002.切换到其他盘下：盘符号 cd : change directory 案例演示： 切换到 c 盘 cd /D c: 3.切换到当前盘的其他目录下 (使用相对路径和绝对路径演示), ..\\表示上一级目录 案例演示： cd d:\\abc2\\test200 cd ..\\..\\abc2\\test200 4.切换到上一级： 案例演示： cd .. 5.切换到根目录：cd \\ 案例演示：cd \\6.查看指定的目录下所有的子级目录 tree7.清屏 cls8.退出 DOS exit 变量变量使用注意事项1.变量表示内存中一块存储区域，不同类型占用的空间不同。 2.该区域有自己的名称 [变量名] 和类型 [数据类型] 3.变量三要素，变量=变量名 + 变量值 + 数据类型 程序中+号的使用1.加号左右两边如果都是数字，做加法运算。 2.加号左右两边有一方为字符串，做拼接运算。 3.运算顺序，从左到右。 1System.out.println(\"hello\" + 100 + 3);//hello1003 数据类型 整数类型整数类型的分类 整数类型使用注意细节1.Java的整型默认为int类型，可以加小写l或者大写L将数字变为long类型。 2.bit，计算机中的最小存储单位。 ​ byte，计算机中的基本存储单元。 ​ 1byte = 8bit 浮点类型浮点型的分类 说明： 1.浮点数都是近似值，尾数可能丢失，造成精度损失。 2.浮点数 = 符号位 + 指数位 + 尾数位 浮点数类型使用注意细节 浮点数常量默认类型为double类型，尾部加f或者F可以变为float。 浮点型常量有两种表现形式： 十进制形式：1.23, 521.0f, .369 科学计数法形式：5.21e2$$5.21 * 10^2$$1.23e-2$$1.23/10^2$$ 通常情况下，应该使用double类型，因为double更精确。 12345678public class App { public static void main(String[] args) { double n1 = 3.123456789; float n2 = 3.123456789F; System.out.println(n1); System.out.println(n2); }} 123.1234567893.1234567 浮点数使用陷阱 2.7 和 8.1 / 3 的比较 1234567891011121314public class App { public static void main(String[] args) { double n1 = 2.7; double n2 = 8.1 / 3; System.out.println(n1 == n2);// false System.out.println(n1); System.out.println(n2); //通过Math.abs判断浮点数类型是否相等 if(Math.abs(n1 - n2) &lt; 0.00001){ System.out.println(\"这两个double类型的数据相等~\"); } }} 1234false2.72.6999999999999997这两个double类型的数据相等~ Java API文档API: Application Programming Interface应用程序编程接口 字符类型（char）案例演示123456789101112public class App { public static void main(String[] args) { char c1 = 'a'; char c2 = '\\t'; char c3 = '许'; char c4 = 97; System.out.println(c1); System.out.println(c2); System.out.println(c3); System.out.println(c4); }} 字符型使用细节 在Java中，char的本质是一个整数，默认输出Unicode码对应的字符。https://tool.chinaz.com/tools/unicode.aspx 可以直接给char赋一个整数，输出的时候，会按照对应的Unicode字符输出。（97 ==》 a） char支持运算，它相当于一个整数，因为它都有对应的Unicode码。思考：System.out.println(‘a’ + “a”); 程序运行后，会输出什么？ 123456789101112131415161718192021222324252627public class App { public static void main(String[] args) { // 在 java中，char的本质是一个整数，在默认输出时，是 unicode 码对应的字符 // 要输出对应的数字，可以(int)字符 char c1 = 97; System.out.println(c1); // a char c2 = 'a'; //输出'a' 对应的数字 System.out.println((int)c2);//97 char c3 = '许'; System.out.println((int)c3);//35768 char c4 = 35768; System.out.println(c4);//许 // char类型是可以进行运算的，相当于一个整数，因为它都对应有 Unicode 码. System.out.println('a' + 10);//107 // 课堂小测试 char c5 = 'b' + 1; System.out.println((int)c5);//99 System.out.println(c5);//c System.out.println('a' + \"a\");//aa System.out.println('a' + 1);//98 }} 字符存储细节字符型存储到计算机里面，会将字符对应的码值（整数）找出来。比如： 存储’a’ =&gt; 码值97 =&gt; 二进制（0110 0001） =&gt;存储 字符编码表 ASCII编码，一个字节表示，一共128个字符。实际上一个字节可以表示256个字符，它没有用完，只用了128个。 Unicode编码，固定大小的编码，字母和汉字统一都是占用2个字节，浪费空间。 UTF-8编码，大小可变的编码表，字母占1个字节，汉字占用3个字节。 GBK编码，可以表示汉字，而且范围比较广，字母1个字节，汉字2个字节。 GB2312编码，可以表示汉字。（GB2312 &lt; GBK） BIG5码，繁体中文，台湾，香港。 布尔类型（boolean）布尔类型也叫boolean类型，只允许取值true或者false，没有null。 在Java中，不可以使用非0或者0代替true或false。 基本数据类型转换自动类型转换 自动类型转换细节 多种类型的数据混合运算时，系统会首先自动将所有的数据转换为容量最大的那种数据类型，然后再进行计算。int + double ==&gt; 会转成double （byte，short）和char之间没有类型转换 123//当把一个具体的值赋给byte时，会先判断该值是否在byte范围内，如果在，就okbyte b1 = 10; //不报错char c1 = b1; //报错，因为byte不能转换为char byte，short，char三者运算时，会在计算时转换为int类型 自动提升原则：表达式结果的类型自动提升为操作数中最大的类型。 强制类型转换自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。有可能会造成精度损失或数据溢出。 强制类型转换细节 强制符号只针对最近的操作数，可以使用小括号来提升优先级。 12int x = (int)(3 * 3.5 + 6 * 1.5);System.out.println(x); char类型可以保存int的常量值，但是不能保存int的变量值，需要强转。 12345char c1 = 100;int i1 = 100;//char c2 = i1;//错误char c2 = (char)i1;System.out.println(c2);//100对应的字符d byte和short，char类型在进行运算时，会被当做int类型处理。 基本数据类型和String类型的转换1、基本数据类型转String类型 基本数据类型的值 + “ “ 2、String类型转基本数据类型 基本类型包装类.parse**() 3、字符串转为字符。str.charAt(0); 12345678910111213public class App { public static void main(String[] args) { String s = \"123\"; int i = Integer.parseInt(s); System.out.println(i);//123 double v = Double.parseDouble(s); System.out.println(v); byte b = Byte.parseByte(s); System.out.println(b); }} 123123123.0123 本章作业 程序阅读题，看看输出什么？ 12308 使用char类型，分别保存\\n \\t \\r \\ 1等字符，并且打印输出 123456789101112131415public class App { public static void main(String[] args) { //分别保存\\n \\t \\r \\\\ 1 等字符 char c1 = '\\n'; char c2 = '\\t'; char c3 = '\\r'; char c4 = '\\\\'; char c5 = '1'; System.out.println(c1); System.out.println(c2); System.out.println(c3); System.out.println(c4); System.out.println(c5); }} 保存两本书名，用+拼接，看效果。 保存两个性别，用+拼接，看效果。 保存两本书价格，用+拼接，看效果。 123456789101112131415public class App { public static void main(String[] args) { String s1 = \"向前一步\"; String s2 = \"你当像鸟飞往你的山\"; System.out.println(s1 + s2); char c1 = '男'; char c2 = '女'; System.out.println(c1 + c2); double d1 = 32.2; double d2 = 31.1; System.out.println(d1 + d2); }} 123向前一步你当像鸟飞往你的山5290663.300000000000004 编程实现如下效果 123456789101112public class App { public static void main(String[] args) { String name = \"bambi\"; int age = 13; char gender = '女'; int score = 99; String hobby = \"climbing\"; System.out.println(\"姓名\" + \"\\t\" + \"年龄\" + \"\\t\" + \"性别\" + \"\\t\" + \"成绩\" + \"\\t\" + \"爱好\" + \"\\n\" + name + \"\\t\" + age + \"\\t\" + gender + \"\\t\" + score + \"\\t\" + hobby); }} 用IDEA执行代码输出结果为： 用CMD执行代码输出结果为： 运算符运算符介绍 算术运算符算术运算符一览 细节说明*对一个数取模，等价于a%b = a-a/bb。** 练习题假如还有 59 天放假，问：合 xx 个星期零 xx 天12345678public class App { public static void main(String[] args) { int days = 258; int weeks = days/7; int leftDays = days%7; System.out.println(days + \"天,\" + \"合\" + weeks + \"星期零\" + leftDays + \"天\"); }} 1258天,合36星期零6天 定义一个变量保存华氏温度，华氏温度转换摄氏温度的公式为：5/9*(华氏温度-100),请求出华氏温度对应的摄氏温度。[234.5]12345678public class App { public static void main(String[] args) {// 定义一个变量保存华氏温度，华氏温度转换摄氏温度的公式为：5/9*(华氏温度-100),请求出华氏温度对应的摄氏温度。[234.5] double fahrenheit = 60.8; double centigrade = 5.0 / 9 * (fahrenheit - 100); System.out.println(centigrade); }} 1-21.77777777777778 关系运算符介绍 关系运算符的结果都是布尔（boolean）类型，要么是true，要么是false。 关系运算符组成的表达式称为关系表达式。 关系运算符一览 程序控制结构程序流程控制介绍顺序控制分支控制 if-else双分支嵌套分支switch 分支结构for 循环控制(!!!)while 循环控制do..while 循环控制多重循环控制(难点! 重点!)跳转控制语句-break跳转控制语句-continue跳转控制语句-return本章作业 12345678910111213141516package chapter5.homework;public class Homework03 { public void test(int year) { if ((year % 4 == 0) &amp;&amp; (year % 100 != 0) || year % 400 == 0) { System.out.println(year + \"年是闰年\"); } else { System.out.println(year + \"年不是闰年\"); } } public static void main(String[] args) { Homework03 homework03 = new Homework03(); homework03.test(2005); }} 123456789101112131415161718192021package chapter5.homework;public class Homework06 { public void test() { int count = 0; for (int i = 1; i &lt;= 100; i++) { if (i % 5 != 0) { count++; System.out.print(i + \"\\t\"); if (count % 5 == 0) { System.out.print(\"\\n\"); } } } } public static void main(String[] args) { Homework06 homework06 = new Homework06(); homework06.test(); }} 123456789101112131415161718package chapter5.homework;public class Homework07 { public void test() { for (char i = 'a'; i &lt;= 'z'; i++) { System.out.print(i + \" \"); } System.out.println(); for (char i = 'Z'; i &gt;= 'A'; i--) { System.out.print(i + \" \"); } } public static void main(String[] args) { Homework07 homework = new Homework07(); homework.test(); }} 1234567891011121314151617181920package chapter5.homework;public class Homework08 { public void test() { double sum = 0; for (int i = 1; i &lt;= 100; i++) { if (i % 2 == 0) { sum -= 1.0 / i; } else { sum += 1.0 / i; } } System.out.println(\"结果为: \" + sum); } public static void main(String[] args) { Homework08 homework = new Homework08(); homework.test(); }} 123456789101112131415161718package chapter5.homework;public class Homework09 { public void test() { int sum = 0; for (int i = 1; i &lt;= 100; i++) { for (int j = 1; j &lt;= i; j++) { sum += j; } } System.out.println(\"总和为：\" + sum); } public static void main(String[] args) { Homework09 homework = new Homework09(); homework.test(); }} 数组、排序和查找为什么需要数组 数组介绍数组可以存放多个同一类型的数据。数组也是一种数据类型，为引用类型。 即：数组就是一组数据 数组快速入门用数组来解决上面的问题。 数组的使用动态初始化使用方式1：动态初始化 定义数据类型[] 数组名 = new 数据类型[大小]； int [] arr=new int[5]; 使用数组名[下标] arr[2] 代表要访问arr数组的第三个元素。（数组下标是从0开始的） 快速入门案例循环输入5个成绩，保存到double数组并输出。 12345678910111213141516import java.util.Scanner;public class Array02 { public static void main(String[] args) { double[] scores = new double[5]; Scanner scanner = new Scanner(System.in); for (int i = 0; i &lt; 5; i++) { System.out.println(\"请输入第\" + (i + 1) + \"个成绩\"); scores[i] = scanner.nextDouble(); } for (int i = 0; i &lt; scores.length; i++) { System.out.print(scores[i] + \"\\t\"); } System.out.println(); }} 1234567891011请输入第1个成绩90请输入第2个成绩89请输入第3个成绩30请输入第4个成绩100请输入第5个成绩8590.0 89.0 30.0 100.0 85.0 静态初始化数组使用注意事项和细节 数组是多个相同类型数据的组合，实现对这些数据的统一管理 数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用。 数组创建后，如果没有赋值，有默认值int 0，short 0, byte 0, long 0, float 0.0,double 0.0，char \\u0000，boolean false，String null 使用数组的步骤1. 声明数组并开辟空间2. 给数组各个元素赋值3. 使用数组 数组的下标是从0 开始的。 数组下标必须在指定范围内使用，否则报：下标越界异常，比如： int [] arr=new int[5]; 则有效下标为0-4 数组属引用类型，数组型数据是对象(object) 数组应用案例创建一个char 类型的26 个元素的数组，分别放置’A’-‘Z’。使用for 循环访问所有元素并打印出来。提示：char 类型数据运算’A’+2 -&gt; ‘C’ 1234567891011121314151617181920public class Test01 { public static void main(String[] args) { char[] arr = new char[26]; for (int i = 0; i &lt; arr.length; i++) { arr[i] = (char) ('A' + i); } System.out.println(\"正序输出====&gt;\"); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + \" \"); } System.out.println(); System.out.println(\"倒序输出====&gt;\"); for (int i = arr.length - 1; i &gt;= 0; i--) { System.out.print(arr[i] + \" \"); } System.out.println(); }} 1234正序输出====&gt;A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 倒序输出====&gt;Z Y X W V U T S R Q P O N M L K J I H G F E D C B A 请求出一个数组int[]的最大值{4,-1,9, 10,23}，并得到对应的下标 1234567891011121314public class Test01 { public static void main(String[] args) { int[] arr = {4, -1, 9, 10, 23}; int maxValue = arr[0]; int maxIndex = 0; for (int i = 0; i &lt; arr.length; i++) { if (arr[i] &gt; maxValue) { maxValue = arr[i]; maxIndex = i; } } System.out.println(\"最大值：\" + maxValue + \"，对应的下标为：\" + maxIndex); }} 1最大值：23，对应的下标为：4 数组赋值机制基本数据类型赋值，这个值就使具体的数据。且互不影响。 12int n1=1;int n2=n1; 数组是引用传递，赋的值是地址。 数组拷贝将int[] arr1 = {10,20,30}; 拷贝到arr2 数组, 要求数据空间是独立的. 12345678910111213141516171819public class Test01 { public static void main(String[] args) { int[] arr1 = {10, 20, 30}; int[] arr2 = new int[arr1.length]; for (int i = 0; i &lt; arr1.length; i++) { arr2[i] = arr1[i]; } System.out.println(\"arr1数组为：\"); for (int i = 0; i &lt; arr1.length; i++) { System.out.print(arr1[i] + \"\\t\"); } System.out.println(); System.out.println(\"arr2数组为：\"); for (int i = 0; i &lt; arr2.length; i++) { System.out.print(arr2[i] + \"\\t\"); } }} 1234arr1数组为：10 20 30 arr2数组为：10 20 30 数组反转要求：把数组{11,22,33,44,55,66}的元素内容反转{66, 55,44,33,22,11}。 12345678910111213141516171819public class Test01 { public static void main(String[] args) { int[] arr = {11, 22, 33, 44, 55, 66}; int[] arrNew = new int[arr.length]; for (int i = 0, j = arrNew.length - 1; i &lt; arr.length; i++, j--) { arrNew[j] = arr[i]; } System.out.println(\"原数组为：\"); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + \"\\t\"); } System.out.println(); System.out.println(\"反转之后的数组为：\"); for (int i = 0; i &lt; arrNew.length; i++) { System.out.print(arrNew[i] + \"\\t\"); } }} 1234原数组为：11 22 33 44 55 66 反转之后的数组为：66 55 44 33 22 11 数组添加/扩容要求：实现动态的给数组添加元素效果，实现对数组扩容。 原始数组使用静态分配int[] arr = {1,2,3} 用户可以决定是否继续添加，添加成功，是否继续？y/n 12345678910111213141516171819202122232425262728293031public class Test01 { public static void main(String[] args) { int[] arr = {1, 2, 3}; int[] arrNew; int number; Scanner scanner = new Scanner(System.in); while (true) { System.out.println(\"请输入是否需要插入元素，y/n\"); char c = scanner.next().charAt(0); if (c == 'y') { arrNew = new int[arr.length + 1]; System.out.println(\"请输入要插入的元素：\"); number = scanner.nextInt(); for (int i = 0; i &lt; arr.length; i++) { arrNew[i] = arr[i]; } arrNew[arrNew.length - 1] = number; arr = arrNew; } else { System.out.println(\"用户主动选择退出~\"); break; } } System.out.println(\"最终的数组结果为：\"); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + \"\\t\"); } System.out.println(); }} 123456789101112请输入是否需要插入元素，y/ny请输入要插入的元素：4请输入是否需要插入元素，y/ny请输入要插入的元素：5请输入是否需要插入元素，y/nn用户主动选择退出~1 2 3 4 5 有一个数组{1， 2， 3， 4， 5}， 可以将该数组进行缩减，提示用户是否继续缩减，每次缩减最后那个元素。当只剩下最后一个元素，提示，不能再缩减。 123456789101112131415161718192021222324252627282930313233343536public class Test01 { public static void main(String[] args) { int[] arr = {1, 2, 3, 4, 5}; int[] arrNew; Scanner scanner = new Scanner(System.in); while (true) { System.out.println(\"请输入是否需要删除元素，y/n\"); char c = scanner.next().charAt(0); if (arr.length == 1) { System.out.println(\"当前数组只剩余一个元素，不能再操作，直接退出~\"); showArray(arr); break; } if (c == 'y') { arrNew = new int[arr.length - 1]; for (int i = 0; i &lt; arrNew.length; i++) { arrNew[i] = arr[i]; } arr = arrNew; showArray(arr); } else { System.out.println(\"用户主动选择退出~\"); showArray(arr); break; } } } private static void showArray(int[] arr) { System.out.println(\"当前数组结果为：\"); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + \"\\t\"); } System.out.println(); }} 123456789101112131415161718192021请输入是否需要删除元素，y/ny当前数组结果为：1 2 3 4 请输入是否需要删除元素，y/ny当前数组结果为：1 2 3 请输入是否需要删除元素，y/ny当前数组结果为：1 2 请输入是否需要删除元素，y/ny当前数组结果为：1 请输入是否需要删除元素，y/ny当前数组只剩余一个元素，不能再操作，直接退出~当前数组结果为：1 排序的介绍排序是将多个数据，依指定的顺序进行排列的过程。 内部排序指将需要处理的所有数据都加载到内部存储器中进行排序。包括(交换式排序法、选择式排序法和插入式排序法)； 外部排序数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。包括(合并排序法和直接合并排序法)。 冒泡排序法冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从后向前（从下标较大的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。 下面我们举一个具体的案例来说明冒泡法。我们将五个无序：24,69,80,57,13 使用冒泡排序法将其排成一个从小到大的有序数列。 1234567891011121314151617181920212223242526public class Test01 { public static void main(String[] args) { int[] arr = {24, 69, 80, 57, 13}; System.out.println(\"原数组为：\"); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + \"\\t\"); } System.out.println(); int temp; for (int i = 0; i &lt; arr.length - 1; i++) { for (int j = 0; j &lt; arr.length - 1 - i; j++) { if (arr[j] &gt; arr[j + 1]) { temp = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = temp; } } } System.out.println(\"冒泡排序输出的结果为：\"); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + \"\\t\"); } System.out.println(); }} 1234原数组为：24 69 80 57 13 冒泡排序输出的结果为：13 24 57 69 80 查找介绍在java 中，我们常用的查找有两种: 顺序查找SeqSearch.java 二分查找【二分法，我们放在算法讲解】 案例有一个数列：白眉鹰王、金毛狮王、紫衫龙王、青翼蝠王猜数游戏：从键盘中任意输入一个名称，判断数列中是否包含此名称【顺序查找】要求: 如果找到了，就提示找到，并给出下标值。 12345678910111213141516171819202122import java.util.Scanner;public class Test01 { public static void main(String[] args) { String[] arr = {\"白眉鹰王\", \"金毛狮王\", \"紫衫龙王\", \"青翼蝠王\"}; Scanner scanner = new Scanner(System.in); System.out.println(\"请输入你要查找的名字：\"); String findName = scanner.next(); int index = -1; for (int i = 0; i &lt; arr.length; i++) { if (arr[i].equals(findName)) { index = i; break; } } if (index == -1) { System.out.println(\"没有找到你要查找的名字。\"); } else { System.out.println(\"你要查找的名字：\" + findName + \"，已找到，其对应的数组下标为： \" + index); } }} 123请输入你要查找的名字：金毛狮王你要查找的名字：金毛狮王，已找到，其对应的数组下标为： 1 多维数组-二维数组二维数组的使用快速入门案例二维数组的每个元素是一维数组。 使用方式1：动态初始化12语法：类型[][] 数组名 = new 类型[大小][大小];例子：int[][] arr = new int[2][3]; 二维数组的内存存在形式 使用方式2：动态初始化123先声明：类型数组名[][]; TwoDimensionalArray02.java再定义(开辟空间) 数组名= new 类型[大小][大小]赋值(有默认值，比如int 类型的就是0) 使用方式3：动态初始化（列数不确定） 使用方式4：静态初始化123456定义: 类型 数组名[][] = { {值1,值2..}, {值1,值2..}, {值1,值2..} }例子: int[][] arr = {{1,1,1}, {8,8,9}, {100}};解读： 定义了一个二维数组arr arr 有三个元素(每个元素都是一维数组) 第一个一维数组有3 个元素, 第二个一维数组有3 个元素, 第三个一维数组有1 个元素 二维数组应用案例使用二维数组打印一个10 行杨辉三角。 12345678910111213141516171819202122public class Test01 { public static void main(String[] args) { int[][] arr = new int[10][]; for (int i = 0; i &lt; arr.length; i++) { arr[i] = new int[i + 1]; for (int j = 0; j &lt; arr[i].length; j++) { if (j == 0 || j == arr[i].length - 1) { arr[i][j] = 1; } else { arr[i][j] = arr[i - 1][j] + arr[i - 1][j - 1]; } } } for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; arr[i].length; j++) { System.out.print(arr[i][j] + \" \"); } System.out.println(); } }} 123456789101 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1 1 7 21 35 35 21 7 1 1 8 28 56 70 56 28 8 1 1 9 36 84 126 126 84 36 9 1 二维数组使用细节和注意事项1234567891) 一维数组的声明方式有:int[] x 或者int x[] 2) 二维数组的声明方式有:int[][] y 或者int[] y[] 或者int y[][] 3) 二维数组实际上是由多个一维数组组成的，它的各个一维数组的长度可以相同，也可以不相同。比如： map[][] 是一个二维数组。int map [][] = {{1,2},{3,4,5}}由map[0] 是一个含有两个元素的一维数组，map[1] 是一个含有三个元素的一维数组构成，我们也称为列数不等的二维数组 二维数组课堂练习本章作业已知有一个升序数组，要求插入一个元素之后，该数组仍然为升序。 1234567891011121314151617181920212223242526272829public class Test01 { public static void main(String[] args) { int[] arr = {10, 12, 45, 90}; int[] arrNew = new int[arr.length + 1]; int num = 23; int index = -1; for (int i = 0; i &lt; arr.length; i++) { if (arr[i] &gt;= num) { index = i; break; } } if (index == -1) {//说明数据应该插入最后一位 index = arr.length; } for (int i = 0, j = 0; i &lt; arrNew.length; i++) { if (index == i) { arrNew[i] = num; } else { arrNew[i] = arr[j]; j++; } } for (int i = 0; i &lt; arrNew.length; i++) { System.out.print(arrNew[i] + \" \"); } System.out.println(); }} 110 12 23 45 90 随机生成10个整数（1-100）范围内，保存到数组中。 12345678910111213141516import java.util.Random;public class Test01 { public static void main(String[] args) { int[] arr = new int[10]; Random random = new Random(); for (int i = 0; i &lt; arr.length; i++) { int num = random.nextInt(100) + 1; arr[i] = num; } for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + \" \"); } System.out.println(); }} 184 53 23 19 43 98 68 26 79 3 面向对象编程（基础部分）类与对象养猫猫问题张老太养了两只猫猫:一只名字叫小白,今年 3 岁,白色。还有一只叫小花,今年 100 岁,花色。请编写一个程序，当用户输入小猫的名字时，就显示该猫的名字，年龄，颜色。如果用户输入的小猫名错误，则显示张老太没有这只猫猫。 使用现有技术解决上述问题 单独定义变量解决 123456789//第 1 只猫信息String cat1Name = \"小白\";int cat1Age = 3;String cat1Color = \"白色\";//第 2 只猫信息String cat2Name = \"小花\";int cat2Age = 100;String cat2Color = \"花色\"; 使用数组 12345//1.数据类型体现不出来//2.只能通过[下标]获取信息，造成变量名字和内容的对应关系不明确//3.不能体现猫的行为String[] cat1 = {\"小白\", \"3\", \"白色\"};String[] cat2 = {\"小花\", \"100\", \"花色\"}; 现有技术缺点分析 不利于数据管理 效率低下 引入类与对象（OOP）1234567891011Cat cat1 = new Cat();cat1.name = \"小白\";cat1.age = 3;cat1.color = \"白色\";cat1.weight = 10;Cat cat2 = new Cat();cat2.name = \"小花\";cat2.age = 100;cat2.color = \"花色\";cat2.weight = 20; 类和对象的内存分配机制（重点！！！）Java内存结构分析 栈：基本数据类型 堆：存放对象（Cat cat，数组等） 方法区：常量池（常量，字符串），类加载信息 练习题分析下列代码的内存结构： 重载介绍同一个类里面，可以有多个同名的方法。但是方法的形参列表不能一样。 可变参数使用可以通过可变参数，将同一个类中同方法名，同功能但是不同参数的方法封装成一个方法。 语法格式修饰符 返回值类型 方法名(参数类型… 形参名) { } 例子求2个整数，3个整数，5个整数的和。 使用传统技术解决问题 12345678public class App { public static void main(String[] args) { SumNum sumNum = new SumNum(); System.out.println(sumNum.sum2(1, 2)); System.out.println(sumNum.sum3(1, 2, 3)); System.out.println(sumNum.sum5(1, 2, 3, 4, 5)); }} 1234567891011public class SumNum { public int sum2(int n1, int n2){ return n1 + n2; } public int sum3(int n1, int n2, int n3){ return n1 + n2 + n3; } public int sum5(int n1, int n2, int n3, int n4, int n5){ return n1 + n2 + n3 + n4 + n5; }} 结果 1233615 使用可变参数解决问题 12345678public class App { public static void main(String[] args) { SumNum sumNum = new SumNum(); System.out.println(sumNum.sums(1, 2)); System.out.println(sumNum.sums(1, 2, 3)); System.out.println(sumNum.sums(1, 2, 3, 4, 5)); }} 123456789public class SumNum { public int sums(int... n){ int total = 0; for (int i = 0; i &lt; n.length; i++) { total += n[i]; } return total; }} 结果 1233615 对象创建流程分析（包含构造器）1Person p = new Person(5, \"闹闹\"); 123456789public class Person { int age = 10; String name; public Person(int age, String name) { this.age = age; this.name = name; }} 成员方法基本介绍在某些情况下，我们要需要定义成员方法(简称方法)。比如人类:除了有一些属性外( 年龄，姓名..),我们人类还有一些行为比如:可以说话、跑步..,通过学习，还可以做算术题。这时就要用成员方法才能完成。 成员方法快速入门笔记本28页图片 方法的调用机制原理笔记本29页图片 为什么需要成员方法笔记本29页图片 成员方法的好处提高代码的复用性 可以将实现的细节封装起来，然后供其他用户来调用即可 成员方法的定义笔记本30页 注意事项和使用细节访问修饰符(作用是控制方法使用的范围)如果不写默认访问，[有四种: public, protected, 默认, private], 具体在后面说 返回数据类型 一个方法最多有一个返回值[思考，如何返回多个结果返回数组] 返回类型可以为任意类型，包含基本类型或引用类型(数组，对象) 如果方法要求有返回数据类型，则方法体中最后的执行语句必须为return 值; 而且要求返回值类型必须和return 的 值类型一致或兼容 如果方法是void，则方法体中可以没有return 语句，或者只写return ; 方法名遵循驼峰命名法，最好见名知义，表达出该功能的意思即可, 比如得到两个数的和getSum, 开发中按照规范 形参列表 类定义的完善 课堂练习题1.编写类AA ，有一个方法：判断一个数是奇数odd 还是偶数, 返回boolean 1234567891011121314151617public class Test01 { public static void main(String[] args) { AA aa = new AA(); int num = 4; if (aa.isOdd(num)) { System.out.println(\"数字\" + num + \"是奇数\"); } else { System.out.println(\"数字\" + num + \"是偶数\"); } }}class AA { public boolean isOdd(int num) { return num % 2 == 0 ? false : true; }} 1数字4是偶数 1数字9是奇数 2.根据行、列、字符打印对应行数和列数的字符，比如：行：3，列：2，字符 #, 则打印相应的效果 12345678910111213141516public class Test02 { public static void main(String[] args) { String[][] arr = new String[3][2]; for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; arr[i].length; j++) { arr[i][j] = \"#\"; } } for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; arr[i].length; j++) { System.out.print(arr[i][j] + \"\\t\"); } System.out.println(); } }} 123# # # # # # 成员方法传参机制(非常非常重要)基本数据类型的传参机制基本数据类型，传递的是值（值拷贝），形参的任何改变不影响实参。 引用数据类型的传参机制引用类型可以通过形参来影响实参。 成员方法返回类型是引用类型应用实例 方法递归调用(非常非常重要，比较难)基本介绍递归就是方法自己调用自己。 递归能解决什么问题? 递归举例打印问题 123456789101112131415public class Recursion01 { public static void main(String[] args) { T t = new T(); t.test(4);//调用方法后输出结果是？ }}class T { public void test(int n) { if (n &gt; 2) { test(n - 1); } System.out.println(\"n=\" + n); }} 123n=2n=3n=4 阶乘问题 123456789101112131415161718192021222324252627282930313233343536373839404142```### 递归重要规则![image-20230920060433456](https://raw.githubusercontent.com/xiaofanshutu/typora2022/main/image-20230920060433456.png)### 课堂练习![image-20230920052744709](https://raw.githubusercontent.com/xiaofanshutu/typora2022/main/image-20230920052744709.png)请使用递归的方式求出斐波那契数1,1,2,3,5,8,13...给你一个整数n，求出它的斐波那契值是多少。```javapublic class RecursionExercise01 { public static void main(String[] args) { T t = new T(); int n = 7; int fibonacciNum = t.fibonacci(n); if (fibonacciNum != -1) { System.out.println(\"数字 \" + n + \" 的斐波那契值为 \" + fibonacciNum); } else { System.out.println(\"数据不合法\"); } }}class T { public int fibonacci(int n) { if (n &gt; 0) { if (n == 1 || n == 2) { return 1; } else { return fibonacci(n - 1) + fibonacci(n - 2); } } else { System.out.println(\"数据不合法，输入的n为：\" + n); return -1; } }} 1数字 7 的斐波那契值为 13 猴子吃桃子问题：有一堆桃子，猴子第一天吃了其中的一半，并再多吃了一个！以后每天猴子都吃其中的一半，然后再多吃一个。当到第10 天时，想再吃时（即还没吃），发现只有1个桃子了。问题：最初共多少个桃子？ 123456789101112131415161718192021package chapter07;public class RecursionExercise01 { public static void main(String[] args) { T t = new T(); int peach = t.peach(1); System.out.println(peach); }}class T { public int peach(int day) { if (day == 10) { return 1; } else if (day &gt;= 1 &amp;&amp; day &lt;= 9) { return (peach(day + 1) + 1) * 2; } else { return -1; } }} 递归调用应用实例-迷宫问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class MiGong { public static void main(String[] args) { MiGongTest miGongTest = new MiGongTest(); int[][] map = new int[8][7]; for (int i = 0; i &lt; map.length; i++) { for (int j = 0; j &lt; map[i].length; j++) { map[i][j] = 0; } } for (int i = 0; i &lt; map.length; i++) { map[i][0] = 1; map[i][6] = 1; } for (int j = 0; j &lt; 7; j++) { map[0][j] = 1; map[7][j] = 1; } map[3][1] = 1; map[3][2] = 1; miGongTest.findWay(map, 1, 1); for (int i = 0; i &lt; map.length; i++) { for (int j = 0; j &lt; map[i].length; j++) { System.out.print(map[i][j] + \" \"); } System.out.println(); } }}class MiGongTest { public boolean findWay(int[][] map, int i, int j) { if (map[6][5] == 2) { return true; } else { if (map[i][j] == 0) { map[i][j] = 2; if (findWay(map, i + 1, j)) {//下 return true; } else if (findWay(map, i, j + 1)) {//右 return true; } else if (findWay(map, i - 1, j)) {//上 return true; } else if (findWay(map, i, j - 1)) {//左 return true; } else { map[i][j] = 3; return false; } } else { return false; } } }} 123456781 1 1 1 1 1 1 1 2 0 0 0 0 1 1 2 2 2 0 0 1 1 1 1 2 0 0 1 1 0 0 2 0 0 1 1 0 0 2 0 0 1 1 0 0 2 2 2 1 1 1 1 1 1 1 1 测试回溯法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class MiGong { public static void main(String[] args) { MiGongTest miGongTest = new MiGongTest(); int[][] map = new int[8][7]; for (int i = 0; i &lt; map.length; i++) { for (int j = 0; j &lt; map[i].length; j++) { map[i][j] = 0; } } for (int i = 0; i &lt; map.length; i++) { map[i][0] = 1; map[i][6] = 1; } for (int j = 0; j &lt; 7; j++) { map[0][j] = 1; map[7][j] = 1; } map[3][1] = 1; map[3][2] = 1; map[2][2] = 1;//测试回溯法 miGongTest.findWay(map, 1, 1); for (int i = 0; i &lt; map.length; i++) { for (int j = 0; j &lt; map[i].length; j++) { System.out.print(map[i][j] + \" \"); } System.out.println(); } }}class MiGongTest { public boolean findWay(int[][] map, int i, int j) { if (map[6][5] == 2) { return true; } else { if (map[i][j] == 0) { map[i][j] = 2; if (findWay(map, i + 1, j)) {//下 return true; } else if (findWay(map, i, j + 1)) {//右 return true; } else if (findWay(map, i - 1, j)) {//上 return true; } else if (findWay(map, i, j - 1)) {//左 return true; } else { map[i][j] = 3; return false; } } else { return false; } } }} 123456781 1 1 1 1 1 1 1 2 2 2 0 0 1 1 3 1 2 0 0 1 1 1 1 2 0 0 1 1 0 0 2 0 0 1 1 0 0 2 0 0 1 1 0 0 2 2 2 1 1 1 1 1 1 1 1 递归调用应用实例-汉诺塔递归调用应用实例-八皇后问题[同学们先尝试做，后面老师评讲.]方法重载(OverLoad)基本介绍同一个类中，拥有相同方法名，且形参列表不一样。（返回类型无要求） 重载的好处减轻了起名和记名的麻烦。 快速入门案例 注意事项和使用细节课堂练习题this关键字深入理解this什么是this？Java虚拟机给每个对象都分配了一个this，代表当前对象。 this本质 this小结1234dog1.info();public void info(){ System.out.println(this.hashCode());//此时，输出的就是dog1的hashCode值。哪个对象调用，this就是哪个对象。} this的注意事项和使用细节 本章作业 定义方法max，实现求某个double数组的最大值，并返回 123456789package com.bambi;public class Homework01 { public static void main(String[] args) { A01 a01 = new A01(); double[] array = {10.01, 80.25, 20.15, 30.71, 12.56}; System.out.println(a01.max(array)); }} 1234567891011121314151617181920package com.bambi;public class A01 { public double max(double[] array) { double ans = 0.0; for (int i = 0; i &lt; array.length; i++) { if (i == 0) { ans = array[i]; } else { if (ans &lt; array[i]) { ans = array[i]; } } } return ans; }} 定义方法find，实现查找某字符串是否在字符串数组中，并返回索引，如果找不到，则返回-1 123456789package com.bambi;public class Homework02 { public static void main(String[] args) { A02 a02 = new A02(); String[] array = {\"bambi\", \"eazin\", \"stefen\"}; System.out.println(a02.find(\"summer\", array)); }} 123456789101112package com.bambi;public class A02 { public int find(String s, String[] array) { for (int i = 0; i &lt; array.length; i++) { if (s.equals(array[i])) { return i; } } return -1; }} 1-1 编写类Book，定义方法updatePrice，实现更改某本书的价格，具体：如果价格大于150，则更改为150；如果价格大于100，则更改为100；否则不变。 12345678public class A03 { public static void main(String[] args) { Book book = new Book(); System.out.println(book.updatePrice(200.55)); System.out.println(book.updatePrice(130.91)); System.out.println(book.updatePrice(50.21)); }} 1234567891011public class Book { //编写类Book，定义方法updatePrice，实现更改某本书的价格，具体：如果价格大于150，则更改为150；如果价格大于100，则更改为100；否则不变。 public double updatePrice(double price){ if(price &gt; 150){ price = 150; } else if (price &gt; 100) { price = 100; } return price; }} 123150.0100.050.21 编写类，实现数组的复制功能copyArr，输入旧数组，返回新数组。 12345678910111213141516171819202122public class A03 { public static void main(String[] args) { A04 a04 = new A04(); int[] ints = {1, 2}; int[] afterArr = a04.copyArr(ints); for (int num : afterArr) { System.out.println(num); } }}public class A04 { //定义一个类，实现数组的复制功能copyArr。输入旧数组，返回一个新数组 public int[] copyArr(int[] array) { int[] newArr = new int[array.length]; for (int i = 0; i &lt; array.length; i++) { newArr[i] = array[i]; } return newArr; }} 面向对象编程（中级部分）IDEA常用快捷键 删除当前行, 默认是ctrl + d 复制当前行, 自己配置 ctrl + alt + 向下光标 补全代码 alt + / 添加注释和取消注释 ctrl + / 【第一次是添加注释，第二次是取消注释】 导入该行需要的类 先配置 auto import , 然后使用 alt+enter 即可 快速格式化代码 ctrl + alt + L 快速运行程序 自己定义 alt + R 生成构造器等 alt + insert [提高开发效率] 查看一个类的层级关系F4 将光标放在一个方法上，输入 ctrl + B , 可以定位到方法 [学继承后，非常有用] —–这个在我电脑上不生效，再试试 自动的分配变量名 , 通过 在后面假 .var [老师最喜欢的] 包","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://xiaofanshutu.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"cutiebambi"},{"title":"面向对象编程（基础部分）","slug":"面向对象编程（基础部分）_韩顺平","date":"2023-10-07T12:03:21.888Z","updated":"2024-01-17T23:38:29.143Z","comments":true,"path":"posts/dfc0bd6b.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/dfc0bd6b.html","excerpt":"","text":"类与对象养猫猫问题张老太养了两只猫猫:一只名字叫小白,今年 3 岁,白色。还有一只叫小花,今年 100 岁,花色。请编写一个程序，当用户输入小猫的名字时，就显示该猫的名字，年龄，颜色。如果用户输入的小猫名错误，则显示张老太没有这只猫猫。 使用现有技术解决上述问题 单独定义变量解决 123456789//第 1 只猫信息String cat1Name = \"小白\";int cat1Age = 3;String cat1Color = \"白色\";//第 2 只猫信息String cat2Name = \"小花\";int cat2Age = 100;String cat2Color = \"花色\"; 使用数组 12345//1.数据类型体现不出来//2.只能通过[下标]获取信息，造成变量名字和内容的对应关系不明确//3.不能体现猫的行为String[] cat1 = {\"小白\", \"3\", \"白色\"};String[] cat2 = {\"小花\", \"100\", \"花色\"}; 现有技术缺点分析 不利于数据管理 效率低下 引入类与对象（OOP）1234567891011Cat cat1 = new Cat();cat1.name = \"小白\";cat1.age = 3;cat1.color = \"白色\";cat1.weight = 10;Cat cat2 = new Cat();cat2.name = \"小花\";cat2.age = 100;cat2.color = \"花色\";cat2.weight = 20; 类和对象的内存分配机制（重点！！！）Java内存结构分析 栈：基本数据类型 堆：存放对象（Cat cat，数组等） 方法区：常量池（常量，字符串），类加载信息 练习题分析下列代码的内存结构： 重载介绍同一个类里面，可以有多个同名的方法。但是方法的形参列表不能一样。 可变参数使用可以通过可变参数，将同一个类中同方法名，同功能但是不同参数的方法封装成一个方法。 语法格式修饰符 返回值类型 方法名(参数类型… 形参名) { } 例子求2个整数，3个整数，5个整数的和。 使用传统技术解决问题 12345678public class App { public static void main(String[] args) { SumNum sumNum = new SumNum(); System.out.println(sumNum.sum2(1, 2)); System.out.println(sumNum.sum3(1, 2, 3)); System.out.println(sumNum.sum5(1, 2, 3, 4, 5)); }} 1234567891011public class SumNum { public int sum2(int n1, int n2){ return n1 + n2; } public int sum3(int n1, int n2, int n3){ return n1 + n2 + n3; } public int sum5(int n1, int n2, int n3, int n4, int n5){ return n1 + n2 + n3 + n4 + n5; }} 结果 1233615 使用可变参数解决问题 12345678public class App { public static void main(String[] args) { SumNum sumNum = new SumNum(); System.out.println(sumNum.sums(1, 2)); System.out.println(sumNum.sums(1, 2, 3)); System.out.println(sumNum.sums(1, 2, 3, 4, 5)); }} 123456789public class SumNum { public int sums(int... n){ int total = 0; for (int i = 0; i &lt; n.length; i++) { total += n[i]; } return total; }} 结果 1233615 对象创建流程分析（包含构造器）1Person p = new Person(5, \"闹闹\"); 123456789public class Person { int age = 10; String name; public Person(int age, String name) { this.age = age; this.name = name; }} 成员方法基本介绍在某些情况下，我们要需要定义成员方法(简称方法)。比如人类:除了有一些属性外( 年龄，姓名..),我们人类还有一些行为比如:可以说话、跑步..,通过学习，还可以做算术题。这时就要用成员方法才能完成。 成员方法快速入门笔记本28页图片 方法的调用机制原理笔记本29页图片 为什么需要成员方法笔记本29页图片 成员方法的好处提高代码的复用性 可以将实现的细节封装起来，然后供其他用户来调用即可 成员方法的定义笔记本30页 注意事项和使用细节访问修饰符(作用是控制方法使用的范围)如果不写默认访问，[有四种: public, protected, 默认, private], 具体在后面说 返回数据类型 一个方法最多有一个返回值[思考，如何返回多个结果返回数组] 返回类型可以为任意类型，包含基本类型或引用类型(数组，对象) 如果方法要求有返回数据类型，则方法体中最后的执行语句必须为return 值; 而且要求返回值类型必须和return 的 值类型一致或兼容 如果方法是void，则方法体中可以没有return 语句，或者只写return ; 方法名遵循驼峰命名法，最好见名知义，表达出该功能的意思即可, 比如得到两个数的和getSum, 开发中按照规范 形参列表 类定义的完善 课堂练习题1.编写类AA ，有一个方法：判断一个数是奇数odd 还是偶数, 返回boolean 1234567891011121314151617public class Test01 { public static void main(String[] args) { AA aa = new AA(); int num = 4; if (aa.isOdd(num)) { System.out.println(\"数字\" + num + \"是奇数\"); } else { System.out.println(\"数字\" + num + \"是偶数\"); } }}class AA { public boolean isOdd(int num) { return num % 2 == 0 ? false : true; }} 1数字4是偶数 1数字9是奇数 2.根据行、列、字符打印对应行数和列数的字符，比如：行：3，列：2，字符 #, 则打印相应的效果 12345678910111213141516public class Test02 { public static void main(String[] args) { String[][] arr = new String[3][2]; for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; arr[i].length; j++) { arr[i][j] = \"#\"; } } for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; arr[i].length; j++) { System.out.print(arr[i][j] + \"\\t\"); } System.out.println(); } }} 123# # # # # # 成员方法传参机制(非常非常重要)基本数据类型的传参机制基本数据类型，传递的是值（值拷贝），形参的任何改变不影响实参。 引用数据类型的传参机制引用类型可以通过形参来影响实参。 成员方法返回类型是引用类型应用实例 方法递归调用(非常非常重要，比较难)基本介绍递归就是方法自己调用自己。 递归能解决什么问题? 递归举例打印问题 123456789101112131415public class Recursion01 { public static void main(String[] args) { T t = new T(); t.test(4);//调用方法后输出结果是？ }}class T { public void test(int n) { if (n &gt; 2) { test(n - 1); } System.out.println(\"n=\" + n); }} 123n=2n=3n=4 阶乘问题 123456789101112131415161718192021222324252627282930313233343536373839404142```### 递归重要规则![image-20230920060433456](https://raw.githubusercontent.com/xiaofanshutu/typora2022/main/image-20230920060433456.png)### 课堂练习![image-20230920052744709](https://raw.githubusercontent.com/xiaofanshutu/typora2022/main/image-20230920052744709.png)请使用递归的方式求出斐波那契数1,1,2,3,5,8,13...给你一个整数n，求出它的斐波那契值是多少。```javapublic class RecursionExercise01 { public static void main(String[] args) { T t = new T(); int n = 7; int fibonacciNum = t.fibonacci(n); if (fibonacciNum != -1) { System.out.println(\"数字 \" + n + \" 的斐波那契值为 \" + fibonacciNum); } else { System.out.println(\"数据不合法\"); } }}class T { public int fibonacci(int n) { if (n &gt; 0) { if (n == 1 || n == 2) { return 1; } else { return fibonacci(n - 1) + fibonacci(n - 2); } } else { System.out.println(\"数据不合法，输入的n为：\" + n); return -1; } }} 1数字 7 的斐波那契值为 13 猴子吃桃子问题：有一堆桃子，猴子第一天吃了其中的一半，并再多吃了一个！以后每天猴子都吃其中的一半，然后再多吃一个。当到第10 天时，想再吃时（即还没吃），发现只有1个桃子了。问题：最初共多少个桃子？ 123456789101112131415161718192021package chapter07;public class RecursionExercise01 { public static void main(String[] args) { T t = new T(); int peach = t.peach(1); System.out.println(peach); }}class T { public int peach(int day) { if (day == 10) { return 1; } else if (day &gt;= 1 &amp;&amp; day &lt;= 9) { return (peach(day + 1) + 1) * 2; } else { return -1; } }} 递归调用应用实例-迷宫问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class MiGong { public static void main(String[] args) { MiGongTest miGongTest = new MiGongTest(); int[][] map = new int[8][7]; for (int i = 0; i &lt; map.length; i++) { for (int j = 0; j &lt; map[i].length; j++) { map[i][j] = 0; } } for (int i = 0; i &lt; map.length; i++) { map[i][0] = 1; map[i][6] = 1; } for (int j = 0; j &lt; 7; j++) { map[0][j] = 1; map[7][j] = 1; } map[3][1] = 1; map[3][2] = 1; miGongTest.findWay(map, 1, 1); for (int i = 0; i &lt; map.length; i++) { for (int j = 0; j &lt; map[i].length; j++) { System.out.print(map[i][j] + \" \"); } System.out.println(); } }}class MiGongTest { public boolean findWay(int[][] map, int i, int j) { if (map[6][5] == 2) { return true; } else { if (map[i][j] == 0) { map[i][j] = 2; if (findWay(map, i + 1, j)) {//下 return true; } else if (findWay(map, i, j + 1)) {//右 return true; } else if (findWay(map, i - 1, j)) {//上 return true; } else if (findWay(map, i, j - 1)) {//左 return true; } else { map[i][j] = 3; return false; } } else { return false; } } }} 123456781 1 1 1 1 1 1 1 2 0 0 0 0 1 1 2 2 2 0 0 1 1 1 1 2 0 0 1 1 0 0 2 0 0 1 1 0 0 2 0 0 1 1 0 0 2 2 2 1 1 1 1 1 1 1 1 测试回溯法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class MiGong { public static void main(String[] args) { MiGongTest miGongTest = new MiGongTest(); int[][] map = new int[8][7]; for (int i = 0; i &lt; map.length; i++) { for (int j = 0; j &lt; map[i].length; j++) { map[i][j] = 0; } } for (int i = 0; i &lt; map.length; i++) { map[i][0] = 1; map[i][6] = 1; } for (int j = 0; j &lt; 7; j++) { map[0][j] = 1; map[7][j] = 1; } map[3][1] = 1; map[3][2] = 1; map[2][2] = 1;//测试回溯法 miGongTest.findWay(map, 1, 1); for (int i = 0; i &lt; map.length; i++) { for (int j = 0; j &lt; map[i].length; j++) { System.out.print(map[i][j] + \" \"); } System.out.println(); } }}class MiGongTest { public boolean findWay(int[][] map, int i, int j) { if (map[6][5] == 2) { return true; } else { if (map[i][j] == 0) { map[i][j] = 2; if (findWay(map, i + 1, j)) {//下 return true; } else if (findWay(map, i, j + 1)) {//右 return true; } else if (findWay(map, i - 1, j)) {//上 return true; } else if (findWay(map, i, j - 1)) {//左 return true; } else { map[i][j] = 3; return false; } } else { return false; } } }} 123456781 1 1 1 1 1 1 1 2 2 2 0 0 1 1 3 1 2 0 0 1 1 1 1 2 0 0 1 1 0 0 2 0 0 1 1 0 0 2 0 0 1 1 0 0 2 2 2 1 1 1 1 1 1 1 1 递归调用应用实例-汉诺塔递归调用应用实例-八皇后问题[同学们先尝试做，后面老师评讲.]方法重载(OverLoad)基本介绍同一个类中，拥有相同方法名，且形参列表不一样。（返回类型无要求） 重载的好处减轻了起名和记名的麻烦。 快速入门案例 注意事项和使用细节课堂练习题this关键字深入理解this什么是this？Java虚拟机给每个对象都分配了一个this，代表当前对象。 this本质 this小结1234dog1.info();public void info(){ System.out.println(this.hashCode());//此时，输出的就是dog1的hashCode值。哪个对象调用，this就是哪个对象。} this的注意事项和使用细节 本章作业 定义方法max，实现求某个double数组的最大值，并返回 123456789package com.bambi;public class Homework01 { public static void main(String[] args) { A01 a01 = new A01(); double[] array = {10.01, 80.25, 20.15, 30.71, 12.56}; System.out.println(a01.max(array)); }} 1234567891011121314151617181920package com.bambi;public class A01 { public double max(double[] array) { double ans = 0.0; for (int i = 0; i &lt; array.length; i++) { if (i == 0) { ans = array[i]; } else { if (ans &lt; array[i]) { ans = array[i]; } } } return ans; }} 定义方法find，实现查找某字符串是否在字符串数组中，并返回索引，如果找不到，则返回-1 123456789package com.bambi;public class Homework02 { public static void main(String[] args) { A02 a02 = new A02(); String[] array = {\"bambi\", \"eazin\", \"stefen\"}; System.out.println(a02.find(\"summer\", array)); }} 123456789101112package com.bambi;public class A02 { public int find(String s, String[] array) { for (int i = 0; i &lt; array.length; i++) { if (s.equals(array[i])) { return i; } } return -1; }} 1-1 编写类Book，定义方法updatePrice，实现更改某本书的价格，具体：如果价格大于150，则更改为150；如果价格大于100，则更改为100；否则不变。 12345678public class A03 { public static void main(String[] args) { Book book = new Book(); System.out.println(book.updatePrice(200.55)); System.out.println(book.updatePrice(130.91)); System.out.println(book.updatePrice(50.21)); }} 1234567891011public class Book { //编写类Book，定义方法updatePrice，实现更改某本书的价格，具体：如果价格大于150，则更改为150；如果价格大于100，则更改为100；否则不变。 public double updatePrice(double price){ if(price &gt; 150){ price = 150; } else if (price &gt; 100) { price = 100; } return price; }} 123150.0100.050.21 编写类，实现数组的复制功能copyArr，输入旧数组，返回新数组。 12345678910111213141516171819202122public class A03 { public static void main(String[] args) { A04 a04 = new A04(); int[] ints = {1, 2}; int[] afterArr = a04.copyArr(ints); for (int num : afterArr) { System.out.println(num); } }}public class A04 { //定义一个类，实现数组的复制功能copyArr。输入旧数组，返回一个新数组 public int[] copyArr(int[] array) { int[] newArr = new int[array.length]; for (int i = 0; i &lt; array.length; i++) { newArr[i] = array[i]; } return newArr; }}","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://xiaofanshutu.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"cutiebambi"},{"title":"数组、排序和查找","slug":"数组、排序和查找_韩顺平","date":"2023-10-07T12:03:21.472Z","updated":"2024-01-17T23:38:33.535Z","comments":true,"path":"posts/c2bc67b6.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/c2bc67b6.html","excerpt":"","text":"为什么需要数组 数组介绍数组可以存放多个同一类型的数据。数组也是一种数据类型，为引用类型。 即：数组就是一组数据 数组快速入门用数组来解决上面的问题。 数组的使用动态初始化使用方式1：动态初始化 定义数据类型[] 数组名 = new 数据类型[大小]； int [] arr=new int[5]; 使用数组名[下标] arr[2] 代表要访问arr数组的第三个元素。（数组下标是从0开始的） 快速入门案例循环输入5个成绩，保存到double数组并输出。 12345678910111213141516import java.util.Scanner;public class Array02 { public static void main(String[] args) { double[] scores = new double[5]; Scanner scanner = new Scanner(System.in); for (int i = 0; i &lt; 5; i++) { System.out.println(\"请输入第\" + (i + 1) + \"个成绩\"); scores[i] = scanner.nextDouble(); } for (int i = 0; i &lt; scores.length; i++) { System.out.print(scores[i] + \"\\t\"); } System.out.println(); }} 1234567891011请输入第1个成绩90请输入第2个成绩89请输入第3个成绩30请输入第4个成绩100请输入第5个成绩8590.0 89.0 30.0 100.0 85.0 静态初始化数组使用注意事项和细节 数组是多个相同类型数据的组合，实现对这些数据的统一管理 数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用。 数组创建后，如果没有赋值，有默认值int 0，short 0, byte 0, long 0, float 0.0,double 0.0，char \\u0000，boolean false，String null 使用数组的步骤1. 声明数组并开辟空间2. 给数组各个元素赋值3. 使用数组 数组的下标是从0 开始的。 数组下标必须在指定范围内使用，否则报：下标越界异常，比如： int [] arr=new int[5]; 则有效下标为0-4 数组属引用类型，数组型数据是对象(object) 数组应用案例创建一个char 类型的26 个元素的数组，分别放置’A’-‘Z’。使用for 循环访问所有元素并打印出来。提示：char 类型数据运算’A’+2 -&gt; ‘C’ 1234567891011121314151617181920public class Test01 { public static void main(String[] args) { char[] arr = new char[26]; for (int i = 0; i &lt; arr.length; i++) { arr[i] = (char) ('A' + i); } System.out.println(\"正序输出====&gt;\"); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + \" \"); } System.out.println(); System.out.println(\"倒序输出====&gt;\"); for (int i = arr.length - 1; i &gt;= 0; i--) { System.out.print(arr[i] + \" \"); } System.out.println(); }} 1234正序输出====&gt;A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 倒序输出====&gt;Z Y X W V U T S R Q P O N M L K J I H G F E D C B A 请求出一个数组int[]的最大值{4,-1,9, 10,23}，并得到对应的下标 1234567891011121314public class Test01 { public static void main(String[] args) { int[] arr = {4, -1, 9, 10, 23}; int maxValue = arr[0]; int maxIndex = 0; for (int i = 0; i &lt; arr.length; i++) { if (arr[i] &gt; maxValue) { maxValue = arr[i]; maxIndex = i; } } System.out.println(\"最大值：\" + maxValue + \"，对应的下标为：\" + maxIndex); }} 1最大值：23，对应的下标为：4 数组赋值机制基本数据类型赋值，这个值就使具体的数据。且互不影响。 12int n1=1;int n2=n1; 数组是引用传递，赋的值是地址。 数组拷贝将int[] arr1 = {10,20,30}; 拷贝到arr2 数组, 要求数据空间是独立的. 12345678910111213141516171819public class Test01 { public static void main(String[] args) { int[] arr1 = {10, 20, 30}; int[] arr2 = new int[arr1.length]; for (int i = 0; i &lt; arr1.length; i++) { arr2[i] = arr1[i]; } System.out.println(\"arr1数组为：\"); for (int i = 0; i &lt; arr1.length; i++) { System.out.print(arr1[i] + \"\\t\"); } System.out.println(); System.out.println(\"arr2数组为：\"); for (int i = 0; i &lt; arr2.length; i++) { System.out.print(arr2[i] + \"\\t\"); } }} 1234arr1数组为：10 20 30 arr2数组为：10 20 30 数组反转要求：把数组{11,22,33,44,55,66}的元素内容反转{66, 55,44,33,22,11}。 12345678910111213141516171819public class Test01 { public static void main(String[] args) { int[] arr = {11, 22, 33, 44, 55, 66}; int[] arrNew = new int[arr.length]; for (int i = 0, j = arrNew.length - 1; i &lt; arr.length; i++, j--) { arrNew[j] = arr[i]; } System.out.println(\"原数组为：\"); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + \"\\t\"); } System.out.println(); System.out.println(\"反转之后的数组为：\"); for (int i = 0; i &lt; arrNew.length; i++) { System.out.print(arrNew[i] + \"\\t\"); } }} 1234原数组为：11 22 33 44 55 66 反转之后的数组为：66 55 44 33 22 11 数组添加/扩容要求：实现动态的给数组添加元素效果，实现对数组扩容。 原始数组使用静态分配int[] arr = {1,2,3} 用户可以决定是否继续添加，添加成功，是否继续？y/n 12345678910111213141516171819202122232425262728293031public class Test01 { public static void main(String[] args) { int[] arr = {1, 2, 3}; int[] arrNew; int number; Scanner scanner = new Scanner(System.in); while (true) { System.out.println(\"请输入是否需要插入元素，y/n\"); char c = scanner.next().charAt(0); if (c == 'y') { arrNew = new int[arr.length + 1]; System.out.println(\"请输入要插入的元素：\"); number = scanner.nextInt(); for (int i = 0; i &lt; arr.length; i++) { arrNew[i] = arr[i]; } arrNew[arrNew.length - 1] = number; arr = arrNew; } else { System.out.println(\"用户主动选择退出~\"); break; } } System.out.println(\"最终的数组结果为：\"); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + \"\\t\"); } System.out.println(); }} 123456789101112请输入是否需要插入元素，y/ny请输入要插入的元素：4请输入是否需要插入元素，y/ny请输入要插入的元素：5请输入是否需要插入元素，y/nn用户主动选择退出~1 2 3 4 5 有一个数组{1， 2， 3， 4， 5}， 可以将该数组进行缩减，提示用户是否继续缩减，每次缩减最后那个元素。当只剩下最后一个元素，提示，不能再缩减。 123456789101112131415161718192021222324252627282930313233343536public class Test01 { public static void main(String[] args) { int[] arr = {1, 2, 3, 4, 5}; int[] arrNew; Scanner scanner = new Scanner(System.in); while (true) { System.out.println(\"请输入是否需要删除元素，y/n\"); char c = scanner.next().charAt(0); if (arr.length == 1) { System.out.println(\"当前数组只剩余一个元素，不能再操作，直接退出~\"); showArray(arr); break; } if (c == 'y') { arrNew = new int[arr.length - 1]; for (int i = 0; i &lt; arrNew.length; i++) { arrNew[i] = arr[i]; } arr = arrNew; showArray(arr); } else { System.out.println(\"用户主动选择退出~\"); showArray(arr); break; } } } private static void showArray(int[] arr) { System.out.println(\"当前数组结果为：\"); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + \"\\t\"); } System.out.println(); }} 123456789101112131415161718192021请输入是否需要删除元素，y/ny当前数组结果为：1 2 3 4 请输入是否需要删除元素，y/ny当前数组结果为：1 2 3 请输入是否需要删除元素，y/ny当前数组结果为：1 2 请输入是否需要删除元素，y/ny当前数组结果为：1 请输入是否需要删除元素，y/ny当前数组只剩余一个元素，不能再操作，直接退出~当前数组结果为：1 排序的介绍排序是将多个数据，依指定的顺序进行排列的过程。 内部排序指将需要处理的所有数据都加载到内部存储器中进行排序。包括(交换式排序法、选择式排序法和插入式排序法)； 外部排序数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。包括(合并排序法和直接合并排序法)。 冒泡排序法冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从后向前（从下标较大的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。 下面我们举一个具体的案例来说明冒泡法。我们将五个无序：24,69,80,57,13 使用冒泡排序法将其排成一个从小到大的有序数列。 1234567891011121314151617181920212223242526public class Test01 { public static void main(String[] args) { int[] arr = {24, 69, 80, 57, 13}; System.out.println(\"原数组为：\"); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + \"\\t\"); } System.out.println(); int temp; for (int i = 0; i &lt; arr.length - 1; i++) { for (int j = 0; j &lt; arr.length - 1 - i; j++) { if (arr[j] &gt; arr[j + 1]) { temp = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = temp; } } } System.out.println(\"冒泡排序输出的结果为：\"); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + \"\\t\"); } System.out.println(); }} 1234原数组为：24 69 80 57 13 冒泡排序输出的结果为：13 24 57 69 80 查找介绍在java 中，我们常用的查找有两种: 顺序查找SeqSearch.java 二分查找【二分法，我们放在算法讲解】 案例有一个数列：白眉鹰王、金毛狮王、紫衫龙王、青翼蝠王猜数游戏：从键盘中任意输入一个名称，判断数列中是否包含此名称【顺序查找】要求: 如果找到了，就提示找到，并给出下标值。 12345678910111213141516171819202122import java.util.Scanner;public class Test01 { public static void main(String[] args) { String[] arr = {\"白眉鹰王\", \"金毛狮王\", \"紫衫龙王\", \"青翼蝠王\"}; Scanner scanner = new Scanner(System.in); System.out.println(\"请输入你要查找的名字：\"); String findName = scanner.next(); int index = -1; for (int i = 0; i &lt; arr.length; i++) { if (arr[i].equals(findName)) { index = i; break; } } if (index == -1) { System.out.println(\"没有找到你要查找的名字。\"); } else { System.out.println(\"你要查找的名字：\" + findName + \"，已找到，其对应的数组下标为： \" + index); } }} 123请输入你要查找的名字：金毛狮王你要查找的名字：金毛狮王，已找到，其对应的数组下标为： 1 多维数组-二维数组二维数组的使用快速入门案例二维数组的每个元素是一维数组。 使用方式1：动态初始化12语法：类型[][] 数组名 = new 类型[大小][大小];例子：int[][] arr = new int[2][3]; 二维数组的内存存在形式 使用方式2：动态初始化123先声明：类型数组名[][]; TwoDimensionalArray02.java再定义(开辟空间) 数组名= new 类型[大小][大小]赋值(有默认值，比如int 类型的就是0) 使用方式3：动态初始化（列数不确定） 使用方式4：静态初始化123456定义: 类型 数组名[][] = { {值1,值2..}, {值1,值2..}, {值1,值2..} }例子: int[][] arr = {{1,1,1}, {8,8,9}, {100}};解读： 定义了一个二维数组arr arr 有三个元素(每个元素都是一维数组) 第一个一维数组有3 个元素, 第二个一维数组有3 个元素, 第三个一维数组有1 个元素 二维数组应用案例使用二维数组打印一个10 行杨辉三角。 12345678910111213141516171819202122public class Test01 { public static void main(String[] args) { int[][] arr = new int[10][]; for (int i = 0; i &lt; arr.length; i++) { arr[i] = new int[i + 1]; for (int j = 0; j &lt; arr[i].length; j++) { if (j == 0 || j == arr[i].length - 1) { arr[i][j] = 1; } else { arr[i][j] = arr[i - 1][j] + arr[i - 1][j - 1]; } } } for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; arr[i].length; j++) { System.out.print(arr[i][j] + \" \"); } System.out.println(); } }} 123456789101 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1 1 7 21 35 35 21 7 1 1 8 28 56 70 56 28 8 1 1 9 36 84 126 126 84 36 9 1 二维数组使用细节和注意事项1234567891) 一维数组的声明方式有:int[] x 或者int x[] 2) 二维数组的声明方式有:int[][] y 或者int[] y[] 或者int y[][] 3) 二维数组实际上是由多个一维数组组成的，它的各个一维数组的长度可以相同，也可以不相同。比如： map[][] 是一个二维数组。int map [][] = {{1,2},{3,4,5}}由map[0] 是一个含有两个元素的一维数组，map[1] 是一个含有三个元素的一维数组构成，我们也称为列数不等的二维数组 二维数组课堂练习本章作业已知有一个升序数组，要求插入一个元素之后，该数组仍然为升序。 1234567891011121314151617181920212223242526272829public class Test01 { public static void main(String[] args) { int[] arr = {10, 12, 45, 90}; int[] arrNew = new int[arr.length + 1]; int num = 23; int index = -1; for (int i = 0; i &lt; arr.length; i++) { if (arr[i] &gt;= num) { index = i; break; } } if (index == -1) {//说明数据应该插入最后一位 index = arr.length; } for (int i = 0, j = 0; i &lt; arrNew.length; i++) { if (index == i) { arrNew[i] = num; } else { arrNew[i] = arr[j]; j++; } } for (int i = 0; i &lt; arrNew.length; i++) { System.out.print(arrNew[i] + \" \"); } System.out.println(); }} 110 12 23 45 90 随机生成10个整数（1-100）范围内，保存到数组中。 12345678910111213141516import java.util.Random;public class Test01 { public static void main(String[] args) { int[] arr = new int[10]; Random random = new Random(); for (int i = 0; i &lt; arr.length; i++) { int num = random.nextInt(100) + 1; arr[i] = num; } for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + \" \"); } System.out.println(); }} 184 53 23 19 43 98 68 26 79 3","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://xiaofanshutu.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"cutiebambi"},{"title":"程序控制结构","slug":"程序控制结构_韩顺平","date":"2023-10-07T12:03:21.120Z","updated":"2024-01-17T23:38:10.765Z","comments":true,"path":"posts/e88088a3.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/e88088a3.html","excerpt":"","text":"程序流程控制介绍顺序控制分支控制 if-else双分支嵌套分支switch 分支结构for 循环控制(!!!)while 循环控制do..while 循环控制多重循环控制(难点! 重点!)跳转控制语句-break跳转控制语句-continue跳转控制语句-return本章作业 12345678910111213141516package chapter5.homework;public class Homework03 { public void test(int year) { if ((year % 4 == 0) &amp;&amp; (year % 100 != 0) || year % 400 == 0) { System.out.println(year + \"年是闰年\"); } else { System.out.println(year + \"年不是闰年\"); } } public static void main(String[] args) { Homework03 homework03 = new Homework03(); homework03.test(2005); }} 123456789101112131415161718192021package chapter5.homework;public class Homework06 { public void test() { int count = 0; for (int i = 1; i &lt;= 100; i++) { if (i % 5 != 0) { count++; System.out.print(i + \"\\t\"); if (count % 5 == 0) { System.out.print(\"\\n\"); } } } } public static void main(String[] args) { Homework06 homework06 = new Homework06(); homework06.test(); }} 123456789101112131415161718package chapter5.homework;public class Homework07 { public void test() { for (char i = 'a'; i &lt;= 'z'; i++) { System.out.print(i + \" \"); } System.out.println(); for (char i = 'Z'; i &gt;= 'A'; i--) { System.out.print(i + \" \"); } } public static void main(String[] args) { Homework07 homework = new Homework07(); homework.test(); }} 1234567891011121314151617181920package chapter5.homework;public class Homework08 { public void test() { double sum = 0; for (int i = 1; i &lt;= 100; i++) { if (i % 2 == 0) { sum -= 1.0 / i; } else { sum += 1.0 / i; } } System.out.println(\"结果为: \" + sum); } public static void main(String[] args) { Homework08 homework = new Homework08(); homework.test(); }} 123456789101112131415161718package chapter5.homework;public class Homework09 { public void test() { int sum = 0; for (int i = 1; i &lt;= 100; i++) { for (int j = 1; j &lt;= i; j++) { sum += j; } } System.out.println(\"总和为：\" + sum); } public static void main(String[] args) { Homework09 homework = new Homework09(); homework.test(); }}","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://xiaofanshutu.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"cutiebambi"},{"title":"运算符","slug":"运算符_韩顺平","date":"2023-10-07T12:03:20.688Z","updated":"2024-01-17T23:38:37.276Z","comments":true,"path":"posts/f29265a7.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/f29265a7.html","excerpt":"","text":"运算符介绍 算术运算符算术运算符一览 细节说明*对一个数取模，等价于a%b = a-a/bb。** 练习题假如还有 59 天放假，问：合 xx 个星期零 xx 天12345678public class App { public static void main(String[] args) { int days = 258; int weeks = days/7; int leftDays = days%7; System.out.println(days + \"天,\" + \"合\" + weeks + \"星期零\" + leftDays + \"天\"); }} 1258天,合36星期零6天 定义一个变量保存华氏温度，华氏温度转换摄氏温度的公式为：5/9*(华氏温度-100),请求出华氏温度对应的摄氏温度。[234.5]12345678public class App { public static void main(String[] args) {// 定义一个变量保存华氏温度，华氏温度转换摄氏温度的公式为：5/9*(华氏温度-100),请求出华氏温度对应的摄氏温度。[234.5] double fahrenheit = 60.8; double centigrade = 5.0 / 9 * (fahrenheit - 100); System.out.println(centigrade); }} 1-21.77777777777778 关系运算符介绍 关系运算符的结果都是布尔（boolean）类型，要么是true，要么是false。 关系运算符组成的表达式称为关系表达式。 关系运算符一览","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://xiaofanshutu.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"cutiebambi"},{"title":"变量","slug":"变量_韩顺平","date":"2023-10-07T12:03:20.216Z","updated":"2024-01-17T23:38:02.944Z","comments":true,"path":"posts/13ffbe88.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/13ffbe88.html","excerpt":"","text":"变量使用注意事项1.变量表示内存中一块存储区域，不同类型占用的空间不同。 2.该区域有自己的名称 [变量名] 和类型 [数据类型] 3.变量三要素，变量=变量名 + 变量值 + 数据类型 程序中+号的使用1.加号左右两边如果都是数字，做加法运算。 2.加号左右两边有一方为字符串，做拼接运算。 3.运算顺序，从左到右。 1System.out.println(\"hello\" + 100 + 3);//hello1003 数据类型 整数类型整数类型的分类 整数类型使用注意细节1.Java的整型默认为int类型，可以加小写l或者大写L将数字变为long类型。 2.bit，计算机中的最小存储单位。 ​ byte，计算机中的基本存储单元。 ​ 1byte = 8bit 浮点类型浮点型的分类 说明： 1.浮点数都是近似值，尾数可能丢失，造成精度损失。 2.浮点数 = 符号位 + 指数位 + 尾数位 浮点数类型使用注意细节 浮点数常量默认类型为double类型，尾部加f或者F可以变为float。 浮点型常量有两种表现形式： 十进制形式：1.23, 521.0f, .369 科学计数法形式：5.21e2$$5.21 * 10^2$$1.23e-2$$1.23/10^2$$ 通常情况下，应该使用double类型，因为double更精确。 12345678public class App { public static void main(String[] args) { double n1 = 3.123456789; float n2 = 3.123456789F; System.out.println(n1); System.out.println(n2); }} 123.1234567893.1234567 浮点数使用陷阱 2.7 和 8.1 / 3 的比较 1234567891011121314public class App { public static void main(String[] args) { double n1 = 2.7; double n2 = 8.1 / 3; System.out.println(n1 == n2);// false System.out.println(n1); System.out.println(n2); //通过Math.abs判断浮点数类型是否相等 if(Math.abs(n1 - n2) &lt; 0.00001){ System.out.println(\"这两个double类型的数据相等~\"); } }} 1234false2.72.6999999999999997这两个double类型的数据相等~ Java API文档API: Application Programming Interface应用程序编程接口 字符类型（char）案例演示123456789101112public class App { public static void main(String[] args) { char c1 = 'a'; char c2 = '\\t'; char c3 = '许'; char c4 = 97; System.out.println(c1); System.out.println(c2); System.out.println(c3); System.out.println(c4); }} 字符型使用细节 在Java中，char的本质是一个整数，默认输出Unicode码对应的字符。https://tool.chinaz.com/tools/unicode.aspx 可以直接给char赋一个整数，输出的时候，会按照对应的Unicode字符输出。（97 ==》 a） char支持运算，它相当于一个整数，因为它都有对应的Unicode码。思考：System.out.println(‘a’ + “a”); 程序运行后，会输出什么？ 123456789101112131415161718192021222324252627public class App { public static void main(String[] args) { // 在 java中，char的本质是一个整数，在默认输出时，是 unicode 码对应的字符 // 要输出对应的数字，可以(int)字符 char c1 = 97; System.out.println(c1); // a char c2 = 'a'; //输出'a' 对应的数字 System.out.println((int)c2);//97 char c3 = '许'; System.out.println((int)c3);//35768 char c4 = 35768; System.out.println(c4);//许 // char类型是可以进行运算的，相当于一个整数，因为它都对应有 Unicode 码. System.out.println('a' + 10);//107 // 课堂小测试 char c5 = 'b' + 1; System.out.println((int)c5);//99 System.out.println(c5);//c System.out.println('a' + \"a\");//aa System.out.println('a' + 1);//98 }} 字符存储细节字符型存储到计算机里面，会将字符对应的码值（整数）找出来。比如： 存储’a’ =&gt; 码值97 =&gt; 二进制（0110 0001） =&gt;存储 字符编码表 ASCII编码，一个字节表示，一共128个字符。实际上一个字节可以表示256个字符，它没有用完，只用了128个。 Unicode编码，固定大小的编码，字母和汉字统一都是占用2个字节，浪费空间。 UTF-8编码，大小可变的编码表，字母占1个字节，汉字占用3个字节。 GBK编码，可以表示汉字，而且范围比较广，字母1个字节，汉字2个字节。 GB2312编码，可以表示汉字。（GB2312 &lt; GBK） BIG5码，繁体中文，台湾，香港。 布尔类型（boolean）布尔类型也叫boolean类型，只允许取值true或者false，没有null。 在Java中，不可以使用非0或者0代替true或false。 基本数据类型转换自动类型转换 自动类型转换细节 多种类型的数据混合运算时，系统会首先自动将所有的数据转换为容量最大的那种数据类型，然后再进行计算。int + double ==&gt; 会转成double （byte，short）和char之间没有类型转换 123//当把一个具体的值赋给byte时，会先判断该值是否在byte范围内，如果在，就okbyte b1 = 10; //不报错char c1 = b1; //报错，因为byte不能转换为char byte，short，char三者运算时，会在计算时转换为int类型 自动提升原则：表达式结果的类型自动提升为操作数中最大的类型。 强制类型转换自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。有可能会造成精度损失或数据溢出。 强制类型转换细节 强制符号只针对最近的操作数，可以使用小括号来提升优先级。 12int x = (int)(3 * 3.5 + 6 * 1.5);System.out.println(x); char类型可以保存int的常量值，但是不能保存int的变量值，需要强转。 12345char c1 = 100;int i1 = 100;//char c2 = i1;//错误char c2 = (char)i1;System.out.println(c2);//100对应的字符d byte和short，char类型在进行运算时，会被当做int类型处理。 基本数据类型和String类型的转换1、基本数据类型转String类型 基本数据类型的值 + “ “ 2、String类型转基本数据类型 基本类型包装类.parse**() 3、字符串转为字符。str.charAt(0); 12345678910111213public class App { public static void main(String[] args) { String s = \"123\"; int i = Integer.parseInt(s); System.out.println(i);//123 double v = Double.parseDouble(s); System.out.println(v); byte b = Byte.parseByte(s); System.out.println(b); }} 123123123.0123 本章作业 程序阅读题，看看输出什么？ 12308 使用char类型，分别保存\\n \\t \\r \\ 1等字符，并且打印输出 123456789101112131415public class App { public static void main(String[] args) { //分别保存\\n \\t \\r \\\\ 1 等字符 char c1 = '\\n'; char c2 = '\\t'; char c3 = '\\r'; char c4 = '\\\\'; char c5 = '1'; System.out.println(c1); System.out.println(c2); System.out.println(c3); System.out.println(c4); System.out.println(c5); }} 保存两本书名，用+拼接，看效果。 保存两个性别，用+拼接，看效果。 保存两本书价格，用+拼接，看效果。 123456789101112131415public class App { public static void main(String[] args) { String s1 = \"向前一步\"; String s2 = \"你当像鸟飞往你的山\"; System.out.println(s1 + s2); char c1 = '男'; char c2 = '女'; System.out.println(c1 + c2); double d1 = 32.2; double d2 = 31.1; System.out.println(d1 + d2); }} 123向前一步你当像鸟飞往你的山5290663.300000000000004 编程实现如下效果 123456789101112public class App { public static void main(String[] args) { String name = \"bambi\"; int age = 13; char gender = '女'; int score = 99; String hobby = \"climbing\"; System.out.println(\"姓名\" + \"\\t\" + \"年龄\" + \"\\t\" + \"性别\" + \"\\t\" + \"成绩\" + \"\\t\" + \"爱好\" + \"\\n\" + name + \"\\t\" + age + \"\\t\" + gender + \"\\t\" + score + \"\\t\" + hobby); }} 用IDEA执行代码输出结果为： 用CMD执行代码输出结果为：","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://xiaofanshutu.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"cutiebambi"},{"title":"FreeMarker","slug":"Freemarker笔记","date":"2023-07-26T13:15:01.077Z","updated":"2024-01-17T23:39:03.576Z","comments":true,"path":"posts/db5fbd34.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/db5fbd34.html","excerpt":"","text":"代码：https://gitee.com/hhgs_admin/freemarkerdemo 主要内容 概述FreeMarker概念：FreeMarker是一个模板引擎，一个基于模板生成文本输出的通用工具，使用纯Java编写。 FreeMarker被设计用来生成HTML Web页面，特别是基于MVC模式的应用程序 虽然FreeMarker具有一些编程的能力，但通常由Java程序准备要显示的数据，由FreeMarker生成页面，通过模板显示准备的数据： FreeMarker不是一个Web应用框架，而适合作为Web应用框架一个组件。 FreeMarker与容器无关，因为它并不知道HTTP或Servlet；FreeMarker同样可以应用于非Web应用程序环境。 FreeMarker更适合作为Model2框架（如Struts）的视图组件，你也可以在模板中使用JSP标记库。 FreeMarker是免费的。 FreeMarker特性通用目标能够生成各种文本：HTML、XML、RTF、Java源代码等等 易于嵌入到你的产品中：轻量级；不需要Servlet环境 插件式模板载入器：可以从任何源载入模板，如本地文件、数据库等等 你可以按你所需生成文本：保存到本地文件；作为Email发送；从Web应用程序发送它返回给Web浏览器 强大的模板语言所有常用的指令：include、if/elseif/else、循环结构 在模板中创建和改变变量 几乎在任何地方都可以使用复杂表达式来指定值 命名的宏，可以具有位置参数和嵌套内容 名字空间有助于建立和维护可重用的宏库，或者将一个大工程分成模块，而不必担心名字冲突 输出转换块：在嵌套模板片段生成输出时，转换HTML转义、压缩、语法高亮等等；你可以定义自己的转换 通用数据模型FreeMarker不是直接反射到Java对象，Java对象通过插件式对象封装，以变量方式在模板中显示 你可以使用抽象（接口）方式表示对象（JavaBean、XML文档、SQL查询结果集等等），告诉模板开发者使用方法，使其不受技术细节的打扰 为Web准备在模板语言中内建处理典型Web相关任务（如HTML转义）的结构 能够集成到Model2 Web应用框架中作为JSP的替代 支持JSP标记库 为MVC模式设计：分离可视化设计和应用程序逻辑；分离页面设计员和程序员 智能的国际化和本地化字符集智能化（内部使用UNICODE） 数字格式本地化敏感 日期和时间格式本地化敏感 非US字符集可以用作标识（如变量名） 多种不同语言的相同模板 强大的XML处理能力&lt;#recurse&gt; 和&lt;#visit&gt;指令（2.3版本）用于递归遍历XML树。在模板中清楚和直觉的访问XML对象模型。开源论坛 JForum 就是使用了 FreeMarker 做为页面模板。 FreeMarker环境搭建新建Maven Web项目 配置坐标依赖和部署插件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;freemarkerdemo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;freemarkerdemo Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- freemarker 的坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.23&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet-api 的依赖--&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;freemarkerdemo&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;!-- 配置Tomcat插件 ,用于启动项目 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;!--如果不设置，则默认为猫的自定义端口，项目路径为http://localhost:默认端口/项目名 --&gt; &lt;configuration&gt; &lt;!--如果端口号改为8081：那么访问的时候路径的端口就要写成8081，否则404 --&gt; &lt;port&gt;8080&lt;/port&gt; &lt;!-- 如果设置为/，则项目了路径为http://localhost:端口号 /--&gt; &lt;!-- 如果设置为/123，则项目了路径为http://localhost:端口号/123 --&gt; &lt;path&gt;/123&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; 修改配置文君web.xml1234567891011121314151617181920212223242526272829&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;freemarker&lt;/servlet-name&gt; &lt;servlet-class&gt;freemarker.ext.servlet.FreemarkerServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!-- 模板路径--&gt; &lt;param-name&gt;TemplatePath&lt;/param-name&gt; &lt;!-- 默认在webapp 目录下查找对应的模板文件--&gt; &lt;param-value&gt;/&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;!-- 模板默认的编码--&gt; &lt;param-name&gt;default_encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;!-- 处理所有的以.ftl结尾的文件；ftl是freemarker默认的文件后缀--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;freemarker&lt;/servlet-name&gt; &lt;url-pattern&gt;*.ftl&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 编写Servlet文件 123456789101112131415161718192021package org.example.controller;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/f01\")public class FreeMarker01 extends HttpServlet { @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {// 给模板的数据 req.setAttribute(\"msg\",\"hello word\");// 请求转发到指定的页面， req.getRequestDispatcher(\"template/f01.ftl\").forward(req,resp); }} 新建模板文件ftl12345678910111213&lt;!--html注释 在浏览器中可以看到的注释--&gt;&lt;#--freemarker注释 在浏览器中不能看到的注释freemarker的语法 1，html所有的标签都适用 2，js与css的使用，与html中语法一致--&gt;&lt;#-- 获取数据--&gt;${msg} 启动项目 访问项目 FreeMarker数据类型 布尔类型1.在Servlet中设置布尔类型的数据 12//布尔类型request.setAttribute(\"flag\",true); 2.获取数据 123456789&lt;#-- 数据类型：布尔类型 在freemarker中布尔类型不能直接输出；如果输出要先转成字符串 方式一：?c 方式二：?string 或 ?string(\"true时的文本\",\"false时的文本\")--&gt;&lt;h5&gt;布尔类型&lt;/h5&gt;${flag?c} &lt;br/&gt;${flag?string} &lt;br/&gt;${flag?string(\"yes\",\"no\")} &lt;br/&gt; 日期类型1.在Servlet中设置日期类型的数据 12//日期类型request.setAttribute(\"createDate\",new Date()); 2.获取数据 12345678910111213141516171819&lt;#-- 数据类型：日期类型 在freemarker中日期类型不能直接输出；如果输出要先转成日期型或字符串 1，年月日 ?date 2,时分秒 ?time 3,年月日时分秒 ?datetime 4,制定格式 ?string(\"自定义格式\") y:年 M:月 d:日 H:时 m:分 s:秒 --&gt;&lt;h5&gt;日期类型&lt;/h5&gt;&lt;#--输出日期格式 --&gt;${createDate?date} &lt;br/&gt;&lt;#--输出时间格式 --&gt;${createDate?time} &lt;br/&gt;&lt;#--输出日期时间格式 --&gt;${createDate?datetime} &lt;br/&gt;&lt;#--输出格式化日期格式 --&gt;${createDate?string(\"yyyy年MM月dd日 HH:mm:ss\")} &lt;br/&gt; 数值类型1.在Servlet中设置数值类型的数据 1234//数值类型request.setAttribute(\"age\",18);//数值类型request.setAttribute(\"salary\",100000);//数值类型request.setAttribute(\"avg\",0.545);//浮点类型 2.获取数据 123456789101112131415161718192021&lt;#-- 数据类型：数值类型 在freemarker中数值类型可以直接输出； 1，转字符串 普通字符串 ?c 货币字符串 ?string.currency 百分比型字符串 ?string.percent 2，保留浮点型数值指定小数位（#表示一个小数位） ?string[\"0.##\"]--&gt;&lt;#-- 直接输出数值类型--&gt;${age}&lt;br/&gt;${salary}&lt;br/&gt;&lt;#-- 将数值转换成字符串输出--&gt;${salary?c}&lt;br/&gt;&lt;#--将数值转换成货币类型的字符串输出 --&gt;${salary?string.currency}&lt;br&gt;&lt;#--将数值转换为百分比的字符串--&gt;${avg?string.percent}&lt;br&gt;&lt;#--将浮点型数值保留指定小数位输出（##表示保留两位小数）--&gt;${avg?string[\"0.##\"]} &lt;br/&gt; 字符串类型1.在Servlet中设置字符串类型的数据 123//字符串类型request.setAttribute(\"msg\",\"hello\");request.setAttribute(\"msg2\",\"freemarker \"); 2.获取数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;hr&gt;&lt;#-- 数据类型：字符串类型 在freemarker中字符串类型可以直接输出； 1，截取字符串（坐闭右开） ?substring(start,end) 2,首字母小写输出 ?uncap_first 3，首字母大写输出 ?cap_first 4，字母转小写输出 ?lower_case 5，字母转大写输出 ?upper_case 6，获取字符串长度 ?length 7，是否以指定字符串开头(boolean类型) ?starts_with(\"xx\")?string 8，是否以指定字符结尾(boolean类型) ?ends_with(\"xx\")?string 9，获取指定字符的索引 ?index_of(\"xx\") 10，去除字符串前后空格 ?trim 11，替换指定字符串 ?replace(\"xx\",\"xx\")--&gt;&lt;h5&gt;字符串类型&lt;/h5&gt;${msg}--------${msg2}&lt;br&gt;${msg?string}--------${msg2?string}&lt;br&gt;&lt;#-- 1.截取字符串（坐闭右开） ?substring(start,end) --&gt;${msg?substring(0,2)} &lt;br&gt;&lt;#-- 2,首字母小写输出 ?uncap_first --&gt;${msg?uncap_first} &lt;br&gt;&lt;#--3，首字母大写输出 ?cap_first --&gt;${msg?cap_first} &lt;br&gt;&lt;#--4，字母转小写输出 ?lower_case --&gt;${msg?lower_case} &lt;br&gt;&lt;#--5，字母转大写输出 ?upper_case --&gt;${msg?upper_case} &lt;br&gt;&lt;#--6，获取字符串长度 ?length --&gt;${msg?length} &lt;br&gt;&lt;#--7，是否以指定字符串开头(boolean类型) ?starts_with(\"xx\")?string --&gt;${msg?starts_with(\"a\")?string} &lt;br&gt;&lt;#--8，是否以指定字符结尾(boolean类型) ?ends_with(\"xx\")?string --&gt;${msg?ends_with(\"o\")?string} &lt;br&gt;&lt;#--9，获取指定字符的索引 ?index_of(\"xx\") --&gt;${msg2?index_of(\"m\")} &lt;br&gt;&lt;#--10，去除字符串前后空格 ?trim --&gt;${msg2?trim} &lt;br&gt;&lt;#--11，替换指定字符串 ?replace(\"xx\",\"xx\") --&gt;${msg?replace(\"he\",\"we\")} &lt;br&gt; 字符串空值清空处理 ​ FreeMarker的变量必须赋值，否则就会抛出异常。而对FreeMarker来说，null值和不存在的变量是完全一样的，因为FreeMarker无法理解null值。 ​ FreeMarker提供两个运算符来避免空值： ​ 1 !：指定确实变量的默认值 ​ ${value！}：如果value值为空，则默认值是空字符串 ​ ${value! “默认值”}： 如果value值为空，则默认值是字符串“默认值” 2 ??： 判断变量是否存在 ​ 如果变量存在，返回true，否则返回false ​ ${(value??)?string} 1234//空数据request.setAttribute(\"str1\",null);request.setAttribute(\"str2\",\"\"); 12345678910111213141516171819&lt;hr&gt;&lt;#-- 如果值不存在，直接输出就会报错--&gt;&lt;#--${a}--&gt;&lt;#--值为null的数据也直接报错--&gt;&lt;#--${str1}--&gt;&lt;#--值为空字符串的不会报错--&gt;&lt;h5&gt;空值处理&lt;/h5&gt;空字符串：${str2}&lt;br/&gt;&lt;#-- 使用!,当值不存在时，默认显示空字符串 --&gt;感叹号：${str1!}&lt;br/&gt;&lt;#-- 使用!\"xx\",当值不存在时，默认显示指定字符串--&gt;${str1! \"str1的数不存在\"}&lt;br/&gt;&lt;#-- 使用??,判断字符串是否为空；返回布尔类型。如果想要输出，需要将布尔类型转换成字符串--&gt;${(str1??)?c}&lt;br/&gt;${(str1??)?string}&lt;br/&gt; sequence类型1.在Servlet中设置序列类型的数据 12345678910111213// 序列类型 （数组、List、Set）// 数组操作String[] stars = new String[]{\"周杰伦\",\"林俊杰\",\"陈奕迅\",\"五月天\"};request.setAttribute(\"stars\",stars);// List操作List&lt;String&gt; citys = Arrays.asList(\"上海\",\"北京\",\"杭州\",\"深圳\");request.setAttribute(\"cityList\",citys);// JavaBean集合List&lt;User&gt; userList = new ArrayList&lt;&gt;();userList.add(new User(1,\"zhangsan\",22));userList.add(new User(2,\"lisi\",18));userList.add(new User(3,\"wangwu\",20));request.setAttribute(\"userList\",userList); 2.获取数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;#-- FreeMarker 数据类型 序列类型（数组、List、Set） 通过list指令输出序列 &lt;#list 序列名 as 元素名&gt; ${元素名} &lt;/#list&gt; 获取序列的长度 ${序列名?size} 获取序列元素的下标 ${元素名?index} 获取第一个元素 ${序列名?first} 获取最后一个元素 ${序列名?last} 倒序输出 序列名?reverse 升序输出 序列名?sort 降序输出 序列名?sort?reverse 指定字段名排序 序列名?sort_by(\"字段名\") 注：一般是JavaBean集合，对应的字段名需要提供get方法--&gt;&lt;#-- 数组操作 --&gt;&lt;#list stars as star&gt; 下标：${star?index} - 姓名：${star} &lt;br&gt;&lt;/#list&gt;获取序列的长度：${stars?size} &lt;br&gt;获取第一个元素：${stars?first} &lt;br&gt;获取最后一个元素： ${stars?last} &lt;br&gt;&lt;hr&gt;&lt;#-- List操作 --&gt;&lt;#list cityList as city&gt; ${city}&lt;/#list&gt;&lt;br&gt;&lt;#--倒序输出 序列名?reverse--&gt;&lt;#list cityList?reverse as city&gt; ${city}&lt;/#list&gt;&lt;br&gt;&lt;#--升序输出 序列名?sort--&gt;&lt;#list cityList?sort as city&gt; ${city}&lt;/#list&gt;&lt;br&gt;&lt;#--降序输出 序列名?sort?reverse--&gt;&lt;#list cityList?sort?reverse as city&gt; ${city}&lt;/#list&gt;&lt;br&gt;&lt;hr&gt;&lt;#list userList as user &gt; 编号：${user.userId} &nbsp; 姓名：${user.uname} &nbsp; ${user.uage} &lt;br&gt;&lt;/#list&gt;&lt;br&gt;&lt;#list userList?sort_by(\"uage\") as user &gt;编号：${user.userId} &nbsp; 姓名：${user.uname} &nbsp; ${user.uage} &lt;br&gt;&lt;/#list&gt;&lt;br&gt;&lt;hr&gt; hash类型1.在Servlet中设置hash类型的数据 123456// Map操作Map&lt;String,String&gt; cityMap = new HashMap&lt;&gt;();cityMap.put(\"sh\",\"上海\");cityMap.put(\"bj\",\"北京\");cityMap.put(\"sz\",\"深圳\");request.setAttribute(\"cityMap\",cityMap); 2.获取数据 12345678910111213141516171819&lt;#-- &nbsp; &nbsp;数据类型：hash类型 &nbsp; &nbsp; &nbsp; &nbsp; key遍历输出 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;#list hash?keys as key&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ${key} -- ${hash[key]} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;/#list&gt; &nbsp; &nbsp; &nbsp; &nbsp; value遍历输出 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;#list hash?values as value&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ${value} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;/#list&gt;--&gt;&lt;#-- key遍历输出 --&gt;&lt;#list cityMap?keys as key&gt; &nbsp; ${key} -- ${cityMap[key]} &lt;br&gt; &lt;/#list&gt; &lt;#-- value遍历输出 --&gt;&lt;#list cityMap?values as value&gt; &nbsp; ${value} | &lt;/#list&gt; FreeMarker常见指令assign 自定义变量指令使用 assign 指令你可以创建一个新的变量， 或者替换一个已经存在的变量。 12345678910&lt;#-- assign 自定义变量指令 语法： &lt;#assign 变量名=值&gt; &lt;#assign 变量名=值 变量名=值&gt; （定义多个变量）--&gt;&lt;#assign str=\"hello\"&gt;${str} &lt;br&gt; &lt;#assign num=1 names=[\"zhangsan\",\"lisi\",\"wangwu\"] &gt;${num} -- ${names?join(\",\")} if elseif else 逻辑判断指令可以使用 if ， elseif 和 else 指令来条件判断是否满足某些条件。 123456789101112131415161718192021222324&lt;h5&gt; 2. if, else, elseif 逻辑判断指令&lt;/h5&gt;&lt;#assign score = 60&gt;&lt;#if score lt 60 &gt; &lt;h6&gt;你个小渣渣！&lt;/h6&gt; &lt;#elseif score == 80&gt; &lt;h6&gt;分不在高，及格就行！&lt;/h6&gt; &lt;#elseif score gt 60 &amp;&amp; score lt 80 &gt; &lt;h6&gt;革命尚未成功，同志仍需努力！&lt;/h6&gt; &lt;#else &gt; &lt;h6&gt;哎哟不错哦！&lt;/h6&gt;&lt;/#if&gt;&lt;#--判断数据是否存在--&gt;&lt;#assign list=\"\"&gt;&lt;#if list??&gt; 数据存在 &lt;#else &gt; 数据不存在&lt;/#if&gt;&lt;br&gt;&lt;#if list2??&gt; 数据存在&lt;#else &gt; 数据不存在&lt;/#if&gt; list 遍历指令可以使用 list 指令来对序列进行遍历。 1234567891011121314151617181920&lt;h5&gt;3. list指令&lt;/h5&gt;&lt;#assign users = [\"张三\",\"李四\",\"王五\"]&gt;&lt;#list users as user&gt; ${user} |&lt;/#list&gt;&lt;br&gt;&lt;#--判断数据不为空，再执行遍历 （如果序列不存在，直接遍历会报错）--&gt;&lt;#if users2??&gt; &lt;#list users2 as user&gt; ${user} &lt;/#list&gt;&lt;/#if&gt;&lt;br&gt;&lt;#-- 当序列没有数据项时，使用默认信息 --&gt;&lt;#assign users3 = []&gt;&lt;#list users3 as user&gt; ${user} | &lt;#else &gt; 用户数据不存在！&lt;/#list&gt; macro 自定义指令可以使用 macro 指令来自定义一些自定义指令。 123456789101112131415161718192021222324252627282930313233343536373839&lt;#-- macro 自定义指令 （宏） 1. 基本使用 格式： &lt;#macro 指令名&gt; 指令内容 &lt;/#macro&gt; 使用： &lt;@指令名&gt;&lt;/@指令名&gt; 2. 有参数的自定义指令 格式： &lt;#macro 指令名 参数名1 参数名2&gt; 指令内容 &lt;/#macro&gt; 使用： &lt;@指令名 参数名1=参数值1 参数名2=参数值2&gt;&lt;/@指令名&gt; 注： 1. 指令可以被多次使用。 2. 自定义指令中可以包含字符串，也可包含内置指令--&gt;&lt;#-- 定义基本的自定义指令 --&gt;&lt;#macro address&gt; © 1999–2015 The FreeMarker Project. All rights reserved. &lt;/#macro&gt; &lt;#-- 使用指令 --&gt;&lt;@address&gt;&lt;/@address&gt; &lt;br&gt; &lt;@address&gt;&lt;/@address&gt; &lt;hr&gt; &lt;#-- 定义有参数的自定义指令 --&gt;&lt;#macro queryUserByName uname&gt; 通过用户名查询用户信息 - ${uname} &lt;/#macro&gt; &lt;#-- 使用指令，并传递参数 --&gt;&lt;@queryUserByName uname=\"admin\"&gt;&lt;/@queryUserByName&gt; &lt;br&gt; &lt;#-- 定义有多个参数的自定义指令 --&gt;&lt;#macro queryUserByParams uname uage&gt; 通过多个餐宿查询用户信息 - ${uname} - ${uage} &lt;/#macro&gt; &lt;#-- 使用指令，并传递多个参数 --&gt;&lt;@queryUserByParams uname=\"admin\" uage=18&gt;&lt;/@queryUserByParams&gt; &lt;br&gt; &lt;hr&gt; 123456789101112131415161718192021&lt;#-- 自定义指令中包含内置指令 --&gt;&lt;#macro cfb&gt; &lt;#list 1..9 as i&gt; &lt;#list 1..i as j&gt; ${j}*${i}=${j*i}&amp;nbsp; &lt;/#list&gt; &lt;br&gt; &lt;/#list&gt; &lt;/#macro&gt; &lt;@cfb&gt;&lt;/@cfb&gt; &lt;@cfb&gt;&lt;/@cfb&gt; &lt;#-- 动态数据 --&gt;&lt;#macro cfb2 num&gt; &lt;#list 1..num as i&gt; &lt;#list 1..i as j&gt; ${j}*${i}=${j*i}&amp;nbsp; &lt;/#list&gt; &lt;br&gt; &lt;/#list&gt; &lt;/#macro&gt; &lt;@cfb2 num=5&gt;&lt;/@cfb2&gt; nested 占位指令nested 指令执行自定义指令开始和结束标签中间的模板片段。嵌套的片段可以包含模板中任意合法的内容。 1234567891011&lt;#-- nested 占位指令 nested 相当于占位符,一般结合macro指令一起使用。 可以将自定义指令中的内容通过nested指令占位，当使用自定义指令时，会将占位内容显示。--&gt;&lt;#macro test&gt; 这是一段文本！ &lt;#nested&gt; &lt;#nested&gt; &lt;/#macro&gt; &lt;@test&gt;&lt;h4&gt;这是文本后面的内容！&lt;/h4&gt;&lt;/@test&gt; import 导入指令import 指令可以引入一个库。也就是说，它创建一个新的命名空间， 然后在那个命名空间中执行给定路径的模 板。可以使用引入的空间中的指令。 创建commons.ftl文件12345678&lt;#macro cfb&gt; &lt;#list 1..9 as i&gt; &lt;#list 1..i as j&gt; ${j}*${i}=${j*i}&amp;nbsp; &lt;/#list&gt; &lt;br&gt; &lt;/#list&gt; &lt;/#macro&gt; 在其他ftl页面中通过import导入commons.ftl的命名空间，使用该命名空间中的指令 创建test.ftl文件1234&lt;#-- 导入命名空间 --&gt;&lt;#import \"commons.ftl\" as common&gt; &lt;#-- 使用命名空间中的指令 --&gt;&lt;@common.cfb&gt;&lt;/@common.cfb&gt; 创建Controller1234567891011121314151617181920212223242526package org.example.controller;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @author liyonghui * @description Freemarker常用指令 * @date 2022/12/20 14:05 */@WebServlet(\"/f04\")public class FreeMarker04 extends HttpServlet { @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {// 请求转发到指定的页面， req.getRequestDispatcher(\"template/test.ftl\").forward(req, resp); }} include 包含指令可以使用 include 指令在你的模板中插入另外一个 FreeMarker 模板文件 。 被包含模板的输出格式是在 include 标签出现的位置插入的。 被包含的文件和包含它的模板共享变量，就像是被复制粘贴进去的一样。 1234567&lt;#--包含指令(引入其他页面文件) include--&gt;&lt;#--html文件--&gt;&lt;#include \"test.html\"&gt; &lt;#--freemarker文件--&gt;&lt;#include \"test.ftl\"&gt; &lt;#--text文件--&gt;&lt;#include \"test.txt\"&gt; FreeMarker页面静态化通过上述介绍可知 Freemarker 是一种基于模板的、用来生成输出文本的通用工具,所以 我们必须要定制符合自己业务的模板，然后生成自己的 html 页面。Freemarker 是通过 freemarker.template.Confifiguration 这个对象对模板进行加载的（它也处理创建和缓存预 解析模板的工作），然后我们通过 getTemplate 方法获得你想要的模板，有一点要记住 freemarker.template.Confifiguration 在你整个应用必须保证唯一实例。 定义模板创建news.ftl模板文件 1234567891011121314151617181920&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;#-- freemaeker模板中设置编码格式，否则中文可能乱码 --&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html;charset=UTF-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;#-- 新闻标题 --&gt; &lt;h2 align=\"center\"&gt;${title}&lt;/h2&gt; &lt;#-- 新闻来源 和 发布时间 --&gt; &lt;p align=\"center\"&gt; 新闻来源：${source} &amp;nbsp;&amp;nbsp; 发布时间：${pubTime} &lt;/p&gt; &lt;#-- 新闻内容 --&gt; &lt;p style=\"text-indent: 2em\"&gt; ${content} &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 加载模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.xxxx.servlet;import freemarker.template.Configuration;import freemarker.template.Template;import freemarker.template.TemplateException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.FileWriter;import java.io.IOException;import java.util.HashMap;import java.util.Map;@WebServlet(\"/news\")public class NewsServlet extends HttpServlet { @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 实例化模板对象 Configuration configuration = new Configuration(); // 设置加载模板的上下文 以及加载模板的路径 （模板存放路径） configuration.setServletContextForTemplateLoading(getServletContext(),\"/template\"); // 设置模板的编码格式 configuration.setDefaultEncoding(\"UTF-8\"); // 加载模板文件 获取模板对象 Template template = configuration.getTemplate(\"news.ftl\"); // 设置数据模型 Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"title\",\"【战“疫”说理】良好的公民素养和国民心态是“硬核”力量\"); map.put(\"source\",\"经济日报-中国经济网\"); map.put(\"pubTime\",\"2020年03月16日 10:00\"); map.put(\"content\",\"公共性的社会大事件，是检验和透视公民素养和国民心态的一个重要窗口。\" + \"在突袭而至的新冠肺炎疫情面前，一方面，抗击疫情的过程就是淬炼公民素养和国民心态的熔炉；另一方面，良好的公民素养和国民心态也是疫情防控的“硬核”力量，更是推动战“疫”积极向好态势不断拓展的精神之盾。\\n\" + \"\\n疫情防控，既是大战，也是大考。涵养良好的公民素养和国民心态，是疫情期间摆在我们面前的考题，同时也是提升国家治理能力过程中需要面对的课题。\\n\" + \"\\n着眼三个方面 提升科学素养\\n\\n疫情面前，每个人都是防控链条中的重要一环。做好自我保护，既是对自己、家人负责，也是对社会负责。有效做好科学防控，每个人都应具备必要的科学素养。\"); // 获取项目的根目录 String basePath = req.getServletContext().getRealPath(\"/\"); // 设置html的存放路径 File htmlFile = new File(basePath + \"/html\"); // 判断文件（目录）是否存在 if (!htmlFile.exists()) { // 如果文件目录不存在，则新建文件目录 htmlFile.mkdir(); } // 得到生成的文件名 （生成随机不重复的文件名） String fileName = System.currentTimeMillis() + \".html\"; // 创建html文件 File file = new File(htmlFile,fileName); // 获取文件输出流 FileWriter writer = new FileWriter(file); // 生成html （将数据模型填充到模板中） try { template.process(map,writer); } catch (TemplateException e) { e.printStackTrace(); } finally { // 关闭资源 writer.flush(); writer.close(); } }} 生成对应的html文件浏览器地址栏输入： http://localhost:8989/news 生成的文件存放在当前项目的webapp目录下的html目录中。 FreeMarker运算符算术运算符123456789101112&lt;!-- 算术运算 +、-、*、/、%--&gt;&lt;#assign a1 = 8 a2 = 2 &gt;${a1} + ${a2} = ${a1 + a2} &lt;br/&gt;${a1} - ${a2} = ${a1 - a2} &lt;br/&gt;${a1} * ${a2} = ${a1 * a2} &lt;br/&gt;${a1} / ${a2} = ${a1 / a2} &lt;br/&gt;${a1} % ${a2} = ${a1 % a2} &lt;br/&gt;&lt;!--字符串运算--&gt;${\"hello\" + \",\" + \"freemarker\"} 逻辑运算符1234&lt;#-- 逻辑运算符 &amp;&amp;、||、!--&gt; 比较运算符123456789&lt;#-- 比较运算符 &gt; (gt): 大于号，推荐使用 gt &lt; (lt)： 小于号，推荐使用 lt &gt;= (gte): 大于等于， 推荐是用 gte &lt;= (lte): 小于等于，推荐使用 lte == ： 等于 != : 不等于--&gt; 空值运算符1234567891011&lt;#-- 空值运算符 1. ??:判断是否为空，返回布尔类型 如果不为空返回 false， 如果为空返回 true，不能直接输出 ${(name??)?string} 2. !: 设置默认值，如果为空，则设置默认值 1. 设置默认为空字符串： ${name!} 2. 设置指定默认值 ${name!'zhangsan'}--&gt;","categories":[{"name":"新技术FreeMarker","slug":"新技术FreeMarker","permalink":"https://xiaofanshutu.github.io/categories/%E6%96%B0%E6%8A%80%E6%9C%AFFreeMarker/"}],"tags":[],"author":"cutiebambi"},{"title":"Java概述","slug":"Java概述_韩顺平","date":"2023-04-29T01:07:41.762Z","updated":"2024-01-17T23:39:26.828Z","comments":true,"path":"posts/1113d944.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/1113d944.html","excerpt":"","text":"如何快速学习一个知识点 转义字符1234567// 在控制台，输入 tab 键，可以实现命令补全 \\t ：一个制表位，实现对齐的功能\\n ：换行符\\\\ ：一个\\\\\" :一个\"\\' ：一个' \\r :一个回车 12345678910111213141516171819202122232425262728//转义字符练习public class App { //编写一个 main 方法 public static void main(String[] args) { //\\t ：一个制表位，实现对齐的功能 System.out.println(\"北京\\t天津\\t上海\"); // \\n ：换行符 System.out.println(\"jack\\nsmith\\nmary\"); // \\\\ ：一个\\ System.out.println(\"C:\\\\Windows\\\\System32\\\\cmd.exe\"); // \\\" :一个\" System.out.println(\"你好呀，\\\"bambi\\\"\"); // \\' ：一个' System.out.println(\"你好呀，\\'bambi\\'\"); // \\r :一个回车 System.out.println(\"你好呀\\r明天\"); // 解读 // 1. 输出 你好呀 // 2. \\r 表示回车 System.out.println(\"你好呀\\r明天\"); }} 12345678910d:\\desktop&gt;java App北京 天津 上海jacksmithmaryC:\\Windows\\System32\\cmd.exe你好呀，\"bambi\"你好呀，'bambi'明天呀明天呀 Java代码规范_行尾风格 DOS（Disk Operating System 磁盘操作系统）命令DOS介绍 相对路径 &amp; 绝对路径 常用DOC命令1234567891011121314151.查看当前目录是有什么内容 dir dir dir d:\\abc2\\test2002.切换到其他盘下：盘符号 cd : change directory 案例演示： 切换到 c 盘 cd /D c: 3.切换到当前盘的其他目录下 (使用相对路径和绝对路径演示), ..\\表示上一级目录 案例演示： cd d:\\abc2\\test200 cd ..\\..\\abc2\\test200 4.切换到上一级： 案例演示： cd .. 5.切换到根目录：cd \\ 案例演示：cd \\6.查看指定的目录下所有的子级目录 tree7.清屏 cls8.退出 DOS exit","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaofanshutu.github.io/categories/Java/"}],"tags":[],"author":"cutiebambi"},{"title":"重要信息记录","slug":"重要信息记录","date":"2023-04-29T01:07:41.762Z","updated":"2024-01-17T23:38:41.448Z","comments":true,"path":"posts/e179e6d6.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/e179e6d6.html","excerpt":"","text":"重要学习网站https://pdai.tech/md/about/me/about-me.html 需要学习的知识 Javascript Java Spring Boot HTML 数据库 集合 并发","categories":[{"name":"日常","slug":"日常","permalink":"https://xiaofanshutu.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[],"author":"cutiebambi"},{"title":"面试题总结","slug":"面试","date":"2023-04-29T01:07:41.762Z","updated":"2024-01-17T23:38:25.743Z","comments":true,"path":"posts/5c3dbcbd.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/5c3dbcbd.html","excerpt":"","text":"Java基础语法基础String、StringBuffer与StringBuilder的区别？Stringfinal修饰的，不可变，每次操作都会产生一个新的String对象。 12public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence StringBuffer线程安全的 123public final class StringBuffer extends AbstractStringBuilder implements java.io.Serializable, CharSequence 12345678910111213141516171819@Overridepublic synchronized StringBuffer append(Object obj) { toStringCache = null; super.append(String.valueOf(obj)); return this;}@Overridepublic synchronized StringBuffer append(String str) { toStringCache = null; super.append(str); return this;}public synchronized StringBuffer append(StringBuffer sb) { toStringCache = null; super.append(sb); return this;} StringBuilder线程不安全的 123public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence 总结性能：StringBuilder &gt; StringBuffer &gt; String 如果经常需要改变字符串的内容，需要使用除String之外的两个类。 平时工作中，优先使用StringBuilder，如果是多线程环境，并且这个变量是共享变量时，使用StringBuffer。 开发框架和中间件Spring什么是Spring框架？列举一些重要的Spring模块？什么是IOC? 如何实现的？什么是AOP? 有哪些AOP的概念？AOP 有哪些应用场景？有哪些AOP Advice通知的类型？AOP 有哪些实现方式？谈谈你对CGLib的理解？Spring AOP和AspectJ AOP有什么区别？Spring中的bean的作用域有哪些？Spring中的单例bean的线程安全问题了解吗？Spring中的bean生命周期？说说自己对于Spring MVC的了解？Spring MVC的工作原理了解嘛？Spring框架中用到了哪些设计模式？@Component和@Bean的区别是什么？将一个类声明为Spring的bean的注解有哪些？Spring事务管理的方式有几种？Spring事务中的隔离级别有哪几种？Spring事务中有哪几种事务传播行为？Bean Factory和ApplicationContext有什么区别？如何定义bean的范围？可以通过多少种方式完成依赖注入？Spring Boot什么是SpringBoot？为什么使用SpringBoot？Spring、Spring MVC和SpringBoot有什么区别？SpringBoot自动配置的原理?Spring Boot的核心注解是哪些？他主由哪几个注解组成的？SpringBoot的核心配置文件有哪几个？他们的区别是什么？什么是Spring Boot Starter？有哪些常用的？spring-boot-starter-parent有什么作用？如何自定义Spring Boot Starter？为什么需要spring-boot-maven-plugin？SpringBoot 打成jar和普通的jar有什么区别？如何使用Spring Boot实现异常处理？SpringBoot 实现热部署有哪几种方式？Spring Boot中的监视器是什么？Spring Boot 可以兼容老 Spring 项目吗？Spring SecurityMyBatisJPA日志框架Tomcat","categories":[{"name":"八股文","slug":"八股文","permalink":"https://xiaofanshutu.github.io/categories/%E5%85%AB%E8%82%A1%E6%96%87/"}],"tags":[],"author":"cutiebambi"},{"title":"马士兵","slug":"马士兵","date":"2023-04-29T01:07:41.762Z","updated":"2024-01-17T23:38:21.012Z","comments":true,"path":"posts/fc27ae96.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/fc27ae96.html","excerpt":"","text":"Java基础Java是什么类型的语言？简单说说Java中对象如何拷贝？伪代码快速实现深拷贝？什么是Object？有哪些常用的方法？怎么创建对象？notify方法为什么唤醒线程的方法是在object里面？不是应该在线程Thread里面吗？ 多态，面向接口编程?聊聊你的认知 制定标准 提高可扩展性 让你设计一个接口，你会考虑到什么点？ 最小隔离 接口和抽象类的区别？ 什么是内部类，说说你的理解以及实战场景HashMap里面有大量的内部类，匿名内部类，局部内部类等等，下来自己看一下 说说static和final在Java中的意义static不能修饰局部变量，static字段和static代码块谁先加载 如果子类里面有static，那么先加载子类还是先加载父类 Java中的基本数据类型占多少个字节，不同的操作系统一样吗？这个是JVM来决定的。不同操作系统占的字节一样，只不过占的空间不一样 int和Integer有什么关联？为什么需要Integer？装箱拆箱为什么需要8种包装类型？因为java是面向对象的语言 String, StringBuffer,StringBuilder的区别，以及String的常用方法？什么是序列化，反序列化，说说运用场景？反序列化的不安全问题如何解决？ 应用场景： dubbo RTC手写自己的rpc框架里面 数组有length()方法吗？构造器是否可以被重写？构造器不可以 char是否可以存储一个汉字可以 字符集和字符编码，解决乱码必学 集合原理系列ArrayList LinkedList： queue Deque 为什么现在舍弃Vector？ HashSet TreeSet HashMap TreeMap LinkedMap（有序） queue 阻塞队列 add remove element offer poll peek take Enumeration接口和Iterator接口的区别有哪些？Enumeration速度是迭代器的两倍，但是遍历的时候不能改里面的东西 异常异常是用来干嘛的？也是一种代码分支的实现方式 什么是事务？为什么需要事务？如何实现事务？事务隔离级别？java事务类型有几种？ jdbc事务 jta事务 容器事务 java修饰符以及各自的作用范围public protect 缺省 private linux什么是linux？如何安装使用linux 说说你常用的linux查看文件和文件夹的命令 如何递归删除文件夹和所有文件 如何拷贝，移动一个文件 如何查找一个文件 你还使用过哪些常用的linux命令 grep是什么命令？man是什么命令？ chmod是什么命令？如何使用？r,w,x/u,g,o/+,-/1,2,4各自代表什么含义？？ VI，VIM是什么？说说你常用的VI命令和按键 netstat命令的作用？如何使用？ kill命令如何使用？ ps和grep各自作用是什么？如何使用？ 如何部署自己的项目到linux服务器？ 什么是编辑视图，预览视图？ Java Web","categories":[{"name":"八股文","slug":"八股文","permalink":"https://xiaofanshutu.github.io/categories/%E5%85%AB%E8%82%A1%E6%96%87/"}],"tags":[],"author":"cutiebambi"},{"title":"Java网络编程","slug":"Java网络编程","date":"2023-04-29T01:07:41.747Z","updated":"2024-01-17T23:40:13.558Z","comments":true,"path":"posts/81e7b834.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/81e7b834.html","excerpt":"","text":"网络编程概述 计算机网络：计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。 网络编程的目的：传播交流信息，数据交换 想要实现网络编程需要什么？：IP和端口号 网络编程C/S 最新类的机器人 Java WebB/S 网络通信的要素 如何实现网络通信？ 地址 IP 端口号 规则：网络通信的协议 小结： 网络编程中的两个主要问题 如何准确定位到网络上的一台或者多台主机 找到主机之后如何进行通信 网络编程中的要素： IP和端口号 网络通信协议UDP/TCP 万物皆对象 IP 唯一定位一台网络上的计算机 127.0.0.1： 本机localhost ip地址的分类 IPV4/IPV6 IPV4：127.0.0.1，4个字节组成，每一个字节0~255，全球总共42亿个，30亿在北美，亚洲只有4亿。2011年用尽了。 IPV6：128位，8个无符号整数 公网（互联网）/ 私网（局域网） ABCD类地址 域名 练习：测试InetAddress的常用方法端口端口表示计算机上的一个程序的进程 不同的进程有不同的端口号，用来区分软件 0~65535 TCP/UDP: 65535*2。tcp:80 udp:80 单个协议下，端口号不能冲突 分类 公有端口： 0~1023 HTTP: 80 HTTPS: 443 FTP: 21 Telent: 23 程序注册端口：1024~49151，分配用户或者程序 Tomcat: 8080 MySQL: 3306 Oracle: 1521 动态/私有：49152~65535 小技巧 12345678910#查看所有的端口netstat -ano#查看指定端口netstat -ano|findStr \"7890\"#查看指定端口的进程tasklist|findStr \"3972\"#打开任务管理器的快捷键 Ctrl + Shift + Esc 端口映射 练习：学习InetSocketAddress常用方法通信协议协议就是一种约定 TCP/IP协议簇重要： TCP：用户传输协议 UDP：用户数据报协议 有名的协议： TCP： IP：网络互连协议 TCP/IP参考模型 TCP/UDP对比 TCP：打电话 连接，稳定 三次握手，四次挥手 123456789最少需要三次，保证稳定连接A:你瞅啥？B:瞅你咋地？A:干一场A:我要走了B:你真的要走了吗？B:你真的真的要走了吗？A:我真的要走了 客户端，服务端 传输完成，释放连接，效率低 UDP：发短信 不连接，不稳定 客户端，服务端：没有明确的界限 不管有没有准备好，都可以发给你 导弹 DDOS：洪水攻击（饱和攻击）","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://xiaofanshutu.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"cutiebambi"},{"title":"注解和反射","slug":"注解和反射","date":"2023-04-29T01:07:41.747Z","updated":"2024-01-17T23:38:48.912Z","comments":true,"path":"posts/a974f5b0.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/a974f5b0.html","excerpt":"","text":"注解入门什么是注解？ Annotation是从JDK5.0开始引入的新技术。 Annotation的作用 不是程序本身，可以对程序作出解释（这一点和注释没有什么区别） 可以被其他程序（比如：编译器）读取 Annotation的格式 “@注释名”，还可以有一些参数。例如@SuppressWarnings(value = “all”) Annotation可以在哪些地方使用？1@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE}) 内置注解@Override这个只适用于修饰方法，表示一个方法打算重写超类中的另一个方法 1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override {} @Deprecated这个可以用于修饰构造函数，方法，属性，包等，表示不推荐使用 12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})public @interface Deprecated {} @SuppressWarnings12345@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings { String[] value();} 元注解 元注解的作用就是负责注解其他注解，Java定义了4个标准的meta-annotation。可以在java.lang.annotation包中找到它们。 @Target 用于描述注解的使用范围（即：被描述的注解可以用在什么地方） 123456789101112@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target { /** * Returns an array of the kinds of elements an annotation type * can be applied to. * @return an array of the kinds of elements an annotation type * can be applied to */ ElementType[] value();} @Retention 表示需要在什么级别保存该注释信息，用于描述注解的生命周期 12345678910@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Retention { /** * Returns the retention policy. * @return the retention policy */ RetentionPolicy value();} @Documented 说明该注解将被包含在Javadoc中，Source &lt; Class &lt; Runtime 12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Documented {} @Inherited 说明子类可以继承父类中的该注解 12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Inherited {} 自定义注解使用@interface自定义注解的时候，会自动继承java.lang.Annotation接口 12345678910111213141516171819202122package com.cutiebambi.annotation;public class Test01 { @myAnnotation(value = {\"你好\",\"明天\"}) public static void main(String[] args) { }}//格式：public @interface 注解名 {自定义内容}@interface myAnnotation{ //每一个方法实际上是声明了一个配置参数。 //方法的名称就是参数的名称。 //返回值类型就是参数的类型（返回值只能是基本类型，Class，String， Enum） //如果只有一个参数成员，一般会将参数名命名为value String[] value(); //可以通过default来声明参数的默认值 //常使用空字符串，0作为默认值 int age() default 0; String name() default \"\";} Java反射机制概述动态语言 vs 静态语言动态语言 是一类在运行时可以改变其结构的语言：例如新的函数，对象，甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说：就是在运行时代码可以根据某些条件改变自身结构。 主要的动态语言：Object-C, C#, JavaScript, PHP, Python 静态语言 运行时结构不可以改变的语言。Java， C，C++ Java不是动态语言，但是Java可以称为“准动态语言”。即Java具有一定的动态性，可以利用反射机制获得类似动态语言的特性。 Java Reflection1Class c = Class.forName(\"java.lang.String\") 加载完类之后，在堆内存的方法区就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。 Java反射机制提供的功能 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时获取泛型信息 在运行时调用任意一个对象的成员变量和方法 处理注解 生成动态代理 Java反射的优点和缺点优点 可以动态创建对象和编译，体现出很大的灵活性 缺点 对性能有影响。使用反射基本上是一个解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。 理解Class类并获取Class实例Class类在Object类中定义了以下方法，此方法将被所有子类继承。此方法的返回值的类型是一个Class类，此类是Java反射的源头，实际上所谓反射：从程序的运行结果来看也很好理解，即：可以通过对象反射求出类的名称。 1public final native Class&lt;?&gt; getClass(); Class类是Reflection的根源，针对任何你想动态加载，运行的类，唯有先获取相应的Class对象。 获取Class类的实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.cutiebambi.annotation;public class Test02 { public static void main(String[] args) throws ClassNotFoundException { Person person = new Student(\"嘻嘻\",1); //获取Class类的几种方式 //1.通过对象获取 Class c1 = person.getClass(); System.out.println(c1.hashCode()); //2.通过forName获取 Class&lt;?&gt; c2 = Class.forName(\"com.cutiebambi.annotation.Student\"); System.out.println(c2.hashCode()); //3.通过类名.class获取 Class&lt;Student&gt; c3 = Student.class; System.out.println(c3.hashCode()); //4.基本内置类型的包装类都有一个TYPE属性，可以用来获取对应的Class类 Class&lt;Integer&gt; c4 = Integer.TYPE; //5.获取父类类型 c1.getSuperClass Class c5 = c1.getSuperclass(); System.out.println(c5.hashCode()); }}class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }}class Student extends Person{ public Student(String name, int age) { super(name, age); System.out.println(\"学生\"); }}class Teacher extends Person{ public Teacher(String name, int age) { super(name, age); System.out.println(\"老师\"); }} 哪些类型可以有Class对象 Key Info class 外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类 interface 接口 [] 数组 enum 枚举 annotation 注解@interface primitive type 基本数据类型 void 123456789101112131415161718192021222324252627282930package com.cutiebambi.annotation;import java.util.Map;//所有类型的classpublic class Test03 { public static void main(String[] args) { Class c1 = Object.class; Class c2 = Class.class; Class c3 = ArrayIndexOutOfBoundsException.class; Class c4 = Map.class; Class c5 = int[].class; Class c6 = int[][].class; Class c7 = Enum.class; Class c8 = Override.class; Class c9 = double.class; Class c10 = void.class; System.out.println(\"c1===&gt;\" + c1); System.out.println(\"c2===&gt;\" + c2); System.out.println(\"c3===&gt;\" + c3); System.out.println(\"c4===&gt;\" + c4); System.out.println(\"c5===&gt;\" + c5); System.out.println(\"c6===&gt;\" + c6); System.out.println(\"c7===&gt;\" + c7); System.out.println(\"c8===&gt;\" + c8); System.out.println(\"c9===&gt;\" + c9); System.out.println(\"c10==&gt;\" + c10); }} 12345678910c1===&gt;class java.lang.Objectc2===&gt;class java.lang.Classc3===&gt;class java.lang.ArrayIndexOutOfBoundsExceptionc4===&gt;interface java.util.Mapc5===&gt;class [Ic6===&gt;class [[Ic7===&gt;class java.lang.Enumc8===&gt;interface java.lang.Overridec9===&gt;doublec10==&gt;void 测试类什么时候会初始化主动引用（一定会发生类的初始化） new一个类的对象 使用java.lang.reflect包的方法对类进行反射调用 调用类的静态成员（除了final方法）和静态方法 当虚拟机启动，先初始化main方法所在的类 当初始化一个类，如果其父类没有初始化，则先会初始化它的父类 被动引用（不会发生类的初始化） 当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化 通过数组定义类引用，不会触发此类的初始化 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.cutiebambi.annotation;public class Test04 { static{ //当虚拟机启动，先初始化main方法所在的类 System.out.println(\"Main方法所在的类初始化\"); } public static void main(String[] args) throws ClassNotFoundException { //主动引用1：new一个类的对象 //Cat cat = new Cat(); //主动引用2：使用java.lang.reflect包的方法对类进行反射调用 //Class.forName(\"com.cutiebambi.annotation.Cat\"); //主动引用3：调用类的静态成员（除了final方法）和静态方法 //String boun = Cat.BOUN; //被动引用1：当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化 //String prem = Cat.PREM; //被动引用2：通过数组定义类引用，不会触发此类的初始化 //Cat[] cats = new Cat[10]; //被动引用3：引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了） String finalstr = Cat.FINALSTR; }}class Animal{ public static String PREM = \"prem\"; private String name; private int age; static{ //当初始化一个类，如果其父类没有初始化，则先会初始化它的父类 System.out.println(\"Animal类初始化\"); }}class Cat extends Animal{ public static String BOUN = \"boun\"; public final static String FINALSTR = \"eazin\"; static{ System.out.println(\"Cat类初始化\"); }} 1234567891011121314//主动引用1：new一个类的对象//主动引用2：使用java.lang.reflect包的方法对类进行反射调用//主动引用3：调用类的静态成员（除了final方法）和静态方法Main方法所在的类初始化Animal类初始化Cat类初始化//被动引用1：当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化Main方法所在的类初始化Animal类初始化//被动引用2：通过数组定义类引用，不会触发此类的初始化//被动引用3：引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）Main方法所在的类初始化 类的加载与ClassLoader类加载器的作用类加载的作用：将class文件字节码内容加载到内存，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象。 类加载器分为哪几种类型？ 12345678910111213141516171819202122232425262728293031package com.cutiebambi.annotation;public class Test05 { public static void main(String[] args) throws ClassNotFoundException { //获取系统类的加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); System.out.println(systemClassLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2 //获取系统类的父类加载器-扩展类加载器 ClassLoader parent = systemClassLoader.getParent(); System.out.println(parent);//sun.misc.Launcher$ExtClassLoader@85ede7b //获取扩展类加载器的父类加载器-根加载器 ClassLoader parent1 = parent.getParent(); System.out.println(parent1);//null //测试当前类是由哪个类加载器加载的 Class aClass = Class.forName(\"com.cutiebambi.annotation.Test05\"); ClassLoader classLoader = aClass.getClassLoader(); System.out.println(classLoader); //测试JDK内部类是由哪个类加载器加载的 Class&lt;?&gt; aClass1 = Class.forName(\"java.lang.Object\"); ClassLoader classLoader1 = aClass1.getClassLoader(); System.out.println(classLoader1); //如何获取系统类加载器可以加载的路径信息 String property = System.getProperty(\"java.class.path\"); System.out.println(property); }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869sun.misc.Launcher$AppClassLoader@18b4aac2sun.misc.Launcher$ExtClassLoader@85ede7bnullsun.misc.Launcher$AppClassLoader@18b4aac2nullD:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\charsets.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\deploy.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\ext\\access-bridge-64.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\ext\\cldrdata.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\ext\\dnsns.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\ext\\jaccess.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\ext\\jfxrt.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\ext\\localedata.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\ext\\nashorn.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\ext\\sunec.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\ext\\sunjce_provider.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\ext\\sunmscapi.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\ext\\sunpkcs11.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\ext\\zipfs.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\javaws.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\jce.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\jfr.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\jfxswt.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\jsse.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\management-agent.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\plugin.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\resources.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\rt.jar;D:\\xudan\\summergoon\\202209_springboot\\springboot-03-web\\target\\classes;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\boot\\spring-boot-starter-web\\2.7.4\\spring-boot-starter-web-2.7.4.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\boot\\spring-boot-starter\\2.7.4\\spring-boot-starter-2.7.4.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\boot\\spring-boot\\2.7.4\\spring-boot-2.7.4.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\boot\\spring-boot-autoconfigure\\2.7.4\\spring-boot-autoconfigure-2.7.4.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\boot\\spring-boot-starter-logging\\2.7.4\\spring-boot-starter-logging-2.7.4.jar;C:\\Users\\cutiebambi\\.m2\\repository\\ch\\qos\\logback\\logback-classic\\1.2.11\\logback-classic-1.2.11.jar;C:\\Users\\cutiebambi\\.m2\\repository\\ch\\qos\\logback\\logback-core\\1.2.11\\logback-core-1.2.11.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\apache\\logging\\log4j\\log4j-to-slf4j\\2.17.2\\log4j-to-slf4j-2.17.2.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\apache\\logging\\log4j\\log4j-api\\2.17.2\\log4j-api-2.17.2.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\slf4j\\jul-to-slf4j\\1.7.36\\jul-to-slf4j-1.7.36.jar;C:\\Users\\cutiebambi\\.m2\\repository\\jakarta\\annotation\\jakarta.annotation-api\\1.3.5\\jakarta.annotation-api-1.3.5.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\yaml\\snakeyaml\\1.30\\snakeyaml-1.30.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\boot\\spring-boot-starter-json\\2.7.4\\spring-boot-starter-json-2.7.4.jar;C:\\Users\\cutiebambi\\.m2\\repository\\com\\fasterxml\\jackson\\core\\jackson-databind\\2.13.4\\jackson-databind-2.13.4.jar;C:\\Users\\cutiebambi\\.m2\\repository\\com\\fasterxml\\jackson\\core\\jackson-annotations\\2.13.4\\jackson-annotations-2.13.4.jar;C:\\Users\\cutiebambi\\.m2\\repository\\com\\fasterxml\\jackson\\core\\jackson-core\\2.13.4\\jackson-core-2.13.4.jar;C:\\Users\\cutiebambi\\.m2\\repository\\com\\fasterxml\\jackson\\datatype\\jackson-datatype-jdk8\\2.13.4\\jackson-datatype-jdk8-2.13.4.jar;C:\\Users\\cutiebambi\\.m2\\repository\\com\\fasterxml\\jackson\\datatype\\jackson-datatype-jsr310\\2.13.4\\jackson-datatype-jsr310-2.13.4.jar;C:\\Users\\cutiebambi\\.m2\\repository\\com\\fasterxml\\jackson\\module\\jackson-module-parameter-names\\2.13.4\\jackson-module-parameter-names-2.13.4.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\boot\\spring-boot-starter-tomcat\\2.7.4\\spring-boot-starter-tomcat-2.7.4.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\apache\\tomcat\\embed\\tomcat-embed-core\\9.0.65\\tomcat-embed-core-9.0.65.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\apache\\tomcat\\embed\\tomcat-embed-el\\9.0.65\\tomcat-embed-el-9.0.65.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\apache\\tomcat\\embed\\tomcat-embed-websocket\\9.0.65\\tomcat-embed-websocket-9.0.65.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\spring-web\\5.3.23\\spring-web-5.3.23.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\spring-beans\\5.3.23\\spring-beans-5.3.23.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\spring-webmvc\\5.3.23\\spring-webmvc-5.3.23.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\spring-aop\\5.3.23\\spring-aop-5.3.23.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\spring-context\\5.3.23\\spring-context-5.3.23.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\spring-expression\\5.3.23\\spring-expression-5.3.23.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\boot\\spring-boot-starter-thymeleaf\\2.7.4\\spring-boot-starter-thymeleaf-2.7.4.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\thymeleaf\\thymeleaf-spring5\\3.0.15.RELEASE\\thymeleaf-spring5-3.0.15.RELEASE.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\thymeleaf\\thymeleaf\\3.0.15.RELEASE\\thymeleaf-3.0.15.RELEASE.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\attoparser\\attoparser\\2.0.5.RELEASE\\attoparser-2.0.5.RELEASE.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\unbescape\\unbescape\\1.1.6.RELEASE\\unbescape-1.1.6.RELEASE.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\slf4j\\slf4j-api\\1.7.36\\slf4j-api-1.7.36.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\thymeleaf\\extras\\thymeleaf-extras-java8time\\3.0.4.RELEASE\\thymeleaf-extras-java8time-3.0.4.RELEASE.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\projectlombok\\lombok\\1.18.24\\lombok-1.18.24.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\spring-core\\5.3.23\\spring-core-5.3.23.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\spring-jcl\\5.3.23\\spring-jcl-5.3.23.jar;D:\\Tools\\IntelliJ IDEA 2022.1\\lib\\idea_rt.jar 创建运行时类的对象获取运行时类的完整结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.cutiebambi.annotation;import com.cutiebambi.pojo.Department;import org.springframework.util.StringUtils;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;public class Test06 { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException { //获取类的信息 //获取类的名字 Class c1 = Class.forName(\"com.cutiebambi.pojo.Employee\"); System.out.println(c1.getName());//包名+类名 System.out.println(c1.getSimpleName());//类名 //获取类的属性 Field[] fields = c1.getFields();//获取类的公共属性 for (Field field: fields) { System.out.println(\"c1.getFields()====&gt;\" + field); } fields = c1.getDeclaredFields();//获取类的所有属性 for (Field field: fields) { System.out.println(\"c1.getDeclaredFields()====&gt;\" + field); } //获取指定名字的属性的值 //System.out.println(c1.getField(\"lastName\"));//获取public属性 System.out.println(c1.getDeclaredField(\"lastName\"));//获取指定的公共属性 //获取类的方法 Method[] methods = c1.getMethods();//获取本类和父类的public方法 for (Method method: methods) { System.out.println(\"c1.getMethods()====&gt;\" + method); } methods = c1.getDeclaredMethods();//获取本类的所有方法 for (Method method: methods) { System.out.println(\"c1.getDeclaredMethods()====&gt;\" + method); } //获取指定方法 System.out.println(c1.getMethod(\"getLastName\")); //获取构造器 Constructor[] constructors = c1.getConstructors(); for (Constructor constructor: constructors) { System.out.println(\"c1.getConstructors()====&gt;\" + constructor); } constructors = c1.getDeclaredConstructors(); for (Constructor constructor: constructors) { System.out.println(\"c1.getDeclaredConstructors()====&gt;\" + constructor); } //获取指定构造器 System.out.println(c1.getConstructor(Integer.class,String.class, String.class, Integer.class, Department.class)); }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748com.cutiebambi.pojo.EmployeeEmployeec1.getDeclaredFields()====&gt;private java.lang.Integer com.cutiebambi.pojo.Employee.idc1.getDeclaredFields()====&gt;private java.lang.String com.cutiebambi.pojo.Employee.lastNamec1.getDeclaredFields()====&gt;private java.lang.String com.cutiebambi.pojo.Employee.emailc1.getDeclaredFields()====&gt;private java.lang.Integer com.cutiebambi.pojo.Employee.genderc1.getDeclaredFields()====&gt;private com.cutiebambi.pojo.Department com.cutiebambi.pojo.Employee.departmentc1.getDeclaredFields()====&gt;private java.util.Date com.cutiebambi.pojo.Employee.birthprivate java.lang.String com.cutiebambi.pojo.Employee.lastNamec1.getMethods()====&gt;public java.lang.Integer com.cutiebambi.pojo.Employee.getId()c1.getMethods()====&gt;public void com.cutiebambi.pojo.Employee.setId(java.lang.Integer)c1.getMethods()====&gt;public void com.cutiebambi.pojo.Employee.setLastName(java.lang.String)c1.getMethods()====&gt;public java.lang.String com.cutiebambi.pojo.Employee.getLastName()c1.getMethods()====&gt;public java.lang.String com.cutiebambi.pojo.Employee.getEmail()c1.getMethods()====&gt;public void com.cutiebambi.pojo.Employee.setGender(java.lang.Integer)c1.getMethods()====&gt;public void com.cutiebambi.pojo.Employee.setDepartment(com.cutiebambi.pojo.Department)c1.getMethods()====&gt;public java.lang.Integer com.cutiebambi.pojo.Employee.getGender()c1.getMethods()====&gt;public void com.cutiebambi.pojo.Employee.setBirth(java.util.Date)c1.getMethods()====&gt;public void com.cutiebambi.pojo.Employee.setEmail(java.lang.String)c1.getMethods()====&gt;public java.util.Date com.cutiebambi.pojo.Employee.getBirth()c1.getMethods()====&gt;public com.cutiebambi.pojo.Department com.cutiebambi.pojo.Employee.getDepartment()c1.getMethods()====&gt;public final void java.lang.Object.wait() throws java.lang.InterruptedExceptionc1.getMethods()====&gt;public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedExceptionc1.getMethods()====&gt;public final native void java.lang.Object.wait(long) throws java.lang.InterruptedExceptionc1.getMethods()====&gt;public boolean java.lang.Object.equals(java.lang.Object)c1.getMethods()====&gt;public java.lang.String java.lang.Object.toString()c1.getMethods()====&gt;public native int java.lang.Object.hashCode()c1.getMethods()====&gt;public final native java.lang.Class java.lang.Object.getClass()c1.getMethods()====&gt;public final native void java.lang.Object.notify()c1.getMethods()====&gt;public final native void java.lang.Object.notifyAll()c1.getDeclaredMethods()====&gt;public java.lang.Integer com.cutiebambi.pojo.Employee.getId()c1.getDeclaredMethods()====&gt;public void com.cutiebambi.pojo.Employee.setId(java.lang.Integer)c1.getDeclaredMethods()====&gt;public void com.cutiebambi.pojo.Employee.setLastName(java.lang.String)c1.getDeclaredMethods()====&gt;public java.lang.String com.cutiebambi.pojo.Employee.getLastName()c1.getDeclaredMethods()====&gt;public java.lang.String com.cutiebambi.pojo.Employee.getEmail()c1.getDeclaredMethods()====&gt;public void com.cutiebambi.pojo.Employee.setGender(java.lang.Integer)c1.getDeclaredMethods()====&gt;public void com.cutiebambi.pojo.Employee.setDepartment(com.cutiebambi.pojo.Department)c1.getDeclaredMethods()====&gt;public java.lang.Integer com.cutiebambi.pojo.Employee.getGender()c1.getDeclaredMethods()====&gt;public void com.cutiebambi.pojo.Employee.setBirth(java.util.Date)c1.getDeclaredMethods()====&gt;public void com.cutiebambi.pojo.Employee.setEmail(java.lang.String)c1.getDeclaredMethods()====&gt;public java.util.Date com.cutiebambi.pojo.Employee.getBirth()c1.getDeclaredMethods()====&gt;public com.cutiebambi.pojo.Department com.cutiebambi.pojo.Employee.getDepartment()public java.lang.String com.cutiebambi.pojo.Employee.getLastName()c1.getConstructors()====&gt;public com.cutiebambi.pojo.Employee()c1.getConstructors()====&gt;public com.cutiebambi.pojo.Employee(java.lang.Integer,java.lang.String,java.lang.String,java.lang.Integer,com.cutiebambi.pojo.Department)c1.getDeclaredConstructors()====&gt;public com.cutiebambi.pojo.Employee()c1.getDeclaredConstructors()====&gt;public com.cutiebambi.pojo.Employee(java.lang.Integer,java.lang.String,java.lang.String,java.lang.Integer,com.cutiebambi.pojo.Department)public com.cutiebambi.pojo.Employee(java.lang.Integer,java.lang.String,java.lang.String,java.lang.Integer,com.cutiebambi.pojo.Department) 调用运行时类的指定结构动态创建对象执行方法12345678910111213141516171819202122232425262728293031323334353637package com.cutiebambi.reflection;import com.cutiebambi.pojo.Department;import com.cutiebambi.pojo.Employee;import com.cutiebambi.pojo.User;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class Test07 { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException { //通过反射获取Class对象，然后再生成一个对象 Class c1 = Class.forName(\"com.cutiebambi.pojo.User\"); Object o = c1.newInstance(); System.out.println(o.toString()); //通过构造器创建对象 Constructor declaredConstructor = c1.getDeclaredConstructor(int.class, int.class, String.class); Object o1 = declaredConstructor.newInstance(1001, 18, \"bambi\"); System.out.println(o1.toString()); //通过反射调用普通方法 User user = (User)c1.newInstance(); Method setName = c1.getDeclaredMethod(\"setName\", String.class); setName.invoke(user, \"boun\");//invoke(对象, 传入的参数值) 激活某个对象的方法，并且传入对应的参数值 System.out.println(user.getName()); //通过反射操作普通属性 Field name = c1.getDeclaredField(\"name\"); //关闭安全检测 name.setAccessible(true); name.set(user, \"prem\"); System.out.println(user.getName()); }} 1234User{id=0, age=0, name='null'}User{id=1001, age=18, name='bambi'}bounprem 性能问题分析1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.cutiebambi.reflection;import com.cutiebambi.pojo.User;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.sql.Timestamp;public class Test08 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException { //性能问题分析 Class c1 = Class.forName(\"com.cutiebambi.pojo.User\"); //普通方式调用方法 User user = new User(); long start = System.currentTimeMillis(); for (int i = 0; i &lt; 1000000000; i++) { user.getName(); } long end = System.currentTimeMillis(); System.out.println(\"普通方式调用方法： \" + (end-start) + \"ms\"); //反射方式调用方法 user = (User)c1.newInstance(); Method getName = c1.getDeclaredMethod(\"getName\"); start = System.currentTimeMillis(); for (int i = 0; i &lt; 1000000000; i++) { getName.invoke(user, null); } end = System.currentTimeMillis(); System.out.println(\"反射方式调用方法： \" + (end-start) + \"ms\"); //关闭检测后的反射方式调用方法 user = (User)c1.newInstance(); getName = c1.getDeclaredMethod(\"getName\"); getName.setAccessible(true); start = System.currentTimeMillis(); for (int i = 0; i &lt; 1000000000; i++) { getName.invoke(user, null); } end = System.currentTimeMillis(); System.out.println(\"关闭检测后的反射方式调用方法： \" + (end-start) + \"ms\"); }} 123普通方式调用方法： 3ms反射方式调用方法： 1605ms关闭检测后的反射方式调用方法： 1575ms 获取泛型信息1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.cutiebambi.reflection;import com.cutiebambi.pojo.User;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.List;import java.util.Map;public class Test09 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException { Class c1 = Class.forName(\"com.cutiebambi.reflection.Test09\"); Type[] types = c1.getDeclaredMethod(\"method1\", Map.class, List.class).getGenericParameterTypes(); for (Type type : types) { if(type instanceof ParameterizedType){ Type[] actualTypeArguments = ((ParameterizedType) type).getActualTypeArguments(); for (Type actualTypeArgument : actualTypeArguments) { System.out.println(actualTypeArgument); } } } System.out.println(\"========================\"); Type returnType = c1.getDeclaredMethod(\"method2\").getGenericReturnType(); if(returnType instanceof ParameterizedType){ Type[] actualTypeArguments = ((ParameterizedType) returnType).getActualTypeArguments(); for (Type actualTypeArgument : actualTypeArguments) { System.out.println(actualTypeArgument); } } } //泛型作为参数类型 public static void method1(Map&lt;String, Object&gt; map, List&lt;User&gt; user){ } //泛型作为返回值类型 public static Map&lt;String, Object&gt; method2(){ return null; }} 123456class java.lang.Stringclass java.lang.Objectclass com.cutiebambi.pojo.User========================class java.lang.Stringclass java.lang.Object 获取注解信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.cutiebambi.reflection;import java.lang.annotation.*;import java.lang.reflect.Field;public class Test10 { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException { //获取注解信息 Class c1 = Class.forName(\"com.cutiebambi.reflection.User\"); Annotation[] annotations = c1.getAnnotations(); for (Annotation annotation : annotations) { System.out.println(annotation);//@com.cutiebambi.reflection.TableBambi(value=db_user) TableBambi tableAnno = (TableBambi)c1.getAnnotation(TableBambi.class); System.out.println(tableAnno.value());//db_user } //获取类指定的注解 Field name = c1.getDeclaredField(\"age\"); FieldBambi fieldBambi = name.getAnnotation(FieldBambi.class); System.out.println(fieldBambi.columnName()); System.out.println(fieldBambi.type()); System.out.println(fieldBambi.length()); }}@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface TableBambi { String value();}@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@interface FieldBambi { String columnName(); String type(); int length();}@TableBambi(\"db_user\")class User { @FieldBambi(columnName = \"db_id\", type = \"int\", length = 5) private int id; @FieldBambi(columnName = \"db_age\", type = \"int\", length = 3) private int age; @FieldBambi(columnName = \"db_name\", type = \"varchar\", length = 4) private String name; public User() { } public User(int id, int age, String name) { this.id = id; this.age = age; this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"User{\" + \"id=\" + id + \", age=\" + age + \", name='\" + name + '\\'' + '}'; }} 12345@com.cutiebambi.reflection.TableBambi(value=db_user)db_userdb_ageint3","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://xiaofanshutu.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"cutiebambi"},{"title":"Spring Boot","slug":"Spring Boot","date":"2023-04-29T01:07:41.747Z","updated":"2024-01-17T23:40:27.670Z","comments":true,"path":"posts/a541262a.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/a541262a.html","excerpt":"","text":"Spring Boot简介回顾什么是SpringSpring是一个开源框架，解决企业级应用开发的复杂性而创建的，简化开发。 Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。 Spring是如何简化Java开发的为了降低Java开发的复杂性，Spring采用了以下4种关键策略： 1、基于POJO的轻量级和最小侵入性编程，所有东西都是bean； 2、通过IOC，依赖注入（DI）和面向接口实现松耦合； 3、基于切面（AOP）和惯例进行声明式编程； 4、通过切面和模版减少样式代码，RedisTemplate，xxxTemplate； 什么是Spring Boot学过Java Web的同学就知道，开发一个web应用，从最初开始接触Servlet结合Tomcat, 跑出一个Hello Wolrld程序，是要经历特别多的步骤；后来就用了框架Struts，再后来是Spring MVC，到了现在的Spring Boot，过一两年又会有其他web框架出现；你们有经历过框架不断的演进，然后自己开发项目所有的技术也在不断的变化、改造吗？建议都可以去经历一遍； 言归正传，什么是Spring Boot呢，就是一个javaweb的开发框架，和Spring MVC类似，对比其他Java Web框架的好处，官方说是简化开发，约定大于配置（越是简化的东西，越是需要严格的规定）， you can “just run”，能迅速的开发web应用，几行代码开发一个http接口。 所有的技术框架的发展似乎都遵循了一条主线规律：从一个复杂应用场景 衍生 一种规范框架，人们只需要进行各种配置而不需要自己去实现它，这时候强大的配置功能成了优点；发展到一定程度之后，人们根据实际生产应用情况，选取其中实用功能和设计精华，重构出一些轻量级的框架；之后为了提高开发效率，嫌弃原先的各类配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案。 是的，这就是Java企业级应用-&gt;J2EE-&gt;Spring-&gt;Spring Boot的过程。 随着Spring不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用Spring 、更容易的集成各种常用的中间件、开源软件； Spring Boot 基于Spring开发，Spirng Boot 本身并不提供Spring框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于Spring框架的应用程序。也就是说，它并不是用来替代Spring的解决方案，而是和Spring框架紧密结合用于提升Spring开发者体验的工具。Spring Boot 以约定大于配置的核心思想，默认帮我们进行了很多设置，多数Spring Boot应用只需要很少的Spring配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、JPA、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。 简单来说就是Spring Boot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，Spring Boot整合了所有的框架 。 Spring Boot 出生名门，从一开始就站在一个比较高的起点，又经过这几年的发展，生态足够完善，Spring Boot已经当之无愧成为Java领域最热门的技术。 Spring Boot的主要优点： 为所有Spring开发者更快的入门 开箱即用，提供各种默认配置来简化项目配置 内嵌式容器简化Web项目 没有冗余代码生成和XML配置的要求 微服务什么是微服务 微服务是一种架构风格，它要求我们在开发一个应用的时候，这个应用必须构建成一系列小服务的组合;可以通过http的方式进行互通。要说微服务架构，先得说说过去我们的单体应用架构。 单体应用架构 所谓单体应用架构(all in one)是指，我们将一个应用的中的所有应用服务都封装在一个应用中。 无论是ERP、CRM或是其他什么系统，你都把数据库访问，web访问, 等等各个功能放到一个war包内。（目前我们写的项目就是如此，将一个系统整体打包成war包） 这样做的好处是，易于开发和测试；也十分方便部署；当需要扩展时，只需要将war复制多份，然后放到多个服务器上，再做个负载均衡就可以了。 单体应用架构的缺点是，哪怕我要修改一个非常小的地方，我都需要停掉整个服务，重新打包、部署这个应用war包。特别是对于一个大型应用，我们不可能把所有内容都放在一个应用里面，我们如何维护、如何分工合作都是问题。 微服务架构 all in one的架构方式，我们把所有的功能单元放在一个应用里面。然后我们把整个应用部署到服务器上。如果负载能力不行，我们将整个应用进行水平复制，进行扩展，然后在负载均衡。 所谓微服务架构，就是打破之前all in one的架构方式，把每个功能元素独立出来。把独立出来的功能元素的动态组合，需要的功能元素才去拿来组合，需要多一些时，可以整合多个功能元素。所以微服务架构是对功能元素进行复制，而没有对整个应用进行复制。 这样做的好处是: 节省了调用资源。 每个功能元素的服务都是一个可替换的、可独立升级的软件代码。 Martin Flower于2014年3月25日写的《Microservices》 ，详细的阐述了什么是微服务。 原文地址: http://martinfowler.com/articles/microservices.html 翻译: https://www.cnblogs.com/liuning8023/p/4493156.html 如何构建微服务 一个大型系统的微服务架构，就像一个复杂交织的神经网络，每-个神经元就是一个功能元素， 它们各自完成自己的功能，然后通过http相互请求调用。比如一个电商系统，查缓存、连数据库、浏览页面、结账、支付等服务都是一个个独立的功能服务,都被微化了，它们作为一个个微服务共同构建了一个庞大的系统。如果修改其中的一个功能，只需要更新升级其中一个功能服务单元即可。 但是这种庞大的系统架构给部署和运维带来很大的难度。于是，spring为我们带来了构建大型分布式微服务的全套、全程产品: 构建一个个功能独立的微服务应用单元，可以使用springboot, 可以帮我们快速构建一个应用； 大型分布式网络服务的调用，这部分由spring cloud来完成，实现分布式； 在分布式中间,进行流式数据计算、批处理，我们有spring cloud data flow。 spring为我们想清楚了整个从开始构建应用到大型分布式应用全流程方案。 第一个SpringBoot程序准备工作我们将学习如何快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。 我的环境准备： java version 1.8 Maven-3.6.1 SpringBoot 2.x 最新版 开发工具： IDEA 创建基础项目说明Spring官方提供了非常方便的工具让我们快速构建应用（提供了一个快速生成的网站） Spring Initializer：https://start.spring.io/ 项目创建方式一： 使用Spring Initializer 的 Web页面创建项目 1、打开 https://start.spring.io/ 2、填写项目信息 3、点击”Generate Project“按钮生成项目；下载此项目 4、解压项目包，并用IDEA以Maven项目导入，一路下一步即可，直到项目导入完毕。 5、如果是第一次使用，可能速度会比较慢，包比较多、需要耐心等待一切就绪。 项目创建方式二： 使用 IDEA 直接创建项目（idea继承了上面说的那个网站） 1、创建一个新项目 2、选择spring initalizr ， 可以看到默认就是去官网的快速构建工具那里实现 3、填写项目信息 4、选择初始化的组件（初学勾选 Web 即可） 5、填写项目路径 6、等待项目构建成功 项目结构分析： 通过上面步骤完成了基础项目的创建。就会自动生成以下文件。 1、程序的主启动类 2、一个 application.properties 配置文件 3、一个 测试类 4、一个 pom.xml pom.xml 分析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 有一个父项目 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.4&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;!-- gav坐标 --&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;hellospringboot&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;hellospringboot&lt;/name&gt; &lt;description&gt;hellospringboot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- web依赖：集成tomcat, dispatcherServlet, xml...... --&gt; &lt;!-- spring boot所有的依赖都是以spring-boot-starter为前缀的 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;!-- 打jar包插件 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 如上所示，pom文件主要有四个部分: 项目元数据信息：创建时候输入的Project Metadata部分，也就是Maven项目的基本元素，包括: groupld、 artifactld、 version、 name、 description等 parent：继承spring- boot -starter-parent的依赖管理，控制版本与打包等内容 dependencies： 项目具体依赖，这里包含了spring-boot-starter -web用于实现HTTP接口(该依赖中包含了Spring MVC)，官网对它的描述是:使用Spring MVC构建Web (包括RESTful)应用程序的入门者，使用Tomcat作为默认嵌入式容器。spring-boot-starter-test用于编写单元测试的依赖包。更多功能模块的使用我们将在后面逐步展开。 build: 构建配置部分。默认使用了spring-boot-maven-plugin,配合spring-boot-starter-parent就可以把Spring Boot应用打包成JAR来直接运行。 编写一个http接口 在主程序的同级目录下，新建一个controller包，一定要在同级目录下，否则识别不到。 在包中新建一个HelloController类。 123456789101112package com.cutiebambi;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController { @RequestMapping(\"/hello\") public String hello(){ return \"hello bambi\"; }} 编写完毕后，从主程序启动项目，浏览器发起请求，看页面返回； 点击 maven的 package, 将项目打成jar包 如果打包成功，则会在target目录下生成一个 jar 包 打成了jar包后，就可以在任何地方运行了。 小技巧 更改tomcat端口号 ( resources 目录下的application.properties 文件) 12#更改项目端口号server.port=8089 更改启动时显示的字符拼成的字母：到项目下的 resources 目录下新建一个banner.txt 即可，将图案放在这个文件即可。 SpringBoo原理初探【重点】pom.xml文件父依赖1234567&lt;!-- 有一个父项目 --&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.4&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; 点进spring-boot-starter-parent，它还有一个parent spring-boot-dependencies这个是核心依赖 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.7.4&lt;/version&gt;&lt;/parent&gt; 以后我们导入依赖默认是不需要写版本（因为有这些版本仓库）；但是如果导入的包没有在依赖中管理着就需要手动配置版本了； 启动器 spring-boot-starter1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; springboot-boot-starter-xxx：就是spring-boot的场景启动器 spring-boot-starter-web：帮我们导入了web模块正常运行所依赖的组件； SpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），如果我们想要使用什么样的功能，只需要在项目中引入相关的（启动器）starter即可，所有相关的依赖都会导入进来 ， 我们未来也可以自己自定义 starter； 主启动类 （看注解）12345678910111213package com.cutiebambi;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;//自动装配：启动类本身就是Spring的一个组件。//SpringBootApplication标注这个类是一个spring boot的应用。启动类下的所有的资源被导入：EnableAutoConfiguration@SpringBootApplicationpublic class HellospringbootApplication { public static void main(String[] args) { SpringApplication.run(HellospringbootApplication.class, args); }} @SpringBootApplication: 说明这个类是Spring Boot的主配置类。 @SpringBootConfiguration: Spring Boot的配置类​ @Configuration: 配置类，对应的是Spring 的xml文件。 ​ @Component @EnableAutoConfiguration: 开启自动配置功能​ @AutoConfigurationPackage: 自动配置包 ​ @Import(AutoConfigurationPackages.Registrar.class): 自动配置包注册 ​ @Import：Spring底层注解，给容器中导入一个组件。 ​ Registrar.class: 将主启动类所在包及包下面所有子包里面的所有组件扫描到Spring容器。 ​ @Import(AutoConfigurationImportSelector.class): 给容器中导入组件 ​ AutoConfigurationImportSelector: 自动配置导入选择器 123456protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { List&lt;String&gt; configurations = new ArrayList(SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader())); ImportCandidates.load(AutoConfiguration.class, this.getBeanClassLoader()).forEach(configurations::add); Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories nor in META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. If you are using a custom packaging, make sure that file is correct.\"); return configurations;} 上面的方法会调用下面这个方法 123456789public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader) { ClassLoader classLoaderToUse = classLoader; if (classLoader ** null) { classLoaderToUse = SpringFactoriesLoader.class.getClassLoader(); } String factoryTypeName = factoryType.getName(); return (List)loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());} 接着这个方法又会调用下面这个方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(ClassLoader classLoader) { Map&lt;String, List&lt;String&gt;&gt; result = (Map)cache.get(classLoader); if (result != null) { return result; } else { Map&lt;String, List&lt;String&gt;&gt; result = new HashMap(); try { //spring.factories这个是自动配置的核心文件 //自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。小结：SpringBoot所有自动配置都是在启动的时候扫描并加载：spring.factories配置文件 ，所有的自动配置类都在这里面，但是不一定生效，要判断条件是否成立，而所谓的条件就是只要导入了对应的strater，就有对应的启动器了，有了启动器，条件成立，自动配置就生效，然后就配置成功！ Enumeration&lt;URL&gt; urls = classLoader.getResources(\"META-INF/spring.factories\"); while(urls.hasMoreElements()) { URL url = (URL)urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); Iterator var6 = properties.entrySet().iterator(); while(var6.hasNext()) { Map.Entry&lt;?, ?&gt; entry = (Map.Entry)var6.next(); String factoryTypeName = ((String)entry.getKey()).trim(); String[] factoryImplementationNames = StringUtils.commaDelimitedListToStringArray((String)entry.getValue()); String[] var10 = factoryImplementationNames; int var11 = factoryImplementationNames.length; for(int var12 = 0; var12 &lt; var11; ++var12) { String factoryImplementationName = var10[var12]; ((List)result.computeIfAbsent(factoryTypeName, (key) -&gt; { return new ArrayList(); })).add(factoryImplementationName.trim()); } } } result.replaceAll((factoryType, implementations) -&gt; { return (List)implementations.stream().distinct().collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)); }); cache.put(classLoader, result); return result; } catch (IOException var14) { throw new IllegalArgumentException(\"Unable to load factories from location [META-INF/spring.factories]\", var14); } }} 总结SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值将这些值作为自动配置类导入容器 ， 自动配置类就生效 ，以前我们需要自己配置的东西，现在SpringBoot 帮我们进行自动配置工作；整个J2EE的整体解决方案和自动配置都在spring-boot-autoconfigure的jar包中，他会把所有需要导入的组件，以类名（全限定名）的方式返回，这些类名对应的组件就会被添加到容器里；容器中有很多的xxxAutoConfiguration的文件（@Bean）, 就是这些类给容器中导入这个场景需要的所有组件 ， 并自动配置，@Configuration ；有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作； yaml语法学习Spring Boot的全局配置文件SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的。 可以是application.properties 语法结构：key=value 也可以是application.yaml（官方推荐使用这个） 语法结构: key: value（key和value之间的空格必须存在） 配置文件的作用：修改Spring Boot自动配置的默认值。 yaml概述YAML是 “YAML Ain’t a Markup Language” 这种语言以数据作为中心，而不是以标记语言为重点！ 以前的配置文件，大多数都是使用xml来配置；比如一个简单的端口配置，我们来对比下yaml和xml 传统xml配置： 123&lt;server&gt; &lt;port&gt;8081&lt;port&gt;&lt;/server&gt; yaml配置： 12server: prot: 8080 yaml基础语法 说明：语法要求严格！ 空格不能省略 以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。 属性和值的大小写都是十分敏感的。 字面量：普通的值 [ 数字，布尔值，字符串 ] 字面量直接写在后面就可以 ， 字符串默认不用加上双引号或者单引号； 12#yaml格式（注意空格）k: v 注意： “ ” 双引号，不会转义字符串里面的特殊字符 ， 特殊字符会作为本身想表示的意思；比如 ：name: “kuang \\n shen” 输出 ：kuang 换行 shen’ ’ 单引号，会转义特殊字符 ， 特殊字符最终会变成和普通字符一样输出比如 ：name: ‘kuang \\n shen’ 输出 ：kuang \\n shen 对象、Map（键值对)1234#对象、Map格式k: v1: v2: 在下一行来写对象的属性和值得关系，注意缩进；比如： 123student: name: qinjiang age: 3 行内写法 1student: {name: qinjiang,age: 3} 数组（ List、set ） 用 - 值表示数组中的一个元素,比如： 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 总结123456789101112131415161718192021#yaml文件可以存储的东西，重点对于空格的要求很严格# 普通的键值对name: mengyuanshishabi# 对象student: name: mengyuan age: 3#行内表示user: {name: mengyuan,age: 3}# 数组pets: - cat - pig - dog# 行内表示pet: [cat,dog,pig]# 而properties只能存键值对 key=value# yaml格式文件的另一个强大之处，在于可以注入到我们的配置类中，下面会说。 注入配置文件yaml注入配置文件 在springboot项目中的resources目录下新建一个文件 application.yaml 编写一个实体类 Dog； 12345678910111213141516171819202122232425262728293031323334package com.cutiebambi;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Component //添加到spring 的组件里，注解生成&lt;bean&gt; ,在之前的开发中，也用注解来注入属性值public class Dog { private String name; private Integer age; public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public String toString() { return \"Dog{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; }} 思考，我们原来是如何给bean注入属性值的！@Value，给狗狗类测试一下： 123456public class Dog { @Value(\"旺财\") private String name; @Value(\"3\") private Integer age;} 在SpringBoot的测试类下注入狗狗输出一下； 我们在编写一个复杂一点的实体类：Person 类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.cutiebambi;import org.springframework.stereotype.Component;import java.util.Date;import java.util.List;import java.util.Map;@Componentpublic class Person { private String name; private Integer age; private Boolean happy; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public Boolean getHappy() { return happy; } public void setHappy(Boolean happy) { this.happy = happy; } public Date getBirth() { return birth; } public void setBirth(Date birth) { this.birth = birth; } public Map&lt;String, Object&gt; getMaps() { return maps; } public void setMaps(Map&lt;String, Object&gt; maps) { this.maps = maps; } public List&lt;Object&gt; getLists() { return lists; } public void setLists(List&lt;Object&gt; lists) { this.lists = lists; } public Dog getDog() { return dog; } public void setDog(Dog dog) { this.dog = dog; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + \", happy=\" + happy + \", birth=\" + birth + \", maps=\" + maps + \", lists=\" + lists + \", dog=\" + dog + '}'; }} 我们来使用yaml配置的方式进行注入，大家写的时候注意区别和优势，我们编写一个yaml配置！ 12345678910111213person: name: bambi age: 9 happy: false birth: 2022/02/12 maps: {key1: value1, key2: value2} lists: - music - climbing - swimming dog: name: 旺财 age: 3 我们刚才已经把person这个对象的所有值都写好了，我们现在来注入到我们的类中！ 1234567891011121314151617/*@ConfigurationProperties作用：将配置文件中配置的每一个属性的值，映射到这个组件中；告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定参数 prefix = “person” : 将配置文件中的person下面的所有属性和组件一一对应*/@Component //注册bean@ConfigurationProperties(prefix = \"person\")public class Person { private String name; private Integer age; private Boolean happy; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;} IDEA 提示，springboot配置注解处理器没有找到，让我们看文档，我们可以查看文档，找到一个依赖！ 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 确认以上配置都OK之后，我们去测试类中测试一下： 结果：所有值全部注入成功！ 加载指定的配置文件@PropertySource ： 加载指定的配置文件； @configurationProperties：默认从全局配置文件中获取值； 1、我们去在resources目录下新建一个person.properties文件 1name=bambi 2、然后在我们的代码中指定加载teacher.properties文件properties 123456789101112131415161718192021222324252627package com.cutiebambi;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;@Component@PropertySource(value = \"classpath:teacher.properties\")public class Teacher { @Value(\"${name}\") private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"Teacher{\" + \"name='\" + name + '\\'' + '}'; }} 3、再次输出测试一下：指定配置文件绑定成功！ 配置文件占位符12345678910111213person: name: bambi${random.uuid} # 随机uuid age: ${random.int} # 随机int happy: false birth: 2022/02/12 maps: {key1: value1, key2: value2} lists: - music - climbing - swimming dog: name: 旺财 age: 3 对比小结配置yaml和配置properties都可以获取到值 ， 强烈推荐 yaml； 如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下 @value； 如果说，我们专门编写了一个JavaBean来和配置文件进行一一映射，就直接@configurationProperties，不要犹豫！ JSR303校验12345678910111213/*@ConfigurationProperties作用：将配置文件中配置的每一个属性的值，映射到这个组件中；告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定参数 prefix = “person” : 将配置文件中的person下面的所有属性一一对应*/@Component //注册bean@ConfigurationProperties(prefix = \"person\")@Validated //数据校验public class Person { @NotNull private String name;} 多环境切换 profile是Spring对不同环境提供不同配置功能的支持，可以通过激活不同的环境版本，实现快速切换环境； 多配置文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yaml , 用来指定多个环境版本； 例如： application-test.properties 代表测试环境配置 application-dev.properties 代表开发环境配置 但是Springboot并不会直接启动这些配置文件，它默认使用application.properties主配置文件； 123#比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试；#我们启动SpringBoot，就可以看到已经切换到dev下的配置了；spring.profiles.active=dev yaml的多文档块和properties配置文件中一样，但是使用yaml去实现不需要创建多个配置文件，更加方便了 ! 1234567891011121314151617server: port: 8081#选择要激活那个环境块spring: profiles: active: prod---server: port: 8083spring: profiles: dev #配置环境的名称---server: port: 8084spring: profiles: prod #配置环境的名称 注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用properties配置文件的！ 配置文件加载位置官方文档说明： https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.external-config.files Spring Boot will automatically find and load application.properties and application.yaml files from the following locations when your application starts: From the classpath（类路径就是src/main/resource或者src/main/java，一般会把配置文件放在resource下。） The classpath root 优先级最低 The classpath /config package From the current directory The current directory The config/ subdirectory in the current directory Immediate child directories of the config/ subdirectory 优先级最高 拓展，运维小技巧指定位置加载配置文件 我们还可以通过spring.config.location来改变默认的配置文件位置 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；这种情况，一般是后期运维做的多，相同配置，外部指定的配置文件优先级最高 1java -jar spring-boot-config.jar --spring.config.location=F:/application.properties 自动配置原理【重点】 配置文件到底能写什么？怎么写？这个和spring.factories有什么关联？ SpringBoot官方文档中有大量的配置，我们无法全部记住 分析自动配置原理从spring.factories中选择一个类进入，我们以HttpEncodingAutoConfiguration（Http编码自动配置） 为例解释自动配置原理； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.cutiebambi;import org.springframework.boot.autoconfigure.AutoConfiguration;import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication.Type;import org.springframework.boot.autoconfigure.web.ServerProperties;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.boot.web.server.WebServerFactoryCustomizer;import org.springframework.boot.web.servlet.filter.OrderedCharacterEncodingFilter;import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;import org.springframework.boot.web.servlet.server.Encoding;import org.springframework.context.annotation.Bean;import org.springframework.core.Ordered;import org.springframework.web.filter.CharacterEncodingFilter;//表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件；@AutoConfiguration//进入这个ServerProperties查看，将配置文件中对应的值和ServerProperties绑定起来；//并把ServerProperties加入到IOC容器中//自动配置属性: 装配好之后，ServerProperties里面的属性就是我们要在配置文件中写的key了。@EnableConfigurationProperties({ServerProperties.class})//Spring的底层注解：根据不同条件，来判断当前配置或者类是否生效。如果满足指定的条件，整个配置类里面的配置就会生效；//这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnWebApplication( type = Type.SERVLET)//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnClass({CharacterEncodingFilter.class})//判断配置文件中是否存在某个配置：server.servlet.encoding.enabled；//如果不存在，判断也是成立的//即使我们配置文件中不配置server.servlet.encoding.enabled=true，也是默认生效的；@ConditionalOnProperty( prefix = \"server.servlet.encoding\", value = {\"enabled\"}, matchIfMissing = true)public class HttpEncodingAutoConfiguration { //他已经和SpringBoot的配置文件映射了 private final Encoding properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(ServerProperties properties) { this.properties = properties.getServlet().getEncoding(); } //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @Bean @ConditionalOnMissingBean //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() { CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.RESPONSE)); return filter; } @Bean public org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration.LocaleCharsetMappingsCustomizer localeCharsetMappingsCustomizer() { return new org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration.LocaleCharsetMappingsCustomizer(this.properties); } static class LocaleCharsetMappingsCustomizer implements WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt;, Ordered { private final Encoding properties; LocaleCharsetMappingsCustomizer(Encoding properties) { this.properties = properties; } public void customize(ConfigurableServletWebServerFactory factory) { if (this.properties.getMapping() != null) { factory.setLocaleCharsetMappings(this.properties.getMapping()); } } public int getOrder() { return 0; } }} 一句话总结 ：根据当前不同的条件判断，决定这个配置类是否生效！ 一但这个配置类生效；这个配置类就会给容器中添加各种组件； 这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件（application.yaml）绑定的； 所有在配置文件中能配置的属性都是在xxxxProperties类中封装着； 配置文件能配置什么就可以参照某个功能对应的这个属性类 1234567891011121314151617181920212223242526@ConfigurationProperties( prefix = \"server\", ignoreUnknownFields = true)public class ServerProperties { private Integer port; private InetAddress address; @NestedConfigurationProperty private final ErrorProperties error = new ErrorProperties(); private ForwardHeadersStrategy forwardHeadersStrategy; private String serverHeader; private DataSize maxHttpHeaderSize = DataSize.ofKilobytes(8L); private Shutdown shutdown; @NestedConfigurationProperty private Ssl ssl; @NestedConfigurationProperty private final Compression compression; @NestedConfigurationProperty private final Http2 http2; private final Servlet servlet; private final Reactive reactive; private final Tomcat tomcat; private final Jetty jetty; private final Netty netty; private final Undertow undertow;} 1234567891011121314#在配置文件中能够配置的东西，都存在一个固有的规律# ***AutoConfiguration: 它们是容器中的一个个组件，最后都会加入到容器中。它们会帮我们自动装配东西，自动装配的东西有默认值，它会从***Properties里面去取默认值。# ***Properties又和配置文件绑定，我们就可以使用自定义的配置了server: port: 9090 address: test ssl: certificate: test enabled: false enabled-protocols: test trust-store-type: dsf tomcat: accept-count: 10 这个就是自动装配的原理！！! 精髓1、SpringBoot启动会加载大量的自动配置类（xxxxAutoConfigurartion），每一个自动配置类中都有对应的 xxxxProperties，这些xxxxProperties中有着相关的属性与默认值，这些属性又是和配置文件（application.yaml）绑定的，所以我们可以通过配置文件来修改SpringBoot自动配置的默认值； 2、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中； 3、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在在其中，我们就不需要再手动配置了） 4、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件（application.yaml）中指定这些属性的值即可； xxxxAutoConfigurartion： 给容器中添加组件 **xxxxProperties:自动配置类，封装配置文件中相关属性； ** 了解：@Conditional了解完自动装配的原理后，我们来关注一个细节问题，自动配置类必须在一定的条件下才能生效； @Conditional派生注解（Spring注解版原生的@Conditional作用） 作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； @Conditional扩展注解 作用（【判断是否满足当前条件） @ConditionalOnBean 容器中是否存在指定bean @ConditionalOnClass 系统中有指定的类 @ConditionalOnExpression 满足SpEL表达式 @ConditionalOnJava 系统的Java版本是否符合要求 @ConditionalOnJndi JNDI存在指定项 @ConditionalOnMissingBean 容器中不存在指定bean @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 那么多的自动配置类，必须在一定的条件下才能生效；也就是说，我们加载了这么多的配置类，但不是所有的都生效了。 我们怎么知道哪些自动配置类生效？ 我们可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效； 12#开启springboot的调试类debug=true 输出的日志中大致分为一下几类： Positive matches:（自动配置类启用的：正匹配） 已经启用了，并且生效的 Negative matches:（没有启动，没有匹配成功的自动配置类：负匹配） Unconditional classes: （没有条件的类） 12345678910111213141516171819Positive matches:----------------- AopAutoConfiguration matched: - @ConditionalOnProperty (spring.aop.auto=true) matched (OnPropertyCondition) Negative matches:----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required class 'javax.jms.ConnectionFactory' (OnClassCondition)Unconditional classes:---------------------- org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration SpringBoot Web 开发前准备 我们要解决的问题： 导入静态资源，怎么样处理静态资源 首页index.jsp/index.html Jsp,模板引擎Thymeleaf 装配扩展SpringMVC 增删改查 拦截器 国际化 处理静态资源创建一个空的web工程 创建一个空web工程之后，先写一个测试controller验证有没有问题，没有问题的话再进行下一步。 123456789101112package com.cutiebambi;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController { @RequestMapping(\"/hello\") public String hello(){ return \"hello bambi\"; }} WebMvcAutoConfiguration.java 源码中关于静态资源的说明： 123456789101112131415161718public void addResourceHandlers(ResourceHandlerRegistry registry) { //1.如果我们在配置文件中自己定义了路径，下面默认的就会失效 if (!this.resourceProperties.isAddMappings()) { logger.debug(\"Default resource handling disabled\"); } else { //2.导入一些静态jar包，如jquery，这些jar包的目录结构要求，如果我们访问http://localhost:8080/webjars/... 就可以访问到/webjars下面的资源 this.addResourceHandler(registry, \"/webjars/**\", \"classpath:/META-INF/resources/webjars/\"); //3.源码中：staticPathPattern = \"/**\"，然后去查看WebProperties的Resources，private static final String[] CLASSPATH_RESOURCE_LOCATIONS = new String[]{\"classpath:/META-INF/resources/\", \"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\"}; this.addResourceHandler(registry, this.mvcProperties.getStaticPathPattern(), (registration) -&gt; { registration.addResourceLocations(this.resourceProperties.getStaticLocations()); if (this.servletContext != null) { ServletContextResource resource = new ServletContextResource(this.servletContext, \"/\"); registration.addResourceLocations(new Resource[]{resource}); } }); }} 总结： 在SpringBoot中，我们可以使用以下几种方式处理静态资源 webjars [^浏览器访问的路径]: localhost:8080/webjars/ public，static，/**, resources [^浏览器访问的路径]: localhost:8080/ 优先级: resources &gt; static(默认) &gt; public 如果我们在配置文件（application.properties）中自己定义了路径，SpringBoot默认的路径就会失效，一般不建议这样做，因为它会直接return，代码不会往下走。 http://localhost:8080/webjars/… 这个路径可以访问到/webjars下面的资源，一般会用于导入的依赖jar包的访问（这些依赖要去 webjars的官方网站：https://www.webjars.org 去找），要求这些jar包的目录结构要求如下： 12345&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;bootstrap&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt; ​ 在浏览器中访问通过webjars导入的静态资源： 那我们项目中要是使用自己的静态资源该怎么导入呢？我们去找staticPathPattern发现第二种映射规则 ：staticPathPattern = “/**” , 访问当前的项目任意资源，它会去找 WebProperties这个类 ,这个类在里面Resources定义了这些目录private static final String[] CLASSPATH_RESOURCE_LOCATIONS = new String[]{“classpath:/META-INF/resources/“, “classpath:/resources/“, “classpath:/static/“, “classpath:/public/“};所以平常我们访问 http://localhost:8080/… ，它就会匹配到上述的目录，去这些目录下寻找资源。 创建三个js文件去验证这三个目录的优先级。 访问localhost:8080/1.js，可以看到返回的是resources下面的js内容，可以得知：resources下面的静态资源优先级最高。 接着把resources目录下的js删掉，继续访问localhost:8080/1.js。这一次返回的是static目录下的js内容。 因此可以得出，优先级由高到低为：resources &gt; static &gt; public, 我们通常就把静态资源放在这三个目录下，至于怎样放，看个人习惯，很少使用/webjars。 首页如何定制123456789101112131415161718192021222324252627282930313233343536373839404142434445@Beanpublic WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) { WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping(new TemplateAvailabilityProviders(applicationContext), applicationContext, this.getWelcomePage(), this.mvcProperties.getStaticPathPattern()); welcomePageHandlerMapping.setInterceptors(this.getInterceptors(mvcConversionService, mvcResourceUrlProvider)); welcomePageHandlerMapping.setCorsConfigurations(this.getCorsConfigurations()); return welcomePageHandlerMapping;}private Resource getWelcomePage() { String[] var1 = this.resourceProperties.getStaticLocations(); int var2 = var1.length; for(int var3 = 0; var3 &lt; var2; ++var3) { String location = var1[var3]; Resource indexHtml = this.getIndexHtml(location); if (indexHtml != null) { return indexHtml; } } ServletContext servletContext = this.getServletContext(); if (servletContext != null) { return this.getIndexHtml((Resource)(new ServletContextResource(servletContext, \"/\"))); } else { return null; }}private Resource getIndexHtml(String location) { return this.getIndexHtml(this.resourceLoader.getResource(location));}private Resource getIndexHtml(Resource location) { try { Resource resource = location.createRelative(\"index.html\"); if (resource.exists() &amp;&amp; resource.getURL() != null) { return resource; } } catch (Exception var3) { } return null;} Thymeleaf模板引擎模板引擎 前端交给我们的页面，是html页面。如果是我们以前开发，我们需要把他们转成jsp页面，jsp好处就是当我们查出一些数据转发到JSP页面以后，我们可以用jsp轻松实现数据的显示，及交互等。 jsp支持非常强大的功能，包括能写Java代码，但是呢，我们现在的这种情况，SpringBoot这个项目首先是以jar的方式，不是war，第二，我们用的还是嵌入式的Tomcat，所以呢，他现在默认是不支持jsp的。 那不支持jsp，如果我们直接用纯静态页面的方式，那给我们开发会带来非常大的麻烦，那怎么办呢？ SpringBoot推荐你可以来使用模板引擎： 模板引擎，我们其实大家听到很多，其实jsp就是一个模板引擎，还有用的比较多的freemarker，包括SpringBoot给我们推荐的Thymeleaf，模板引擎有非常多，但再多的模板引擎，他们的思想都是一样的，什么样一个思想呢我们来看一下这张图： 模板引擎的作用就是我们来写一个页面模板，比如有些值呢，是动态的，我们写一些表达式。而这些值，从哪来呢，就是我们在后台封装一些数据。然后把这个模板和这个数据交给我们模板引擎，模板引擎按照我们这个数据帮你把这表达式解析、填充到我们指定的位置，然后把这个数据最终生成一个我们想要的内容给我们写出去，这就是我们这个模板引擎，不管是jsp还是其他模板引擎，都是这个思想。只不过呢，就是说不同模板引擎之间，他们可能这个语法有点不一样。其他的我就不介绍了，我主要来介绍一下SpringBoot给我们推荐的Thymeleaf模板引擎，这模板引擎呢，是一个高级语言的模板引擎，他的这个语法更简单。而且呢，功能更强大。我们呢，就来看一下这个模板引擎，那既然要看这个模板引擎。首先，我们来看SpringBoot里边怎么用。 引入Thymeleaf 怎么引入呢，对于springboot来说，什么事情不都是一个start的事情嘛，我们去在项目中引入一下。给大家三个网址： Thymeleaf 官网：https://www.thymeleaf.org/ Thymeleaf 在Github 的主页：https://github.com/thymeleaf/thymeleaf Spring官方文档：找到我们对应的版本https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter 找到对应的pom依赖：可以适当点进源码看下本来的包！ 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; Maven会自动下载jar包，我们可以去看下下载的东西； Thymeleaf分析 前面呢，我们已经引入了Thymeleaf，那这个要怎么使用呢？ 我们首先得按照SpringBoot的自动配置原理看一下我们这个Thymeleaf的自动配置规则，再按照那个规则，我们进行使用。我们去找一下Thymeleaf的自动配置类：ThymeleafProperties 1234567891011121314151617181920212223@ConfigurationProperties( prefix = \"spring.thymeleaf\")public class ThymeleafProperties { private static final Charset DEFAULT_ENCODING; public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; private boolean checkTemplate = true; private boolean checkTemplateLocation = true; private String prefix = \"classpath:/templates/\"; private String suffix = \".html\"; private String mode = \"HTML\"; private Charset encoding; private boolean cache; private Integer templateResolverOrder; private String[] viewNames; private String[] excludedViewNames; private boolean enableSpringElCompiler; private boolean renderHiddenMarkersBeforeCheckboxes; private boolean enabled; private final Servlet servlet; private final Reactive reactive;} 我们可以在其中看到默认的前缀和后缀！ 我们只需要把我们的html页面放在类路径下的templates下，thymeleaf就可以帮我们自动渲染了。 使用thymeleaf什么都不需要配置，只需要将他放在指定的文件夹下即可！ 测试 编写一个IndexController 1234567891011121314package com.cutiebambi;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;//在templates目录下的所有页面，只能通过controller来跳转。//这个需要模板引擎的支持！thymeleaf@Controllerpublic class IndexController { @RequestMapping(\"/helloindex\") public String index(){ return \"index\"; }} 编写一个测试页面 index.html 放在 templates 目录下12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Hello Bambi&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 明天更好~~&lt;/body&gt;&lt;/html&gt; 启动项目请求测试 Thymeleaf 语法学习 要学习语法，还是参考官网文档最为准确，我们找到对应的版本看一下； Thymeleaf 官网：https://www.thymeleaf.org/ ， 简单看一下官网！我们去下载Thymeleaf的官方文档！ 我们做个最简单的练习 ：我们需要查出一些数据，在页面中展示 修改测试请求，增加数据传输。 1234567891011121314package com.cutiebambi;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class TestController { @RequestMapping(\"/test\") public String test(Model model){ model.addAttribute(\"msg\", \"你好呀，bambi！\"); return \"test\"; }} 我们要使用thymeleaf，需要在html文件中导入命名空间的约束，方便提示。我们可以去官方文档查一下然后把命名空间写进来。 1&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt; 我们去编写下前端页面。 123456789101112&lt;!DOCTYPE html&gt;&lt;!--命名空间的约束--&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--所有的html元素都可以被thymeleaf替换接管， th:元素名称 --&gt; &lt;div th:text=\"${msg}\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 启动项目进行测试。 SpringMVC自动配置原理官网阅读 在进行项目编写前，我们还需要知道一个东西，就是SpringBoot对我们的SpringMVC还做了哪些配置，包括如何扩展，如何定制。 只有把这些都搞清楚了，我们在之后使用才会更加得心应手。途径一：源码分析；途径二：官方文档！ 地址 ：https://docs.spring.io/spring-boot/docs/2.7.4/reference/htmlsingle/#web.servlet.spring-mvc.auto-configuration 1234567891011121314151617181920212223242526//Spring MVC自动配置Spring MVC Auto-configuration//Spring Boot为Spring MVC提供了自动配置，在大多数应用程序中都能很好地工作。Spring Boot provides auto-configuration for Spring MVC that works well with most applications.//自动配置在Spring默认配置的基础上添加了以下特性:The auto-configuration adds the following features on top of Spring’s defaults://包含ContentNegotiatingViewResolver和BeanNameViewResolver bean。Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.//对提供静态资源的支持，包括对webjar的支持(在本文档后面介绍)。Support for serving static resources, including support for WebJars (covered later in this document).//自动注册Converter、GenericConverter和Formatter bean。Automatic registration of Converter, GenericConverter, and Formatter beans.//对HttpMessageConverters的支持(在本文档后面介绍)。Support for HttpMessageConverters (covered later in this document).//MessageCodesResolver的自动注册(在本文档后面介绍)。Automatic registration of MessageCodesResolver (covered later in this document).//静态index . html的支持。Static index.html support.//自动使用ConfigurableWebBindingInitializer bean(在本文档后面介绍)。Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document).//如果你想保留那些Spring Boot MVC定制，并做更多的MVC定制(拦截器、格式化器、视图控制器和其他功能)，你可以添加你自己的WebMvcConfigurer类型的@Configuration类，但不需要@EnableWebMvc。If you want to keep those Spring Boot MVC customizations and make more MVC customizations (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc.//如果你想提供RequestMappingHandlerMapping, RequestMappingHandlerAdapter，或ExceptionHandlerExceptionResolver的自定义实例，并且仍然保持Spring引导MVC的自定义，你可以声明一个WebMvcRegistrations类型的bean，并使用它来提供这些组件的自定义实例。If you want to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, and still keep the Spring Boot MVC customizations, you can declare a bean of type WebMvcRegistrations and use it to provide custom instances of those components.//如果你想完全控制Spring MVC，你可以添加你自己的@Configuration，带有@EnableWebMvc注解，或者添加你自己的@Configuration注解的DelegatingWebMvcConfiguration，就像@EnableWebMvc的Javadoc中描述的那样。If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc, or alternatively add your own @Configuration-annotated DelegatingWebMvcConfiguration as described in the Javadoc of @EnableWebMvc. 我们来仔细对照，看一下它怎么实现的，它告诉我们SpringBoot已经帮我们自动配置好了SpringMVC，然后自动配置了哪些东西呢？ ContentNegotiatingViewResolver 内容协商视图解析器自动配置了ViewResolver，就是我们之前学习的SpringMVC的视图解析器； 即根据方法的返回值取得视图对象（View），然后由视图对象决定如何渲染（转发，重定向）。 我们去看看这里的源码：我们找到 WebMvcAutoConfiguration ， 然后搜索ContentNegotiatingViewResolver。找到如下方法！ 123456789101112@Bean@ConditionalOnBean({ViewResolver.class})@ConditionalOnMissingBean( name = {\"viewResolver\"}, value = {ContentNegotiatingViewResolver.class})public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) { ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver(); resolver.setContentNegotiationManager((ContentNegotiationManager)beanFactory.getBean(ContentNegotiationManager.class)); resolver.setOrder(Integer.MIN_VALUE); return resolver;} 我们可以点进ContentNegotiatingViewResolver类看看！找到对应的解析视图的代码； 12345678910111213141516171819202122232425262728//注解说明：@Nullable 即参数可为null@Nullablepublic View resolveViewName(String viewName, Locale locale) throws Exception { RequestAttributes attrs = RequestContextHolder.getRequestAttributes(); Assert.state(attrs instanceof ServletRequestAttributes, \"No current ServletRequestAttributes\"); List&lt;MediaType&gt; requestedMediaTypes = this.getMediaTypes(((ServletRequestAttributes)attrs).getRequest()); if (requestedMediaTypes != null) { //获取候选的视图对象 List&lt;View&gt; candidateViews = this.getCandidateViews(viewName, locale, requestedMediaTypes); //选择一个最适合的视图对象，然后把这个对象返回 View bestView = this.getBestView(candidateViews, requestedMediaTypes, attrs); if (bestView != null) { return bestView; } } String mediaTypeInfo = this.logger.isDebugEnabled() &amp;&amp; requestedMediaTypes != null ? \" given \" + requestedMediaTypes.toString() : \"\"; if (this.useNotAcceptableStatusCode) { if (this.logger.isDebugEnabled()) { this.logger.debug(\"Using 406 NOT_ACCEPTABLE\" + mediaTypeInfo); } return NOT_ACCEPTABLE_VIEW; } else { this.logger.debug(\"View remains unresolved\" + mediaTypeInfo); return null; }} 我们继续点进去看，他是怎么获得候选的视图的呢？ getCandidateViews中看到他是把所有的视图解析器拿来，进行while循环，挨个解析！ 12345678910111213141516private List&lt;View&gt; getCandidateViews(String viewName, Locale locale, List&lt;MediaType&gt; requestedMediaTypes) throws Exception { List&lt;View&gt; candidateViews = new ArrayList(); if (this.viewResolvers != null) { Assert.state(this.contentNegotiationManager != null, \"No ContentNegotiationManager set\"); //遍历所有的视图解析器 Iterator var5 = this.viewResolvers.iterator(); while(var5.hasNext()) { ViewResolver viewResolver = (ViewResolver)var5.next(); View view = viewResolver.resolveViewName(viewName, locale); if (view != null) { candidateViews.add(view); } } }} 所以得出结论：ContentNegotiatingViewResolver 这个视图解析器就是用来组合所有的视图解析器的 我们再去研究下他的组合逻辑，看到有个属性viewResolvers，看看它是在哪里进行赋值的！ 12345678910111213141516171819202122232425262728protected void initServletContext(ServletContext servletContext) { Collection&lt;ViewResolver&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(this.obtainApplicationContext(), ViewResolver.class).values(); ViewResolver viewResolver; if (this.viewResolvers == null) { //这里它是从beanFactory工具中获取容器中的所有视图解析器 //ViewRescolver.class 把所有的视图解析器来组合的 this.viewResolvers = new ArrayList(matchingBeans.size()); Iterator var3 = matchingBeans.iterator(); while(var3.hasNext()) { viewResolver = (ViewResolver)var3.next(); if (this != viewResolver) { this.viewResolvers.add(viewResolver); } } } else { for(int i = 0; i &lt; this.viewResolvers.size(); ++i) { viewResolver = (ViewResolver)this.viewResolvers.get(i); if (!matchingBeans.contains(viewResolver)) { String name = viewResolver.getClass().getName() + i; this.obtainApplicationContext().getAutowireCapableBeanFactory().initializeBean(viewResolver, name); } } } AnnotationAwareOrderComparator.sort(this.viewResolvers); this.cnmFactoryBean.setServletContext(servletContext);} 既然它是在容器中去找视图解析器，我们是否可以猜想，我们就可以去实现一个视图解析器了呢？ 我们可以自己给容器中去添加一个视图解析器；这个类就会帮我们自动的将它组合进来；我们去实现一下 我们在我们的主程序中去写一个视图解析器来试试；123456789101112131415161718192021222324package com.cutiebambi.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.View;import org.springframework.web.servlet.ViewResolver;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import java.util.Locale;@Configurationpublic class MyMvcConfig implements WebMvcConfigurer { @Bean public ViewResolver MyViewResolver(){ return MyViewResolver(); } public static class MyViewResolver implements ViewResolver { @Override public View resolveViewName(String viewName, Locale locale) throws Exception { return null; } }} 怎么看我们自己写的视图解析器有没有起作用呢？我们给 DispatcherServlet 中的 doDispatch方法 加个断点进行调试一下，因为所有的请求都会走到这个方法中。 我们启动我们的项目，然后随便访问一个页面，看一下Debug信息； 刚开始这样写之后，我本地debug还没进到doDispatch的断点，项目就报错了。 1org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'MyViewResolver' defined in class path resource [com/cutiebambi/config/MyMvcConfig.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.web.servlet.ViewResolver]: Factory method 'MyViewResolver' threw exception; nested exception is java.lang.StackOverflowError 后来经过琢磨，把MyMvcConfig改成下面这样之后，程序就可以正常启动了。 12345678910111213141516171819//如果你想diy一些定制化的功能，只要写这个组件，然后将它交给springboot, springboot就会帮我们自动装配。//这个注解表明这是扩展的SpringMVC@Configurationpublic class MyMvcConfig implements WebMvcConfigurer { //ViewResolver 实现了视图解析器接口的类，我们就可以把它看作是视图解析器 @Bean public ViewResolver MyViewResolver(){ return new MyViewResolver(); }}//自定义一个自己的视图解析器，MyViewResolver//把这个从上面挪下来class MyViewResolver implements ViewResolver { @Override public View resolveViewName(String viewName, Locale locale) throws Exception { return null; }} 找到this 找到视图解析器viewResolvers，我们看到我们自己定义的视图解析器也在这里了^-^ 所以说，我们如果想要使用自己定制化的东西，我们只需要给容器中添加这个组件就好了！剩下的事情SpringBoot就会帮我们做了！ 转换器和格式化器 在WebMvcAutoConfiguration.java中找到格式化转换器： 12345678@Beanpublic FormattingConversionService mvcConversionService() { WebMvcProperties.Format format = this.mvcProperties.getFormat(); //拿到配置文件中的格式化规则 WebConversionService conversionService = new WebConversionService((new DateTimeFormatters()).dateFormat(format.getDate()).timeFormat(format.getTime()).dateTimeFormat(format.getDateTime())); this.addFormatters(conversionService); return conversionService;} 点进去： 1234567891011public DateTimeFormatters dateFormat(String pattern) { if (isIso(pattern)) { this.dateFormatter = DateTimeFormatter.ISO_LOCAL_DATE; this.datePattern = \"yyyy-MM-dd\"; } else { this.dateFormatter = formatter(pattern); this.datePattern = pattern; } return this;} 可以看到在我们的Properties文件中，我们可以进行自动配置它！ 如果配置了自己的格式化方式，就会注册到Bean中生效，我们可以在配置文件中配置日期格式化的规则： 修改SpringBoot的默认配置方式一：这么多的自动配置，原理都是一样的，通过这个WebMVC的自动配置原理分析，我们要学会一种学习方式，通过源码探究，得出结论；这个结论一定是属于自己的，而且一通百通。 SpringBoot的底层，大量用到了这些设计细节思想，所以，没事需要多阅读源码！得出结论； SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（如果用户自己配置@bean），如果有就用用户配置的，如果没有就用自动配置的； 如果有些组件可以存在多个，比如我们的视图解析器，就将用户配置的和自己默认的组合起来！ 方式二：扩展使用Spring MVC官方文档如下： If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components. 我们要做的就是编写一个@Configuration注解类，并且类型要为WebMvcConfigurer，还不能标注@EnableWebMvc注解；我们去自己写一个；我们新建一个包叫config，写一个类MyMvcConfig； 123456789101112131415161718192021package com.cutiebambi.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.View;import org.springframework.web.servlet.ViewResolver;import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import java.util.Locale;//如果你想diy一些定制化的功能，只要写这个组件，然后将它交给springboot, springboot就会帮我们自动装配。//扩展spring mvc@Configurationpublic class MyMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { //只需要访问 http://localhost:8080/bambi 就可以跳转到index.html registry.addViewController(\"/bambi\").setViewName(\"index\"); }} 我们去浏览器访问一下： 经过验证，确实跳转过来了！所以说，我们要扩展SpringMVC，官方推荐我们这么去使用，既保留了SpringBoot所有的自动配置，也能用我们扩展的配置！ 分析原理：1、WebMvcAutoConfiguration 是 SpringMVC的自动配置类，里面有一个类WebMvcAutoConfigurationAdapter 2、这个类上有一个注解，在做其他自动配置时会导入：@Import(EnableWebMvcConfiguration.class) 3、我们点进EnableWebMvcConfiguration这个类看一下，它继承了一个父类：DelegatingWebMvcConfiguration 这个父类中有这样一段代码： 1234567891011121314151617public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport { private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); public DelegatingWebMvcConfiguration() { } @Autowired( required = false ) //从容器中获取所有的Webmvc Configurer public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) { if (!CollectionUtils.isEmpty(configurers)) { this.configurers.addWebMvcConfigurers(configurers); } }} 4、我们可以在这个类中去寻找一个我们刚才设置的viewController当做参考，发现它调用了一个 123protected void addViewControllers(ViewControllerRegistry registry) { this.configurers.addViewControllers(registry);} 5、我们点进去看一下 123456789public void addViewControllers(ViewControllerRegistry registry) { Iterator var2 = this.delegates.iterator(); while(var2.hasNext()) { //将所有的WebMvcConfigurer相关配置来一起调用！包括我们自己配置的和Spring给我们配置的 WebMvcConfigurer delegate = (WebMvcConfigurer)var2.next(); delegate.addViewControllers(registry); }} 所以得出结论：所有的WebMvcConfiguration都会被作用，不止Spring自己的配置类，我们自己的配置类当然也会被调用； 全面接管SpringMVC测试加上@EnableWebMvc之后会发生什么？ 官方文档： 12//如果你想完全控制Spring MVC，你可以添加你自己的@Configuration，带有@EnableWebMvc注解，或者添加你自己的@Configuration注解的DelegatingWebMvcConfiguration，就像@EnableWebMvc的Javadoc中描述的那样。If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc, or alternatively add your own @Configuration-annotated DelegatingWebMvcConfiguration as described in the Javadoc of @EnableWebMvc. 全面接管即：SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己去配置！ 只需在我们的配置类中要加一个@EnableWebMvc。 我们看下如果我们全面接管了SpringMVC了，我们之前SpringBoot给我们配置的静态资源映射会不会无效，我们可以去测试一下； 不加注解之前，访问静态资源： 在工程static下添加一个静态资源 1234567&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\"/&gt;&lt;!-- 不加这行代码，文本中的汉字会乱码 --&gt;&lt;body&gt;&lt;h2&gt;hello bambi,我是静态资源~&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 给配置类加上注解：@EnableWebMvc 我们发现所有的SpringMVC自动配置都失效了！访问不到静态资源了； 当然，我们开发中，不推荐使用全面接管SpringMVC 思考：为什么加了一个注解，自动配置就失效了？ 查看代码，加上@EnableWebMvc其实就是导入了一个类: DelegatingWebMvcConfiguration, DelegatingWebMvcConfiguration类的作用是从容器中获取所有的WebMvcConfigurer。 123456@Retention(RetentionPolicy.RUNTIME)@Target({ElementType.TYPE})@Documented@Import({DelegatingWebMvcConfiguration.class})public @interface EnableWebMvc {} 123456789101112131415161718@Configuration( proxyBeanMethods = false)public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport { private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); public DelegatingWebMvcConfiguration() { } @Autowired( required = false ) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) { if (!CollectionUtils.isEmpty(configurers)) { this.configurers.addWebMvcConfigurers(configurers); } }} DelegatingWebMvcConfiguration继承了一个父类 WebMvcConfigurationSupport 1public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport 我们再来看一下Webmvc自动配置类 (WebMvcAutoConfiguration)的代码。只有当不存在WebMvcConfigurationSupport的时候才会生效，加了@EnableWebMvc之后就相当于是自动引入了WebMvcAutoConfiguration类，所以Spring Boot的自动配置类就会失效。 总结：@EnableWebMvc将WebMvcConfigurationSupport组件导入进来了；而导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能！这个WebMvcConfigurationSupport进来之后，就使WebMvcAutoConfiguration这个类不满足条件，导致自动配置类失效！在SpringBoot中会有非常多的扩展配置，只要看见了这个，我们就应该多留心注意~ 一个简单的员工管理系统准备工作 导入lombok依赖 Lombok官网: https://www.projectlombok.org/ Lombok项目是一个Java库，它会自动插入编辑器和构建工具中，Lombok提供了一组有用的注释，用来消除Java类中的大量样板代码。仅五个字符(@Data)就可以替换数百行代码从而产生干净，简洁且易于维护的Java类。用在实体类中，用注解生成构造方法，get/set，等方法 12345&lt;!-- lombok --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt; @Data：注解在类，生成setter/getter、equals、canEqual、hashCode、toString方法，如为final属性，则不会为该属性生成setter方法 模拟DB中的数据，编写部门和员工的实体类以及对应的Dao。 部门表实体类 1234567891011121314package com.cutiebambi.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;//部门表@Data@AllArgsConstructor@NoArgsConstructorpublic class Department { private Integer id; private String departmentName;} 部门表Dao层 123456789101112131415161718192021222324252627282930313233343536package com.cutiebambi.dao;import com.cutiebambi.pojo.Department;import org.springframework.stereotype.Repository;import java.util.Collection;import java.util.HashMap;import java.util.List;import java.util.Map;//部门dao@Repositorypublic class DepartmentDao { //模拟数据库中的数据 private static Map&lt;Integer, Department&gt; departments = null; static{ //创建一个部门表 departments = new HashMap&lt;Integer, Department&gt;(); departments.put(101, new Department(101, \"教学部\")); departments.put(102, new Department(102, \"市场部\")); departments.put(103, new Department(103, \"教研部\")); departments.put(104, new Department(104, \"运营部\")); departments.put(105, new Department(105, \"后勤部\")); } //获取所有部门信息 public Collection&lt;Department&gt; getDepartments(){ return departments.values(); } //根据id获取单个部门信息 public Department getDepartmentById(Integer id){ return departments.get(id); }} 员工表实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.cutiebambi.pojo;import lombok.AllArgsConstructor;import lombok.NoArgsConstructor;import java.util.Date;//员工表@NoArgsConstructorpublic class Employee { private Integer id; private String lastName; private String email; private Integer gender; //0:女 1:男 private Department department; private Date birth; public Employee(Integer id, String lastName, String email, Integer gender, Department department) { this.id = id; this.lastName = lastName; this.email = email; this.gender = gender; this.department = department; this.birth = new Date(); } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public Integer getGender() { return gender; } public void setGender(Integer gender) { this.gender = gender; } public Department getDepartment() { return department; } public void setDepartment(Department department) { this.department = department; } public Date getBirth() { return birth; } public void setBirth(Date birth) { this.birth = birth; }} 员工表Dao层12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.cutiebambi.dao;import com.cutiebambi.pojo.Department;import com.cutiebambi.pojo.Employee;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Repository;import org.springframework.util.StringUtils;import java.util.Collection;import java.util.HashMap;import java.util.Map;//员工dao@Repositorypublic class EmployeeDao { @Autowired //Field injection is not recommended private DepartmentDao departmentDao; private static Integer id = 1006; private static Map&lt;Integer, Employee&gt; employees = null; //模拟DB中的数据 static{ //创建一个员工表(自己写的时候，把这一行没写，直接用employees call put方法了。差点弄出来空指针异常了) employees = new HashMap&lt;Integer, Employee&gt;(); employees.put(1001, new Employee(1001, \"summer\", \"1@lucky.com\", 0, new Department(101, \"教学部\"))); employees.put(1002, new Employee(1002, \"jack\", \"2@lucky.com\", 1, new Department(101, \"市场部\"))); employees.put(1003, new Employee(1003, \"cecil\", \"3@lucky.com\", 1, new Department(101, \"教研部\"))); employees.put(1004, new Employee(1004, \"roy\", \"4@lucky.com\", 1, new Department(101, \"运营部\"))); employees.put(1005, new Employee(1005, \"cara\", \"5@lucky.com\", 0, new Department(101, \"后勤部\"))); } //增加一个员工 public void addEmployee(Employee employee){ //Integer id = 1006;//这行代码不能写在这里，要不每一次新增员工的时候，id都是从1006开始了！又是我犯的一个错误 if(employee.getId() == null){ employee.setId(id++); } employees.put(employee.getId(), employee); } //查询全部员工 public Collection&lt;Employee&gt; getEmployees(){ return employees.values(); } //根据id查询员工 public Employee getEmployeeById(Integer id){ return employees.get(id); } //删除员工 public void removeEmployeeById(Integer id){ employees.remove(id); }} 首页实现 实现通过localhost:8080或者localhost:8080/index进入首页的功能 123456789@Configurationpublic class MyMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { //只需要访问http://localhost:8080/或者http://localhost:8080/index就可以跳转到index.html页面 registry.addViewController(\"/\").setViewName(\"index\"); registry.addViewController(\"/index\").setViewName(\"index\"); }} 所有的静态资源导入都需要使用Thymeleaf接管。所以： 要先给静态资源导入Thymeleaf命名空间。1&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; 按照Thymeleaf的语法规则，修改静态资源文件。 123456&lt;!-- Bootstrap core CSS --&gt;&lt;link th:href=\"@{/css/bootstrap.min.css}\" rel=\"stylesheet\"&gt;&lt;!-- Custom styles for this template --&gt;&lt;link th:href=\"@{/css/signin.css}\" rel=\"stylesheet\"&gt;&lt;img class=\"mb-4\" th:src=\"@{/img/bootstrap-solid.svg}\" alt=\"\" width=\"72\" height=\"72\"&gt; 修改这里的时候有遇到下面这个问题。之前中英文我写的href是@{/index.html}，但是点击中文或者English的超链接的时候一直报错，导致国际化一直跳转失败。后来把href改为@{/index}问题才得以解决。 12345678&lt;button class=\"btn btn-lg btn-primary btn-block\" type=\"submit\"&gt; [[#{login.signIn}]] &lt;/button&gt;&lt;p class=\"mt-5 mb-3 text-muted\"&gt;© 2022-2023&lt;/p&gt;&lt;a class=\"btn btn-sm\" th:href=\"@{/index(l='zh_CN')}\"&gt;中文&lt;/a&gt;&lt;a class=\"btn btn-sm\" th:href=\"@{/index(l='en_US')}\"&gt;English&lt;/a&gt;&lt;!-- 之前这样写的，点击之后总是跳转到error页面&lt;a class=\"btn btn-sm\" th:href=\"@{/index.html(l='zh_CN')}\"&gt;中文&lt;/a&gt;&lt;a class=\"btn btn-sm\" th:href=\"@{/index.html(l='en_US')}\"&gt;English&lt;/a&gt;--&gt; 后来经过思考，发现如果改一下自定义Config，就可以通过href访问到/index.html页面了。但是至于为什么这个可以，我还不知道底层原理，后面知道了之后再补充到这里 12345678910@Configurationpublic class MyMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\"/\").setViewName(\"index\"); registry.addViewController(\"/index\").setViewName(\"index\"); //加上这行代码，上面的html就可以写成th:href=\"@{/index.html(l='en_US')}然后也能正常跳转了。 registry.addViewController(\"/index.html\").setViewName(\"index\"); }} ![](https://raw.githubusercontent.com/xiaofanshutu/typora2022/main/202210090836775.png) ![](https://raw.githubusercontent.com/xiaofanshutu/typora2022/main/202210090836715.png) 关闭模板引擎的缓存123spring: thymeleaf: cache: false 页面国际化准备工作 先在IDEA中统一设置properties的编码问题！ 配置文件编写 我们在resources资源文件下新建一个i18n目录，存放国际化配置文件 建立一个login.properties文件，还有一个login_zh_CN.properties；发现IDEA自动识别了我们要做国际化操作；文件夹变了！ 接着可以直接在Resource Bundle上右键，添加en_US国际化配置文件 接下来，我们就来编写国际化配置文件，我们可以看到idea下面有另外一个视图； 如果你的IDEA没有这个视图，那么去plugins里面下载如下插件，下载完之后页面就会显示Resource Bundle视图。 配置文件生效探究 我们去看一下SpringBoot对国际化的自动配置！这里又涉及到一个类：MessageSourceAutoConfiguration 里面有一个方法，这里发现SpringBoot已经自动配置好了管理我们国际化资源文件(就是在i8n文件夹下的文件)的组件 ResourceBundleMessageSource； （这个东西是识别国际化配置信息文件里的信息） 12345678910111213141516171819202122@Beanpublic MessageSource messageSource(MessageSourceProperties properties) { ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); //如果你配置了basename，那么就会用你配置的basename路径 if (StringUtils.hasText(properties.getBasename())) { messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(properties.getBasename()))); } if (properties.getEncoding() != null) { messageSource.setDefaultEncoding(properties.getEncoding().name()); } messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale()); Duration cacheDuration = properties.getCacheDuration(); if (cacheDuration != null) { messageSource.setCacheMillis(cacheDuration.toMillis()); } messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat()); messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage()); return messageSource;} 我们项目的国际化文件在i18n下面，所以配置我们的basename为i18n.login12345spring: thymeleaf: cache: false messages: basename: i18n.login 配置页面国际化值 去页面获取国际化的值，查看Thymeleaf的文档，找到message取值操作为：#{…}。 配置国际化解析 在Spring中有一个国际化的Locale （区域信息对象）；里面有一个叫做LocaleResolver （获取区域信息对象）的解析器！ 我们去我们webmvc（WebMvcAutoConfiguration.java）自动配置文件，寻找一下！看到SpringBoot默认配置： 1234567891011121314@Bean@ConditionalOnMissingBean( name = {\"localeResolver\"} //不存在localeResolver的时候，走这个bean设置默认Locale)public LocaleResolver localeResolver() { if (this.webProperties.getLocaleResolver() == org.springframework.boot.autoconfigure.web.WebProperties.LocaleResolver.FIXED) { return new FixedLocaleResolver(this.webProperties.getLocale()); } else { //接收端国际化分解 AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.webProperties.getLocale()); return localeResolver; }} 点进去AcceptHeaderLocaleResolver（这是源码给的一个国际化（地区）解析器，我们也可以参考这个写一个自己的国际化解析器） 12345678910111213141516171819public Locale resolveLocale(HttpServletRequest request) { Locale defaultLocale = this.getDefaultLocale(); if (defaultLocale != null &amp;&amp; request.getHeader(\"Accept-Language\") == null) { return defaultLocale; } else { Locale requestLocale = request.getLocale(); List&lt;Locale&gt; supportedLocales = this.getSupportedLocales(); if (!supportedLocales.isEmpty() &amp;&amp; !supportedLocales.contains(requestLocale)) { Locale supportedLocale = this.findSupportedLocale(request, supportedLocales); if (supportedLocale != null) { return supportedLocale; } else { return defaultLocale != null ? defaultLocale : requestLocale; } } else { return requestLocale; } }} 自己的国际化解析器 123456789101112131415161718192021222324252627package com.cutiebambi.config;import org.springframework.util.StringUtils;import org.springframework.web.servlet.LocaleResolver;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Locale;public class MyLocaleResolver implements LocaleResolver { @Override public Locale resolveLocale(HttpServletRequest request) { String language = request.getParameter(\"lang\"); Locale requestLocale = Locale.getDefault(); if(!StringUtils.isEmpty(language)){ String[] s = StringUtils.split(language, \"_\"); requestLocale = new Locale(s[0], s[1]); } return requestLocale; } @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) { }} 请求端携带上lang参数12&lt;a class=\"btn btn-sm\" th:href=\"@{/index(lang='zh_CN')}\"&gt;中文&lt;/a&gt;&lt;a class=\"btn btn-sm\" th:href=\"@{/index(lang='en_US')}\"&gt;English&lt;/a&gt; 将自己写的国际化解析器放进Spring Boot里面 12345//这样做之后，自己写的国际化组件就生效了@Bean//注入自己写的国际化组件public LocaleResolver localeResolver(){ return new MyLocaleResolver();} 测试自己的代码 点击英文 点击中文 总结页面国家化步骤： 我们需要配置i18n文件，并在application.properties配置文件中绑定，之后在对应的html中用thymeleaf获取（获取国家化信息使用#{} ，链接url是@{} ，变量${}） Thymeleaf 官网：https://www.thymeleaf.org/ 如果我们需要在项目中进行按钮自动切换，我们需要自己定义一个组件MyLocalResolver继承LocaleResolver 记得将自己写的组件配置到spring容器中，@Bean 登录功能与拦截器登录功能实现 LoginController 1234567891011121314151617181920212223package com.cutiebambi.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.util.StringUtils;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import javax.servlet.http.HttpSession;@Controllerpublic class LoginController { @RequestMapping(\"/user/login\") public String login(@RequestParam(name = \"userName\") String userName, @RequestParam(name = \"password\") String password, Model model, HttpSession session){ if(!StringUtils.isEmpty(userName) &amp;&amp; password.equals(\"1\")){ session.setAttribute(\"loginUser\", userName); return \"redirect:/main.html\"; //重定向 }else{ model.addAttribute(\"msg\", \"用户名或密码错误，登录失败\"); return \"index\"; } }} MyMvcConfig 1234567891011121314151617181920212223242526package com.cutiebambi.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.LocaleResolver;import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class MyMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { //只需要访问http://localhost:8080/或者http://localhost:8080/index就可以跳转到index.html页面 registry.addViewController(\"/\").setViewName(\"index\"); registry.addViewController(\"/index\").setViewName(\"index\"); registry.addViewController(\"/index.html\").setViewName(\"index\"); registry.addViewController(\"/main.html\").setViewName(\"dashboard\"); } //将自定义的国际化组件放进Spring Boot里。 @Bean public LocaleResolver localeResolver(){ return new MyLocaleResolver(); }} index.html 1234567891011&lt;body class=\"text-center\"&gt; &lt;!-- 修改form表单action --&gt; &lt;form class=\"form-signin\" th:action=\"@{/user/login}\"&gt; ... &lt;button class=\"btn btn-lg btn-primary btn-block\" type=\"submit\"&gt; [[#{login.signIn}]] &lt;/button&gt; &lt;p class=\"mt-5 mb-3 text-muted\"&gt;© 2022-2023&lt;/p&gt; &lt;a class=\"btn btn-sm\" th:href=\"@{/index(lang='zh_CN')}\"&gt;中文&lt;/a&gt; &lt;a class=\"btn btn-sm\" th:href=\"@{/index(lang='en_US')}\"&gt;English&lt;/a&gt; &lt;/form&gt;&lt;/body&gt; 将登录之后的左上角名字显示为登录的用户名 1&lt;a class=\"navbar-brand col-sm-3 col-md-2 mr-0\" href=\"http://getbootstrap.com/docs/4.0/examples/dashboard/#\" th:text=\"${session.loginUser}\"&gt;&lt;/a&gt; 验证结果 拦截器功能实现 LoginHandlerInterceptor 123456789101112131415161718192021222324252627282930313233package com.cutiebambi.config;import org.springframework.boot.web.servlet.server.Session;import org.springframework.util.StringUtils;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;public class LoginHandlerInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { /* //我写的代码 if(!StringUtils.isEmpty(request.getParameter(\"userName\")) &amp;&amp; request.getParameter(\"password\").equals(\"1\")){ return true; }else{ return false; } */ //老师的代码 HttpSession session = request.getSession(); if(session.getAttribute(\"loginUser\") != null){ return true; }else { session.setAttribute(\"msg\", \"用户名或者密码错误，我是从拦截器过来的提示信息\");// 感觉加上这行没什么作用 request.getRequestDispatcher(\"/index.html\").forward(request,response);//转发到index.html 显示提示信息 return false; } }} MyMvcConfig12345678910111213141516171819202122232425262728293031323334353637package com.cutiebambi.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.LocaleResolver;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@Configurationpublic class MyMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { //只需要访问http://localhost:8080/或者http://localhost:8080/index就可以跳转到index.html页面 registry.addViewController(\"/\").setViewName(\"index\"); registry.addViewController(\"/index\").setViewName(\"index\"); registry.addViewController(\"/index.html\").setViewName(\"index\"); registry.addViewController(\"/main.html\").setViewName(\"dashboard\"); } //将自定义的国际化组件放进Spring Boot里。 @Bean public LocaleResolver localeResolver(){ return new MyLocaleResolver(); } //拦截器 @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(\"/**\").excludePathPatterns(\"/\", \"/index.html\", \"/user/login\", \"/img/**\", \"/css/**\", \"/js/**\"); }} 展示员工列表将公共代码抽取存放在commons.html里面 点击员工管理按钮, 实现从后台获取员工列表数据并且在前台页面展示 新建一个EmployeeController 1234567891011121314151617181920212223242526package com.cutiebambi.controller;import com.cutiebambi.dao.EmployeeDao;import com.cutiebambi.pojo.Employee;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.util.StringUtils;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import javax.servlet.http.HttpSession;import java.util.Collection;@Controllerpublic class EmployeeController { @Autowired private EmployeeDao employeeDao; @RequestMapping(\"/employee/getEmployees\") public String getEmployees(Model model){ Collection&lt;Employee&gt; employees = employeeDao.getEmployees(); model.addAttribute(\"emps\", employees); return \"/emp/list\"; }} 点击前台’员工管理’tab，调用这个方法 前台接收并且解析获取到的数据123456789101112131415161718192021222324252627282930313233343536373839&lt;div class=\"row\"&gt; &lt;!-- 侧边栏 --&gt; &lt;div th:replace=\"~{/commons/commons.html :: sidebar(active='list.html')}\"&gt;&lt;/div&gt; &lt;main role=\"main\" class=\"col-md-9 ml-sm-auto col-lg-10 pt-3 px-4\"&gt; &lt;h2&gt;Section title&lt;/h2&gt; &lt;div class=\"table-responsive\"&gt; &lt;table class=\"table table-striped table-sm\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;lastName&lt;/th&gt; &lt;th&gt;email&lt;/th&gt; &lt;th&gt;gender&lt;/th&gt; &lt;th&gt;department&lt;/th&gt; &lt;th&gt;birth&lt;/th&gt; &lt;th&gt;action&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr th:each=\"employee : ${emps}\"&gt; &lt;td th:text=\"${employee.getId()}\"&gt;&lt;/td&gt; &lt;td th:text=\"${employee.getLastName()}\"&gt;&lt;/td&gt; &lt;td th:text=\"${employee.getEmail()}\"&gt;&lt;/td&gt; &lt;!-- 这里使用了三元运算符 --&gt; &lt;td th:text=\"${employee.getGender()} == 0? '女' : '男'\"&gt;&lt;/td&gt; &lt;td th:text=\"${employee.getDepartment().getDepartmentName()}\"&gt;&lt;/td&gt; &lt;!-- 格式化日期 --&gt; &lt;td th:text=\"${#calendars.format(employee.getBirth(),'yyyy/MM/dd HH:mm:ss')}\"&gt;&lt;/td&gt; &lt;td&gt; &lt;button class=\"btn btn-sm btn-primary\"&gt;增加&lt;/button&gt; &lt;button class=\"btn btn-sm btn-danger\"&gt;删除&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/main&gt;&lt;/div&gt; 侧边栏：根据点击的tab不同来实现动态高亮 添加，修改与删除员工错误处理https://blog.csdn.net/wang_luwei/article/details/123652585","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://xiaofanshutu.github.io/categories/SpringBoot/"}],"tags":[],"author":"cutiebambi"},{"title":"CS61A","slug":"CS61A","date":"2023-04-29T01:07:41.731Z","updated":"2024-01-17T23:38:56.334Z","comments":true,"path":"posts/e7a99a5e.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/e7a99a5e.html","excerpt":"","text":"Week1-0826命令 ls: lists all files in the current directory cd &lt;path to directory&gt;: change into the specified directory mkdir &lt;directory name&gt;: make a new directory with the given name mv &lt;source path&gt; &lt;destination path&gt;: move the file at the given source to the given destination ls cd $ cd C:/Users/cutiebambi/Desktop $ cd ..：跳转到上级目录 $ cd ：这个的意思是home directory，所以cd ~意思就是跳转到你的home directory $ cd：这是cd ~的一个缩写方式 mkdir$ mkdir 20230114 mv$ mv d:/20230114 d:/dest Python Basics 浮点除法 (/)：将第一个数字除以第二个数字，计算结果为带小数点的数字，即使数字被整除也是如此。 整除法 (//)：将第一个数字除以第二个数字，然后向下舍入，计算结果为整数。 模 (%)：计算除法剩余的正余数。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://xiaofanshutu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"cutiebambi"},{"title":"HTML5","slug":"HTML","date":"2023-04-29T01:07:41.731Z","updated":"2024-01-17T23:39:11.784Z","comments":true,"path":"posts/98f3a6d9.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/98f3a6d9.html","excerpt":"","text":"什么是HTMLHTML Hyper Text Markup Language(超文本标记语言) HTML的全称为超文本标记语言，是一种标记语言。它包括一系列标签．通过这些标签可以将网络上的文档格式统一，使分散的Internet资源连接为一个逻辑整体。HTML文本是由HTML命令组成的描述性文本，HTML命令可以说明文字，图形、动画、声音、表格、链接等。 W3C World Wide Web Consortium(万维网联盟) 万维网联盟创建于1994年，是Web技术领域最具权威和影响力的国际中立性技术标准机构。W3C已发布了200多项影响深远的Web技术标准及实施指南，如广为业界采用的超文本标记语言HTML（标准通用标记语言下的一个应用）、可扩展标记语言XML（标准通用标记语言下的一个子集）以及帮助残障人士有效获得Web信息的无障碍指南（WCAG）等，有效促进了Web技术的互相兼容，对互联网技术的发展和应用起到了基础性和根本性的支撑作用。 网页基本信息1234567891011121314151617&lt;!-- DOCTYPE: 告诉浏览器，我们要使用什么规范 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;!-- head: 代表网页头部 --&gt;&lt;head&gt; &lt;!-- meta: 描述性标签，用来描述我们网站的一些信息 --&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;!-- title: 网页标题 --&gt; &lt;title&gt;我的第一个HTML网页&lt;/title&gt;&lt;/head&gt;&lt;!-- body: 代表网页主体 --&gt;&lt;body&gt;你好，bambi&lt;/body&gt;&lt;/html&gt; 网页基本标签12345678910111213141516171819202122232425262728293031&lt;body&gt;&lt;!--标题标签--&gt;&lt;h1&gt;h1标题&lt;/h1&gt;&lt;h2&gt;h2标题&lt;/h2&gt;&lt;h3&gt;h2标题&lt;/h3&gt;&lt;h4&gt;h2标题&lt;/h4&gt;&lt;h5&gt;h2标题&lt;/h5&gt;&lt;h6&gt;h2标题&lt;/h6&gt;&lt;!--段落标签--&gt;&lt;p&gt; 这是一个段落标签&lt;/p&gt;&lt;!--换行标签--&gt;这是一个换行&lt;br&gt;标签&lt;!--水平线标签--&gt;&lt;hr&gt;&lt;!--字体样式标签-粗体--&gt;&lt;strong&gt;hope to see you on the top&lt;/strong&gt;&lt;!--字体样式标签-斜体--&gt;&lt;em&gt;boun prem&lt;/em&gt;&lt;!--特殊符号-空格--&gt;你&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;好&lt;!--特殊符号-大于--&gt;&amp;gt;&lt;!--特殊符号-小于--&gt;&amp;lt;&lt;!--特殊符号-版权所有--&gt;&amp;copy;&lt;/body&gt; 图像标签 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;HTML学习&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=\"resources/image/5.png\" title=\"海绵宝宝\" width=\"300\" height=\"300\" /&gt;&lt;/body&gt;&lt;/html&gt; 超链接标签及其应用文本超链接123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;HTML学习&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--href: 必填，表示要跳转到哪一个页面--&gt;&lt;!--target: 表示窗口在哪里打开--&gt;&lt;a href=\"test01.html\" target=\"_blank\"&gt;文本超链接&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 图像超链接12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;HTML学习&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"test01.html\" target=\"_blank\"&gt;&lt;img src=\"resources/image/5.png\" title=\"图片超链接\" width=\"300\" height=\"300\" /&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 锚链接123&lt;a id=\"bottom\"&gt;&lt;/a&gt;&lt;!--锚链接--&gt;&lt;a href=\"test01.html#bottom\"&gt;跳转到底部&lt;/a&gt; 功能性链接邮件链接12&lt;!--邮件链接--&gt;&lt;a href=\"mailto:15191434031@163.com\"&gt;邮件链接&lt;/a&gt; 块元素和行内元素 块元素 无论内容多少，该元素独占一行 (p, h1-h6) 行内元素 内容撑开宽度，左右都是行内元素的可以排在一行 (a, strong, em) 列表标签无序列表1234&lt;!--无序列表--&gt;&lt;ul&gt;a&lt;/ul&gt;&lt;ul&gt;b&lt;/ul&gt;&lt;ul&gt;c&lt;/ul&gt; 有序列表123456&lt;!--有序列表--&gt;&lt;ol&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;草莓&lt;/li&gt;&lt;/ol&gt; 自定义列表123456789&lt;!--自定义列表: 自定义列表一般用在网站底部--&gt;&lt;dl&gt; &lt;dt&gt;我的爱好 &lt;dd&gt;游泳&lt;/dd&gt; &lt;dd&gt;看书&lt;/dd&gt; &lt;dd&gt;听音乐&lt;/dd&gt; &lt;dd&gt;跑步&lt;/dd&gt; &lt;/dt&gt;&lt;/dl&gt; 表格标签1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;表格标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- tr:行 td:列 跨行:rowspan 跨列:colspan--&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td rowspan=\"3\"&gt;11&lt;/td&gt; &lt;td&gt;12&lt;/td&gt; &lt;td&gt;13&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;22&lt;/td&gt; &lt;td&gt;23&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt;33&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 媒体元素视频文件1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;媒体元素&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--controls:控制条autoplay:自动播放--&gt;&lt;video src=\"resources/video/02.mp4\" controls autoplay&gt;测试视频&lt;/video&gt;&lt;/body&gt;&lt;/html&gt; 视频能成功加载并且会自动播放 音频文件1&lt;audio src=\"resources/video/02.mp4\" controls autoplay&gt;&lt;/audio&gt; 页面结构分析 元素名 描述 header 标记头部区域的内容（用于页面或页面中的一块区域） footer 标记脚部区域的内容（用于整个页面或者页面的一块区域） section Web页面中的一块独立区域 article 独立的文章内容 aside 相关内容或应用（常用于侧边栏） nav 导航类辅助内容 iframe内联框架12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;内联框架&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;iframe src=\"test03.html\" name=\"mainFrame\"&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt; 初识表单post和get提交123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;提交表单&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"test01.html\" method=\"get\"&gt; &lt;p&gt;用户名：&lt;input type=\"text\"/&gt;&lt;/p&gt; &lt;p&gt;密 码：&lt;input type=\"password\"/&gt;&lt;/p&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;input type=\"reset\" value=\"重置\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 文本框和单选框 123456789101112131415161718&lt;!--文本输入框--&gt;文本输入框&lt;p&gt; &lt;input type=\"text\" name=\"name\"&gt;&lt;/p&gt;&lt;!--密码框--&gt;密码框&lt;p&gt; &lt;input type=\"password\"&gt;&lt;/p&gt;&lt;!--单选框，默认选中男checked--&gt;性别&lt;p&gt; &lt;input type=\"radio\" name=\"sex\" value=\"男\" checked&gt;男 &lt;input type=\"radio\" name=\"sex\" value=\"女\"&gt;女&lt;/p&gt; 按钮和多选框12345678910&lt;p&gt; &lt;input type=\"checkbox\" value=\"reading\" name=\"hobby\"&gt;阅读 &lt;input type=\"checkbox\" value=\"running\" name=\"hobby\" checked&gt;跑步 &lt;input type=\"checkbox\" value=\"yoga\" name=\"hobby\"&gt;瑜伽&lt;/p&gt;&lt;p&gt; &lt;input type=\"button\" value=\"按钮显示的文字\" name=\"btn1\"&gt; &lt;input type=\"image\" src=\"resources/image/5.png\" width=\"200\"&gt;&lt;/p&gt; 列表框文本域和文件域12345678910111213141516171819202122&lt;p&gt;下拉框 &lt;select name=\"水果天堂\"&gt; &lt;option value=\"banana\"&gt;香蕉&lt;/option&gt; &lt;option value=\"apple\" selected&gt;苹果&lt;/option&gt;&lt;!-- 苹果默认会是选中的 --&gt; &lt;option value=\"strawberry\"&gt;草莓&lt;/option&gt; &lt;/select&gt;&lt;/p&gt;&lt;p&gt;文本域 &lt;textarea name=\"remark\" cols=\"60\" rows=\"10\"&gt; 在这里写入备注内容 &lt;/textarea&gt;&lt;/p&gt;&lt;p&gt;文件域 &lt;input type=\"file\" name=\"file\"&gt; &lt;input type=\"button\" value=\"上传文件\" name=\"upload\"&gt;&lt;/p&gt; 搜索框滑块和简单验证123456789101112131415161718&lt;form&gt;&lt;p&gt;邮箱： &lt;input type=\"email\" name=\"email\"&gt;&lt;/p&gt;&lt;p&gt;URL： &lt;input type=\"url\" name=\"url\"&gt;&lt;/p&gt;&lt;p&gt;滑块： &lt;input type=\"range\" min=\"0\" max=\"100\" name=\"voice\" step=\"2\"&gt;&lt;/p&gt;&lt;p&gt;搜索： &lt;input type=\"search\" name=\"search\"&gt;&lt;/p&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 表单的应用 隐藏域hidden 只读readonly 禁用disable 表单初级验证 placeholder：提示信息 required：非空判断 pattern：正则表达式 123&lt;p&gt; 用户名：&lt;input type=\"text\" name=\"name\" required placeholder=\"请输入用户名\"&gt;&lt;/p&gt;","categories":[{"name":"HTML5","slug":"HTML5","permalink":"https://xiaofanshutu.github.io/categories/HTML5/"}],"tags":[],"author":"cutiebambi"},{"title":"Javascript","slug":"Javascript","date":"2023-04-29T01:07:41.731Z","updated":"2024-01-17T23:40:19.407Z","comments":true,"path":"posts/cbb79327.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/cbb79327.html","excerpt":"","text":"聊聊JavaScriptJavaScript的起源故事网景公司急需一种网页脚本语言，使得浏览器可以与网页互动。工程师Brendan Eich负责开发这种新语言。他觉得，没必要设计得很复杂，这种语言只要能够完成一些简单操作就够了，比如判断用户有没有填写表单。 Brendan Eich。1995年4月，网景公司录用了他。 Brendan Eich的主要方向和兴趣是函数式编程，网景公司招聘他的目的，是研究将Scheme语言作为网页脚本语言的可能性。 仅仅一个月之后，1995年5月，网景公司做出决策，未来的网页脚本语言必须”看上去与Java足够相似”，但是比Java简单，使得非专业的网页作者也能很快上手。这个决策实际上将Perl、Python、Tcl、Scheme等非面向对象编程的语言都排除在外了。 Brendan Eich被指定为这种”简化版Java语言”的设计师。 但是，他对Java一点兴趣也没有。为了应付公司安排的任务，他只用10天时间就把Javascript设计出来了。 由于设计时间太短，语言的一些细节考虑得不够严谨，导致后来很长一段时间，Javascript写出来的程序混乱不堪。如果Brendan Eich预见到，未来这种语言会成为互联网第一大语言，全世界有几百万学习者，他会不会多花一点时间呢？ 设计思想总的来说，他的设计思路是这样的： 1234（1）借鉴C语言的基本语法；（2）借鉴Java语言的数据类型和内存管理；（3）借鉴Scheme语言，将函数提升到\"第一等公民\"（first class）的地位；（4）借鉴Self语言，使用基于原型（prototype）的继承机制。 所以，Javascript语言实际上是两种语言风格的混合产物—-（简化的）函数式编程+（简化的）面向对象编程。这是由Brendan Eich（函数式编程）与网景公司（面向对象编程）共同决定的。 小结JavaScript是 Netscape 公司于 Sun 公司合作开发的。在“javascript”出现之前，Web浏览器不过是一种能够显示超文本文档的软件的基础部分。而在“javascript”出现之后，网页的内容不再局限于枯燥的文本，他们的可交互性得到了显著的改善。 Javascript的第一个版本，即javaScript1.0版本，出现在1995年推出的Netscape Navigatior住在这浏览器市场，微软的IE浏览器则扮演这追赶者的角色。微软在推出IE 3的时候发布了自己的VBScript语言并以JScript为名发布了javaScript的一个版本，一次很快跟上了Netscape的步伐。 详细内容： https://zhuanlan.zhihu.com/p/400339768 ECMAScriptECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会，European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，所以它可以理解为是JavaScript的一个标准,但实际上后两者是ECMA-262标准的实现和扩展。 一个合格的Java开发必须精通JavaScript 快速入门引入JavaScript内部标签123&lt;script&gt; alert(123);&lt;/script&gt; 外部引入1&lt;script src=\"hello.js\"&gt;&lt;/script&gt; 基本语法入门定义变量123456&lt;script&gt; //变量类型 变量名 = 变量值 var name = \"boun\"; var age = 13; alert(\"name= \" + name + \", age= \" + age);&lt;/script&gt; 条件控制123456&lt;script&gt; var score = 98; if(score &gt; 90){ alert(\"你的表现真的很不错，继续保持哦\") }&lt;/script&gt; 浏览器调试 在浏览器的控制台打印变量 console.log(score); 用浏览器F12调试代码 数据类型number：js不区分整数和小数123456123 //整数123.1 // 浮点数1.123e3 //科学计数法-80 //负数NaN //not a numberInfinity //无限大 字符串12'abc'\"abc\" 布尔值12truefalse 逻辑运算123&amp;&amp;与||或!非 比较运算1234=== 等于（类型不一样，值一样，也会判断为true）=== 绝对等于（类型一样，值一样，结果才会判断为true） NaN===NaN 结果为false，一般用isNaN来判断 null和undefinednull: 空 undefined: 未定义 数组123456789&lt;script&gt; //定义数组方式一（为了保证代码的可读性，尽量使用这种方式来定义数组） const arr = [1, 2, 3, 'hello', null, true]; //定义数组方式二 const arr2 = new Array(8, 9, null, false, 'hi'); console.log(arr); console.log(arr2);&lt;/script&gt; 根据下标取值，如果越界，则会报undefined错误 对象12345678&lt;script&gt; const person = { name: \"summer\", age: 3, tags: [\"js\", \"java\", \"springboot\"] }; console.log(person);&lt;/script&gt; 严格检查模式这个可以预防因js的随意性产生的一些问题。 数据类型字符串 正常字符串我们用单引号或双引号包裹 转义字符\\ 12345\\'\\n\\t\\u4e2d Unicode字符\"\\x41\" ASCII字符 多行字符串编写 12345`hello你好` 模板字符串 12let name = \"summer\";let msg = '你好呀，${name}'; 字符串长度 12var student = \"abby\";console.log(student.length); 字符串的可变性，不可变 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;我的第一个Javascript&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; var name=\"Summer\"; console.log(name.length); name[0]='b'; console.log(name);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 大小写转换 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;我的第一个Javascript&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; var name=\"Summer\"; console.log(name.toUpperCase()); console.log(name.toLowerCase());&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; indexOf12345&lt;script&gt; var name=\"Summer\"; console.log(name.indexOf('a'));//-1 console.log(name.indexOf('m'));//2&lt;/script&gt; subString 1234&lt;script&gt; var name=\"abcdef\"; console.log(name.substring(1,3));//bc [) 前包后不包&lt;/script&gt; 数组1var arr = [1,2,3,4,5]; 1.长度 1234&lt;script&gt; var arr = [1,2,3,4,5]; console.log(arr.length);//5&lt;/script&gt; 数组长度是可变的，如果给arr.length赋值，数组大小就会变化。 12345&lt;script&gt; const arr = [1, 2, 3, 4, 5]; arr.length = 10; console.log(arr.length);//10&lt;/script&gt; indexOf() 通过元素获得下标 1234&lt;script&gt; const arr = [1, 2, 3, 4, 5]; console.log(arr.indexOf(3));//2&lt;/script&gt; slice() 截取arr的一部分，返回一个新数组 1234&lt;script&gt; const arr = [1, 2, 3, 4, 5]; console.log(arr.slice(1,3));//[2, 3]&lt;/script&gt; push() pop() 从尾部插入数据/弹出尾部的数据 123456789&lt;script&gt; const arr = [1, 2, 3, 4, 5]; arr.push(6); arr.push(7); console.log(arr);//[1, 2, 3, 4, 5, 6, 7] arr.pop(); console.log(arr);//[1, 2, 3, 4, 5, 6]&lt;/script&gt; unshift() shift()从头部插入或弹出数据 1234567891011&lt;script&gt; const arr = [1, 2, 3, 4, 5]; //Inserts new elements at the start of an array, and returns the new length of the array. arr.unshift(6); arr.unshift(7); console.log(arr);//[7, 6, 1, 2, 3, 4, 5] //Removes the first element from an array and returns it. arr.shift(); console.log(arr);//[6, 1, 2, 3, 4, 5]&lt;/script&gt; sort() 12345&lt;script&gt; const arr = [5, 2, 6, 4, 1,3]; arr.sort(); console.log(arr);//[1, 2, 3, 4, 5, 6]&lt;/script&gt; reverse()元素反转 12345&lt;script&gt; const arr = [1, 2, 3, 4, 5, 6]; arr.reverse(); console.log(arr);//[6, 5, 4, 3, 2, 1]&lt;/script&gt; contact() 并没有修改原始数组，只是返回一个新数组 123456&lt;script&gt; const arr = [1, 2, 3, 4, 5, 6]; const arr2 = [7, 8, 9]; console.log(arr.concat(arr2));//[1, 2, 3, 4, 5, 6, 7, 8, 9] console.log(arr);//[1, 2, 3, 4, 5, 6]&lt;/script&gt; join() 12345&lt;script&gt; const arr = [1, 2, 3, 4, 5, 6]; console.log(arr.join(\"-\"));//1-2-3-4-5-6 console.log(arr);//[1, 2, 3, 4, 5, 6]&lt;/script&gt; 多维数组 对象对象就是若干个键值对，JavaScript中对象所有的键都是字符串，值是任意对象。 对象属性赋值 123456789&lt;script&gt; const person ={ name: \"summer\", age: 30, score: 80 } person.name = \"lucky\"; console.log(person);//{name: 'lucky', age: 30, score: 80}&lt;/script&gt; 使用一个不存在的对象属性，不会报错 动态的删减属性 动态添加属性 判断一个属性是否存在于这个对象中 判断一个属性是否是这个对象自身拥有的 流程控制if判断12345678&lt;script&gt; const name = \"summer\"; if(name.indexOf(\"m\") &gt; -1){ console.log(\"yes\"); }else{ console.log(\"no\"); }&lt;/script&gt; 1yes while循环1234567&lt;script&gt; let i = 10; while (i &gt; 0){ console.log(i); i--; }&lt;/script&gt; for循环12345678910111213141516171819202122232425&lt;script&gt; const array = [1, 2, 3, 4, 5]; //普通for console.log(\"=================\"); for (let i = 0; i &lt; array.length; i++) { console.log(array[i]); } //for...in... console.log(\"=================\"); for (const arrayKey in array) { console.log(arrayKey);//这个输出的是array各个值对应的key } console.log(\"=================\"); for (const arrayKey in array) { console.log(array[arrayKey]); } //for...of... console.log(\"=================\"); for (const number of array) { console.log(number); }&lt;/script&gt; foreach循环123456&lt;script&gt; const array = [1, 2, 3, 4, 5]; array.forEach(function (value){ console.log(value); });&lt;/script&gt; Map和Set (ES6新特性)1234&lt;script&gt; const map = new Map([[\"tom\", 90], [\"anny\", 85], [\"jack\", 95]]); console.log(map);// {'tom' =&gt; 90, 'anny' =&gt; 85, 'jack' =&gt; 95}&lt;/script&gt; Set：元素不重复的集合 1234&lt;script&gt; const set = new Set([1,2,3,2,5]); console.log(set);//{1, 2, 3, 5}&lt;/script&gt; Iterator作业：使用Iterator遍历Map和Set（使用for…of…或者for…in…）遍历数组 123456&lt;script&gt; const arr = [3, 4, 5]; for (let x of arr) { console.log(x); }&lt;/script&gt; 1234567&lt;script&gt; const arr = [3, 4, 5]; arr.name = \"halla\"; for (let number in arr) { console.log(number); }&lt;/script&gt; 遍历Map 123456&lt;script&gt; const map = new Map([[\"tom\", 90], [\"anny\", 85], [\"jack\", 95]]); for (const mapElement of map) { console.log(mapElement); }&lt;/script&gt; 遍历Set 123456&lt;script&gt; const set = new Set([1,2,3]); for (const number of set) { console.log(number); }&lt;/script&gt; 函数定义函数12345678910&lt;script&gt; //方式一 function abs(x) { if(x &gt;= 0){ return x; }else{ return -x; } }&lt;/script&gt; 1234567891011&lt;script&gt; //方式二 //function (x)是一个匿名函数，把结果赋给abs，通过abs就可以访问函数 const abs = function (x) { if (x &gt;= 0) { return x; } else { return -x; } };&lt;/script&gt; 调用函数1234abs(-8) //8abs(9) //9abs(10,123,456,789) //10 //参数问题，可以传入任意个参数abs() //NaN 参数问题如何规避？ 不存在参数 12345678910111213&lt;script&gt; //function (x)是一个匿名函数，把结果赋给abs，通过abs就可以访问函数 const abs = function (x) { if(typeof x != \"number\"){ console.log(\"参数格式不对，请重新传入参数\") } if (x &gt;= 0) { return x; } else { return -x; } };&lt;/script&gt; arguments arguments代表传递进来的所有参数，是一个数组 问题：abs(x, y, z) arguments会获取到包括x在内的所有参数的值，所以如果想要得到y的值，必须先拿到x的值 1234567891011121314151617&lt;script&gt; //function (x)是一个匿名函数，把结果赋给abs，通过abs就可以访问函数 const abs = function (x) { if(typeof x != \"number\"){ console.log(\"参数格式不对，请重新传入参数\") } if(arguments.length &gt; 1){ console.log(\"传入的参数值多于一个\") } if (x &gt;= 0) { return x; } else { return -x; } };&lt;/script&gt; rest rest参数只能写在最后，用…标识 1234567&lt;script&gt; const abs = function (x, y, ...z) { console.log(\"x=\" + x); console.log(\"y=\" + y); console.log(\"z=\" + z); };&lt;/script&gt; 变量的作用域1234567&lt;script&gt; function getNum() { var x = 1; x = x+1; } x = x+2;//Uncaught ReferenceError: x is not defined&lt;/script&gt; 1234567891011&lt;script&gt; function a() { const x = 1; function b() { const y = x + 1; console.log(\"y=\" + y);//y=2 }; return b(); const z = y + 1;//Uncaught ReferenceError: y is not defined }&lt;/script&gt; 全局变量12345678910&lt;script&gt; function a() { var x = 1; function f(){ console.log(x); } f(); console.log(x); }&lt;/script&gt; 123a()11 全局对象window1234&lt;!-- alert(str) 等价于 alert(window.str) --&gt;&lt;script&gt; var str = 123;&lt;/script&gt; 测试全局对象12345678910&lt;script&gt; var str = 123; window.alert(str); //123 var old_alert = window.alert; old_alert(str); //123 window.alert = function (x){ alert(x); //Uncaught RangeError: Maximum call stack size exceeded } window.alert(\"456\");&lt;/script&gt; 123456789&lt;script&gt; var str = 123; window.alert(str); //123 var old_alert = window.alert; old_alert(str); //123 window.alert = function (){ } window.alert(456); //没有任何弹出信息&lt;/script&gt; 123456789101112&lt;script&gt; var str = 123; window.alert(str); //123 var old_alert = window.alert; old_alert(str); //123 window.alert = function (){ } window.alert(456); //没有任何弹出信息 window.alert = old_alert; window.alert(789); //789&lt;/script&gt; 规范所有的全局变量都会绑定到window上，如果不同的文件用了同样的全局变量，就会冲突。 解决方案：定义唯一命名空间 12345678910&lt;script&gt; //唯一全局命名空间 var kuangstudy = []; //定义全局变量 kuangstudy.name = \"java\"; kuangstudy.add = function (a, b) { return a + b; }&lt;/script&gt; 局部作用域letES6之后引入了let，为了解决局部作用域冲突的问题。 用var定义变量 12345678&lt;script&gt; function aaa(){ for (var i = 0; i&lt;5; i++){ console.log(i); } console.log(i);//之前老师讲课的时候，这里是可以输出i的值的，但是我今天测试发现不能输出，会报undefined错误，应该是JS底层什么东西改了导致的。 }&lt;/script&gt; 用let定义变量 12345678&lt;script&gt; function aaa(){ for (let i = 0; i&lt;5; i++){ console.log(i); } console.log(i);//Uncaught ReferenceError: i is not defined }&lt;/script&gt; 常量constES6之前如何定义常量？123456&lt;script&gt; var PI = 3.14; console.log(PI);//3.14 PI = 3.15; console.log(PI);//3.15 常量PI的值被改变了&lt;/script&gt; ES6之后，引入了const 方法定义方法方法：把函数放在对象内部，对象只有两个东西，一个是属性，一个是方法。 1234567891011121314&lt;script&gt; const kuangshen = { name: \"kuang\", birth: 2020, age: function () { const now = new Date().getFullYear(); return now - this.birth; } }; //调用属性 console.log(kuangshen.name);//kuang //调用方法 console.log(kuangshen.age());//3&lt;/script&gt; 上面这段代码里面的this代表什么？ 123456789101112131415161718&lt;script&gt; function getAge() { const now = new Date().getFullYear(); return now - this.birth; } const kuangshen = { name: \"kuang\", birth: 2020, age: getAge }; //this默认指向调用它的那个对象 console.log(kuangshen.age());//3 //这里this指向了window对象，但是window对象没有birth属性，所以获取到的内容是NaN console.log(window.getAge());//NaN&lt;/script&gt; apply在js中可以控制this的指向！ 123456789101112131415&lt;script&gt; function getAge() { const now = new Date().getFullYear(); return now - this.birth; } const kuangshen = { name: \"kuang\", birth: 2020, age: getAge }; console.log(window.getAge.apply(kuangshen, []));//3 //this指向kuangshen，参数为空 console.log(window.getAge().apply(kuangshen, []));//Uncaught TypeError: window.getAge(...).apply is not a function &lt;/script&gt; 内部对象标准对象 Date基本使用1234567891011&lt;script&gt; const now = new Date(); console.log(\"年： \" + now.getFullYear()); console.log(\"月： \" + now.getMonth()); console.log(\"日： \" + now.getDate()); console.log(\"星期： \" + now.getDay()); console.log(\"时： \" + now.getHours()); console.log(\"分： \" + now.getMinutes()); console.log(\"秒： \" + now.getSeconds()); console.log(\"时间戳： \" + now.getTime());//时间戳是全世界统一的&lt;/script&gt; 12345678年： 2023月： 0日： 11星期： 3时： 10分： 36秒： 41时间戳： 1673404601231 转换1234567&lt;script&gt; //时间戳转换为Date对象 now = new Date(1673404601231); console.log(now); console.log(now.toLocaleString()); console.log(now.toUTCString());&lt;/script&gt; 123Wed Jan 11 2023 10:36:41 GMT+0800 (中国标准时间)2023/1/11 10:36:41Wed, 11 Jan 2023 02:36:41 GMT JSONJSON是什么？JSON是一个标记符的序列。这套标记符包含六个构造字符、字符串、数字和三个字面名。JSON是一个序列化的对象或数组。 六个构造字符：begin-array = ws %x5B ws ; [ 左方括号begin-object = ws %x7B ws ; { 左大括号end-array = ws %x5D ws ; ] 右方括号end-object = ws %x7D ws ; } 右大括号name-separator = ws %x3A ws ; : 冒号value-separator = ws %x2C ws ; , 逗号 在这六个构造字符的前或后允许存在无意义的空白符(ws):ws = *（%x20 /; 空间%x09 /; 水平标签%x0A /; 换行或换行%x0D）; 回程 JSON的构成:值可以是对象、数组、数字、字符串或者三个字面值(false、null、true)中的一个。值中的字面值中的英文必须使用小写。 对象由花括号括起来的逗号分割的成员构成，成员是字符串键和上文所述的值由逗号分割的键值对组成，如： 1{\"name\": \"John Doe\", \"age\": 18, \"address\": {\"country\" : \"china\", \"zip-code\": \"10000\"}} JSON中的对象可以包含多个键值对，并且有数组结构，该语言正是一次实现过程内容的描述。 数组是由方括号括起来的一组值构成，如： 1[3, 1, 4, 1, 5, 9, 2, 6] 字符串与C或者Java的字符串非常相似。字符串是由双引号包围的任意数量Unicode字符的集合，使用反斜线转义。一个字符（character）即一个单独的字符串（character string）。 数字也与C或者Java的数值非常相似。除去未曾使用的八进制与十六进制格式。除去一些编码细节。 一些合法的JSON的实例： 1{\"a\": 1, \"b\": [1, 2, 3]} 1[1, 2, \"3\", {\"a\": 4}] 13.14 1\"plain_text\" JSON和JS对象的区别？JSON 与 JS 对象的关系JSON 是 JS 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。 1var obj = {a: 'Hello', b: 'World'}; //这是一个对象，注意键名也是可以使用引号包裹的 1var json = '{\"a\": \"Hello\", \"b\": \"World\"}'; //这是一个 JSON 字符串，本质是一个字符串 JSON 和 JS 对象互转从JSON字符串转换为JS对象，使用 JSON.parse() 方法： 1var obj = JSON.parse('{\"a\": \"Hello\", \"b\": \"World\"}'); //结果是 {a: 'Hello', b: 'World'} 从JS对象转换为JSON字符串，使用 JSON.stringify() 方法： 1var json = JSON.stringify({a: 'Hello', b: 'World'}); //结果是 '{\"a\": \"Hello\", \"b\": \"World\"}' Ajax原生JS写法 xhr异步请求JQuery封装好的方法 $(“#name”).ajax(“”)axios面向对象编程什么是面向对象？类：模板 对象：具体的实例 在JavaScript中，这个需要换一个思维方式。 原型：","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://xiaofanshutu.github.io/categories/Javascript/"}],"tags":[],"author":"cutiebambi"},{"title":"Java Web","slug":"Java Web","date":"2022-06-12T00:31:41.000Z","updated":"2024-01-17T23:39:22.939Z","comments":true,"path":"posts/fb60fea1.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/fb60fea1.html","excerpt":"","text":"Java Web基本概念基本概念 用Java开发网页的技术统称为JavaWeb。 web程序：可以提供浏览器访问的程序； web应用分两种: 静态web资源（如html 页面）： 指web页面中的数据始终是不变。 所有用户看到都是同一个页面。 技术：HTML、CSS。 动态web资源： 指web页面中的浏览的数据是由服务器提供的。 所有用户看到都是同一个页面。 技术：JSP/Servlet、ASP、PHP等。 web应用程序编写完毕后，若想提供给外界访问：需要一个服务器来统一管理； web服务器常见的web的服务器： Apache Nginx IIS WebLogic WebSphere Tomcat Tomcat 因为技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。 Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和 并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP程序的首选。对于一个Java初学web的人来说，它是最佳的选择。 Tomcat安装tomcattomcat官网：http://tomcat.apache.org/ 1、选择合适在的压缩包 2、下载压缩包并解压 Tomcat启动和配置 启动tomcat，然后访问http://localhost:8080/测试 可能遇到的问题： Java环境变量没有配置 闪退问题：需要配置兼容性 乱码问题：配置文件中设置 配置 可以配置启动的端口号 123&lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt; tomcat默认端口号：8080 mysql默认端口号：3306 http默认端口号：80 https默认端口号：443 可以配置主机的名称 12&lt;Host name=\"localhost\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\"&gt; 默认的主机名称为：localhost-&gt;127.0.0.1 默认网站应用存放的位置为：webapps 面试题 请你谈谈网站是如何访问的。 输入一个域名，回车 检查本机的hosts配置文件下有没有这个域名映射 有：直接返回对应的ip地址，这个地址中，有我们要访问的web程序，可以直接访问。 1127.0.0.1 localhost 没有：去DNS服务器找，找到的话返回，找不到就返回找不到。 发布一个web网站将自己写的网站，放到服务器(Tomcat)中指定的web应用的文件夹（webapps）下，就可以访问了 网站应该有的结构 1234567891011121314--webapps：Tomcat服务器的web目录 -ROOT -betterme：自己新建的网站的目录名 -WEB-INF -classes: java程序 -lib：web应用所依赖的jar包 -web.xml：网站配置文件 - index.html：默认的首页 - static -css -style.css -js -img -..... Http什么是HTTP超文本传输协议（Hyper Text Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上。 文本：html，字符串，~ …. 超文本：图片，音乐，视频，定位，地图……. 默认端口：80 HTTPS （全称：Hyper Text Transfer Protocol over SecureSocket Layer），是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性 。HTTPS 在HTTP 的基础下加入SSL，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。 默认端口：443 两个时代 http1.0 HTTP/1.0：客户端与web服务器连接后，只能获得一个web资源。 http2.0 HTTP/1.1：客户端与web服务器连接后，可以获得多个web资源。 Http请求 客户端——发请求（Request）—–服务器 General 12345Request URL: https://www.baidu.com/ 请求地址Request Method: GET 请求方式，一般是GET/POSTStatus Code: 200 OK 状态码：200表示成功，404表示没有找到资源，500表示服务器错误Remote Address: 36.152.44.96:443 远程地址Referrer Policy: strict-origin-when-cross-origin 12345Accept: text/htmlAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,zh-TW;q=0.8Cache-Control: privateConnection: keep-alive 请求行（request line） 请求方式：GET, POST, HEAD, DELETE, PUT, TRACT GET: 请求能都携带的参数比较少，大小没有限制，会在浏览器的URL地址栏显示数据内容，不安全，但是高效。 POST：请求能够携带的参数没有限制，大小没有限制，不会在浏览器URL地址栏中显示数据内容，安全，但不高效。 消息头12345Accept: 告诉浏览器，它所支持的数据类型Accept-Encoding: 支持哪种编码格式 GBK UTF-8Accept-Language: 告诉浏览器，它的语言环境Cache-Control: 缓存控制Connection: 告诉浏览器，请求完成是断开还是保持连接 Http响应服务器—–响应—–客户端 Response Headers 1234Cache-Control: private 缓存控制Connection: keep-alive 连接Content-Encoding: gzip 编码Content-Type: text/html;charset=utf-8 HTTP请求的完全过程：https://blog.csdn.net/ailunlee/article/details/90600174 响应体12345678Accept：告诉浏览器，它所支持的数据类型Accept-Encoding：支持哪种编码格式 GBK UTF-8 GB2312 ISO8859-1Accept-Language：告诉浏览器，它的语言环境Cache-Control：缓存控制Connection：告诉浏览器，请求完成是断开还是保持连接HOST：主机Refresh：告诉客户端，多久刷新一次；Location：让网页重新定位； 响应状态码200：请求响应成功 3xx：请求重定向 重定向：你重新到我给你的位置去。 4xx：找不到资源 404 5xx：服务器代码错误 500 502 面试题：当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示出来，经历了什么？ Maven为什么要学习这个技术？ 在Java Web开发中，需要使用大量的jar包，我们手动去导入； 如何能够让一个东西自动帮我导入和配置这个jar包。 由此，Maven诞生了！ Maven项目架构管理工具我们目前用它就是为了方便导入jar包的！ Maven的核心思想：约定大于配置 有约束，不要去违反 下载安装Maven官网: https://maven.apache.org/ 下载完成后，解压即可； 配置环境变量在系统环境变量中，配置以下配置： M2_HOME (maven的目录下的bin目录) MAVEN_HOME (maven的目录) 在系统的path中添加 %MAVEN_HOME%\\bin 配置完成后，测试maven是否安装成功。 配置阿里云加速镜像使用阿里云Maven中央仓库作为下载源，速度更快更稳定。 maven 安装目录的 conf/settings.xml 在&lt;mirrors&gt;&lt;/mirrors&gt;标签中添加 mirror子节点 12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 本地仓库修改本地的仓库存放位置 maven 安装目录的 conf/settings.xml 在&lt;settings&gt;&lt;/settings&gt;标签中添加 localRepository子节点，按个人习惯存放。 1&lt;localRepository&gt;D:\\Tools\\apache-maven-3.8.5\\maven_repo&lt;/localRepository&gt; 在IDEA中使用Maven1、启动IDEA 2、 创建一个MavenWeb项目 3、等待项目初始化完毕 4、检查IDEA中的Maven设置 6、到这里，Maven在IDEA中的配置和使用就OK了! 创建一个普通的Maven项目 只有在Web应用下才有的项目结构 标记文件夹功能 在 IDEA中配置Tomcat1、添加tomcat 2、相关配置 3、启动tomcat pom文件pom.xml 是Maven的核心配置文件. 记录了项目具体依赖的Jar包的配置版本。 maven由于它是约定大于配置，有时候会遇到写的配置文件不生效的问题。 解决方案： 123456789101112131415161718192021&lt;!--在build中配置resources，来防止我们资源导出失败的问题--&gt;&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; Maven仓库的使用地址：https://mvnrepository.com ServletServlet简介Servlet用java语言开发动态资源网站的技术。 把实现了Servlet接口的Java程序叫做，Servlet servlet生成的class文件存放在tomcat中webapps目录下。 HelloServletSerlvet接口有两个默认的实现类：HttpServlet，GenericServlet 1、构建一个普通的Maven项目，删掉里面的src目录，以后我们的学习就在这个项目里面建立 Module；这个空的工程就是Maven主工程； 2、 关于Maven父子工程的理解： 父工程会显示子工程的信息。 子工程会继承父工程。 3、编写一个Servlet程序 3.1、在父工程引用相关的Jar包 123456789101112&lt;!-- servlet --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- jsp --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.3.3&lt;/version&gt;&lt;/dependency&gt; 3.2、编写一个普通类，继承HttpServlet 123456789101112131415package com.betterme;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class HelloServlet extends HttpServlet { @Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException { response.setContentType(\"text/html; charset=utf-8\"); response.getWriter().print(\"Hello,小番薯兔\"); }} 3.3、Servlet的映射 为什么需要映射：我们写的是JAVA程序，但是要通过浏览器访问，而浏览器需要连接web服务器， 所以我们需要再web服务中注册我们写的Servlet，让浏览器找到我们java程序的发布目录 12345678910&lt;!--注册Servlet--&gt;&lt;servlet&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;servlet-class&gt;com.betterme.HelloServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!--Servlet的请求路径--&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/betterme&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 3.4、配置Tomcat，并访问。 Servlet原理Servlet是由Web服务器调用。 Servlet映射问题1、一个Servlet可以指定一个映射路径 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 2、一个Servlet可以指定多个映射路径 1234567891011121314&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello2&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello3&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 3、一个Servlet可以指定通用映射路径 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 4、默认请求路径 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 5、指定一些后缀或者前缀等等… 12345&lt;!-- 注意，*前面不能加项目映射的路径--&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;*.demo&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 6、优先级问题指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求； 12345678910111213141516171819&lt;!--但是如果你在地址栏输入/hello, 也是能访问到HelloServlet的, 这就是因为固有的映射路径优先级最高--&gt;&lt;servlet&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;servlet-class&gt;com.betterme.HelloServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!--这里配置的是/*, 所以默认会进入error--&gt;&lt;servlet&gt; &lt;servlet-name&gt;error&lt;/servlet-name&gt; &lt;servlet-class&gt;com.betterme.ErrorServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;error&lt;/servlet-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; ServletContextweb容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext对象，它代表了当前的 web应用； 共享数据在一个Servlet中保存的数据，可以在另外一个servlet中拿到； 12345678910111213141516package com.betterme;import javax.servlet.ServletContext;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class HelloServlet extends HttpServlet { @Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException { ServletContext servletContext = this.getServletContext(); servletContext.setAttribute(\"name\", \"小番薯兔\"); }} 1234567891011121314151617package com.betterme;import javax.servlet.ServletContext;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class GetServlet extends HttpServlet { @Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException { ServletContext servletContext = this.getServletContext(); response.setContentType(\"text/html; charset=utf-8\"); response.getWriter().print(\"name:\" + servletContext.getAttribute(\"name\")); }} 1234567891011121314151617&lt;servlet&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;servlet-class&gt;com.betterme.HelloServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet&gt; &lt;servlet-name&gt;get&lt;/servlet-name&gt; &lt;servlet-class&gt;com.betterme.GetServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;get&lt;/servlet-name&gt; &lt;url-pattern&gt;/get&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 测试访问结果: 先访问hello路径保存数据到ServletContext 再访问get路径获取上面保存的数据 获取初始化参数12345678910111213&lt;context-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;12345&lt;/param-value&gt;&lt;/context-param&gt;&lt;servlet&gt; &lt;servlet-name&gt;get&lt;/servlet-name&gt; &lt;servlet-class&gt;com.betterme.GetInitParamServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;get&lt;/servlet-name&gt; &lt;url-pattern&gt;/get&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 1234567891011121314151617package com.betterme;import javax.servlet.ServletContext;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class GetInitParamServlet extends HttpServlet { @Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException { ServletContext servletContext = this.getServletContext(); response.setContentType(\"text/html; charset=utf-8\"); response.getWriter().print(servletContext.getInitParameter(\"password\")); }} 请求转发123456789101112131415161718package com.bambi.servlet;import javax.servlet.RequestDispatcher;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class DispatcherServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { ServletContext context = this.getServletContext(); RequestDispatcher requestDispatcher = context.getRequestDispatcher(\"/hello\");// 请求转发的路径 requestDispatcher.forward(req, resp); }} 1234567891011121314151617package com.bambi.servlet;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"进入HelloServlet doGet方法\"); ServletContext servletContext = this.getServletContext(); servletContext.setAttribute(\"name\", \"summer\"); }} 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;context-param&gt; &lt;param-name&gt;hobby&lt;/param-name&gt; &lt;param-value&gt;climbing&lt;/param-value&gt; &lt;/context-param&gt; &lt;servlet&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;servlet-class&gt;com.bambi.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;com.bambi.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/dispatcher&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 访问/dispatcher的时候，经过转发，实际会访问/hello.但是url不会改变 读取资源文件123456789101112131415161718192021package com.bambi.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.InputStream;import java.util.Properties;public class ReadPropertiesServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { InputStream resourceAsStream = this.getServletContext().getResourceAsStream(\"/WEB-INF/classes/db.properties\"); Properties properties = new Properties(); properties.load(resourceAsStream); String userName = properties.getProperty(\"userName\"); String password = properties.getProperty(\"password\"); resp.getWriter().print(userName + \": \" + password); }} 12userName= summerpassword= 12345 12345678&lt;servlet&gt; &lt;servlet-name&gt;read&lt;/servlet-name&gt; &lt;servlet-class&gt;com.bambi.servlet.ReadPropertiesServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;read&lt;/servlet-name&gt; &lt;url-pattern&gt;/read&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; java文件和resources目录下的文件都打包在了classes文件夹里面，这个文件夹我们俗称为classpath。 HttpServletResponseweb服务器接收到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest对象，代表响应的一个HttpServletResponse； 获取客户端请求过来的参数：HttpServletRequest 响应客户端响应一些信息：HttpServletResponse 简单分类负责向浏览器发送数据的方法 12ServletOutputStream getOutputStream() throws IOException;PrintWriter getWriter() throws IOException; 负责向浏览器发送响应头的方法 12345678910void setCharacterEncoding(String var1);void setContentLength(int var1);void setContentLengthLong(long var1);void setContentType(String var1);void setDateHeader(String var1, long var2);void addDateHeader(String var1, long var2);void setHeader(String var1, String var2);void addHeader(String var1, String var2);void setIntHeader(String var1, int var2);void addIntHeader(String var1, int var2); 响应的状态码 12345int SC_OK = 200;int SC_MULTIPLE_CHOICES = 300;int SC_BAD_REQUEST = 400;int SC_NOT_FOUND = 404;int SC_INTERNAL_SERVER_ERROR = 500; 常见应用验证码功能1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.*;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;public class ImageServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //让浏览器3秒刷新一次 resp.setHeader(\"refresh\", \"3\"); //在内存中创建一个图片 BufferedImage bufferedImage = new BufferedImage(80, 20, BufferedImage.TYPE_INT_RGB); //得到图片 Graphics2D graphics = (Graphics2D) bufferedImage.getGraphics(); //设置图片背景颜色 graphics.setBackground(Color.white); graphics.fillRect(0, 0, 80, 20); //给图片写数据 graphics.setColor(Color.red); graphics.setFont(new Font(null, Font.BOLD, 20)); graphics.drawString(generateNum(), 0, 20); resp.setContentType(\"image/png\"); resp.setDateHeader(\"expires\", -1); resp.setHeader(\"Cache-Control\", \"no-cache\"); //把图片写给浏览器 ImageIO.write(bufferedImage, \"png\", resp.getOutputStream()); } private String generateNum() { Random random = new Random(); String num = random.nextInt(9999999) + \"\"; StringBuffer stringBuffer = new StringBuffer(); for (int i = 0; i &lt; 7 - num.length(); i++) { stringBuffer.append(\"0\"); } num = stringBuffer.toString() + num; return num; }} 12345678&lt;servlet&gt;&lt;servlet-name&gt;randomNum&lt;/servlet-name&gt;&lt;servlet-class&gt;ImageServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;randomNum&lt;/servlet-name&gt;&lt;url-pattern&gt;/randomNum&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 下载文件 获取下载文件的路径 下载的文件名是什么 想办法让浏览器能够支持下载我们需要的东西 获取下载文件的输入流 获取OutputStream对象 将FileOutputStream流写入到buffer缓冲区 xxxxxxxxxx&nbsp;– listing properties –name=DB02pwd=130.133.13.14java 123456789101112131415161718192021222324252627282930import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.FileInputStream;import java.io.IOException;public class DownloadPicServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String realPath = this.getServletContext().getRealPath(\"/WEB-INF/classes/test.png\"); System.out.println(\"需要下载的文件的路径是\" + realPath); String fileName = realPath.substring(realPath.lastIndexOf(\"\\\\\") + 1); resp.setHeader(\"Content-disposition\", \"attachment;filename=\" + fileName); FileInputStream fileInputStream = new FileInputStream(realPath); int len = 0; byte[] buffer = new byte[1024]; ServletOutputStream outputStream = resp.getOutputStream(); while ((len = fileInputStream.read(buffer)) != -1) { outputStream.write(buffer, 0, len); } fileInputStream.close(); outputStream.close(); }} 12345678&lt;servlet&gt; &lt;servlet-name&gt;downloadPic&lt;/servlet-name&gt; &lt;servlet-class&gt;DownloadPicServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;downloadPic&lt;/servlet-name&gt; &lt;url-pattern&gt;/downloadPic&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 在地址栏输入downloadPic 回车 文件下载成功 如果文件名是中文，那么用URLEncoder.encode(fileName, “utf8”)把文件名转一下，要不可能会出现乱码 12345678910111213141516171819202122232425262728293031import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.FileInputStream;import java.io.IOException;import java.net.URLEncoder;public class DownloadPicServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String realPath = this.getServletContext().getRealPath(\"/WEB-INF/classes/测试中文文件名.png\"); System.out.println(\"需要下载的文件的路径是\" + realPath); String fileName = realPath.substring(realPath.lastIndexOf(\"\\\\\") + 1); resp.setHeader(\"Content-disposition\", \"attachment;filename=\" + URLEncoder.encode(fileName, \"utf8\")); FileInputStream fileInputStream = new FileInputStream(realPath); int len = 0; byte[] buffer = new byte[1024]; ServletOutputStream outputStream = resp.getOutputStream(); while ((len = fileInputStream.read(buffer)) != -1) { outputStream.write(buffer, 0, len); } fileInputStream.close(); outputStream.close(); }} 转发与重定向转发流程： 实现代码： 1request.getRequestDispatcher(\"/地址\").forward(request, response); 重定向流程： 实现代码 1response.sendRedirect(\"/地址\"); 123456789101112import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class RedirectServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.sendRedirect(\"/servlet_05_war/randomNum\"); }} 12345678&lt;servlet&gt; &lt;servlet-name&gt;redirect&lt;/servlet-name&gt; &lt;servlet-class&gt;RedirectServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;redirect&lt;/servlet-name&gt; &lt;url-pattern&gt;/redirect&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 1234567891011121314151617import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class Request extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //处理请求 String userName = req.getParameter(\"userName\"); String password = req.getParameter(\"password\"); System.out.println(userName + \":\" + password); //重定向一定要注意路径问题 resp.sendRedirect(\"/servlet_05_war/success.jsp\"); }} 12345678&lt;servlet&gt; &lt;servlet-name&gt;request&lt;/servlet-name&gt; &lt;servlet-class&gt;Request&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;request&lt;/servlet-name&gt; &lt;url-pattern&gt;/login&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; index.jsp 12345678910&lt;html&gt; &lt;body&gt; &lt;%--这里提交的路径，需要寻找到项目的路径--%&gt; &lt;form action=\"${pageContext.request.contextPath}/login\" method=\"get\"&gt; UserName:&lt;input type=\"text\" name=\"userName\"&gt; &lt;br&gt; Password:&lt;input type=\"password\" name=\"password\"&gt; &lt;br&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; success.jsp 1234567&lt;html&gt; &lt;body&gt; &lt;h1&gt;success~&lt;/h1&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 如果Request类不加重定向代码，那么submit之后就会进入一个空白页面，在路径上会把填写的userName和password打出来。 如果Request类加了重定向代码，那么submit之后就会进入重定向后的页面。 HttpServletRequestHttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，HTTP请求中的所有信息会被封装到HttpServletRequest，通过这个HttpServletRequest的方法，获得客户端的所有信息； 1//获取参数request.getParameter(\"p1\");request.getParameterValues(\"p2\");//设置request编码为UTF-8request.setCharacterEncoding(\"UTF-8\"); 获取前端传递的参数并且实现请求转发工程目录结构 12345678910111213141516171819202122232425262728293031import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Arrays;public class LoginServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.setCharacterEncoding(\"utf-8\"); resp.setCharacterEncoding(\"utf-8\"); //获取前台表单数据 String userName = req.getParameter(\"userName\"); String password = req.getParameter(\"password\"); String[] hobbies = req.getParameterValues(\"hobby\"); System.out.println(Arrays.toString(hobbies)); //请求转发 //这里的/指的是当前的web应用 req.getRequestDispatcher(\"/success.jsp\").forward(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); }} web.xml 12345678&lt;servlet&gt; &lt;servlet-name&gt;login&lt;/servlet-name&gt; &lt;servlet-class&gt;LoginServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;login&lt;/servlet-name&gt; &lt;url-pattern&gt;/login&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; index.jsp 123456789101112131415161718192021&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Login Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"${pageContext.request.contextPath}/login\" method=\"post\"&gt; 用户名：&lt;input type=\"text\" name=\"userName\"&gt; &lt;br&gt; 密码：&lt;input type=\"password\" name=\"password\"&gt; &lt;br&gt; 爱好：&lt;input type=\"checkbox\" name=\"hobby\" value=\"跑步\"&gt;跑步 &lt;input type=\"checkbox\" name=\"hobby\" value=\"阅读\"&gt;阅读 &lt;input type=\"checkbox\" name=\"hobby\" value=\"编程\"&gt;编程 &lt;input type=\"checkbox\" name=\"hobby\" value=\"听音乐\"&gt;听音乐 &lt;input type=\"checkbox\" name=\"hobby\" value=\"爬山\"&gt;爬山 &lt;br&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; success.jsp 123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Login Success Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Login success~&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; ==请求转发和重定向的区别== 相同点 页面都会实现跳转 不同点 请求转发的时候，url不会产生变化；307 重定向的时候，url地址栏会发生变化；302 Cookie &amp; Session会话用户打开一个 浏览器，点击了很多 超链接，访问多个web资源，关闭浏览器，这个过程可以称之为会话。 ==有状态会话==： 1、 服务端给客户端一个标识，客户端带上标识访问服务端即可: cookie 2、 服务器登记你来过了，下次你来的时候我来匹配你: seesion 保存会话的两种技术Cookie 1客户端技术 （响应，请求） Session 1服务器技术，利用这个技术，可以保存用户的会话信息。我们可以把信息或者数据放在Session中。 常见常见：网站登录之后，你下次不用再登录了，第二次访问直接就上去了！ Cookie什么是Cookie访问网站的时候，Cookie会在客户端保存。一般会保存在本地的 用户目录下 appdata； 1、访问网站时，服务器会返回cookie信息。 2、客户端访问服务器时，需要带上cookie，方便知道你是谁。 关于Cookie的细节问题 一个Cookie只能保存一个信息； 一个web站点可以给浏览器发送多个cookie，每个站点最多存放20个cookie； Cookie大小有限制4kb； 300个cookie浏览器上限 删除Cookie 不设置有效期，关闭浏览器，自动失效； 设置有效期时间为 0 ； 1cookie.setMaxAge(0); 中文编码解码12URLEncoder.encode(\"小番薯兔\", \"utf-8\");URLDecoder.decode(cookie.getValue(), \"utf-8\"); 练习12345678910111213141516171819202122232425262728293031323334353637383940414243package com.betterme.servlet;import javax.servlet.ServletException;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.util.Date;//保存用户上一次访问的时间public class CookieDemo01 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.setCharacterEncoding(\"utf-8\"); resp.setCharacterEncoding(\"utf-8\"); resp.setContentType(\"text/html;charset=utf-8\"); PrintWriter out = resp.getWriter(); //Cookie,服务器端从客户端获取。 Cookie[] cookies = req.getCookies();//这里返回数组，说明Cookie可能存在多个。 //判断Cookie是否存在 if (cookies != null) { out.print(\"你上一次访问这个网站的时间是：\"); for (Cookie cookie : cookies) { if (cookie.getName().equals(\"lastLoginTime\")) { //获取cookie中的值 long l = Long.parseLong(cookie.getValue()); Date date = new Date(l); out.write(date.toString()); } } } else { out.write(\"这是你第一次访问这个网站\"); } //服务器给客户端响应一个Cookie Cookie cookie = new Cookie(\"lastLoginTime\", System.currentTimeMillis() + \"\"); cookie.setMaxAge(24*60*60);//设置cookie过期时间 resp.addCookie(cookie); }} 12345678&lt;servlet&gt; &lt;servlet-name&gt;cookieDemo01&lt;/servlet-name&gt; &lt;servlet-class&gt;com.betterme.servlet.CookieDemo01&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;cookieDemo01&lt;/servlet-name&gt; &lt;url-pattern&gt;/cookieDemo01&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; https://gitee.com/xiaofanshutugoon/cloudimage/raw/master/img/snipaste_20220517_080641.png Session（重点）什么是Session 服务器会给每一个用户（浏览器）创建一个Seesion对象； 一个Seesion独占一个浏览器，只要浏览器没有关闭，这个Session就存在； 用户登录之后，整个网站他都可以访问！—&gt; Session的应用：保存用户的信息；用户的权限等等 Session和Cookie的区别 Cookie是把用户的数据写给用户的浏览器，浏览器保存 （可以保存多个） Session把用户的数据写到用户独占Session中，服务器端保存 （保存重要的信息，减少服务器资源的浪费） Session对象由服务器创建； 使用场景 保存一个登录用户的信息； 在整个网站中经常会使用的数据，我们将它保存在Session中； Session常用方法123456789101112//得到SessionHttpSession session = req.getSession();//给Session中存数据session.setAttribute(\"name\",\"admin\");//获取Session中的数据session.getAttribute(\"name\");//删除Session中的数据session.removeAttribute(\"name\");//获取Session的IDString sessionId = session.getId()//手动注销SessionSessionsession.invalidate(); 练习1保存一个字符串到session 12345678910111213141516171819202122232425262728293031package com.betterme.servlet;import javax.servlet.ServletException;import javax.servlet.http.*;import java.io.IOException;public class SessionDemo01 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //解决乱码问题 req.setCharacterEncoding(\"utf-8\"); resp.setCharacterEncoding(\"utf-8\"); resp.setContentType(\"text/html;charset=utf-8\"); //得到session HttpSession session = req.getSession(); //给session中存数据 session.setAttribute(\"name\", \"小番薯兔\"); //获取session的ID String id = session.getId(); //判断session是不是新session if (session.isNew()) { resp.getWriter().write(\"session创建成功, ID:\" + id); } else { resp.getWriter().write(\"这个session在服务器中已经存在了, ID:\" + id); } }} 用SessionDemo02获取SessionDemo01保存在session中的字符串 12345678910111213141516171819package com.betterme.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class SessionDemo02 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.setCharacterEncoding(\"utf-8\"); resp.setCharacterEncoding(\"utf-8\"); resp.setContentType(\"text/html;charset=utf-8\"); String name = (String) req.getSession().getAttribute(\"name\"); System.out.println(name); }} 练习2保存一个对象到session 12345678910111213141516171819202122232425262728293031323334package com.betterme.servlet;import com.betterme.servlet.pojo.Person;import javax.servlet.ServletException;import javax.servlet.http.*;import java.io.IOException;public class SessionDemo01 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //解决乱码问题 req.setCharacterEncoding(\"utf-8\"); resp.setCharacterEncoding(\"utf-8\"); resp.setContentType(\"text/html;charset=utf-8\"); //得到session HttpSession session = req.getSession(); //给session中存数据// session.setAttribute(\"name\", \"小番薯兔\"); session.setAttribute(\"person\", new Person(\"小番薯兔\", 23)); //获取session的ID String id = session.getId(); //判断session是不是新session if (session.isNew()) { resp.getWriter().write(\"session创建成功, ID:\" + id); } else { resp.getWriter().write(\"这个session在服务器中已经存在了, ID:\" + id); } }} 获取保存在session中的对象 123456789101112131415161718192021package com.betterme.servlet;import com.betterme.servlet.pojo.Person;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class SessionDemo02 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.setCharacterEncoding(\"utf-8\"); resp.setCharacterEncoding(\"utf-8\"); resp.setContentType(\"text/html;charset=utf-8\"); Person person = (Person) req.getSession().getAttribute(\"person\"); System.out.println(person); }} 练习3手动注销Session 123456789101112131415161718package com.betterme.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;public class SessionDemo03 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { HttpSession session = req.getSession(); session.removeAttribute(\"name\"); //手动注销Session session.invalidate(); }} 不同浏览器生成的sessionId是不同的。 手动清除session前 手动清除session后 会话自动过期12345&lt;!--设置Session默认的失效时间--&gt;&lt;session-config&gt; &lt;!--1分钟后Session自动失效，以分钟为单位--&gt; &lt;session-timeout&gt;1&lt;/session-timeout&gt;&lt;/session-config&gt; 1分钟后，刷新页面，重新生成了一个sessionId。 疑问：自动失效的这个，这个是只能让第一次的sessionId自动失效一次吗？经过测试，一旦重新生成了一个sessionId之后，这个sessionId就不会失效了。 下来查资料研究一下这里 JSP什么是JSPJava Server Pages(JSP)：Java服务器端页面，也和Servlet一样，用于动态Web技术！最大的特点： 写JSP就像在写HTML 区别： HTML只给用户提供静态的数据 JSP页面中可以嵌入JAVA代码，为用户提供动态数据； JSP原理学习思路：JSP到底是怎么执行的？ 代码层面没有任何问题 服务器内部工作 tomcat中有一个work目录； IDEA中使用Tomcat的会在IDEA的tomcat中生产一个work目录 浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet！ JSP最终也会被转换成为一个Java类！ JSP 本质上就是一个Servlet。 123public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase implements org.apache.jasper.runtime.JspSourceDependent, org.apache.jasper.runtime.JspSourceImports 1public abstract class HttpJspBase extends HttpServlet implements HttpJspPage 12345678910//初始化public void _jspInit() {}//销毁public void _jspDestroy() {}public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response) throws java.io.IOException, javax.servlet.ServletException { } 内置对象 12345678final javax.servlet.jsp.PageContext pageContext;//页面上下文javax.servlet.http.HttpSession session = null;//sessionfinal javax.servlet.ServletContext application;//applicationfinal javax.servlet.ServletConfig config;//configjavax.servlet.jsp.JspWriter out = null;//outfinal java.lang.Object page = this;//page 当前页HttpServletRequest request//请求HttpServletResponse response//响应 输出页面前增加的代码 12345678910111213try { response.setContentType(\"text/html\");//设置响应的页面类型 pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true); _jspx_page_context = pageContext; application = pageContext.getServletContext(); config = pageContext.getServletConfig(); session = pageContext.getSession(); out = pageContext.getOut(); _jspx_out = out;}以上的这些对象，我们可以在jsp页面上直接使用。 在JSP页面中，只要是java代码就会原封不动的输出，如果是html代码，就会被转换为out.write(“\\r\\n”); JSP基础语法任何语言都有自己的语法。 JSP 作为java技术的一种应用，它拥有一些自己扩充的语法（了解即可），可支持Java所有语法！ JSP表达式12345&lt;%-- JSP表达式 作用：用来将程序的输出，输出到客户端 &lt;%=变量或者表达式%&gt; --%&gt;&lt;%=new java.util.Date()%&gt; JSP脚本片段1234567891011121314151617181920212223242526272829&lt;%-- JSP脚本片段 作用：用来将程序的输出，输出到客户端 &lt;%=变量或者表达式%&gt; --%&gt;&lt;% int sum = 0; for (int i = 0; i &lt; 100; i++) { sum += i; } out.println(\"&lt;h1&gt;sum=\" + sum + \"&lt;/h1&gt;\");%&gt;&lt;% int x = 100; out.println(x);%&gt;&lt;p&gt;这是一个JSP文档&lt;/p&gt;&lt;% out.println(x);%&gt;&lt;%-- 在JSP代码中嵌入HTML元素 --%&gt;&lt;% for (int i = 0; i &lt; 3; i++) {%&gt;&lt;h2&gt;Hello Summer&lt;/h2&gt;&lt;% }%&gt; JSP声明12345678910&lt;!-- JSP声明 --&gt;&lt;%! static{ String message = \"Enjoy Every Day~\"; } private void testMethod(){ System.out.println(\"你好，明天~\"); }%&gt; JSP声明：会被编译到JSP生成Java的类中！其他的，就会被生成到_jspService方法中！ 在JSP，嵌入Java代码即可！ 1&lt;%%&gt;&lt;%=%&gt;&lt;%!%&gt;&lt;%--注释--%&gt; JSP的注释，不会在客户端显示，HTML注释就会！ JSP指令1234567891011&lt;%@page args.... %&gt;&lt;%@include file=\"\"%&gt;&lt;%--@include会将两个页面合二为一--%&gt;&lt;%@include file=\"common/header.jsp\"%&gt;&lt;h1&gt;网页主体&lt;/h1&gt;&lt;%@include file=\"common/footer.jsp\"%&gt;&lt;hr&gt;&lt;%--jSP标签jsp:include：拼接页面，本质还是三个--%&gt;&lt;jsp:include page=\"/common/header.jsp\"/&gt;&lt;h1&gt;网页主体&lt;/h1&gt;&lt;jsp:include page=\"/common/footer.jsp\"/&gt; 9大内置对象 PageContext Request Response Session Application —&gt; SerlvetContext config —&gt;SerlvetConfig out page ，不需要了解 exception 123456789101112131415161718192021222324252627282930313233343536&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%-- 内置对象 --%&gt;&lt;% pageContext.setAttribute(\"name1\", \"jack1\");//保存的数据只在一个页面中有效 request.setAttribute(\"name2\", \"jack2\");//保存的数据只在一次请求中有效，请求转发会携带这个数据 session.setAttribute(\"name3\", \"jack3\");//保存的数据只在一次会话中有效，从打开浏览器到关闭浏览器 application.setAttribute(\"name4\", \"jack4\");//保存的数据只在服务器中有效，从打开服务器到关闭服务器%&gt;&lt;%--脚本片段中的代码，会被原封不动的生成到.jsp_java--%&gt;&lt;% //从pageContext取出保存的值 String name1 = (String) pageContext.findAttribute(\"name1\"); String name2 = (String) pageContext.findAttribute(\"name2\"); String name3 = (String) pageContext.findAttribute(\"name3\"); String name4 = (String) pageContext.findAttribute(\"name4\"); String name5 = (String) pageContext.findAttribute(\"name5\");%&gt;&lt;%--使用EL表达式输出 ${} --%&gt;&lt;h1&gt;取出的值为：&lt;/h1&gt;&lt;h5&gt;${name1}&lt;/h5&gt;&lt;h5&gt;${name2}&lt;/h5&gt;&lt;h5&gt;${name3}&lt;/h5&gt;&lt;h5&gt;${name4}&lt;/h5&gt;&lt;h5&gt;${name5}&lt;/h5&gt;&lt;%--这种方式如果值不存在，EL表达式会自动给你过滤掉--%&gt;&lt;h5&gt;&lt;%=name5%&gt;&lt;/h5&gt;&lt;%--这种方式如果值不存在，那么会输出一个null--%&gt;&lt;/body&gt;&lt;/html&gt; 请求转发 12345678910111213&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% pageContext.forward(\"/index.jsp\"); //等价于 //request.getRequestDispatcher(\"/index.jsp\").forward(request, response); %&gt;&lt;/body&gt;&lt;/html&gt; request保存的数据只在一次请求中有效，请求转发会携带这个数据 将pageContextDemo01转发到pageContextDemo02，这个时候访问pageContextDemo01的时候，就能访问到name2 pageContextDemo01.jsp 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;pageContextDemo01&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%-- 内置对象 --%&gt;&lt;% pageContext.setAttribute(\"name1\", \"jack1\");//保存的数据只在一个页面中有效 request.setAttribute(\"name2\", \"jack2\");//保存的数据只在一次请求中有效，请求转发会携带这个数据 session.setAttribute(\"name3\", \"jack3\");//保存的数据只在一次会话中有效，从打开浏览器到关闭浏览器 application.setAttribute(\"name4\", \"jack4\");//保存的数据只在服务器中有效，从打开服务器到关闭服务器%&gt;&lt;%--脚本片段中的代码，会被原封不动的生成到.jsp_java--%&gt;&lt;% //从pageContext取出保存的值 String name1 = (String) pageContext.findAttribute(\"name1\"); String name2 = (String) pageContext.findAttribute(\"name2\"); String name3 = (String) pageContext.findAttribute(\"name3\"); String name4 = (String) pageContext.findAttribute(\"name4\"); String name5 = (String) pageContext.findAttribute(\"name5\");%&gt;&lt;%--请求转发--%&gt;&lt;% pageContext.forward(\"/pageContextDemo02.jsp\");%&gt;&lt;%--使用EL表达式输出 ${} --%&gt;&lt;h1&gt;取出的值为：&lt;/h1&gt;&lt;h5&gt;${name1}&lt;/h5&gt;&lt;h5&gt;${name2}&lt;/h5&gt;&lt;h5&gt;${name3}&lt;/h5&gt;&lt;h5&gt;${name4}&lt;/h5&gt;&lt;h5&gt;${name5}&lt;/h5&gt;&lt;%--这种方式如果值不存在，EL表达式会自动给你过滤掉--%&gt;&lt;h5&gt;&lt;%=name5%&gt;&lt;/h5&gt;&lt;%--这种方式如果值不存在，那么会输出一个null--%&gt;&lt;/body&gt;&lt;/html&gt; pageContextDemo02.jsp 12345678910111213141516171819202122232425262728&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;pageContextDemo02&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--脚本片段中的代码，会被原封不动的生成到.jsp_java--%&gt;&lt;% //从pageContext取出保存的值 String name1 = (String) pageContext.findAttribute(\"name1\"); String name2 = (String) pageContext.findAttribute(\"name2\"); String name3 = (String) pageContext.findAttribute(\"name3\"); String name4 = (String) pageContext.findAttribute(\"name4\"); String name5 = (String) pageContext.findAttribute(\"name5\");%&gt;&lt;%--使用EL表达式输出 ${} --%&gt;&lt;h1&gt;取出的值为：&lt;/h1&gt;&lt;h5&gt;${name1}&lt;/h5&gt;&lt;h5&gt;${name2}&lt;/h5&gt;&lt;h5&gt;${name3}&lt;/h5&gt;&lt;h5&gt;${name4}&lt;/h5&gt;&lt;h5&gt;${name5}&lt;/h5&gt;&lt;%--这种方式如果值不存在，EL表达式会自动给你过滤掉--%&gt;&lt;h5&gt;&lt;%=name5%&gt;&lt;/h5&gt;&lt;%--这种方式如果值不存在，那么会输出一个null--%&gt;&lt;/body&gt;&lt;/html&gt; 但是如果直接访问pageContextDemo02，还是不能访问name2 request：客户端向服务器发送请求，产生的数据，可能过会就用不上了，例：某个文章！ session：客户端向服务器发送请求，产生的数据，可能用完了还要用，例：用户信息； application：客户端向服务器发送请求，产生的数据，一个用户用完了，其他用户还可能使用。例：全局参数。 JSP标签、JSTL标签、EL表达式12345678910111213&lt;!-- JSTL表达式的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl-api&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- standard标签库 --&gt;&lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;/dependencies&gt; EL表达式${} 获取数据 执行运算 获取web开发的常用对象 JSP标签123456&lt;jsp:include page=\"相对 URL 地址\" flush=\"true\" /&gt;&lt;jsp:forward page=\"相对 URL 地址\" /&gt; &lt;jsp:param name=\"fontcolor\" value=\"red\" /&gt; &lt;jsp:param name=\"background\" value=\"black\" /&gt;&lt;/jsp:forward&gt; 示例jspTag1.jsp 123456789101112&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Better me&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;jsp:forward page=\"jspTag2.jsp\"&gt; &lt;jsp:param name=\"name\" value=\"lucky\"/&gt; &lt;jsp:param name=\"age\" value=\"10\"/&gt; &lt;/jsp:forward&gt;&lt;/body&gt;&lt;/html&gt; 示例jspTag2.jsp 12345678910111213&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Better me me&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%-- 通过JSP表达式获取name和age &lt;%=变量或者表达式%&gt; --%&gt; 姓名： &lt;%=request.getParameter(\"name\")%&gt; 年龄： &lt;%=request.getParameter(\"age\")%&gt;&lt;/body&gt;&lt;/html&gt; JSTL表达式JSTL支持通用的、结构化的任务，比如迭代，条件判断，XML文档操作，国际化标签，SQL标签。 核心标签（掌握部分即可） 格式化标签 SQL 标签 XML 标签 JSTL 函数 JSTL标签库使用步骤 引入对应的taglib 使用其中的方法 c:if123456789101112131415161718192021222324252627282930&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;%-- 引入JSTL核心标签库，我们才能使用JSTL标签 --%&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;if测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"coreif.jsp\" method=\"get\"&gt; &lt;%-- 通过EL表达式获取表单中的数据 ${param.参数名} --%&gt; &lt;input type=\"text\" name=\"userName\" value=\"${param.userName}\"&gt; &lt;input type=\"submit\" value=\"登录\"&gt;&lt;/form&gt;&lt;%-- 判断如果提交的用户名是管理员，则提示登录成功 --%&gt;&lt;c:if test=\"${param.userName == 'admin'}\" var=\"isAdmin\"&gt; &lt;c:out value=\"欢迎你登录系统，管理员\"&gt;&lt;/c:out&gt;&lt;/c:if&gt;&lt;c:if test=\"${param.userName != 'admin'}\" var=\"isAdmin\"&gt; &lt;c:out value=\"欢迎你登录系统，${param.userName}\" &gt;&lt;/c:out&gt;&lt;/c:if&gt;&lt;/body&gt;&lt;/html&gt; c:choose &amp; c:when1234567891011121314151617181920212223242526&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;%-- 引入JSTL核心标签库，我们才能使用JSTL标签 --%&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;c:set var=\"score\" value=\"95\"/&gt;&lt;c:choose&gt; &lt;c:when test=\"${score &gt;= 90}\"&gt; 优秀 &lt;/c:when&gt; &lt;c:when test=\"${score &gt;= 80}\"&gt; 良好 &lt;/c:when&gt; &lt;c:when test=\"${score &lt;= 70}\"&gt; 一般 &lt;/c:when&gt;&lt;/c:choose&gt;&lt;/body&gt;&lt;/html&gt; c:forEach12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;%@ page import=\"java.util.ArrayList\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;%-- 引入JSTL核心标签库，我们才能使用JSTL标签 --%&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% ArrayList&lt;String&gt; nameList = new ArrayList&lt;&gt;(); nameList.add(\"summer\"); nameList.add(\"lucky\"); nameList.add(\"cara\"); nameList.add(\"jacky\"); nameList.add(\"iris\"); nameList.add(\"mia\"); nameList.add(\"mat\"); nameList.add(\"cat\"); request.setAttribute(\"list\", nameList);%&gt;&lt;%--var: 每一次遍历出来的变量items: 要遍历的对象step: 步长--%&gt;&lt;c:forEach var=\"name\" items=\"${list}\"&gt; &lt;c:out value=\"${name}\"/&gt; &lt;br&gt;&lt;/c:forEach&gt;&lt;hr&gt;&lt;c:forEach var=\"name\" items=\"${list}\" begin=\"1\" end=\"5\" step=\"2\"&gt; &lt;c:out value=\"${name}\"/&gt; &lt;br&gt;&lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt; Java Bean实体类JavaBean有特定的写法： 必须要有一个无参构造 属性必须私有化 必须有对应的get/set方法； 一般用来和数据库的字段做映射 ORM（Object Relational Mapping）； ORM ：对象关系映射 数据库表—&gt;Java程序里面的一个类 字段—&gt;属性 行记录——&gt;对象 刚开始运行之后报了500错误，后来检查之后发现是因为实体类这里我只加了有参构造方法，没有无参构造方法 。但是 问我在jsp代码里面是下面这样用的，所以就报错。 123456789101112&lt;%@ page import=\"com.lucky.entity.User\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;jsp:useBean id=\"user\" class=\"com.lucky.entity.User\" scope=\"page\"/&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415package com.lucky.entity;public class User { private int id; private String name; private int age; private String sex; public User(int id, String name, int age, String sex) { this.id = id; this.name = name; this.age = age; this.sex = sex; }} 经过完善之后的代码如下： 1234567891011121314151617181920212223242526&lt;%@ page import=\"com.lucky.entity.User\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% //User user = new User();%&gt;&lt;jsp:useBean id=\"user\" class=\"com.lucky.entity.User\" scope=\"page\"/&gt;&lt;jsp:setProperty name=\"user\" property=\"id\" value=\"10001\"/&gt;&lt;jsp:setProperty name=\"user\" property=\"name\" value=\"李华\"/&gt;&lt;jsp:setProperty name=\"user\" property=\"age\" value=\"22\"/&gt;&lt;jsp:setProperty name=\"user\" property=\"sex\" value=\"女\"/&gt;id: &lt;jsp:getProperty name=\"user\" property=\"id\"/&gt; &lt;br&gt;name: &lt;jsp:getProperty name=\"user\" property=\"name\"/&gt; &lt;br&gt;age: &lt;jsp:getProperty name=\"user\" property=\"age\"/&gt; &lt;br&gt;sex: &lt;jsp:getProperty name=\"user\" property=\"sex\"/&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.lucky.entity;import java.util.ArrayList;import java.util.List;//实体类一般都是和数据库中的表一一对应public class User { private int id; private String name; private int age; private String sex; public User() { } public User(int id, String name, int age, String sex) { this.id = id; this.name = name; this.age = age; this.sex = sex; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; }} MVC什么是MVC Model：模型 View：视图 Controller ：控制器 开始的时候，web应用的操作，用户直接访问控制层，控制层就可以直接操作数据库； 123servlet--CRUD--&gt;数据库弊端：程序十分臃肿，不利于维护servlet的代码中：处理请求、响应、视图跳转、处理JDBC、处理业务代码、处理逻辑代码 MVC三层架构图 Model 业务处理 ：业务逻辑（Service） 数据持久层：CRUD （DAO） View 展示数据 提供链接发起Servlet请求 （a，form，img…） Controller 接收用户的请求 （req：请求参数、Session信息…） 交给业务层处理对应的代码 控制视图的跳转 1234561、登录2、接收用户的登录请求3、处理用户的请求（获取用户登录的参数，username，password）4、交给业务层处理登录业务（判断用户名密码是否正确：事务）5、Dao层查询用户名和密码是否正确6、数据库 过滤器、监听器FilterFilter：过滤器 ，用来过滤请求中的数据； 处理中文乱码 登录验证… 1、导入包（javax.servlet.Filter） 2、实现Filter接口，重写相应方法 123456789101112131415161718192021222324252627282930313233package com.bambi.filter;import javax.servlet.*;import java.io.IOException;public class CharacterEncodingFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\"执行init方法\"); } //chain: 链 /* 1. 过滤器中的所有代码，在过滤特定的请求的时候都会执行 2. 必须要让过滤器继续执行。 filterChain.doFilter(servletRequest, servletResponse); */ @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { servletRequest.setCharacterEncoding(\"utf-8\"); servletResponse.setCharacterEncoding(\"utf-8\"); servletResponse.setContentType(\"text/html; charset=utf-8\"); System.out.println(\"filter执行前\"); filterChain.doFilter(servletRequest, servletResponse);//让请求继续走，如果不写，程序到这里就被拦截停止了 System.out.println(\"filter执行后\"); } //Web服务器关闭的时候，就会执行销毁方法。 @Override public void destroy() { System.out.println(\"执行销毁方法\"); }} 3、在web.xml配置Filter 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;filter&gt; &lt;filter-name&gt;filter&lt;/filter-name&gt; &lt;filter-class&gt;com.bambi.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;filter&lt;/filter-name&gt; &lt;!--所有的请求，都会经过这个过滤器--&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;filter2&lt;/filter-name&gt; &lt;filter-class&gt;com.bambi.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;filter2&lt;/filter-name&gt; &lt;!--servletTest下面的所有请求，都会经过这个过滤器--&gt; &lt;url-pattern&gt;/servletTest/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 监听器实现一个监听器的接口；（有N种方式） 1、编写一个监听器，实现监听器的接口。 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.bambi.listener;import javax.servlet.ServletContext;import javax.servlet.http.HttpSessionEvent;import javax.servlet.http.HttpSessionListener;//统计网站在线人数：统计sessionpublic class OnlineCountListener implements HttpSessionListener { //创建session监听：看你的一举一动 //一旦创建session成功，就会出发一次这个事件 public void sessionCreated(HttpSessionEvent se) { ServletContext servletContext = se.getSession().getServletContext(); Integer onlineCount = (Integer)servletContext.getAttribute(\"onlineCount\"); if(onlineCount == null){ onlineCount = new Integer(1); }else{ int count = onlineCount.intValue(); onlineCount = new Integer(count + 1); } servletContext.setAttribute(\"onlineCount\", onlineCount); } //销毁session监听 //一旦销毁session就会触发一次这个事件 public void sessionDestroyed(HttpSessionEvent se) { ServletContext servletContext = se.getSession().getServletContext(); Integer onlineCount = (Integer)servletContext.getAttribute(\"onlineCount\"); if(onlineCount == null){ onlineCount = new Integer(0); }else{ int count = onlineCount.intValue(); onlineCount = new Integer(count - 1); } servletContext.setAttribute(\"onlineCount\", onlineCount); } /* * Session销毁 * * 1.手动销毁 * 2.自动销毁 * */} 2、在web.xml配置监听器 1234&lt;!-- 注册监听器 --&gt;&lt;listener&gt; &lt;listener-class&gt;com.bambi.listener.OnlineCountListener&lt;/listener-class&gt;&lt;/listener&gt; 过滤器、监听器的常见应用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.bambi.listener;import java.awt.*;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.awt.event.WindowListener;public class TestPanel { public static void main(String[] args) { Frame frame = new Frame(\"天天开心\"); Panel panel = new Panel(null); frame.setLayout(null); frame.setBounds(200,200,300,300); frame.setBackground(new Color(128,208,255)); panel.setBounds(30,30, 100, 100); panel.setBackground(new Color(200,150,160)); frame.add(panel); frame.setVisible(true); //适配器模式 frame.addWindowListener(new WindowAdapter() { @Override public void windowDeactivated(WindowEvent e) { System.out.println(\"关闭中~~~~\"); } }); //监听关闭事件 frame.addWindowListener(new WindowListener() { @Override public void windowOpened(WindowEvent e) { System.out.println(\"打开\"); } @Override public void windowClosing(WindowEvent e) { System.out.println(\"关闭中\"); System.exit(0); } @Override public void windowClosed(WindowEvent e) { System.out.println(\"关闭\"); } @Override public void windowIconified(WindowEvent e) { } @Override public void windowDeiconified(WindowEvent e) { } @Override public void windowActivated(WindowEvent e) { System.out.println(\"激活\"); } @Override public void windowDeactivated(WindowEvent e) { System.out.println(\"未激活\"); } }); }} 用户登录之后才能进入主页，用户注销之后不能进入主页 待写","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://xiaofanshutu.github.io/categories/Java-Web/"}],"tags":[],"author":"cutiebambi"},{"title":"IO学习笔记","slug":"IO学习笔记","date":"2022-05-28T00:31:41.000Z","updated":"2024-01-17T23:39:18.791Z","comments":true,"path":"posts/c89e3217.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/c89e3217.html","excerpt":"","text":"文件基础知识 常用的文件操作创建文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.File;import java.io.IOException;public class FileCreate { public static void main(String[] args) { FileCreate fileCreate = new FileCreate(); fileCreate.create01(); fileCreate.create02(); fileCreate.create03(); } //public File(String pathname)根据路径构造一个File对象 public void create01() { String pathname = \"D:\\\\goon\\\\test\\\\test01.doc\"; File file = new File(pathname); try { file.createNewFile(); } catch (IOException e) { System.out.println(\"创建文件失败\"); } } //public File(File parent, String child)根据父目录文件+子路径构造 public void create02() { String parentPath = \"D:\\\\\"; String child = \"goon\\\\test\\\\test02.doc\"; File parentFile = new File(parentPath); File file = new File(parentFile, child); try { file.createNewFile(); } catch (IOException e) { System.out.println(\"创建文件失败\"); } } //public File(String parent, String child)根据父目录+子路径构造 public void create03() { String parent = \"D:\\\\\"; String child = \"goon\\\\test\\\\test03.doc\"; File file = new File(parent, child); try { file.createNewFile(); } catch (IOException e) { System.out.println(\"创建文件失败\"); } }} 常用方法 getName() getAbsolutePath() getParent() length() exists() isFile() isDirectory() 12345678910111213141516171819202122232425262728293031323334import java.io.File;import java.io.IOException;public class FileMethods { public static void main(String[] args) { FileMethods fileMethods = new FileMethods(); fileMethods.createFile(); } public void createFile() { try { String parentPath = \"D:\\\\demo\\\\test\"; String child = \"a.txt\"; File parentFile = new File(parentPath); if (!parentFile.exists()) { parentFile.mkdirs(); } File file = new File(parentFile, child); if (!file.exists()) { file.createNewFile(); } System.out.println(\"文件名字：\" + file.getName());//a.txt System.out.println(\"文件绝对路径：\" + file.getAbsolutePath());//D:\\demo\\test\\a.txt System.out.println(\"文件父目录：\" + file.getParent());//D:\\demo\\test System.out.println(\"文件长度(字节)：\" + file.length());//0 System.out.println(\"文件是否存在：\" + file.exists());//true System.out.println(\"是不是一个文件：\" + file.isFile());//true System.out.println(\"是不是一个目录：\" + file.isDirectory());//false file.createNewFile(); } catch (IOException e) { System.out.println(\"创建文件失败\"); } }} 1234567文件名字：a.txt文件绝对路径：D:\\demo\\test\\a.txt文件父目录：D:\\demo\\test文件长度(字节)：0文件是否存在：true是不是一个文件：true是不是一个目录：false 目录的操作和删除123public boolean mkdir()创建一级目录public boolean mkdirs()创建多级目录public boolean delete()删除空目录或文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.io.File;public class FileOperation { public static void main(String[] args) { FileOperation fileOperation = new FileOperation(); fileOperation.fileFolderTest03(); } //1. 判断文件全路径是否存在，如果存在就删除该文件 public void fileFolderTest01() { String path = \"D:\\\\goon\\\\test\\\\test01.doc\"; File file = new File(path); if (file.exists()) { System.out.println(\"文件存在\"); file.delete(); System.out.println(\"删除成功\"); } } //2. 判断文件的父目录是否存在，如果存在就删除，不存在就提示文件父路径不存在 public void fileFolderTest02() { String path = \"D:\\\\demo\\\\test\"; File file = new File(path); if (file.exists()) { file.delete();//只能删除空目录或者文件 System.out.println(\"删除成功\"); } else { System.out.println(\"该路径不存在\"); } } //3. 判断文件父路径是否存在，如果存在就提示已经存在，不存在就创建该路径 public void fileFolderTest03() { String path = \"D:\\\\demo\\\\a\\\\b\\\\c\"; File file = new File(path); if (file.exists()) { System.out.println(\"该路径已存在\"); } else { boolean mkdirs = file.mkdirs(); if (mkdirs) { System.out.println(\"该路径不存在，但是已创建出该路径\"); } } }} IO流原理以及流的分类流的分类 抽象基类 字节流 字符流 输入流 InputStream Reader 输出流 OutputStream Writer InputStream FileInputStream12publicclass FileInputStream extends InputStream 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.example.hanshunping.io;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;public class FileInputStream_ { public static void main(String[] args) { FileInputStream_ fileInputStream_ = new FileInputStream_(); System.out.println(\"=====方式1=====\"); fileInputStream_.read01(); System.out.println(\"\\n\"); System.out.println(\"=====方式2=====\"); fileInputStream_.read02(); } //读取的文件里面不含中文 public void read01() { String name = \"D:\\\\test.txt\"; FileInputStream fileInputStream = null; try { fileInputStream = new FileInputStream(name); int readFlag; while ((readFlag = fileInputStream.read()) != -1) { System.out.print((char) readFlag); } } catch (FileNotFoundException e) { throw new RuntimeException(e); } catch (IOException e) { throw new RuntimeException(e); } finally { try { fileInputStream.close(); } catch (IOException e) { throw new RuntimeException(e); } } } //读取的文件里面含有中文 public void read02() { String name = \"D:\\\\test2.txt\"; FileInputStream fileInputStream = null; try { fileInputStream = new FileInputStream(name); byte[] bytes = new byte[50]; int readLength; //read(byte b[])：Reads up to b.length bytes of data from this input stream into an array of bytes. //return：the total number of bytes read into the buffer while ((readLength = fileInputStream.read(bytes)) != -1) { System.out.print(new String(bytes, 0, readLength)); } } catch (FileNotFoundException e) { throw new RuntimeException(e); } catch (IOException e) { throw new RuntimeException(e); } finally { try { fileInputStream.close(); } catch (IOException e) { throw new RuntimeException(e); } } }} 1234567=====方式1=====day day up!=====方式2=====每天进步一点点~哈哈~better me~ OutputStream FileOutputStream12publicclass FileOutputStream extends OutputStream xxxxxxxxxx&nbsp;import java.io.File;​public class FileOperation { &nbsp; &nbsp;public static void main(String[] args) { &nbsp; &nbsp; &nbsp; &nbsp;FileOperation fileOperation = new FileOperation(); &nbsp; &nbsp; &nbsp; &nbsp;fileOperation.fileFolderTest03(); &nbsp; }​ &nbsp; &nbsp;//1. 判断文件全路径是否存在，如果存在就删除该文件 &nbsp; &nbsp;public void fileFolderTest01() { &nbsp; &nbsp; &nbsp; &nbsp;String path = “D:\\goon\\test\\test01.doc”; &nbsp; &nbsp; &nbsp; &nbsp;File file = new File(path); &nbsp; &nbsp; &nbsp; &nbsp;if (file.exists()) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(“文件存在”); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;file.delete(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(“删除成功”); &nbsp; &nbsp; &nbsp; } &nbsp; }​ &nbsp; &nbsp;//2. 判断文件的父目录是否存在，如果存在就删除，不存在就提示文件父路径不存在 &nbsp; &nbsp;public void fileFolderTest02() { &nbsp; &nbsp; &nbsp; &nbsp;String path = “D:\\demo\\test”; &nbsp; &nbsp; &nbsp; &nbsp;File file = new File(path); &nbsp; &nbsp; &nbsp; &nbsp;if (file.exists()) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;file.delete();//只能删除空目录或者文件 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(“删除成功”); &nbsp; &nbsp; &nbsp; } else { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(“该路径不存在”); &nbsp; &nbsp; &nbsp; } &nbsp; }​ &nbsp; &nbsp;//3. 判断文件父路径是否存在，如果存在就提示已经存在，不存在就创建该路径 &nbsp; &nbsp;public void fileFolderTest03() { &nbsp; &nbsp; &nbsp; &nbsp;String path = “D:\\demo\\a\\b\\c”; &nbsp; &nbsp; &nbsp; &nbsp;File file = new File(path); &nbsp; &nbsp; &nbsp; &nbsp;if (file.exists()) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(“该路径已存在”); &nbsp; &nbsp; &nbsp; } else { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;boolean mkdirs = file.mkdirs(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (mkdirs) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(“该路径不存在，但是已创建出该路径”); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; } &nbsp; }}java 12345678910111213141516171819202122232425262728293031323334353637package com.example.hanshunping.io;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;public class FileOutputStream_ { public static void main(String[] args) { String path = \"D:\\\\test3.txt\"; FileOutputStream fileOutputStream = null; try { //1. 这种方式创建的FileOutputStream，当写入内容时，会覆盖原来的内容 //fileOutputStream = new FileOutputStream(path); //2. 这种方式创建的FileOutputStream，当写入内容时，不会覆盖原来的内容，新内容会追加到久内容后面 fileOutputStream = new FileOutputStream(path, true); //public void write(int b) char c = 'D'; fileOutputStream.write(c); //public void write(byte b[]) String str = \"hello summer\"; fileOutputStream.write(str.getBytes()); //public void write(byte b[], int off, int len) fileOutputStream.write(str.getBytes(), 0, 3); } catch (IOException e) { throw new RuntimeException(e); } finally { try { fileOutputStream.close(); } catch (IOException e) { throw new RuntimeException(e); } } }} 练习编程实现文件的拷贝 12345678910111213141516171819202122232425262728293031323334353637package com.example.hanshunping.io;import java.io.*;public class FileCopy { public static void main(String[] args) { String readPath = \"D:\\\\test.txt\"; String writePath = \"D:\\\\demo.txt\"; FileInputStream fileInputStream = null; FileOutputStream fileOutputStream = null; try { fileInputStream = new FileInputStream(readPath); fileOutputStream = new FileOutputStream(writePath); byte[] bytes = new byte[1024]; int readLength; while ((readLength = fileInputStream.read(bytes)) != -1) { fileOutputStream.write(bytes, 0, readLength); } } catch (FileNotFoundException e) { throw new RuntimeException(e); } catch (IOException e) { throw new RuntimeException(e); } finally { try { if (fileInputStream != null) { fileInputStream.close(); } if (fileOutputStream != null) { fileOutputStream.close(); } } catch (IOException e) { throw new RuntimeException(e); } } }} FileReader 常用方法 new FileReader(File/String) read()每次读取单个字符，返回该字符，如果到文件末尾则返回-1 read(char[])批量读取多个字符到数组，返回读取到的字符数，如果到文件末尾则返回-1 相关API new String(char[])将char[]转换成String new String(char[], off, len)将char[]的指定部分转换成String 练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;public class FileReader_ { public static void main(String[] args) { System.out.println(\"=====方式1=====\"); String path = \"D:\\\\test.txt\"; FileReader fileReader = null; try { fileReader = new FileReader(path); int readData; while ((readData = fileReader.read()) != -1) { System.out.print((char) readData); } } catch (IOException e) { throw new RuntimeException(e); } finally { if(fileReader != null){ try { fileReader.close(); } catch (IOException e) { throw new RuntimeException(e); } } } System.out.println(\"=====方式2=====\"); try { fileReader = new FileReader(path); char[] chr = new char[500]; int readLength; while ((readLength = fileReader.read(chr)) != -1) { System.out.print(new String(chr, 0, readLength)); } } catch (IOException e) { throw new RuntimeException(e); } finally { if(fileReader != null){ try { fileReader.close(); } catch (IOException e) { throw new RuntimeException(e); } } } }} 123456789101112131415161718192021222324252627282930313233343536=====方式1=====public class FileCreate { public static void main(String[] args) { FileCreate fileCreate = new FileCreate(); fileCreate.create01(); } //public File(String pathname)根据路径构造一个File对象 public void create01() { String pathname = \"D:\\\\goon\\\\test\\\\test01.doc\"; File file = new File(pathname); try { file.createNewFile(); } catch (IOException e) { System.out.println(\"创建文件失败\"); } }}=====方式2=====public class FileCreate { public static void main(String[] args) { FileCreate fileCreate = new FileCreate(); fileCreate.create01(); } //public File(String pathname)根据路径构造一个File对象 public void create01() { String pathname = \"D:\\\\goon\\\\test\\\\test01.doc\"; File file = new File(pathname); try { file.createNewFile(); } catch (IOException e) { System.out.println(\"创建文件失败\"); } }} FileWriter 常用方法 new FileWriter(File/String)：覆盖模式，相当于流的指针在首端 new FileWriter(File/String, true)：追加模式，相当于流的指针在尾端 write(int)：写入单个字符 write(char[])：写入指定数组 write(char[], off, len)：写入指定数组的指定部分 write(string)：写入整个字符串 write(string, off, len)：写入字符串的指定部分 相关API toCharArray: 将String转换成char[] 【String类的方法】 注意： ==FileWriter使用后，必须要关闭(close)或者刷新(flush)，否则写入不到指定的文件。== 练习123456789101112131415161718192021222324252627282930313233343536373839import java.io.FileWriter;import java.io.IOException;public class FileWriter_ { public static void main(String[] args) { String fileName = \"D:\\\\demo\\\\test\\\\b.txt\"; FileWriter fileWriter = null; try { //1. FileWriter(String fileName) fileWriter = new FileWriter(fileName); //2. write(String str) fileWriter.write(\"D\"); //3. write(String str) fileWriter.write(\"你好呀!\"); //4. write(String str, int off, int len) fileWriter.write(\"little rabbit\", 7, 6); char[] chars = \"hello world\".toCharArray(); //5. write(char cbuf[]) fileWriter.write(chars); //6. write(char cbuf[], int off, int len) fileWriter.write(chars, 6, 5); } catch (IOException e) { throw new RuntimeException(e); } finally { if (fileWriter != null) { try { fileWriter.close(); } catch (IOException e) { throw new RuntimeException(e); } } } }} 1D你好呀!rabbithello worldworld 节点流和处理流概述节点流 分类 字节输入流 字节输出流 字符输入流 字符输出流 抽象基类 InputStream OutputStream Reader Writer 访问文件 FileInputStream FileOutputStream FileReader FileWriter 访问数组 ByteArrayInputStream ByteArrayOutputStream CharArrayReader CharArrayWriter 访问管道 PipedInputStream PipedOutputStream PipedReader PipedWriter 访问字符串 StringReader StringWriter 处理流 分类 字节输入流 字节输出流 字符输入流 字符输出流 抽象基类 InputStream OutputStream Reader Writer 对象流 ObjectInputStream ObjectOutputStream 文件流 FileInputStream FileOutputStream 转换流 InputStreamReader OutputStreamWriter 打印流 PrintStream PrintWriter （父）FilterInputStream （父）FilterOutputStream （父）FilterReader FilterWriter 推回输入流 （子）PushbackInputStream （子）PushbackReader 特殊流 （子）DataInputStream （子）DataOutputStream 缓冲流 （子）BufferedInputStream （子）BufferedOutputStream BufferedReader BufferedWriter 节点流和处理流的区别和联系 节点流是底层流/低级流，直接跟数据源相关。 处理流既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出。 处理流也叫包装流，它可以对节点流进行包装。使用了修饰器设计模式，不会直接与数据源相连。 字符处理流BufferedReader&amp;BufferedWriter12public class BufferedReaderextends Reader 12public class BufferedWriterextends Writer 1234567891011121314151617181920212223import org.springframework.util.StringUtils;import java.io.*;public class BufferedCopy { public static void main(String[] args) throws IOException { String fileSrc = \"D:\\\\demo\\\\test\\\\a.txt\"; String fileDest = \"D:\\\\demo\\\\test\\\\b.txt\"; BufferedReader bufferedReader = new BufferedReader(new FileReader(fileSrc)); BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(fileDest)); String content = \"\"; while ((content = bufferedReader.readLine()) != null) { bufferedWriter.write(content); } if(bufferedReader != null){ bufferedReader.close(); } if(bufferedWriter != null){ bufferedWriter.close(); } }} 字节处理流BufferedInputStream&amp;BufferedOutputStream12public class BufferedInputStreamextends FilterInputStream 12public class BufferedOutputStreamextends FilterOutputStream 用字节处理流实现图片拷贝123456789101112131415161718192021222324252627import java.io.*;public class BufferedInputStreamCopy { public static void main(String[] args) throws IOException { String fileSrc = \"D:\\\\demo\\\\test\\\\a.jpg\"; String fileDest = \"D:\\\\demo\\\\test\\\\b.jpg\"; byte[] bytes = new byte[100]; BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(fileSrc)); BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(fileDest)); int length; //读取方式一// while ((length = bufferedInputStream.read()) != -1) {// bufferedOutputStream.write(length);// } //读取方式二 while ((length = bufferedInputStream.read(bytes)) != -1) { bufferedOutputStream.write(bytes, 0, length); } if (bufferedInputStream != null) { bufferedInputStream.close(); } if (bufferedOutputStream != null) { bufferedOutputStream.close(); } }} 对象处理流对象处理流的使用细节 读写顺序要一致。 序列化或反序列化的对象，需要实现Serializable接口。 序列化的类中建议添加serialVersionUID，为了提高版本的兼容性。 序列化对象时，默认将里面的所有属性都进行序列化。但是如果成员是被static或者transient修饰的，则不会被序列化。 序列化对象时，要求里面属性的类型也需要实现序列化接口。 序列化具备可继承性，即如果某类已经实现了序列化，则它的所有子类也默认实现了序列化。 ObjectOutputStream123public class ObjectOutputStreamextends OutputStreamimplements ObjectOutput, ObjectStreamConstants 练习用ObjectOutputStream序列化一个基本数据类型和一个Dog对象，并存储到test.dat文件中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.io.Serializable;public class ObjectOutputStream_ { public static void main(String[] args) throws IOException { String name = \"D:\\\\demo\\\\test\\\\test.dat\"; FileOutputStream fileOutputStream = new FileOutputStream(name); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeInt(9); objectOutputStream.writeObject(new Dog(\"旺财\", 1)); if (objectOutputStream != null) { objectOutputStream.close(); } }}class Dog implements Serializable { private String name; private int age; public Dog(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Dog{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; }} ObjectInputStream123public class ObjectInputStreamextends InputStreamimplements ObjectInput, ObjectStreamConstants 练习使用ObjectInputStream读取test.dat并且反序列化数据 123456789101112131415161718192021import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.ObjectInputStream;public class ObjectInputStream_ { public static void main(String[] args) throws IOException, ClassNotFoundException { String name = \"D:\\\\demo\\\\test\\\\test.dat\"; FileInputStream fileInputStream = new FileInputStream(name); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); System.out.println(objectInputStream.readInt()); //刚开始忘了注释这一行，运行下面那一行的时候报错了 java.io.EOFException //System.out.println(objectInputStream.readObject()); Dog dog = (Dog) objectInputStream.readObject(); System.out.println(dog.getName()); System.out.println(dog.getAge()); if (objectInputStream != null) { objectInputStream.close(); } }} 标准输入输出流123456789101112131415161718192021222324252627import java.io.InputStream;import java.io.PrintStream;import java.util.Scanner;public class StandardStream { public static void main(String[] args) { //1. public final static InputStream in = null; //2. 编译类型：InputStream InputStream in = System.in; //3. 运行类型：BufferedInputStream //4. 表示标准输入 键盘 System.out.println(System.in);//java.io.BufferedInputStream@4d7e1886 //1. public final static PrintStream out = null; //2. 编译类型：PrintStream PrintStream out = System.out; //3. 运行类型：PrintStream //4. 表示标准输出 显示器 System.out.println(System.out);//java.io.PrintStream@3cd1a2f1 System.out.println(\"标准输出，打印到显示器\"); Scanner scanner = new Scanner(System.in); System.out.println(\"从键盘接收数据：\"); System.out.println(\"next = \" + scanner.next()); }} 123456java.io.BufferedInputStream@4d7e1886java.io.PrintStream@3cd1a2f1标准输出，打印到显示器从键盘接收数据：hellonext = hello 转换流通过乱码问题引出转换流12345678910import java.io.*;public class CodeIssue { public static void main(String[] args) throws IOException { String fileName = \"D:\\\\demo\\\\test\\\\code_issue.txt\"; BufferedReader bufferedReader = new BufferedReader(new FileReader(fileName)); System.out.println(bufferedReader.readLine()); bufferedReader.close(); }} 1���ѽ 所以就引出了转换流。 InputStreamReader123java.lang.Object java.io.Reader java.io.InputStreamReader 12public class InputStreamReaderextends Reader 练习将字节流FileInputStream用gbk的编码格式包装成字符流InputStreamReader，接着再包装成BufferedReader。 123456789101112import java.io.*;public class BufferedReader_ { public static void main(String[] args) throws IOException { String fileName = \"D:\\\\demo\\\\test\\\\code_issue.txt\"; String charset = \"gbk\"; InputStreamReader inputStreamReader = new InputStreamReader(new FileInputStream(fileName), charset); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); System.out.println(bufferedReader.readLine()); bufferedReader.close(); }} 1你好呀 OutputStreamWriter123java.lang.Object java.io.Writer java.io.OutputStreamWriter 12public class OutputStreamWriterextends Writer 练习将字节流FileOutputStream用utf8的编码格式包装成字符流OutputStreamWriter，对文件进行写入，按照gbk的格式。 1234567891011import java.io.*;public class OutputStreamWriter_ { public static void main(String[] args) throws IOException { String fileName = \"D:\\\\demo\\\\test\\\\aa.txt\"; String charset = \"utf8\"; OutputStreamWriter outputStreamWriter = new OutputStreamWriter(new FileOutputStream(fileName), charset); outputStreamWriter.write(\"你好，世界！\"); outputStreamWriter.close(); }} 打印流PrintStream（字节打印流）1234java.lang.Object java.io.OutputStream java.io.FilterOutputStream java.io.PrintStream 123public class PrintStreamextends FilterOutputStreamimplements Appendable, Closeable 12345678import java.io.PrintStream;public class PrintStream_ { public static void main(String[] args) { PrintStream printStream = System.out; printStream.print(\"你好，明天！\"); }} 1你好，明天！ PrintWriter（字符打印流）123java.lang.Object java.io.Writer java.io.PrintWriter 12public class PrintWriterextends Writer Properties普通方法读取配置文件配置文件内容 12name=DB01pwd=130.133.13.14 1234567891011121314import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;public class Properties01 { public static void main(String[] args) throws IOException { BufferedReader bufferedReader = new BufferedReader(new FileReader(\"src\\\\sql.properties\")); String content; while ((content = bufferedReader.readLine()) != null) { String[] stars = content.split(\"=\"); System.out.println(stars[0] + \": \" + stars[1]); } }} 12name: DB01pwd: 130.133.13.14 Properties类基本介绍12public class Propertiesextends Hashtable&lt;Object,Object&gt; Properties类常用方法Properties类读取配置文件123456789101112import java.io.FileReader;import java.io.IOException;import java.util.Properties;public class Properties02 { public static void main(String[] args) throws IOException { Properties properties = new Properties(); properties.load(new FileReader(\"src\\\\sql.properties\")); System.out.println(properties.getProperty(\"name\")); System.out.println(properties.getProperty(\"pwd\")); }} 12DB01130.133.13.14 Properties类添加新的key-value到配置文件1234567891011121314import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.util.Properties;public class Properties03 { public static void main(String[] args) throws IOException { Properties properties = new Properties(); properties.load(new FileReader(\"src\\\\sql.properties\")); properties.put(\"通过程序添加的key\", \"通过程序添加的value\"); properties.store(new FileWriter(\"src\\\\sql.properties\"), null); properties.list(System.out); }} 12345-- listing properties --name=DB01通过程序添加的key=通过程序添加的valuepwd=130.133.13.14charset=utf8 double check: 检查local file，新的key-value添加成功 这里记录一个小插曲，测试的时候，用IDEA打开这个配置文件的时候，出现了乱码。 上面这个问题的解决办法如下： File-&gt;Setting Properties类读取配置文件，并且修改某一个key-value1234567891011121314import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.util.Properties;public class Properties03 { public static void main(String[] args) throws IOException { Properties properties = new Properties(); properties.load(new FileReader(\"src\\\\sql.properties\")); properties.put(\"name\", \"DB02\"); properties.store(new FileWriter(\"src\\\\sql.properties\"), null); properties.list(System.out); }} 123-- listing properties --name=DB02pwd=130.133.13.14","categories":[{"name":"Java IO","slug":"Java-IO","permalink":"https://xiaofanshutu.github.io/categories/Java-IO/"}],"tags":[],"author":"cutiebambi"},{"title":"Java集合练习题","slug":"Java集合框架学习笔记","date":"2022-05-08T00:31:41.000Z","updated":"2024-01-17T23:40:02.482Z","comments":true,"path":"posts/efe18b52.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/efe18b52.html","excerpt":"","text":"集合的理解和好处集合的理解和好处 可以动态保存任意多个对象，使用比较方便 提供了一系列方便的操作对象的方法：add,remove,set,get等 使用集合添加，删除新元素的代码，会很简洁 集合的框架体系 Collection接口和常用方法1public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; Collection接口实现类的特点 可以存放多个元素 Collection的有些实现类是有序的 Collection的有些实现类是无序的 Collection接口常用方法 add: 添加单个元素 remove：删除指定元素 contains：查找元素是否存在 size：获取元素个数 isEmpty：判断是否为空 clear：清空 addAll：添加多个元素 containsAll：查找多个元素是否存在 removeAll：删除多个元素 Collection接口的元素遍历方式方式1 - Iterator（迭代器）==代码== 12345678910111213141516// Collection// Map// 1. 集合主要是两组（单列集合，双列集合）// 2. Collection接口有两个重要的子接口，List Set，他们的实现子类都是单列集合// 3. Map接口的实现子类都是双列集合public static void main(String[] args){ Collection collection = new ArrayList(); collection.add(\"test1\"); collection.add(\"test2\"); collection.add(\"test3\"); Iterator iterator = collection.iterator(); while (iterator.hasNext()) { Object next = iterator.next(); System.out.println(next); }} 123test1test2test3 方式2 - 增强for循环==增强for循环的特点== 增强for可以在collection集合上使用 增强for底层仍然调用的是迭代器 可以这样理解，增强for就是简化版的迭代器遍历 123public Iterator&lt;E&gt; iterator() { return new Itr();} ==代码== 12345678910public static void main(String[] args){ Collection collection = new ArrayList(); collection.add(\"test1\"); collection.add(\"test2\"); collection.add(\"test3\"); for (Object o : collection) { System.out.println(o); }} 123test1test2test3 List接口和常用方法List接口特点 List集合中的元素是有序的（即添加和取出顺序一致）、并且可以重复。 List集合中的每个元素都有其对应的顺序索引，即支持索引。 List容器中的元素都对应一个整数型序号记载其在容器中的位置，可以根据序号存取容器中的元素。 JDK API中List接口的实现类有： Java1.8 API Doc List接口常用的方法： void add(int index, E element)Inserts the specified element at the specified position in this list (optional operation). boolean addAll(int index, Collection&lt;? extends E&gt; c)Inserts all of the elements in the specified collection into this list at the specified position (optional operation). E get(int index)Returns the element at the specified position in this list. int indexOf(Object o)Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. int lastIndexOf(Object o)Returns the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element. E remove(int index)Removes the element at the specified position in this list (optional operation). E set(int index, E element)Replaces the element at the specified position in this list with the specified element (optional operation). List subList(int fromIndex, int toIndex)Returns a view of the portion of this list between the specified fromIndex, inclusive, and toIndex, exclusive. List接口课堂练习123456789101112131415161718192021222324252627public class ListExercise { public static void main(String[] args) { // 添加10个以上元素 List list = new ArrayList(); for (int i = 0; i &lt; 20; i++) { list.add(\"Hello\" + i); } // 在2号位置插入一个元素“summergoon” list.add(1, \"summergoon\"); // 获取第5个元素 System.out.println(list.get(4)); // 删除第6个元素 list.remove(5); // 修改第7个元素 list.set(6, \"modify\"); // 再使用迭代器遍历集合 Iterator iterator = list.iterator(); while (iterator.hasNext()) { Object next = iterator.next(); System.out.println(next); } }} List的元素遍历方式方式1：Iterator迭代器12345678910111213public static void main(String[] args) { List list = new ArrayList(); list.add(\"tom\"); list.add(\"jerry\"); list.add(\"naonao\"); // Iterator Iterator iterator = list.iterator(); while (iterator.hasNext()) { Object next = iterator.next(); System.out.println(next); }} 方式二：增强for1234567891011public static void main(String[] args) { List list = new ArrayList(); list.add(\"tom\"); list.add(\"jerry\"); list.add(\"naonao\"); // 增强for for (Object o : list) { System.out.println(o); }} 方式三：普通for1234567891011public static void main(String[] args) { List list = new ArrayList(); list.add(\"tom\"); list.add(\"jerry\"); list.add(\"naonao\"); // 普通for for (int i = 0; i &lt; list.size(); i++) { System.out.println(list.get(i)); }} 上面三种的输出都是一样的 123tomjerrynaonao 课堂练习12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Book implements Comparable&lt;Book&gt; { private String name; private String author; private double price; public Book(String name, String author, double price) { this.name = name; this.author = author; this.price = price; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } public double getPrice() { return price; } public void setPrice(double price) { this.price = price; } @Override public String toString() { return \"Book{\" + \"name='\" + name + '\\'' + \", author='\" + author + '\\'' + \", price=\" + price + '}'; } @Override public int compareTo(Book o) { return (int) (this.price - o.price); }} 1234567891011121314public class ListSort { public static void main(String[] args) { List list = new ArrayList(); list.add(new Book(\"如何拥抱一只刺猬\", \"测试1\", 69.9)); list.add(new Book(\"动物的家\", \"测试2\", 30.6)); list.add(new Book(\"我长大了\", \"测试3\", 90.9)); Collections.sort(list); for (Object o : list) { System.out.println(o); } }} 123Book{name='动物的家', author='测试2', price=30.6}Book{name='如何拥抱一只刺猬', author='测试1', price=69.9}Book{name='我长大了', author='测试3', price=90.9} ArrayList源码剖析ArrayList的注意事项 Implements all optional list operations, and permits all elements, including null. ArrayList是由数组来实现数据存储的。 ArrayList基本等同于Vector，ArrayList是线程不安全的（但是执行效率高）。在多线程的情况下，不建议使用ArrayList。 ArrayList底层操作机制源码分析（重点、难点） ArrayList中维护了一个Object类型的数组elementData 当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第1次添加，则扩容elementData为10，如果需要再次扩容，则扩容elementData为1.5倍。 1public ArrayList() 如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如果需要扩容，则扩容elementData为1.5倍。 1public ArrayList(int initialCapacity) 源码剖析使用无参构造器创建ArrayList对象，跟踪源码1234567891011121314151617181920public class ArrayListSource { public static void main(String[] args) { //使用无参构造器创建ArrayList对象 List list = new ArrayList(); for (int i = 1; i &lt;= 10; i++) { list.add(i); } for (int i = 11; i &lt;= 15; i++) { list.add(i); } list.add(100); list.add(200); list.add(null); for (Object o : list) { System.out.println(o); } }} 创建一个空的elementData[] 123456/** * Constructs an empty list with an initial capacity of ten. */public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;} 装箱 12345public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);} 执行list.add (1) 先确定是否要扩容 (2)然后再执行赋值 12345public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;} 确定是否要扩容 123private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));} 计算minCapacity 123456private static int calculateCapacity(Object[] elementData, int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity;} (1)modCount++记录集合被修改的次数 (2)如果elementData的大小不够，就调用grow()去扩容。 1234567private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);} (1)真正的扩容 (2)使用扩容机制来确定要扩容到多大 (3)第一次newCapacity = 10 (4)第二次及其以后，按照1.5倍扩容 (5)扩容使用的是Arrays.copyOf() 1234567891011private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);} 使用有参构造器创建ArrayList对象，跟踪源码【待写】Vector源码剖析Vector的基本介绍 Vector类的定义说明 Vector底层也是一个对象数组， 1protected Object[] elementData; Vector是线程同步的，即线程安全，Vector类的操作方法带有synchronized 123456public synchronized E get(int index) { if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); return elementData(index);} 源码剖析使用无参构造器创建Vector对象，跟踪源码12345678910public class Vector_ { public static void main(String[] args) { Vector vector = new Vector(); for (int i = 0; i &lt; 10; i++) { vector.add(i); } vector.add(100); vector.add(200); }} 装箱操作 12345public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);} 执行vector.add (1)modCount++：记录集合被修改的次数 (2)先确定是否需要扩容 (3)然后再执行赋值 123456public synchronized boolean add(E e) { modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true;} 如果elementData的大小不够，就调用grow()去扩容 12345private void ensureCapacityHelper(int minCapacity) { // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);} 真正的扩容 (1)使用扩容机制来确定要扩容到多大 (2)capacityIncrement=0，第一次oldCapacity=10，newCapacity=oldCapacity*2=20，即相当于按照2倍扩容 (3)扩容使用的是Arrays.copyOf() 1234567891011private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity);} 使用有参构造器创建Vector对象，跟踪源码【待写】Vector底层结构和ArrayList的比较 底层结构 版本 线程 安全（同步）效率 扩容倍数 ArrayList 可变数组 jdk1.2 不安全，效率高 如果 有参构造1.5倍如果是无参1. 第一次102. 第二次开始按1.5扩 Vector 可变数组 Object[] jdk1.0 安全，效率低 如果指定大小，则每次直接按2倍扩如果是无参构造，默认10，满了 之后，按2倍扩容 LinkedList源码剖析模拟双向链表1234567891011121314151617181920212223242526272829303132333435363738public class HashSetStructure { public static void main(String[] args) { // 1. 创建一个数组，数组的类型是Node[] // 2. 有些人，直接把Node[] 数组称为 表 Node[] table = new Node[16]; // 3. 创建节点 Node summer = new Node(\"summer\", null); table[2] = summer; Node ada = new Node(\"ada\", null); summer.next = ada;// 将ada挂载到summer Node cara = new Node(\"cara\", null); ada.next = cara;// 将cara挂载到jack Node lucky = new Node(\"lucky\", null); table[3] = lucky; for (Node node : table) { System.out.println(node); } }}class Node {// 节点，存储数据，可以指向下一个节点，从而形成链表 Object item;// 存放数据 Node next;// 指向下一个节点 public Node(Object item, Node next) { this.item = item; this.next = next; } @Override public String toString() { return \"Node{\" + \"item=\" + item + \", next=\" + next + '}'; }} 12345678910111213141516nullnullNode{item=summer, next=Node{item=ada, next=Node{item=cara, next=null}}}Node{item=lucky, next=null}nullnullnullnullnullnullnullnullnullnullnullnull LinkedList源码剖析add 12345678public LinkedList() {}protected AbstractSequentialList() {}protected AbstractList() {}protected AbstractCollection() {} 12345public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);} 1234public boolean add(E e) { linkLast(e); return true;} 1234567891011void linkLast(E e) { final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;} remove 123public E remove() { return removeFirst();} 123456public E removeFirst() { final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f);} 123456789101112131415private E unlinkFirst(Node&lt;E&gt; f) { // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element;} remove(3) 1234public E remove(int index) { checkElementIndex(index); return unlink(node(index));} 1234private void checkElementIndex(int index) { if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));} 123private boolean isElementIndex(int index) { return index &gt;= 0 &amp;&amp; index &lt; size;} 123456789101112131415Node&lt;E&gt; node(int index) { // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) { Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; } else { Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; }} 12345678910111213141516171819202122232425E unlink(Node&lt;E&gt; x) { // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) { first = next; } else { prev.next = next; x.prev = null; } if (next == null) { last = prev; } else { next.prev = prev; x.next = null; } x.item = null; size--; modCount++; return element;} 得到某个元素 1234public E get(int index) { checkElementIndex(index); return node(index).item;} 1234private void checkElementIndex(int index) { if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));} 123private boolean isElementIndex(int index) { return index &gt;= 0 &amp;&amp; index &lt; size;} 123456789101112131415Node&lt;E&gt; node(int index) { // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) { Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; } else { Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; }} LinkedList和ArrayList比较 底层结构 增删的效率 改查的效率 ArrayList 可变数组 较低数组扩容 较高 LinkedList 双向链表 较高通过链表追加 较低 实际中如何选择？ 如果“改查”操作多，选择ArrayList 如果“增删”操作多，选择LinkedList Set接口和常用方法Set接口基本介绍PS: Set接口的实现类的对象，简称Set接口对象 无序（添加和取出的顺序不一致），没有索引 不允许重复元素，所以最多包含一个null JDK API中Set接口的实现类如下： Set接口常用方法和List接口一样，Set接口也是Collection的子接口，常用方法和Collection接口一样。 Set接口的遍历方式和Collection的遍历方式一样，因为Set接口是Collection接口的子接口。 Iterator迭代器 增强for ==不能使用==索引的方式 12345678910111213141516171819202122232425public class Set_ { public static void main(String[] args) { System.out.println(\"======添加数据======\"); Set set = new HashSet(); set.add(\"joan\"); set.add(\"summer\"); set.add(null); set.add(\"joan\"); set.add(null); System.out.println(set); System.out.println(\"======Iterator遍历======\"); Iterator iterator = set.iterator(); while (iterator.hasNext()) { Object obj = iterator.next(); System.out.println(obj); } System.out.println(\"======增强for遍历======\"); for (Object o : set) { System.out.println(o); } System.out.println(\"======删除数据======\"); set.remove(\"joan\"); System.out.println(set); }} 123456789101112======添加数据======[null, joan, summer]======Iterator遍历======nulljoansummer======增强for遍历======nulljoansummer======删除数据======[null, summer] HashSet源码剖析HashSet的全面说明 HashSet实现了Set接口 HashSet实际上是HashMap 123public HashSet() { map = new HashMap&lt;&gt;();} 可以存放null值，但是只能有一个null HashSet不保证元素是有序的，取决于hash后，再确定索引的结果（即不保证数据存放和取出的顺序一致） 不能有重复的元素/对象 HashSet案例说明12345678910111213141516171819202122public class HashSet_ { public static void main(String[] args) { Set set = new HashSet(); //执行add方法后，会返回一个boolean值 //如果添加成功，返回true，否则返回false //可以通过remove指定删除哪个对象 System.out.println(set.add(\"joan\")); System.out.println(set.add(\"lucky\")); System.out.println(set.add(\"summer\")); System.out.println(set.add(\"null\")); System.out.println(set.add(\"joan\"));// false: 不能添加重复元素 System.out.println(set.add(\"jack\")); System.out.println(set.add(\"null\"));// false: 不能添加重复元素 System.out.println(\"=====删除前=====\"); System.out.println(set); set.remove(\"null\");// 将会删掉null System.out.println(\"=====删除后=====\"); System.out.println(set); }} 1234567891011truetruetruetruefalsetruefalse=====删除前=====[lucky, joan, null, summer, jack]=====删除后=====[lucky, joan, summer, jack] HashSet底层机制说明 HashSet底层是HashMap， HashMap底层是数组+链表+红黑树 添加一个元素时，==先得到Hash值==，会转换成索引值 找到存储数据表table，看这个索引位置是否已经存放有元素 如果没有，直接加入 如果有，==调用equals方法比较==，如果相同，就放弃添加，如果不相同，则添加到最后 在Java8中，如果一条链表的元素个数到TREEIFY_THRESHOLD(默认是8)，并且table的大小&gt;=MIN_TREEIFY_CAPACITY(默认64)，就会进行树化（红黑树） 模拟简单的数组+链表结构1234567891011121314151617181920212223242526272829303132333435363738public class HashSetStructure { public static void main(String[] args) { // 1. 创建一个数组，数组的类型是Node[] // 2. 有些人，直接把Node[] 数组称为 表 Node[] table = new Node[16]; // 3. 创建节点 Node summer = new Node(\"summer\", null); table[2] = summer; Node ada = new Node(\"ada\", null); summer.next = ada;// 将ada挂载到summer Node cara = new Node(\"cara\", null); ada.next = cara;// 将cara挂载到jack Node lucky = new Node(\"lucky\", null); table[3] = lucky; for (Node node : table) { System.out.println(node); } }}class Node {// 节点，存储数据，可以指向下一个节点，从而形成链表 Object item;// 存放数据 Node next;// 指向下一个节点 public Node(Object item, Node next) { this.item = item; this.next = next; } @Override public String toString() { return \"Node{\" + \"item=\" + item + \", next=\" + next + '}'; }} 12345678910111213141516nullnullNode{item=summer, next=Node{item=ada, next=Node{item=cara, next=null}}}Node{item=lucky, next=null}nullnullnullnullnullnullnullnullnullnullnullnull 分析HashSet的添加元素的底层是如何实现的( hash() + equals() ) 源码剖析123456789public class HashSetSource { public static void main(String[] args) { HashSet hashSet = new HashSet(); hashSet.add(\"java\"); hashSet.add(\"php\"); hashSet.add(\"java\"); System.out.println(hashSet); }} 分析上面的代码： 执行构造器 123public HashSet() { map = new HashMap&lt;&gt;();} 执行add()方法 1234// 这里的PRESENT是 private static final Object PRESENT = new Object();public boolean add(E e) { return map.put(e, PRESENT)==null;} 123public V put(K key, V value) {// key: java value: PRESENT(object) return putVal(hash(key), key, value, false, true);} 执行hash(key) 方法会得到key对应的hash值，这个hash值不是hashCode，是根据算法(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)得到对应的hash值.(这个hash值就是table表对应的索引值) 1234static final int hash(Object key) {// key: java int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); // 无符号右移16位} hashCode() 123456789101112public int hashCode() { int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) { char val[] = value; for (int i = 0; i &lt; value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h;} ==核心代码（重点中的重点）== 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { //定义辅助变量 Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //如果当前table是null，或者大小等于0，就第一次扩容，扩到16个空间 if ((tab = table) == null || (n = tab.length) == 0)//table是hashMap的一个属性，这个table就是放node节点的一个数组。类型是：Node[] n = (tab = resize()).length; //(1)根据key，得到hash，去计算该key应该存放到table表的哪个索引位置，并让p指向这个索引位置的对象 //(2)判断p指向的索引位置的对象是否为null //(2.1)如果p指向的索引位置的对象为null，表示还没有存放元素，就创建一个Node(key=\"java\", value=\"PRESENT\") // 就放在该位置tab[i] = newNode(hash, key, value, null); if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null);//(set_pic_2) //(2.2)如果p指向的索引位置的对象不为null else { //一个开发技巧：在需要局部变量（辅助变量）的时候，再创建 Node&lt;K,V&gt; e; K k; //如果当前索引位置对应的链表的第一个元素的hash值和准备添加的key的hash值一样。并且满足下面两个条件之一： //(1) 准备加入的key和p指向的Node节点的k是同一个对象(set_pic_3) //(2) p指向的Node节点的对象k和准备加入的key经equals()方法比较后相同(set_pic_4) //如果满足上面两个条件之一，那么就不能加入 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 再判断p是不是一颗红黑树，如果是红黑树，就调用putTreeVal来进行添加 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); //如果table对应索引位置，已经是一个链表，就使用for循环比较 //(1) 依次和链表的每一个元素比较后，都不相同，则加入到该链表最后(set_pic_5) //(2) 在依次和该链表的每一个元素比较的过程中，如果有相同情况，就直接break else { //set_pic_6 for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st // TREEIFY_THRESHOLD=8 //注意：在把元素添加到链表后，会立即进行判断，判断该链表是否已经达到8个节点, // 如果达到8个节点，就调用treeifyBin(tab, hash)对当前链表进行树化（转成红黑树） // 在转成红黑树时，还会进行一个判断，如果该table数组的大小小于MIN_TREEIFY_CAPACITY（64）， // 判断条件如下： // if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) // resize(); // 如果上面条件成立，不会马上转成红黑树，会先进行table扩容 // 只有当上面的条件不成立的时候，才进行转成红黑树 treeifyBin(tab, hash); break;//添加到节点后面然后退出 } if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break;//放弃添加然后退出 // 这句代码，p依次指向它自己的下一个节点，这样就达到了循环每一个节点 p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; //onlyIfAbsent是put方法调用putVal的时候传入进来的参数，永远为false //public V put(K key, V value) { // return putVal(hash(key), key, value, false[这个参数对应的就是onlyIfAbsent], true); //} if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; //size就是每加入一个节点Node(k, v, h, next), size就会增加 if (++size &gt; threshold) resize();// 扩容 //这个方法其实是给它的子类用的 afterNodeInsertion(evict); //返回null表示添加成功 return null;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778final Node&lt;K,V&gt;[] resize() { Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) { if (oldCap &gt;= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold } else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else { // zero initial threshold signifies using defaults //DEFAULT_INITIAL_CAPACITY: 1&lt;&lt;4 2*2*2*2=16 newCap = DEFAULT_INITIAL_CAPACITY; //DEFAULT_LOAD_FACTOR: 0.75 //临界值0.75*16=12（缓冲层） newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({\"rawtypes\",\"unchecked\"}) //辅助变量newTable执行完下面这行代码后，就会变成有16个位置的空数组 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; //hashMap的table变成有16个位置的空数组（(set_pic_1)） table = newTab; if (oldTab != null) { for (int j = 0; j &lt; oldCap; ++j) { Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else { // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do { next = e.next; if ((e.hash &amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab;} set_pic_1： set_pic_2：刚开始创建一个空table, 接着，当插入一个数据之后 set_pic_3：插入数据时，判断能不能插入根据：即将要插入的key对应的对象和p所指向的Node对应的key的对象是否一样 set_pic_4：添加数据时，equals()方法存在的意义 set_pic_5： set_pic_6： 123Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) { return new Node&lt;&gt;(hash, key, value, next);} 分析HashSet的扩容和转成红黑树机制 HashSet底层是HashMap，第一次添加时，table数组扩容到16，临界值（threshold）是16*加载因子（loadFactor）是0.75 = 12 如果table数组使用到了临界值12，就会扩容到162 = 32， 新的临界值就是 320.75 = 24, 以此类推 在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD（默认是8），并且table的大小 &gt;= MIN_TREEIFY_CAPACITY（默认是64），就会进行树化（转成红黑树），==否则仍然采用数组扩容机制== 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class HashSetIncrement { public static void main(String[] args) { // HashSet底层是HashMap，第一次添加时，table数组扩容到16， // 临界值（threshold）是16*加载因子（loadFactor）是0.75 = 12 // 如果table数组使用到了临界值12，就会扩容到16*2 = 32， 新的临界值就是 32*0.75 = 24, 以此类推 HashSet hashSet = new HashSet();// for (int i = 0; i &lt; 100; i++) {// hashSet.add(i);// } // 在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD（默认是8）， // 并且table的大小 &gt;= MIN_TREEIFY_CAPACITY（默认是64），就会进行树化（转成红黑树）， // 否则仍然采用数组扩容机制// for (int i = 0; i &lt; 12; i++) {// hashSet.add(new A(i));// } // 当我们向hashSet增加一个元素，这个元素在底层封装了一个数据Node，加入到了table，就算是size++， // 而不是说非得增加到table表的第一个才算是增加size++ for (int i = 0; i &lt; 7; i++) { hashSet.add(new A(i)); } for (int j = 0; j &lt; 7; j++) { hashSet.add(new B(j)); } }}class A { private int i; public A(int i) { this.i = i; } @Override public int hashCode() { return 100; } @Override public String toString() { return \"A{\" + \"i=\" + i + '}'; }}class B{ private int n; public B(int n) { this.n = n; } @Override public int hashCode() { return 200; } @Override public String toString() { return \"B{\" + \"n=\" + n + '}'; }} HashSet课堂 练习1我的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class HashSetExercise { public static void main(String[] args) { // 定义一个Employee类，name，age // 创建3个Employee对象放入HashSet中 // name和age相同时，认为是相同员工，不能添加到HashSet中 HashSet hashSet = new HashSet(); Employee jack = new Employee(\"jack\", 10); Employee jack2 = new Employee(\"jack\", 10); Employee lucky = new Employee(\"lucky\", 10); hashSet.add(jack); hashSet.add(jack2); hashSet.add(lucky); System.out.println(hashSet); }}class Employee { private String name; private int age; public Employee(String name, int age) { this.name = name; this.age = age; } @Override public int hashCode() { return (name + age).hashCode(); } // 刚开始我没有重写equals方法，导致虽然名字和年龄相同了，但是还是插入到了HashSet里面 @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Employee employee = (Employee) o; return age == employee.age &amp;&amp; Objects.equals(name, employee.name); } @Override public String toString() { return \"Employee{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; }} 运行结果： 1[Employee{name='jack', age=10}, Employee{name='lucky', age=10}] 老师的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class HashSetExercise { public static void main(String[] args) { // 定义一个Employee类，name，age // 创建3个Employee对象放入HashSet中 // name和age相同时，认为是相同员工，不能添加到HashSet中 HashSet hashSet = new HashSet(); Employee jack = new Employee(\"jack\", 10); Employee jack2 = new Employee(\"jack\", 10); Employee lucky = new Employee(\"lucky\", 10); hashSet.add(jack); hashSet.add(jack2); hashSet.add(lucky); System.out.println(hashSet); }}class Employee { private String name; private int age; public Employee(String name, int age) { this.name = name; this.age = age; } // 老师的代码和我的代码的主要区别就在equals()和hashCode()方法这里 @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Employee employee = (Employee) o; return age == employee.age &amp;&amp; Objects.equals(name, employee.name); } @Override public int hashCode() { return Objects.hash(name, age); } @Override public String toString() { return \"Employee{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; }} 1[Employee{name='lucky', age=10}, Employee{name='jack', age=10}] HashSet课堂 练习2我的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import java.util.HashSet;import java.util.Objects;public class HashSetExercise { public static void main(String[] args) { // 定义一个Employee类，name，sal, birthday(MyDate类型，属性包括：year，month，day) // 创建3个Employee对象放入HashSet中 // name和birthday相同时，认为是相同员工，不能添加到HashSet中 HashSet hashSet = new HashSet(); hashSet.add(new Employee(\"jack\", 18000, new MyDate(1989, 3, 5))); hashSet.add(new Employee(\"lucky\", 9000, new MyDate(1996, 7, 1))); hashSet.add(new Employee(\"jack\", 26000, new MyDate(1989, 3, 5))); System.out.println(hashSet); }}class Employee { private String name; private int sal; private MyDate date; public Employee(String name, int sal, MyDate date) { this.name = name; this.sal = sal; this.date = date; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Employee employee = (Employee) o; return Objects.equals(name, employee.name) &amp;&amp; Objects.equals(date, employee.date); } @Override public int hashCode() { return Objects.hash(name, date); } @Override public String toString() { return \"Employee{\" + \"name='\" + name + '\\'' + \", sal=\" + sal + \", date=\" + date + '}'; }}class MyDate { private int year; private int month; private int day; public MyDate(int year, int month, int day) { this.year = year; this.month = month; this.day = day; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; MyDate myDate = (MyDate) o; return year == myDate.year &amp;&amp; month == myDate.month &amp;&amp; day == myDate.day; } @Override public int hashCode() { return Objects.hash(year, month, day); } @Override public String toString() { return \"MyDate{\" + \"year=\" + year + \", month=\" + month + \", day=\" + day + '}'; }} 1[Employee{name='lucky', sal=9000, date=MyDate{year=1996, month=7, day=1}}, Employee{name='jack', sal=18000, date=MyDate{year=1989, month=3, day=5}}] Map接口和常用方法Map接口实现类特点 用于保存具有映射关系的数据Key-Value Map中的key和value可以是任意引用类型的数据，会封装到HashMap$Node对象中 Map中的key不允许重复，原因和HashSet一样 Map中的value可以重复 Map中的key可以为null，value也可以为null，key为null只能有一个，value为null可以有多个，和第4点前后呼应 常用String类作为Map的key Key和value之间存在单向一对一的关系，即通过key可以找到对应的value值 Map存放的数据是Key-Value Map接口和常用方法Map体系的继承图 Map接口的常用方法12345678910111213141516171819202122232425262728293031323334353637383940public class MapMethod { public static void main(String[] args) { Map map = new HashMap(); //1. put map.put(\"小丸子\", \"樱桃小丸子\"); map.put(\"桔梗\", \"犬夜叉\"); map.put(\"月野兔\", \"美少女战士\"); map.put(\"唐三\", \"同样的key，value会覆盖\"); map.put(\"唐三\", \"斗罗大陆\"); map.put(null, \"null key\"); map.put(\"null value\", null); map.put(\"学校\", new School(\"哈哈大学\")); System.out.println(map);// {null=null key, 学校=com.example.hanshunping.map.School@4d7e1886, 唐三=斗罗大陆, 小丸子=樱桃小丸子, null value=null, 月野兔=美少女战士, 桔梗=犬夜叉} //2.get System.out.println(map.get(\"月野兔\"));// 美少女战士 //3.size System.out.println(map.size());// 7 //4.isEmpty System.out.println(map.isEmpty());// false //5.containsKey System.out.println(map.containsKey(\"猪太郎\"));// false System.out.println(map.containsKey(\"小丸子\"));// true //6.remove System.out.println(map.remove(\"test\"));// null Object remover = map.remove(null); System.out.println(remover.getClass());// class java.lang.String System.out.println(map);// {学校=com.example.hanshunping.map.School@4d7e1886, 唐三=斗罗大陆, 小丸子=樱桃小丸子, null value=null, 月野兔=美少女战士, 桔梗=犬夜叉} //7.clear map.clear(); System.out.println(map);// {} }}class School { private String name; public School(String name) { this.name = name; }} Map接口的元素遍历方式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class MapFor { public static void main(String[] args) { Map map = new HashMap(); map.put(\"小丸子\", \"樱桃小丸子\"); map.put(\"桔梗\", \"犬夜叉\"); map.put(\"月野兔\", \"美少女战士\"); map.put(\"唐三\", \"斗罗大陆\"); //1.keySet //(1)增强for System.out.println(\"=====1.keySet 增强for=====\"); for (Object key : map.keySet()) { System.out.println(key + \"-\" + map.get(key)); } //(2)迭代器 System.out.println(\"=====1.keySet 迭代器=====\"); Iterator iterator = map.keySet().iterator(); while (iterator.hasNext()) { Object next = iterator.next();// 这里iterator.next()的类型是class java.lang.String System.out.println(next); } //2.values //(1)增强for System.out.println(\"=====2.values 增强for=====\"); for (Object value : map.values()) { System.out.println(value); } //(2)迭代器 System.out.println(\"=====2.values 迭代器=====\"); Collection values = map.values(); Iterator valuesIterator = values.iterator(); while (valuesIterator.hasNext()) { Object next = valuesIterator.next();// valuesIterator.next()的类型是class java.lang.String System.out.println(next); } //3.entrySet Set set = map.entrySet(); //(1)增强for System.out.println(\"=====3.entrySet 增强for=====\"); for (Object o : set) { Map.Entry entry = (Map.Entry) o;// o的类型是class java.util.HashMap$Node System.out.println(entry.getValue() + \"-\" + entry.getValue()); } //(2)迭代器 System.out.println(\"=====3.entrySet 迭代器=====\"); Iterator entrySetIterator = set.iterator(); while (entrySetIterator.hasNext()) { Object next = entrySetIterator.next();// entrySetIterator.next()的类型是class java.util.HashMap$Node Map.Entry entry = (Map.Entry) next; System.out.println(entry.getValue() + \"-\" + entry.getValue()); } }} 123456789101112131415161718192021222324252627282930=====1.keySet 增强for=====唐三-斗罗大陆小丸子-樱桃小丸子月野兔-美少女战士桔梗-犬夜叉=====1.keySet 迭代器=====唐三小丸子月野兔桔梗=====2.values 增强for=====斗罗大陆樱桃小丸子美少女战士犬夜叉=====2.values 迭代器=====斗罗大陆樱桃小丸子美少女战士犬夜叉=====3.entrySet 增强for=====斗罗大陆-斗罗大陆樱桃小丸子-樱桃小丸子美少女战士-美少女战士犬夜叉-犬夜叉=====3.entrySet 迭代器=====斗罗大陆-斗罗大陆樱桃小丸子-樱桃小丸子美少女战士-美少女战士犬夜叉-犬夜叉 Map接口课堂练习123456789101112131415161718192021222324252627282930313233public class MapExercise { public static void main(String[] args) { Map map = new HashMap(); Employee jack = new Employee(\"jack\", 1001, 31000); Employee rose = new Employee(\"rose\", 1002, 25000); Employee jacky = new Employee(\"jacky\", 1003, 9000); map.put(jack.getId(), jack); map.put(rose.getId(), rose); map.put(jacky.getId(), jacky); // keySet-增强for遍历 System.out.println(\"=====keySet-增强for遍历=====\"); Employee employee = null; for (Object key : map.keySet()) { employee = (Employee) map.get(key); if (employee.getSalary() &gt; 18000) { System.out.println(employee.toString()); } } // entrySet-迭代器遍历 System.out.println(\"=====entrySet-迭代器遍历=====\"); Set set = map.entrySet(); Iterator iterator = set.iterator(); while (iterator.hasNext()) { Object next = iterator.next(); Map.Entry entry = (Map.Entry) next; Employee employee1 = (Employee) entry.getValue(); if (employee1.getSalary() &gt; 18000) { System.out.println(employee1); } } }} 123456=====keySet-增强for遍历=====Employee{name='jack', id=1001, salary=31000.0}Employee{name='rose', id=1002, salary=25000.0}=====entrySet-迭代器遍历=====Employee{name='jack', id=1001, salary=31000.0}Employee{name='rose', id=1002, salary=25000.0} Map接口底层代码分析1234567891011121314151617181920212223242526public class MapSource_ { public static void main(String[] args) { Map hashMap = new HashMap(); hashMap.put(\"no1\", \"小可爱1号\"); hashMap.put(\"no2\", \"小可爱2号\"); //1. k-v 最后是 HashMap$Node node = newNode(hash, key, value, null); //2. k-v 为了方便程序员遍历, 还会创建一个EntrySet集合, 该集合存放的元素的类型是Entry, 而一个Entry对象里面就有k,v,EntrySet&lt;Entry&lt;K, V&gt;&gt; // 底层代码: public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() Set set = hashMap.entrySet(); System.out.println(set.getClass()); // class java.util.HashMap$EntrySet //3. entrySet里面数据定义的类型是Map.Entry, 底层代码: Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet(); 但是实际上存放的还是HashMap$Node. // 为什么可以把一个Node类型存放到Map.Entry里面呢? 这是因为HashMap$Node实现了Map$Entry. 底层代码：static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; for (Object obj : set) { System.out.println(obj.getClass());// class java.util.HashMap$Node } //4. 既然key,value已经存放到HashMap$Node, 那为什么设计者设计的时候, 又把对象存放到了EntrySet里面呢? 这是因为对象存放到entrySet之后, 就方便我们程序员遍历了. // 为什么会方便程序员遍历呢? 这是因为Map.Entry提供了两个重要的方法 (1)K getKey(); (2)V getValue(); for (Object o : set) { Map.Entry entry = (Map.Entry) o; System.out.println(entry.getKey() + \"-\" + entry.getValue()); } }} 12345class java.util.HashMap$EntrySetclass java.util.HashMap$Nodeclass java.util.HashMap$Nodeno2-小可爱2号no1-小可爱1号 ==entry里面的key和value其实是指向node节点 key和value的引用== HashMap源码剖析HashMap基本介绍 Map接口的常用实现类：==HashMap==、Hashtable和Properties。 HashMap是以Key-Value键值对的方式来存储数据的（Entry）。 Key不能重复，value可以重复，允许有null key和null value。 如果添加相同的key，后面的会覆盖前面的key-value，等同于修改。（key不变，value会替换） 与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的。 HashMap没有实现同步，因此线程是不安全的。方法没有做同步互斥的操作（synchronized），public V put(K key, V value) HashMap底层代码剖析执行HashMap() 123public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted} 123public V put(K key, V value) { return putVal(hash(key), key, value, false, true);} 1234static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);} 123456789101112public int hashCode() { int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) { char val[] = value; for (int i = 0; i &lt; value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { //定义辅助变量 Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //如果当前table是null，或者大小等于0，就第一次扩容，扩到16个空间 if ((tab = table) == null || (n = tab.length) == 0)//table是hashMap的一个属性，这个table就是放node节点的一个数组。类型是：Node[] n = (tab = resize()).length; //(1)根据key，得到hash，去计算该key应该存放到table表的哪个索引位置，并让p指向这个索引位置的对象 //(2)判断p指向的索引位置的对象是否为null //(2.1)如果p指向的索引位置的对象为null，表示还没有存放元素，就创建一个Node(key=\"java\", value=\"PRESENT\") // 就放在该位置tab[i] = newNode(hash, key, value, null); if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); //(2.2)如果p指向的索引位置的对象不为null else { //一个开发技巧：在需要局部变量（辅助变量）的时候，再创建 Node&lt;K,V&gt; e; K k; //如果当前索引位置对应的链表的第一个元素和准备添加的key的hash值一样。并且满足下面两个条件之一： //(1) 准备加入的key和现存的p指向的Node节点的key是同一个对象 //(2) 现存的p指向的Node节点的key的equals()和准备加入的key比较后相同 //如果满足上面两个条件之一，那么就不能加入 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 再判断p是不是一颗红黑树，如果是红黑树，就调用putTreeVal来进行添加 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); //如果table对应索引位置，已经是一个链表，就使用for循环比较 //(1) 依次和链表的每一个元素比较后，都不相同，则加入到该链表最后 //(2) 在依次和该链表的每一个元素比较的过程中，如果有相同情况，就直接break else { //如果找到的节点后面是链表，就循环比较 for (int binCount = 0; ; ++binCount) {//死循环 if ((e = p.next) == null) {//如果整个链表没有和它相同的，就加到链表的最后 p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st // TREEIFY_THRESHOLD=8 //注意：在把元素添加到链表后，会立即进行判断，判断该链表是否已经达到8个节点, // 如果达到8个节点，就调用treeifyBin(tab, hash)对当前链表进行树化（转成红黑树） // 在转成红黑树时，还会进行一个判断，判断该table数组的大小是否小于MIN_TREEIFY_CAPACITY（64）， // 判断条件如下： // if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) // resize(); // 如果小于64，不会马上转成红黑树，会先进行table扩容 // 只有当上面的条件不成立的时候，才进行转成红黑树 treeifyBin(tab, hash); break;//添加到节点后面然后退出 } //如果在循环比较的过程中，有相同的 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break;//放弃添加然后退出 // 这句代码，p依次指向它自己的下一个节点，这样就达到了循环每一个节点 p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; //onlyIfAbsent是put方法调用putVal的时候传入进来的参数，永远为false //public V put(K key, V value) { // return putVal(hash(key), key, value, false[这个参数对应的就是onlyIfAbsent], true); //} if (!onlyIfAbsent || oldValue == null) //这里就实现了map同key的时候，后面的value会覆盖前面的value e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; //size就是每加入一个节点Node(k, v, h, next), size就会增加 if (++size &gt; threshold) resize();// 扩容 afterNodeInsertion(evict); //返回null表示添加成功 return null;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778final Node&lt;K,V&gt;[] resize() { Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) { if (oldCap &gt;= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold } else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else { // zero initial threshold signifies using defaults //DEFAULT_INITIAL_CAPACITY: 1&lt;&lt;4 2*2*2*2=16 newCap = DEFAULT_INITIAL_CAPACITY; //DEFAULT_LOAD_FACTOR: 0.75 //临界值0.75*16=12（缓冲层） newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({\"rawtypes\",\"unchecked\"}) //辅助变量newTable执行完下面这行代码后，就会变成有16个位置的空数组 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; //hashMap的table变成有16个位置的空数组 table = newTab; if (oldTab != null) { for (int j = 0; j &lt; oldCap; ++j) { Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else { // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do { next = e.next; if ((e.hash &amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab;} HashMap表的扩容和树化模拟扩容123456789101112131415161718192021222324252627import java.util.HashMap;import java.util.Objects;public class HashMapSource2 { public static void main(String[] args) { HashMap map = new HashMap(); for (int i = 1; i &lt; 16; i++) { map.put(new Test(i), \"小番薯\"); } System.out.println(map); }}class Test { private int number; public Test(int number) { this.number = number; } @Override public String toString() { return \"\\nTest{\" + \"number=\" + number + '}'; }} 0 -&gt; 16(12) 16(12) -&gt; 32(24) 32(24) -&gt; 64(48) 64(48) -&gt; 128(96) table表也不能一直无限扩容下去，有个限制，如果大于等于MAXIMUM_CAPACITY(1 &lt;&lt; 30 = 1073741824)就不能再继续扩容下去了 模拟树化1234567891011121314151617181920212223242526272829303132import java.util.HashMap;import java.util.Objects;public class HashMapSource2 { public static void main(String[] args) { HashMap map = new HashMap(); for (int i = 1; i &lt; 16; i++) { map.put(new Test(i), \"兔子\"); } System.out.println(map); }}class Test { private int number; //重写hashCode方法，为了让添加的节点都会在table表的同一个索引位置上。 @Override public int hashCode() { return 10; } public Test(int number) { this.number = number; } @Override public String toString() { return \"\\nTest{\" + \"number=\" + number + '}'; }} 12345678910111213141516{Test{number=9}=兔子, Test{number=1}=兔子, Test{number=2}=兔子, Test{number=14}=兔子, Test{number=3}=兔子, Test{number=4}=兔子, Test{number=5}=兔子, Test{number=6}=兔子, Test{number=15}=兔子, Test{number=7}=兔子, Test{number=8}=兔子, Test{number=10}=兔子, Test{number=12}=兔子, Test{number=11}=兔子, Test{number=13}=兔子} 刚开始table是null 插入第一条数据之后，table扩容到16，临界值为12 一直插入数据，直到当前10号索引位置的所挂载的元素超过8个，这个时候不会立即进行树化，因为table表的空间还小于64，所以table表就会进行再一次扩容，这一次会扩容到32，临界值会变为24。 当再进行一次数据的插入操作之后，table表会再一次进行扩容，这一次会扩容到64，临界值会变为48。 再插入一条数据，这个时候，table的索引位置10就会树化，变为TreeNode HashTable源码剖析Hashtable基本介绍 存放的元素是键值对。 key和value都不能是null。 Key不能重复，value可以重复，允许有null key和null value。 Hashtable的方法基本和HashMap类似。 与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的。 Hashtable是线程安全的。(synchronized) 123456789101112131415public class Hashtable_ { public static void main(String[] args) { Hashtable hashtable = new Hashtable(); hashtable.put(\"小丸子\", \"樱桃小丸子\"); hashtable.put(\"桔梗\", \"犬夜叉\"); hashtable.put(\"月野兔\", \"美少女战士\"); hashtable.put(\"唐三\", \"哈哈\");//会被下面的value覆盖 hashtable.put(\"唐三\", \"斗罗大陆\"); /* hashtable.put(null, \"key是null\");//会抛异常 java.lang.NullPointerException hashtable.put(\"value是null\", null);//会抛异常 java.lang.NullPointerException */ System.out.println(hashtable); }} 1{唐三=斗罗大陆, 月野兔=美少女战士, 小丸子=樱桃小丸子, 桔梗=犬夜叉} HashMap底层代码剖析123456789public class Hashtable_ { public static void main(String[] args) { Hashtable hashtable = new Hashtable(); for (int i = 1; i &lt; 10; i++) { hashtable.put(\"student\" + i, \"test\"); } System.out.println(hashtable); }} 底层有数组，Hashtable$Entry[]， 初始化大小为11。临界值是8，threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1); 123public Hashtable() { this(11, 0.75f);//initialCapacity:11 loadFactor:0.75} 1234567891011121314151617181920212223public synchronized V put(K key, V value) { // Make sure the value is not null if (value == null) {//value如果为null在这里就会抛出空指针异常 throw new NullPointerException(); } // Makes sure the key is not already in the hashtable. Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; @SuppressWarnings(\"unchecked\") Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index]; for(; entry != null ; entry = entry.next) { if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) { V old = entry.value; entry.value = value; return old; } } //这里正式执行添加数据操作 addEntry(hash, key, value, index); return null;} 执行方法addEntry，将key-value封装到Entry. 1234567891011121314151617181920private void addEntry(int hash, K key, V value, int index) { modCount++; Entry&lt;?,?&gt; tab[] = table; //如果table表的size大于等于临界值，就会进行table的扩容 if (count &gt;= threshold) { // Rehash the table if the threshold is exceeded rehash(); tab = table; hash = key.hashCode(); index = (hash &amp; 0x7FFFFFFF) % tab.length; } // Creates the new entry. @SuppressWarnings(\"unchecked\") Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index]; tab[index] = new Entry&lt;&gt;(hash, key, value, e); count++;} 123456789101112131415161718192021222324252627282930protected void rehash() { int oldCapacity = table.length; Entry&lt;?,?&gt;[] oldMap = table; // overflow-conscious code //oldCapacity &lt;&lt; 1 + 1 = 2*oldCapacity + 1 int newCapacity = (oldCapacity &lt;&lt; 1) + 1; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) { if (oldCapacity == MAX_ARRAY_SIZE) // Keep running with MAX_ARRAY_SIZE buckets return; newCapacity = MAX_ARRAY_SIZE; } Entry&lt;?,?&gt;[] newMap = new Entry&lt;?,?&gt;[newCapacity]; modCount++; threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1); table = newMap; for (int i = oldCapacity ; i-- &gt; 0 ;) { for (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != null ; ) { Entry&lt;K,V&gt; e = old; old = old.next; int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity; e.next = (Entry&lt;K,V&gt;)newMap[index]; newMap[index] = e; } }} Hashtable和HashMap对比 版本 线程安全（同步）？ 效率 允许null key和null value？ HashMap 1.2 不安全 高 允许 Hashtable 1.0 安全 较低 不允许 PropertiesProperties基本介绍 Properties可以用于从*.properties中加载数据到Properties类对象，进行数据的读取和修改。 工作中*.properties通常作为配置文件。 Properties用法1234567891011121314151617181920212223242526272829303132public class Properties_ { public static void main(String[] args) { Properties properties = new Properties(); //1.put //不能存null key或者null value。 public class Properties extends Hashtable&lt;Object,Object&gt; //properties.put(null, \"null key\"); //properties.put(\"null value\", null);//Exception in thread \"main\" java.lang.NullPointerException properties.put(\"1001\", \"jack\");//Exception in thread \"main\" java.lang.NullPointerException properties.put(\"1001\", \"lucky\");//相同的key，后一个value会替换前一个value。 properties.put(\"1002\", \"cara\"); properties.put(\"1003\", \"ada\"); System.out.println(\"=====put=====\"); System.out.println(properties); //2.get System.out.println(\"=====get=====\"); System.out.println(properties.get(\"1001\")); //3.getProperty(String key) System.out.println(\"=====getProperty(String key)=====\"); System.out.println(properties.getProperty(\"1002\")); //4.getProperty(String key, String defaultValue) System.out.println(\"=====getProperty(String key, String defaultValue)=====\"); System.out.println(properties.getProperty(\"1005\", \"user not exists\")); //3.remove properties.remove(\"1003\"); System.out.println(\"=====remove=====\"); System.out.println(properties); }} 12345678910=====put====={1003=ada, 1002=cara, 1001=lucky}=====get=====lucky=====getProperty(String key)=====cara=====getProperty(String key, String defaultValue)=====user not exists=====remove====={1002=cara, 1001=lucky} Properties源码剖析123public Properties() { this(null);} 123public Properties(Properties defaults) { this.defaults = defaults;} 123public Hashtable() { this(11, 0.75f);} 123456789101112131415161718192021222324public synchronized V put(K key, V value) { // Make sure the value is not null if (value == null) { throw new NullPointerException(); } // Makes sure the key is not already in the hashtable. Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; @SuppressWarnings(\"unchecked\") Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index]; for(; entry != null ; entry = entry.next) { //如果要插入的的key的hash值和准备插入的table索引位置的对象的hash值一样，并且equals方法相等，那么就执行替换操作 if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) { V old = entry.value; entry.value = value;//替换 return old; } } addEntry(hash, key, value, index); return null;} 1234567891011121314151617181920private void addEntry(int hash, K key, V value, int index) { modCount++; Entry&lt;?,?&gt; tab[] = table; if (count &gt;= threshold) { // Rehash the table if the threshold is exceeded //如果table中的数据大于等于临界值，就会扩容 rehash(); tab = table; hash = key.hashCode(); index = (hash &amp; 0x7FFFFFFF) % tab.length; } // Creates the new entry. @SuppressWarnings(\"unchecked\") Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index]; tab[index] = new Entry&lt;&gt;(hash, key, value, e); count++;} 1234567891011121314151617181920212223242526272829303132protected void rehash() { int oldCapacity = table.length; Entry&lt;?,?&gt;[] oldMap = table; // overflow-conscious code //2*oldCapacity + 1 int newCapacity = (oldCapacity &lt;&lt; 1) + 1; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) { if (oldCapacity == MAX_ARRAY_SIZE) // Keep running with MAX_ARRAY_SIZE buckets return; newCapacity = MAX_ARRAY_SIZE; } Entry&lt;?,?&gt;[] newMap = new Entry&lt;?,?&gt;[newCapacity]; modCount++; //计算新的临界值 threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1); table = newMap; //遍历旧数据，将原来的值再放到新的map上 for (int i = oldCapacity ; i-- &gt; 0 ;) { for (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != null ; ) { Entry&lt;K,V&gt; e = old; old = old.next; int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity; e.next = (Entry&lt;K,V&gt;)newMap[index]; newMap[index] = e; } }} TreeSet源码剖析TreeSet基本介绍 TreeSet基本用法使用无参构造器创建TreeSet对象1234567891011public class TreeSet_ { public static void main(String[] args) { //输出的结果和数据插入的顺序不一致 TreeSet treeSet = new TreeSet(); treeSet.add(\"jack\"); treeSet.add(\"roy\"); treeSet.add(\"alisa\"); treeSet.add(\"cecil\"); System.out.println(treeSet); }} 1[alisa, cecil, jack, roy] 使用有参构造器创建TreeSet对象12345678910111213141516public class TreeSetSortable { public static void main(String[] args) { //按字母升序排列 TreeSet treeSet = new TreeSet(new Comparator() { @Override public int compare(Object o1, Object o2) { return ((String) o1).compareTo(((String) o2)); } }); treeSet.add(\"jack\"); treeSet.add(\"roy\"); treeSet.add(\"alisa\"); treeSet.add(\"cecil\"); System.out.println(treeSet); }} 1[alisa, cecil, jack, roy] TreeSet源码剖析123public TreeSet(Comparator&lt;? super E&gt; comparator) { this(new TreeMap&lt;&gt;(comparator));} 123public boolean add(E e) { return m.put(e, PRESENT)==null;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public V put(K key, V value) { Entry&lt;K,V&gt; t = root; //插入第一个数据，t为null，进入这个if条件 if (t == null) { compare(key, key); // type (and possibly null) check //插入数据 root = new Entry&lt;&gt;(key, value, null); size = 1; modCount++; return null; } int cmp; Entry&lt;K,V&gt; parent; // split comparator and comparable paths //comparator会动态绑定到我们写的匿名内部类对象 Comparator&lt;? super K&gt; cpr = comparator; if (cpr != null) { do { parent = t; //比较 cmp = cpr.compare(key, t.key); if (cmp &lt; 0) //t=t.left，如果左侧还有节点，那么while循环会继续比较 t = t.left; else if (cmp &gt; 0) //t=t.right，如果右侧还有节点，那么while循环会继续比较 t = t.right; else return t.setValue(value); } while (t != null); } else { if (key == null) throw new NullPointerException(); @SuppressWarnings(\"unchecked\") Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; do { parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); } while (t != null); } Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); if (cmp &lt; 0) parent.left = e; else parent.right = e; fixAfterInsertion(e); size++; modCount++; return null;} TreeMap源码剖析TreeMap基本介绍 TreeMap基本用法使用无参构造器创建TreeMap对象12345678910111213//Constructs a new, empty tree map, using the natural ordering of its keys. All keys inserted into the map must implement the Comparable interface. Furthermore, all such keys must be mutually comparable.public class TreeMap_ { public static void main(String[] args) { TreeMap treeMap = new TreeMap(); treeMap.put(\"jack\", \"1001\"); treeMap.put(\"henry\", \"1002\"); treeMap.put(\"roy\", \"1003\"); treeMap.put(\"winnie\", \"1004\"); treeMap.put(\"cecil\", \"1005\"); treeMap.put(\"cara\", \"1006\"); System.out.println(treeMap); }} 1{cara=1006, cecil=1005, henry=1002, jack=1001, roy=1003, winnie=1004} 使用有参构造器创建TreeMap对象1234567891011121314151617public class TreeMapSortable { public static void main(String[] args) { TreeMap treeMap = new TreeMap(new Comparator() { @Override public int compare(Object o1, Object o2) { return ((String) o1).length() - (((String) o2).length()); } }); treeMap.put(\"jack\", \"1001\"); treeMap.put(\"henry\", \"1002\"); treeMap.put(\"roy\", \"1003\"); treeMap.put(\"winnie\", \"1004\"); treeMap.put(\"cecil\", \"1005\"); treeMap.put(\"cara\", \"1006\"); System.out.println(treeMap); }} 1{roy=1003, jack=1006, henry=1005, winnie=1004} TreeMap源码剖析123public TreeMap(Comparator&lt;? super K&gt; comparator) { this.comparator = comparator;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public V put(K key, V value) { Entry&lt;K,V&gt; t = root; if (t == null) { compare(key, key); // type (and possibly null) check root = new Entry&lt;&gt;(key, value, null); size = 1; modCount++; return null; } int cmp; Entry&lt;K,V&gt; parent; // split comparator and comparable paths Comparator&lt;? super K&gt; cpr = comparator; if (cpr != null) { do { parent = t; cmp = cpr.compare(key, t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); } while (t != null); } else { if (key == null) throw new NullPointerException(); @SuppressWarnings(\"unchecked\") Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; do { parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); } while (t != null); } Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); if (cmp &lt; 0) parent.left = e; else parent.right = e; fixAfterInsertion(e); size++; modCount++; return null;} 123456public V setValue(V value) { //如果key相同，value会进行替换 V oldValue = this.value; this.value = value; return oldValue;} Collections工具类Collections工具类基本介绍12public class Collectionsextends Object Collections工具类常用方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;public class Collections_ { public static void main(String[] args) { List list = new ArrayList(); list.add(\"roy\"); list.add(\"cecil\"); list.add(\"summer\"); list.add(\"roy\"); //reverse: 反转list中的元素 Collections.reverse(list); System.out.println(\"=====reverse=====\"); System.out.println(list); //shuffle: 对list中的元素进行随机排序 System.out.println(\"=====shuffle=====\"); for (int i = 0; i &lt; 3; i++) { Collections.shuffle(list); System.out.println(list); } //sort: 根据元素的自然顺序对list集合元素进行升序排序 System.out.println(\"=====sort=====\"); Collections.sort(list); System.out.println(list); //sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c: 按指定顺序对元素进行排序 Collections.sort(list, new Comparator() { @Override public int compare(Object o1, Object o2) { return ((String) o2).length() - ((String) o1).length(); } }); System.out.println(\"=====sort传入比较器=====\"); System.out.println(list); //swap: 将j处元素和i处元素进行交换 System.out.println(\"=====swap=====\"); Collections.swap(list, 2, 1); System.out.println(list); //frequency: 返回集合中指定元素出现的次数 System.out.println(\"=====frequency=====\"); System.out.println(Collections.frequency(list, \"roy\")); //copy: 将src中的内容复制到dest中 System.out.println(\"=====copy=====\"); List list1 = new ArrayList(); list.add(\"henry\"); list.add(\"jacky\"); list.add(\"jack\"); Collections.copy(list, list1); System.out.println(list); //replaceAll: 使用新值替换List对象的所有旧值 System.out.println(\"=====replaceAll=====\"); Collections.replaceAll(list, \"roy\", \"lucky\"); System.out.println(list); //max: 根据元素的自然顺序，返回给定集合中的最大元素 System.out.println(\"=====max=====\"); System.out.println(Collections.max(list)); //max: 根据Comparator指定的顺序，返回给定集合中的最大元素 System.out.println(\"=====max=====\"); System.out.println(Collections.max(list, new Comparator() { @Override public int compare(Object o1, Object o2) { return ((String) o2).length() - ((String) o1).length(); } })); //min: 根据元素的自然顺序，返回给定集合中的最小元素 System.out.println(\"=====min=====\"); System.out.println(Collections.min(list)); //min: 根据Comparator指定的顺序，返回给定集合中的最小元素 System.out.println(\"=====min=====\"); System.out.println(Collections.min(list, new Comparator() { @Override public int compare(Object o1, Object o2) { return ((String) o2).compareTo(((String) o1)); } })); }} 1234567891011121314151617181920212223242526=====reverse=====[roy, summer, cecil, roy]=====shuffle=====[roy, roy, summer, cecil][roy, cecil, roy, summer][roy, cecil, summer, roy]=====sort=====[cecil, roy, roy, summer]=====sort传入比较器=====[summer, cecil, roy, roy]=====swap=====[summer, roy, cecil, roy]=====frequency=====2=====copy=====[summer, roy, cecil, roy, henry, jacky, jack]=====replaceAll=====[summer, lucky, cecil, lucky, henry, jacky, jack]=====max=====summer=====max=====jack=====min=====cecil=====min=====summer 集合框架练习练习题一题目： 封装一个新闻类，包含标题和内容属性，提供get、set方法，重写toString方法，打印对象时只打印标题。 只提供一个带参数的构造器，实例化对象时，只初始化标题；并且实例化两个对象。 将新闻对象添加到ArrayList集合中，并且进行倒序遍历。 在遍历集合的过程中，对新闻标题进行处理，超过15个字的，只保留前15个，然后在后边加上”…” 在控制台打印遍历经过处理的新闻标题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Homework01 { public static void main(String[] args) { ArrayList arrayList = new ArrayList(); News news01 = new News(\"a今天是世界读书日 在书中“读”行四海 用画笔畅游太空\"); News news02 = new News(\"b海军 中国人民解放军海军成立73周年 十年之变：人民海军风浪中步履铿锵\"); arrayList.add(news01); arrayList.add(news02); Collections.sort(arrayList, new Comparator() { @Override public int compare(Object o1, Object o2) { return ((News) o2).getTitle().compareTo(((News) o1).getTitle()); } }); Iterator iterator = arrayList.iterator(); while (iterator.hasNext()) { News news = (News) iterator.next(); String title = news.getTitle(); if (title.length() &gt; 15) { news.setTitle(title.substring(0, 15) + \"...\"); } System.out.println(news.getTitle()); } }}class News { private String title; private String content; public News(String title) { this.title = title; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } @Override public String toString() { return \"News{\" + \"title='\" + title + '\\'' + '}'; }} 12b海军 中国人民解放军海军成立...a今天是世界读书日 在书中“读... 练习题二使用ArrayList完成对象Car{name, price}的各种操作 add: 添加单个元素 remove： 删除指定元素 contains：查找元素是否存在 size：获取元素个数 isEmpty：判断是否为空 clear：清空 addAll：添加多个元素 containsAll：查找多个元素是否都存在 removeAll：删除多个元素 使用增强for和迭代器来遍历所有的Car，需要重写Car的toString()方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class Homework02 { public static void main(String[] args) { List list = new ArrayList(); List list2 = new ArrayList(); List list3 = new ArrayList(); Car car1 = new Car(\"亚洲龙\", 270000); Car car2 = new Car(\"奥迪A7L\", 770000); Car car3 = new Car(\"思域\", 160000); Car car4 = new Car(\"宋PLUS\", 205000); Car car5 = new Car(\"速腾\", 165000); //add list.add(car1); System.out.println(\"===add===\" + list); //addAll list2.add(car2); list2.add(car3); list.addAll(list2); list3.add(car4); list3.add(car5); list.addAll(list3); System.out.println(\"===addAll===\" + list); //remove list.remove(car3); System.out.println(\"===remove===\" + list); //contains System.out.println(\"===contains===\" + list.contains(car3)); //size System.out.println(\"===size===\" + list.size()); //isEmpty System.out.println(\"===isEmpty===\" + list.isEmpty()); //containsAll System.out.println(\"===containsAll===\" + list.containsAll(list3)); //removeAll System.out.println(\"===removeAll===\" + list.removeAll(list2)); //遍历集合 System.out.println(\"=====增强for循环遍历集合=====\"); for (Object o : list) { System.out.println((Car) o); } System.out.println(\"=====迭代器遍历集合=====\"); Iterator iterator = list.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } //clear list.clear(); System.out.println(\"===clear===\" + list); }}class Car { private String name; private double price; public Car(String name, double price) { this.name = name; this.price = price; } @Override public String toString() { return \"Car{\" + \"name='\" + name + '\\'' + \", price=\" + price + '}'; }} 1234567891011121314151617===add===[Car{name='亚洲龙', price=270000.0}]===addAll===[Car{name='亚洲龙', price=270000.0}, Car{name='奥迪A7L', price=770000.0}, Car{name='思域', price=160000.0}, Car{name='宋PLUS', price=205000.0}, Car{name='速腾', price=165000.0}]===remove===[Car{name='亚洲龙', price=270000.0}, Car{name='奥迪A7L', price=770000.0}, Car{name='宋PLUS', price=205000.0}, Car{name='速腾', price=165000.0}]===contains===false===size===4===isEmpty===false===containsAll===true===removeAll===true=====增强for循环遍历集合=====Car{name='亚洲龙', price=270000.0}Car{name='宋PLUS', price=205000.0}Car{name='速腾', price=165000.0}=====迭代器遍历集合=====Car{name='亚洲龙', price=270000.0}Car{name='宋PLUS', price=205000.0}Car{name='速腾', price=165000.0}===clear===[] 练习题三 使用HashMap类实例化一个Map类型的对象m，key是String类型，value是int类型，分别用于存储员工的姓名和工资。jack-100,summer-1000,roy:2000 将jack的工资改为2600元。 为所有员工工资加薪100元。 遍历集合中的所有员工。 遍历集合中所有的工资。 123456789101112131415161718192021222324252627282930313233import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;public class Homework03 { public static void main(String[] args) { Map map = new HashMap(); map.put(\"lucky\", 5000); map.put(\"lucy\", 6000); map.put(\"henry\", 3500); map.put(\"lucky\", 8000); Iterator iterator = map.keySet().iterator(); while (iterator.hasNext()) { String key = (String) iterator.next(); int salary = (int) map.get(key); salary += 100; map.put(key, salary); } Set set = map.entrySet(); for (Object o : set) { Map.Entry entry = (Map.Entry) o; System.out.println(entry.getValue()); } System.out.println(\"===============\"); for (Object o : set) { Map.Entry entry = (Map.Entry) o; System.out.println(entry.getKey()); } }} 1234567810036006100===============luckyhenrylucy 练习题四分析HashSet和TreeSet分别如何实现去重的？ 练习题五分析下面的代码运行会不会抛出异常，并从源码层面说明原因。 1234567891011import java.util.TreeSet;public class TreeSet_ { public static void main(String[] args) { TreeSet treeSet = new TreeSet(); treeSet.add(new Person()); }}class Person {} 12345Exception in thread \"main\" java.lang.ClassCastException: com.example.hanshunping.collection.Person cannot be cast to java.lang.Comparable at java.util.TreeMap.compare(TreeMap.java:1294) at java.util.TreeMap.put(TreeMap.java:538) at java.util.TreeSet.add(TreeSet.java:255) at com.example.hanshunping.collection.TreeSet_.main(TreeSet_.java:8) 练习题六分析下面这段代码的输出结果是什么？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.HashSet;import java.util.Objects;public class Homework06 { public static void main(String[] args) { HashSet hashSet = new HashSet(); Person p1 = new Person(1001, \"AA\"); Person p2 = new Person(1001, \"BB\"); hashSet.add(p1); hashSet.add(p2); p1.setName(\"CC\"); hashSet.remove(p1); System.out.println(hashSet); hashSet.add(new Person(1001, \"CC\")); System.out.println(hashSet); hashSet.add(new Person(1001, \"AA\")); System.out.println(hashSet); }}class Person { private int id; private String name; public Person(int id, String name) { this.id = id; this.name = name; } @Override public String toString() { return \"Person{\" + \"id=\" + id + \", name='\" + name + '\\'' + '}'; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return id == person.id &amp;&amp; Objects.equals(name, person.name); } @Override public int hashCode() { return Objects.hash(id, name); } public void setId(int id) { this.id = id; } public void setName(String name) { this.name = name; }} 123[Person{id=1001, name='CC'}, Person{id=1001, name='BB'}][Person{id=1001, name='CC'}, Person{id=1001, name='BB'}, Person{id=1001, name='CC'}][Person{id=1001, name='CC'}, Person{id=1001, name='BB'}, Person{id=1001, name='CC'}, Person{id=1001, name='AA'}]","categories":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"https://xiaofanshutu.github.io/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}],"tags":[],"author":"cutiebambi"},{"title":"Java面向对象总结","slug":"Java面向对象基础","date":"2022-04-06T13:20:01.000Z","updated":"2024-01-17T23:40:08.640Z","comments":true,"path":"posts/ec82f976.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/ec82f976.html","excerpt":"","text":"Java基础包机制包就相当于文件夹 学习阿里巴巴开发手册 Java方法什么是方法12System.out.println();类名.对象.方法名 方法的定义及调用方法重载方法名相同，参数不同。 命令行传参可变参数任何方法最多只能有一个可变参数，并且必须是参数列表最后一个。 递归（工作中不常用）示例代码1234567891011public static void main(String[] args) { System.out.println(f(5));}public static int f(int i) { if (i == 1) { return 1; } else { return i * f(i - 1); }} Java数组数组概述相同数据类型的有序集合 1int[] arrays = {1, 2, 3}; 数组声明创建12int[] num = new int[10];num.length 三种初始化静态初始化1int[] arrays = {1, 2, 3}; 动态初始化123int[] arrays = new int[2];arrays[0] = 1;arrays[1] = 2; 默认初始化数组是引用类型，它的元素相当于类的实例变量。 123int[] arrays = new int[2];System.out.println(arrays[0]);//输出0System.out.println(arrays[1]);//输出0 数组的四个基本特点 长度是确定的。一旦创建，就不可以改变大小。 元素必须是相同类型。 元素可以是任何数据类型，包括基本类型和引用类型。 数组变量属于引用类型，数组也可以看做是对象，数组中的每个元素相当于该对象的成员变量。 数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，数组本身都是在堆中的。 数组使用 for循环 1234int[] arrays = new int[]{1,2,3};for (int i = 0; i &lt; arrays.length; i++) { System.out.println(arrays[i] + \" \");} 增强for循环 1234int[] arrays = new int[]{1,2,3};for (int num: arrays) { System.out.println(num + \" \");} 作为方法参数 作为方法返回值 多维数组1int[][] arrays = {{1,2}, {3,4}, {5,6}} Arrays类Arrays类中的方法都是static修饰的。 Arrays类的结构图 扩展知识：IDEA中的Structure模块使用详解 类方法的展示 开头的 m 标识是表示方法，如果出现 f 标识则表示为属性； m 或者 f 后面紧跟着的是方法或者属性的访问修饰符： #红色关闭的锁表示为private； #圆圈表示不带任何修饰符，default； #一把钥匙代表protected； #绿色打开的锁代表public； 接下来是方法名称； 括号内为方法的入参类型； 冒号后面为方法的返回值类型； 顶部各个图标说明 表示展示的顺序按照访问权限从public到private的格式展示；（structure排序都是先展示方法，再展示属性，这个不可设置和更改） 表示展示的顺序按照开头字母a-z的顺序来展示； 会展示实现的接口类和继承的抽象类，把所有的实现方法展示在其中； 会展示类中所有属性的get、set方法； 会展示所有的属性字段；（注意：单独使用只会展示修饰符为public的属性字段，想要展示其他访问修饰符的字段需要结合下面说到的红色锁来实现）； structure默认只会展示被public修饰的属性，需要查看非公有属性需要使用该按钮； 展示所继承的方法，包括所继承的object方法； 会展示出匿名内部类； 会展示出使用的lambda表达式； 点击左侧属性和方法时，右侧代码跟着滚动定位； 点击右侧代码中的属性和方法时，左侧的structure中对应的属性和方法跟着滚动定位； 常用方法 给数组赋值：通过fill方法 对数组排序：通过sort方法，按升序排序 比较数组：通过equals方法比较数组中的元素是否相等 查找数组元素：通过binarySearch方法能对排序好的数组进行二分查找操作 冒泡排序外层循环：控制循环的次数 内层循环：比较两个数字的大小 123456789101112131415public static void main(String[] args) { int[] arrays = new int[]{10,20,3, 8, 65, 99, 130, 120}; for (int i = 0; i &lt; arrays.length; i++) { for (int j = 0; j &lt; i; j++) { if(arrays[i] &gt; arrays[j]){ int num = arrays[i]; arrays[i] = arrays[j]; arrays[j] = num; } } } for (int array: arrays) { System.out.print(array + \" \"); }} 1130 120 99 65 20 10 8 3 稀疏数组这一节我跳过了，没有学 什么是面向对象面向对象的本质就是：以类的方式组织代码，以对象的组织（封装）数据。 从认识论角度考虑是先有对象后有类。对象，是具体的事物。类，是抽象的，是对对象的抽象。 从代码运行角度考虑是先有类后有对象。类是对象的模板。 回顾方法及加深理解方法的定义break和return的区别 break 跳出当前循环；但是如果是嵌套循环，则只能跳出当前的这一层循环，只有逐层break才能跳出所有循环。 123456789public void breakTest() { for (int i = 0; i &lt; 10; i++) { if (i == 6) { break; // 在执行i==6时强制终止循环，i==6不会被执行 } System.out.println(i); }} 输出结果为0 1 2 3 4 5 ；6以后的都不会输出 10 1 2 3 4 5 continue ​ 终止当前循环，但是不会跳出循环，终止当前循环后，会根据条件，继续往下根据循环条件执行循环。 123456789public void continueTest() { for (int i = 0; i &lt; 10; i++) { if (i == 6) { continue; // i==6不会被执行，而是被中断了 } System.out.println(i); }} 输出结果为0 1 2 3 4 5 7 8 9；只有6没有输出 10 1 2 3 4 5 7 8 9 return 从当前的方法中退出，返回到该调用方法的语句处，继续执行。 返回一个值给调用该方法的语句，返回值的数据类型必须与方法的声明中的返回值类型一致。 Java中break continue和return的区别 方法的调用静态方法与非静态方法的区别 ==调用方法不同== 静态方法可以直接调用，类名调用和对象调用。 非静态方法只能通过对象调用。 ==生命周期不同== 静态方法的生命周期和对应的类一样长，静态方法和静态变量会跟随着类的定义而被分配合装载入内存中。一直到线程结束，静态属性和方法才会被销毁。（也就是静态方法属于类） 非静态方法的生命周期和类的实例化对象一样长，只有当类实例化了一个对象，非静态方法才会被创建，而当这个对象被销毁的时候，非静态方法也马上被销毁。（也就是非静态方法属于对象） 这个内容是参考这个文章写的 静态方法和非静态方法的区别 java中的this关键字 当局部变量与成员变量重名的时候，可以使用this表明用的是对象的成员变量。 当方法需要一个该类的对象做参数的时候，可以用this代替。 当一个方法需要返回对当前对象的引用的时候，可以用return this。 现在针对上面的每一种情况，写一个例子，方便理解。 第一点： 123456789101112131415161718192021222324252627282930public class learnKeywordThis { public String s = \"A\"; public learnKeywordThis() { } public learnKeywordThis(String s) { System.out.println(\"s的值 = \" + s); s = \"B\"; System.out.println(\"经过s=\\\"B\\\"赋值后成员变量s的值\"); System.out.println(\"成员变量s的值 = \" + this.s); this.s = \"B\"; System.out.println(\"经过this.s=\\\"B\\\"赋值后成员变量s的值\"); System.out.println(\"成员变量s的值 = \" + this.s); } public void show() { System.out.println(\"无参构造器中成员变量s的值 = \" + s); } public static void main(String[] args) { System.out.println(\"调用无参构造器\"); new learnKeywordThis().show(); System.out.println(\"调用含参构造器后\"); new learnKeywordThis(\"C\"); }} Output 12345678调用无参构造器无参构造器中成员变量s的值 = A调用含参构造器后s的值 = C经过s=\"B\"赋值后成员变量s的值成员变量s的值 = A经过this.s=\"B\"赋值后成员变量s的值成员变量s的值 = B 第二点： 1234567891011121314151617181920class B { B(A a) { a.show(); }}public class A { public void doB() { new B(this); } public void show() { System.out.println(\"我是A\"); } public static void main(String[] args) { new A().doB(); }} Output 1我是A 12345678910111213141516171819class B { public B() { System.out.println(\"这里的this是\" + this.getClass().getSimpleName()); } public void Bshow() { System.out.println(\"这里的this是\" + this.getClass().getSimpleName()); }}public class A extends B { public A() { } public static void main(String[] args) { new A(); new B().Bshow(); }} 123这里的this是A这里的this是B这里的this是B 我们这里讨论了this的五种用法，但是都是根据this的定义引申出在不同情况下的用法。this只能在方法内部使用，当调用方法中含有this的时候，this就指的调用该方法的对象的引用，当方法参数中需要传入一个类的对象的时候，用this代指这个传入类的对象。当用构造方法初始化成员变量的时候，JVM会默认传入当前对象来初始化成员变量。 Java this的一两点使用 Java this keyword Oracle Using the this keyword 形参和实参值传递和引用传递类与对象的关系创建与初始化对象使用new关键字创建对象使用new关键字创建对象的时候，除了分配内存空间之外，还会给创建好的对象进行默认的初始化以及对类中构造器的调用。 使用new关键字，本质是在调用构造器 构造器必须要掌握哦 构造器： 和类名相同 没有返回值 作用： new 本质是在调用构造方法 初始化对象的值 注意点： 定义有参构造之后，如果想使用无参构造，就必须显示的定义一个无参的构造。 Alt+Insert快捷键 Java简单的内存图 前期学习的一个小总结 类与对象 类是一个模板，抽象的，对象是一个具体的实例。 方法 定义，调用。 对象的引用 引用类型 基本类型 对象是通过引用来操作的： 栈 —-&gt; 堆 属性：字段Field 成员变量 默认初始化： ​ 数字：0 0.0 ​ char：u0000 ​ boolean：false ​ 引用：null 修饰符 属性类型 属性名 = 属性值！ 对象的创建和使用 必须使用new关键字创建对象，构造器 Person person = new Person(); 对象的属性 person.name 对象的方法 person.sleep(); 类 静态的属性 属性 动态的行为 方法 封装该露的露，该藏的藏写程序要追求高内聚，低耦合。 高内聚：类的内部数据操作细节自己完成，不允许外部干涉。 低耦合：仅仅暴露少量的方法给外部使用。 属性私有，get/set12345678910public class Application { public static void main(String[] args) { Student s1 = new Student(); s1.setName(\"jack\"); s1.setAge(30); System.out.println(\"name:\" + s1.getName() + \",age: \" + s1.getAge()); }} 12345678910111213141516171819202122public class Student { //属性私有 private String name; private int age; // 提供一些可以操作这些属性的公有方法. get/set public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} 1name:jack,age: 30 封装的意义 提高程序的安全性，保护数据 隐藏代码的实现细节 统一接口 系统可维护性增加了 继承概念​ 继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。 ​ extends ​ Java中的类只有单继承，没有多继承 ​ 继承就是扩展，子类对父类的扩展 ​ 子类和父类之间的关系，具有“is a”的关系。 ​ 子类继承父类，子类就会拥有父类的全部方法（私有的东西不会被继承） ​ 记住一个快捷键：Ctrl+H Object类在Java中，所有的类默认直接或间接继承Object类 super代码理解12345public class Application { public static void main(String[] args) { Student s1 = new Student(); }} 12345public class Person { public Person() { System.out.println(\"Person的无参构造执行了\"); }} 12345public class Student extends Person { public Student() { System.out.println(\"Student的无参构造执行了\"); }} 12Person的无参构造执行了Student的无参构造执行了 super注意点 super调用父类的构造方法，必须在构造方法的第一个 super必须只能出现在子类的方法或者构造方法中 super和this不能同时调用构造方法 ​ VS this ​ 代表的对象不同： ​ this：本身调用者这个对象 ​ super：代表父类对象的应用 ​ 前提： ​ this：没有继承也可以使用 ​ super：只能在继承条件下才可以使用 ​ 构造方法： ​ this()：本类的构造 ​ super()：父类的构造 方法重写（重点）重点需要有继承关系，子类重写父类的方法！ 方法名必须相同 参数列表必须相同 修饰符：范围可以扩大，但是不能缩小。 Public&gt;Protected&gt;Default&gt;Private 抛出的异常：范围可以被缩小，但是不能扩大。 ClassNotFoundException –&gt; Exception(大) 重写，子类的方法和父类必须要一致，方法体不同 为什么需要重写： 父类的功能，子类不一定需要，或者不一定满足。 Alt+Insert; Override 代码理解1234567891011public class Application { public static void main(String[] args) { // 方法的调用只和左边，定义的数据类型有关系 Student s1 = new Student(); s1.say(); // 父类的引用指向了子类 Person p = new Student(); p.say(); }} 12Student的say方法Student的say方法 多态多态概念 即同一个方法可以根据发送对象的不同而采用多种不同的行为方式 一个对象的实际类型是确定的，但可以指向对象的引用的类型有很多 多态存在的条件 有继承关系 子类重写父类的方法 父类引用指向子类对象 instanceof123public class Person {} 123public class Student extends Person {} 123public class Teacher extends Person {} 123456789101112131415161718192021222324252627public class Application { public static void main(String[] args) { Object object = new Student(); System.out.println(\"===Object object = new Student();===\"); System.out.println(object instanceof Student);// true System.out.println(object instanceof Person);// true System.out.println(object instanceof Object);// true System.out.println(object instanceof Teacher);// false System.out.println(object instanceof String);// false Person person = new Student(); System.out.println(\"===Person person = new Student();===\"); System.out.println(person instanceof Student);// true System.out.println(person instanceof Person);// true System.out.println(person instanceof Object);// true System.out.println(person instanceof Teacher);// false //System.out.println(person instanceof String);// 编译错误 Student student = new Student(); System.out.println(\"===Student student = new Student();===\"); System.out.println(student instanceof Student);// true System.out.println(student instanceof Person);// true System.out.println(student instanceof Object);// true //System.out.println(student instanceof Teacher);// 编译错误 //System.out.println(student instanceof String);// 编译错误 }} 多态注意事项 多态是方法的多态，属性没有多态 父类和子类，是要有联系的。 类型转换异常！ ClassCastException! 存在条件：继承关系，方法需要重写，父类引用指向子类对象！ Father f1 = new Son(); 父类引用指向子类对象 把子类转换为父类，向上转型 把父类转换为子类，向下转型；强制转换 方便方法的调用，减少重复代码 代码理解123456789101112public class Application { public static void main(String[] args) { // 一个对象的实际类型是确定的，但是可以指向的引用类型就不确定。 // 父类的引用指向子类 // 对象能执行哪些方法，主要看对象左边的类型，和右边的关系不大。 Student s1 = new Student(); Person p1 = new Student(); Object obj = new Student(); s1.run(); p1.run(); // 子类重写了父类的方法，所以这里执行的是子类的方法 }} 12345public class Person { public void run(){ System.out.println(\"Person run\"); }} 123456public class Student extends Person { @Override public void run() { System.out.println(\"Student run\"); }} 代码执行结果： 12Student runStudent run static关键字详解静态方法12345public class Student { public static void getInfo() { System.out.println(\"call get info method\"); }} 12345public class Application { public static void main(String[] args) { Student.getInfo(); }} 静态属性123456public class Student { public static String name; public static int rank; public String country; public int age;} 12345678public class Application { public static void main(String[] args) { Student student = new Student(); String name = Student.name; int rank = Student.rank; int age = student.age; }} 静态代码块12345678public class Application { public static void main(String[] args) { Person person = new Person(); System.out.println(\"=============\"); Person person2 = new Person(); }} 123456静态代码块匿名代码块构造方法=============匿名代码块构造方法 静态导入包12345678910// 静态导入包import static java.lang.Math.random;import static java.lang.Math.PI;public class Application { public static void main(String[] args) { System.out.println(random()); System.out.println(PI); }} 120.30151016218947913.141592653589793 抽象类1234567891011// abstract 抽象类， extends 单继承public abstract class Action { // 约束~有人帮我们实现 // abstract 抽象方法，只有方法名字，没有方法的实现。 public abstract void doSomething(); //1. 不能new这个抽象类，只能靠子类去实现它；约束！ //2. 抽象类中可以写普通的方法 //3. 抽象方法必须在抽象类中 // 抽象的抽象：约束} 存在抽象类的构造器吗？ 通过查看代码，发现编译后的class文件如下： 123456public abstract class Action { public Action() { } public abstract void doSomething();} 接口普通类、抽象类和接口的对比 普通类：只有具体实现 抽象类：集体实现和规范（抽象方法）都有 接口：只有规范，自己无法写方法 声明类的关键字是class，声明接口的关键字是interface接口的概念 接口就是规范，定义的是一组规则。 接口的本质在是契约，制定好之后大家都去遵守。 OO的精髓，是对对象的抽象，最能体现这一点的就是接口。 接口的作用 约束 定义一些方法，让不同的人去实现。 方法都是public abstract 属性都是public static final 接口不能被实例化，接口中没有构造方法 implements可以实现多个接口 必须要重写接口中的方法 代码理解12345678910111213141516171819202122232425262728package com.example.kuangshenjava.oop.demo09;public class UserServiceImpl implements UserService, TimeService { @Override public void add(String name) { } @Override public void remove(String name) { } @Override public void update(String name) { } @Override public void search(String name) { } @Override public void getTime() { }} 123456789package com.example.kuangshenjava.oop.demo09;public interface UserService { // 接口中所有的定义方法其实都是抽象的public abstract public abstract void add(String name); void remove(String name); void update(String name); void search(String name);} 12345package com.example.kuangshenjava.oop.demo09;public interface TimeService { void getTime();} 内部类12345678910111213141516171819public class Outer { private int id; public void out() { System.out.println(\"这是外部类的方法\"); } //普通内部类 public class Inner { private void in() { System.out.println(\"这是内部类的方法\"); } } //获得外部类的私有属性 public void getID() { System.out.println(id); }} 1234567891011121314public class Outer { private int id; public void out() { System.out.println(\"这是外部类的方法\"); } //静态内部类 public static class Inner { private void in() { System.out.println(\"这是静态内部类的方法\"); } }} 12345678910public class Outer { //局部内部类 public void method() { class Inner { private void in() { System.out.println(\"这是局部内部类的方法\"); } } }} 123456789101112public class Outer { public static void main(String[] args) { //没有名字初始化类，不用将实例保存到变量中。 new Recorder().getInfo(); }}class Recorder { public void getInfo() { System.out.println(\"Call getInfo method\"); }} 异常异常体系结构 记住以下几个关键字try catch finally throw throws 注意： throw是在代码块内的，即用于捕获方法内的异常并抛出时用 throws是针对方法的，即将方法的异常信息抛出去 可以理解为throw是主动（在方法内容里我们是主动捕获并throw的），而throws是被动（在方法上是没有捕获异常进行处理，直接throws的） 使用位置不同：throw位于方法体内部，可以作为单独语句使用，throws必须跟在方法参数列表后面，不能单独使用。 内容不同：throw抛出一个异常对象，而且只能是一个，throws后面跟异常类，可以有多个。 小技巧：IDEA快捷键 psvm ctrl + alt + t","categories":[{"name":"Java面向对象和基础","slug":"Java面向对象和基础","permalink":"https://xiaofanshutu.github.io/categories/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"cutiebambi"}],"categories":[{"name":"Oracle","slug":"Oracle","permalink":"https://xiaofanshutu.github.io/categories/Oracle/"},{"name":"MySQL","slug":"MySQL","permalink":"https://xiaofanshutu.github.io/categories/MySQL/"},{"name":"Java","slug":"Java","permalink":"https://xiaofanshutu.github.io/categories/Java/"},{"name":"Spring6","slug":"Spring6","permalink":"https://xiaofanshutu.github.io/categories/Spring6/"},{"name":"Spring","slug":"Spring","permalink":"https://xiaofanshutu.github.io/categories/Spring/"},{"name":"HTML5","slug":"HTML5","permalink":"https://xiaofanshutu.github.io/categories/HTML5/"},{"name":"Java基础","slug":"Java基础","permalink":"https://xiaofanshutu.github.io/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"新技术FreeMarker","slug":"新技术FreeMarker","permalink":"https://xiaofanshutu.github.io/categories/%E6%96%B0%E6%8A%80%E6%9C%AFFreeMarker/"},{"name":"日常","slug":"日常","permalink":"https://xiaofanshutu.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"八股文","slug":"八股文","permalink":"https://xiaofanshutu.github.io/categories/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://xiaofanshutu.github.io/categories/SpringBoot/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://xiaofanshutu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"Javascript","slug":"Javascript","permalink":"https://xiaofanshutu.github.io/categories/Javascript/"},{"name":"Java Web","slug":"Java-Web","permalink":"https://xiaofanshutu.github.io/categories/Java-Web/"},{"name":"Java IO","slug":"Java-IO","permalink":"https://xiaofanshutu.github.io/categories/Java-IO/"},{"name":"Java集合框架","slug":"Java集合框架","permalink":"https://xiaofanshutu.github.io/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"},{"name":"Java面向对象和基础","slug":"Java面向对象和基础","permalink":"https://xiaofanshutu.github.io/categories/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%9F%BA%E7%A1%80/"}],"tags":[]}