{"meta":{"title":"草莓大福","subtitle":"","description":"","author":"John Doe","url":"https://xiaofanshutu.github.io","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2022-06-17T07:16:23.391Z","comments":false,"path":"404.html","permalink":"https://xiaofanshutu.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2022-06-17T07:16:23.628Z","updated":"2022-06-17T07:16:23.628Z","comments":false,"path":"google1xxxxxxx0.html","permalink":"https://xiaofanshutu.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"","date":"2022-06-17T07:16:23.622Z","updated":"2022-06-17T07:16:23.622Z","comments":false,"path":"baidu_verify_xxxxxxx.html","permalink":"https://xiaofanshutu.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2022-06-17T07:16:23.429Z","comments":false,"path":"List/index.html","permalink":"https://xiaofanshutu.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2022-06-17T07:16:23.620Z","comments":false,"path":"about/index.html","permalink":"https://xiaofanshutu.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2022-06-17T07:16:23.623Z","comments":false,"path":"categories/index.html","permalink":"https://xiaofanshutu.github.io/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2022-06-17T07:16:23.621Z","comments":false,"path":"archives/index.html","permalink":"https://xiaofanshutu.github.io/archives/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2022-06-17T08:09:55.549Z","comments":false,"path":"contact/index.html","permalink":"https://xiaofanshutu.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 cutiebambiの友链信息 博客名称: cutiebambiの博客 博客网址: https://xiaofanshutu.github.io/ 博客头像: https://cdn.jsdelivr.net/gh/xiaofanshutu/myBlogPic@main/matery/img/logo.png 博客介绍: The harder you work, the luckier you will be"},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2022-06-17T07:16:23.624Z","comments":false,"path":"census/index.html","permalink":"https://xiaofanshutu.github.io/census/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2022-06-17T07:16:23.630Z","comments":false,"path":"resource/index.html","permalink":"https://xiaofanshutu.github.io/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2022-06-17T07:16:23.632Z","comments":false,"path":"tags/index.html","permalink":"https://xiaofanshutu.github.io/tags/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-06-17T07:16:23.433Z","comments":false,"path":"List/tools/index.html","permalink":"https://xiaofanshutu.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2022-06-17T07:16:23.628Z","comments":false,"path":"friends/index.html","permalink":"https://xiaofanshutu.github.io/friends/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-06-28T07:53:23.584Z","updated":"2022-06-17T07:16:23.406Z","comments":false,"path":"List/galleries/index.html","permalink":"https://xiaofanshutu.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2022-06-17T07:16:23.430Z","comments":false,"path":"List/movies/index.html","permalink":"https://xiaofanshutu.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-06-17T07:16:23.431Z","comments":false,"path":"List/music/index.html","permalink":"https://xiaofanshutu.github.io/List/music/index.html","excerpt":"","text":""},{"title":"动漫卡通","date":"2022-06-17T08:40:11.341Z","updated":"2022-06-17T08:40:11.341Z","comments":false,"path":"List/galleries/动漫卡通/index.html","permalink":"https://xiaofanshutu.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E5%8D%A1%E9%80%9A/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"白马Java/JavaSE笔记（五）重制版","date":"2025-09-07T23:26:13.342Z","updated":"2025-09-07T23:28:25.714Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/0.html","excerpt":"泛型程序设计在前面我们学习了最重要的类和对象，了解了面向对象编程的思想，注意，非常重要，面向对象是必须要深入理解和掌握的内容，不能草草结束。在本章节，我们还会继续深入了解，从泛型开始，再到数据结构，最后再开始我们的集合类学习，循序渐进。 泛型为了统计学生成绩，要求设计一个Score对象，包括课程名称、课程号、课程成绩，但是成绩分为两种，一种是以优秀、良好、合格 来作为结果，还有一种就是 60.0、75.5、92.5 这样的数字分数，可能高等数学这门课是以数字成绩进行结算，而计算机网络实验这门课是以等级进行结算，这两种分数类型都有可能出现，那么现在该如何去设计这样的一个Score类呢？ 现在的问题就是，成绩可能是String类型，也可能是Integer类型，如何才能很好的去存可能出现的两种类型呢？ 1234567891011public class Score { String name; String id; Object value; //因为Object是所有类型的父类，因此既可以存放Integer也能存放String public Score(String name, String id, Object value) { this.name = name; this.id = id; this.value = value; }} 以上的方法虽然很好地解决了多种类型存储问题，但是Object类型在编译阶段并不具有良好的类型判断能力，很容易出现以下的情况： 12345678public static void main(String[] args) { Score score = new Score(\"数据结构与算法基础\", \"EP074512\", \"优秀\"); //是String类型的 ... Integer number = (Integer) score.score; //获取成绩需要进行强制类型转换，虽然并不是一开始的类型，但是编译不会报错}","text":"泛型程序设计在前面我们学习了最重要的类和对象，了解了面向对象编程的思想，注意，非常重要，面向对象是必须要深入理解和掌握的内容，不能草草结束。在本章节，我们还会继续深入了解，从泛型开始，再到数据结构，最后再开始我们的集合类学习，循序渐进。 泛型为了统计学生成绩，要求设计一个Score对象，包括课程名称、课程号、课程成绩，但是成绩分为两种，一种是以优秀、良好、合格 来作为结果，还有一种就是 60.0、75.5、92.5 这样的数字分数，可能高等数学这门课是以数字成绩进行结算，而计算机网络实验这门课是以等级进行结算，这两种分数类型都有可能出现，那么现在该如何去设计这样的一个Score类呢？ 现在的问题就是，成绩可能是String类型，也可能是Integer类型，如何才能很好的去存可能出现的两种类型呢？ 1234567891011public class Score { String name; String id; Object value; //因为Object是所有类型的父类，因此既可以存放Integer也能存放String public Score(String name, String id, Object value) { this.name = name; this.id = id; this.value = value; }} 以上的方法虽然很好地解决了多种类型存储问题，但是Object类型在编译阶段并不具有良好的类型判断能力，很容易出现以下的情况： 12345678public static void main(String[] args) { Score score = new Score(\"数据结构与算法基础\", \"EP074512\", \"优秀\"); //是String类型的 ... Integer number = (Integer) score.score; //获取成绩需要进行强制类型转换，虽然并不是一开始的类型，但是编译不会报错} 使用Object类型作为引用，对于使用者来说，由于是Object类型，所以说并不能直接判断存储的类型到底是String还是Integer，取值只能进行强制类型转换，显然无法在编译期确定类型是否安全，项目中代码量非常之大，进行类型比较又会导致额外的开销和增加代码量，如果不经比较就很容易出现类型转换异常，代码的健壮性有所欠缺 所以说这种解决办法虽然可行，但并不是最好的方案。 为了解决以上问题，JDK 5新增了泛型，它能够在编译阶段检查类型安全，大大提升开发效率。 泛型类泛型其实就一个待定类型，我们可以使用一个特殊的名字表示泛型，泛型在定义时并不明确是什么类型，而是需要到使用时才会确定对应的泛型类型。 我们可以将一个类定义为一个泛型类： 1234567891011public class Score&lt;T&gt; { //泛型类需要使用&lt;&gt;，我们需要在里面添加1 - N个类型变量 String name; String id; T value; //T会根据使用时提供的类型自动变成对应类型 public Score(String name, String id, T value) { //这里T可以是任何类型，但是一旦确定，那么就不能修改了 this.name = name; this.id = id; this.value = value; }} 我们来看看这是如何使用的： 1234567public static void main(String[] args) { Score&lt;String&gt; score = new Score&lt;String&gt;(\"计算机网络\", \"EP074512\", \"优秀\"); //因为现在有了类型变量，在使用时同样需要跟上&lt;&gt;并在其中填写明确要使用的类型 //这样我们就可以根据不同的类型进行选择了 String value = score.value; //一旦类型明确，那么泛型就变成对应的类型了 System.out.println(value);} 泛型将数据类型的确定控制在了编译阶段，在编写代码的时候就能明确泛型的类型，如果类型不符合，将无法通过编译！因为是具体使用对象时才会明确具体类型，所以说静态方法中是不能用的： 只不过这里需要注意一下，我们在方法中使用待确定类型的变量时，因为此时并不明确具体是什么类型，那么默认会认为这个变量是一个Object类型的变量，因为无论具体类型是什么，一定是Object类的子类： 我们可以对其进行强制类型转换，但是实际上没多大必要： 123public void test(T t){ String str = (String) t; //都明确要用String了，那这里定义泛型不是多此一举吗} 因为泛型本身就是对某些待定类型的简单处理，如果都明确要使用什么类型了，那大可不必使用泛型。还有，不能通过这个不确定的类型变量就去直接创建对象和对应的数组： 注意，具体类型不同的泛型类变量，不能使用不同的变量进行接收： 如果要让某个变量支持引用确定了任意类型的泛型，那么可以使用?通配符： 12345public static void main(String[] args) { Test&lt;?&gt; test = new Test&lt;Integer&gt;(); test = new Test&lt;String&gt;(); Object o = test.value; //但是注意，如果使用通配符，那么由于类型不确定，所以说具体类型同样会变成Object} 当然，泛型变量不止可以只有一个，如果需要使用多个的话，我们也可以定义多个： 12345public class Test&lt;A, B, C&gt; { //多个类型变量使用逗号隔开 public A a; public B b; public C c;} 那么在使用时，就需要将这三种类型都进行明确指定： 123456public static void main(String[] args) { Test&lt;String, Integer, Character&gt; test = new Test&lt;&gt;(); //使用钻石运算符可以省略其中的类型 test.a = \"lbwnb\"; test.b = 10; test.c = '淦';} 是不是感觉好像还是挺简单的？只要是在类中，都可以使用类型变量： 123456789101112public class Test&lt;T&gt;{ private T value; public void setValue(T value) { this.value = value; } public T getValue() { return value; }} 只不过，泛型只能确定为一个引用类型，基本类型是不支持的： 123public class Test&lt;T&gt;{ public T value;} 如果要存放基本数据类型的值，我们只能使用对应的包装类： 123public static void main(String[] args) { Test&lt;Integer&gt; test = new Test&lt;&gt;();} 当然，如果是基本类型的数组，因为数组本身是引用类型，所以说是可以的： 123public static void main(String[] args) { Test&lt;int[]&gt; test = new Test&lt;&gt;();} 通过使用泛型，我们就可以将某些不明确的类型在具体使用时再明确。 泛型与多态不只是类，包括接口、抽象类，都是可以支持泛型的： 123public interface Study&lt;T&gt; { T test();} 当子类实现此接口时，我们可以选择在实现类明确泛型类型，或是继续使用此泛型让具体创建的对象来确定类型： 1234567891011121314public class Main { public static void main(String[] args) { A a = new A(); Integer i = a.test(); } static class A implements Study&lt;Integer&gt; { //在实现接口或是继承父类时，如果子类是一个普通类，那么可以直接明确对应类型 @Override public Integer test() { return null; } }} 或者是继续摆烂，依然使用泛型： 1234567891011121314public class Main { public static void main(String[] args) { A&lt;String&gt; a = new A&lt;&gt;(); String i = a.test(); } static class A&lt;T&gt; implements Study&lt;T&gt; { //让子类继续为一个泛型类，那么可以不用明确 @Override public T test() { return null; } }} 继承也是同样的： 1234567static class A&lt;T&gt; { }static class B extends A&lt;String&gt; {} 泛型方法当然，类型变量并不是只能在泛型类中才可以使用，我们也可以定义泛型方法。 当某个方法（无论是是静态方法还是成员方法）需要接受的参数类型并不确定时，我们也可以使用泛型来表示： 123456789public class Main { public static void main(String[] args) { String str = test(\"Hello World!\"); } private static &lt;T&gt; T test(T t){ //在返回值类型前添加&lt;&gt;并填写泛型变量表示这个是一个泛型方法 return t; }} 泛型方法会在使用时自动确定泛型类型，比如上我们定义的是类型T作为参数，同样的类型T作为返回值，实际传入的参数是一个字符串类型的值，那么T就会自动变成String类型，因此返回值也是String类型。 12345678910public static void main(String[] args) { String[] strings = new String[1]; Main main = new Main(); main.add(strings, \"Hello\"); System.out.println(Arrays.toString(strings));}private &lt;T&gt; void add(T[] arr, T t){ arr[0] = t;} 实际上泛型方法在很多工具类中也有，比如说Arrays的排序方法： 12345678Integer[] arr = {1, 4, 5, 2, 6, 3, 0, 7, 9, 8};Arrays.sort(arr, new Comparator&lt;Integer&gt;() { //通过创建泛型接口的匿名内部类，来自定义排序规则，因为匿名内部类就是接口的实现类，所以说这里就明确了类型 @Override public int compare(Integer o1, Integer o2) { //这个方法会在执行排序时被调用（别人来调用我们的实现） return 0; }}); 比如现在我们想要让数据从大到小排列，我们就可以自定义： 123456789101112public static void main(String[] args) { Integer[] arr = {1, 4, 5, 2, 6, 3, 0, 7, 9, 8}; Arrays.sort(arr, new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { //两个需要比较的数会在这里给出 return o2 - o1; //compare方法要求返回一个int来表示两个数的大小关系，大于0表示大于，小于0表示小于 //这里直接o2-o1就行，如果o2比o1大，那么肯定应该排在前面，所以说返回正数表示大于 } }); System.out.println(Arrays.toString(arr));} 因为我们前面学习了Lambda表达式，像这种只有一个方法需要实现的接口，直接安排了： 12345public static void main(String[] args) { Integer[] arr = {1, 4, 5, 2, 6, 3, 0, 7, 9, 8}; Arrays.sort(arr, (o1, o2) -&gt; o2 - o1); //瞬间变一行，效果跟上面是一样的 System.out.println(Arrays.toString(arr));} 包括数组复制方法： 12345public static void main(String[] args) { String[] arr = {\"AAA\", \"BBB\", \"CCC\"}; String[] newArr = Arrays.copyOf(arr, 3); //这里传入的类型是什么，返回的类型就是什么，也是用到了泛型 System.out.println(Arrays.toString(newArr));} 因此，泛型实际上在很多情况下都能够极大地方便我们对于程序的代码设计。 泛型的界限现在有一个新的需求，现在没有String类型的成绩了，但是成绩依然可能是整数，也可能是小数，这时我们不希望用户将泛型指定为除数字类型外的其他类型，我们就需要使用到泛型的上界定义： 123456789101112131415public class Score&lt;T extends Number&gt; { //设定类型参数上界，必须是Number或是Number的子类 private final String name; private final String id; private final T value; public Score(String name, String id, T value) { this.name = name; this.id = id; this.value = value; } public T getValue() { return value; }} 只需要在泛型变量的后面添加extends关键字即可指定上界，使用时，具体类型只能是我们指定的上界类型或是上界类型的子类，不得是其他类型。否则一律报错： 实际上就像这样： 同样的，当我们在使用变量时，泛型通配符也支持泛型的界限： 123public static void main(String[] args) { Score&lt;? extends Integer&gt; score = new Score&lt;&gt;(\"数据结构与算法\", \"EP074512\", 60);} 那么既然泛型有上界，那么有没有下界呢？肯定的啊： 只不过下界仅适用于通配符，对于类型变量来说是不支持的。下界限定就像这样： 那么限定了上界后，我们再来使用这个对象的泛型成员，会变成什么类型呢？ 1234public static void main(String[] args) { Score&lt;? extends Number&gt; score = new Score&lt;&gt;(\"数据结构与算法基础\", \"EP074512\", 10); Number o = score.getValue(); //可以看到，此时虽然使用的是通配符，但是不再是Object类型，而是对应的上界} 但是我们限定下界的话，因为还是有可能是Object，所以说依然是跟之前一样： 1234public static void main(String[] args) { Score&lt;? super Number&gt; score = new Score&lt;&gt;(\"数据结构与算法基础\", \"EP074512\", 10); Object o = score.getValue();} 通过给设定泛型上限，我们就可以更加灵活地控制泛型的具体类型范围。 类型擦除前面我们已经了解如何使用泛型，那么泛型到底是如何实现的呢，程序编译之后的样子是什么样的？ 123public abstract class A &lt;T&gt;{ abstract T test(T t);} 实际上在Java中并不是真的有泛型类型（为了兼容之前的Java版本）因为所有的对象都是属于一个普通的类型，一个泛型类型编译之后，实际上会直接使用默认的类型： 123public abstract class A { abstract Object test(Object t); //默认就是Object} 当然，如果我们给类型变量设定了上界，那么会从默认类型变成上界定义的类型： 123public abstract class A &lt;T extends Number&gt;{ //设定上界为Number abstract T test(T t);} 那么编译之后： 123public abstract class A { abstract Number test(Number t); //上界Number，因为现在只可能出现Number的子类} 因此，泛型其实仅仅是在编译阶段进行类型检查，当程序在运行时，并不会真的去检查对应类型，所以说哪怕是我们不去指定类型也可以直接使用： 123public static void main(String[] args) { Test test = new Test(); //对于泛型类Test，不指定具体类型也是可以的，默认就是原始类型} 只不过此时编译器会给出警告： 同样的，由于类型擦除，实际上我们在使用时，编译后的代码是进行了强制类型转换的： 1234public static void main(String[] args) { A&lt;String&gt; a = new B(); String i = a.test(\"10\"); //因为类型A只有返回值为原始类型Object的方法} 实际上编译之后： 1234public static void main(String[] args) { A a = new B(); String i = (String) a.test(\"10\"); //依靠强制类型转换完成的} 不过，我们思考一个问题，既然继承泛型类之后可以明确具体类型，那么为什么@Override不会出现错误呢？我们前面说了，重写的条件是需要和父类的返回值类型和形参一致，而泛型默认的原始类型是Object类型，子类明确后变为其他类型，这显然不满足重写的条件，但是为什么依然能编译通过呢？ 123456public class B extends A&lt;String&gt;{ @Override String test(String s) { return null; }} 我们来看看编译之后长啥样： 123456// Compiled from \"B.java\"public class com.test.entity.B extends com.test.entity.A&lt;java.lang.String&gt; { public com.test.entity.B(); java.lang.String test(java.lang.String); java.lang.Object test(java.lang.Object); //桥接方法，这才是真正重写的方法，但是使用时会调用上面的方法} 通过反编译进行观察，实际上是编译器帮助我们生成了一个桥接方法用于支持重写： 12345678910public class B extends A { public Object test(Object obj) { //这才是重写的桥接方法 return this.test((String) obj); //桥接方法调用我们自己写的方法 } public String test(String str) { //我们自己写的方法 return null; }} 类型擦除机制其实就是为了方便使用后面集合类（不然每次都要强制类型转换）同时为了向下兼容采取的方案。因此，泛型的使用会有一些限制： 首先，在进行类型判断时，不允许使用泛型，只能使用原始类型： 只能判断是不是原始类型，里面的具体类型是不支持的： 12Test&lt;String&gt; test = new Test&lt;&gt;();System.out.println(test instanceof Test); //在进行类型判断时，不允许使用泛型，只能使用原始类型 还有，泛型类型是不支持创建参数化类型数组的： 要用只能用原始类型： 123public static void main(String[] args) { Test[] test = new Test[10]; //同样是因为类型擦除导致的，运行时可不会去检查具体类型是什么} 只不过只是把它当做泛型类型的数组还是可以用的： 函数式接口学习了泛型，我们来介绍一下再JDK 1.8中新增的函数式接口。 函数式接口就是JDK1.8专门为我们提供好的用于Lambda表达式的接口，这些接口都可以直接使用Lambda表达式，非常方便，这里我们主要介绍一下四个主要的函数式接口： Supplier供给型函数式接口：这个接口是专门用于供给使用的，其中只有一个get方法用于获取需要的对象。 1234@FunctionalInterface //函数式接口都会打上这样一个注解public interface Supplier&lt;T&gt; { T get(); //实现此方法，实现供给功能} 比如我们要实现一个专门供给Student对象Supplier，就可以使用： 12345public class Student { public void hello(){ System.out.println(\"我是学生！\"); }} 123456//专门供给Student对象的Supplierprivate static final Supplier&lt;Student&gt; STUDENT_SUPPLIER = Student::new;public static void main(String[] args) { Student student = STUDENT_SUPPLIER.get(); student.hello();} Consumer消费型函数式接口：这个接口专门用于消费某个对象的。 123456789@FunctionalInterfacepublic interface Consumer&lt;T&gt; { void accept(T t); //这个方法就是用于消费的，没有返回值 default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) { //这个方法便于我们连续使用此消费接口 Objects.requireNonNull(after); return (T t) -&gt; { accept(t); after.accept(t); }; }} 使用起来也是很简单的： 123456//专门消费Student对象的Consumerprivate static final Consumer&lt;Student&gt; STUDENT_CONSUMER = student -&gt; System.out.println(student+\" 真好吃！\");public static void main(String[] args) { Student student = new Student(); STUDENT_CONSUMER.accept(student);} 当然，我们也可以使用andThen方法继续调用： 1234567public static void main(String[] args) { Student student = new Student(); STUDENT_CONSUMER //我们可以提前将消费之后的操作以同样的方式预定好 .andThen(stu -&gt; System.out.println(\"我是吃完之后的操作！\")) .andThen(stu -&gt; System.out.println(\"好了好了，吃饱了！\")) .accept(student); //预定好之后，再执行} 这样，就可以在消费之后进行一些其他的处理了，使用很简洁的代码就可以实现： Function函数型函数式接口：这个接口消费一个对象，然后会向外供给一个对象（前两个的融合体） 123456789101112131415161718@FunctionalInterfacepublic interface Function&lt;T, R&gt; { R apply(T t); //这里一共有两个类型参数，其中一个是接受的参数类型，还有一个是返回的结果类型 default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) { Objects.requireNonNull(before); return (V v) -&gt; apply(before.apply(v)); } default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) { Objects.requireNonNull(after); return (T t) -&gt; after.apply(apply(t)); } static &lt;T&gt; Function&lt;T, T&gt; identity() { return t -&gt; t; }} 这个接口方法有点多，我们一个一个来看，首先还是最基本的apply方法，这个是我们需要实现的： 123456//这里实现了一个简单的功能，将传入的int参数转换为字符串的形式private static final Function&lt;Integer, String&gt; INTEGER_STRING_FUNCTION = Object::toString;public static void main(String[] args) { String str = INTEGER_STRING_FUNCTION.apply(10); System.out.println(str);} 我们可以使用compose将指定函数式的结果作为当前函数式的实参： 123456public static void main(String[] args) { String str = INTEGER_STRING_FUNCTION .compose((String s) -&gt; s.length()) //将此函数式的返回值作为当前实现的实参 .apply(\"lbwnb\"); //传入上面函数式需要的参数 System.out.println(str);} 相反的，andThen可以将当前实现的返回值进行进一步的处理，得到其他类型的值： 123456public static void main(String[] args) { Boolean str = INTEGER_STRING_FUNCTION .andThen(String::isEmpty) //在执行完后，返回值作为参数执行andThen内的函数式，最后得到的结果就是最终的结果了 .apply(10); System.out.println(str);} 比较有趣的是，Function中还提供了一个将传入参数原样返回的实现： 1234public static void main(String[] args) { Function&lt;String, String&gt; function = Function.identity(); //原样返回 System.out.println(function.apply(\"不会吧不会吧，不会有人听到现在还是懵逼的吧\"));} Predicate断言型函数式接口：接收一个参数，然后进行自定义判断并返回一个boolean结果。 123456789101112131415161718192021222324@FunctionalInterfacepublic interface Predicate&lt;T&gt; { boolean test(T t); //这个方法就是我们要实现的 default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) { Objects.requireNonNull(other); return (t) -&gt; test(t) &amp;&amp; other.test(t); } default Predicate&lt;T&gt; negate() { return (t) -&gt; !test(t); } default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) { Objects.requireNonNull(other); return (t) -&gt; test(t) || other.test(t); } static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) { return (null == targetRef) ? Objects::isNull : object -&gt; targetRef.equals(object); }} 我们可以来编写一个简单的例子： 123public class Student { public int score;} 12345678910private static final Predicate&lt;Student&gt; STUDENT_PREDICATE = student -&gt; student.score &gt;= 60;public static void main(String[] args) { Student student = new Student(); student.score = 80; if(STUDENT_PREDICATE.test(student)) { //test方法的返回值是一个boolean结果 System.out.println(\"及格了，真不错，今晚奖励自己一次\"); } else { System.out.println(\"不是，Java都考不及格？隔壁初中生都在打ACM了\"); }} 我们也可以使用组合条件判断： 12345678public static void main(String[] args) { Student student = new Student(); student.score = 80; boolean b = STUDENT_PREDICATE .and(stu -&gt; stu.score &gt; 90) //需要同时满足这里的条件，才能返回true .test(student); if(!b) System.out.println(\"Java到现在都没考到90分？你的室友都拿国家奖学金了\");} 同样的，这个类型提供了一个对应的实现，用于判断两个对象是否相等： 1234public static void main(String[] args) { Predicate&lt;String&gt; predicate = Predicate.isEqual(\"Hello World\"); //这里传入的对象会和之后的进行比较 System.out.println(predicate.test(\"Hello World\"));} 通过使用这四个核心的函数式接口，我们就可以使得代码更加简洁，具体的使用场景会在后面讲解。 判空包装Java8还新增了一个非常重要的判空包装类Optional，这个类可以很有效的处理空指针问题。 比如对于下面这样一个很简单的方法： 12345private static void test(String str){ //传入字符串，如果不是空串，那么就打印长度 if(!str.isEmpty()) { System.out.println(\"字符串长度为：\"+str.length()); }} 但是如果我们在传入参数时，丢个null进去，直接原地爆炸： 123456789public static void main(String[] args) { test(null);}private static void test(String str){ if(!str.isEmpty()) { //此时传入的值为null，调用方法马上得到空指针异常 System.out.println(\"字符串长度为：\"+str.length()); }} 因此我们还需要在使用之前进行判空操作： 123456private static void test(String str){ if(str == null) return; //这样就可以防止null导致的异常了 if(!str.isEmpty()) { System.out.println(\"字符串长度为：\"+str.length()); }} 虽然这种方式很好，但是在Java8之后，有了Optional类，它可以更加优雅地处理这种问题，我们来看看如何使用： 123456private static void test(String str){ Optional .ofNullable(str) //将传入的对象包装进Optional中 .ifPresent(s -&gt; System.out.println(\"字符串长度为：\"+s.length())); //如果不为空，则执行这里的Consumer实现} 优雅，真是太优雅了，同样的功能，现在我们只需要两行就搞定了，而且代码相当简洁。如果你学习过JavaScript或是Kotlin等语言，它的语法就像是： 12var str : String? = nullstr?.upperCase() 并且，包装之后，我们再获取时可以优雅地处理为空的情况： 1234private static void test(String str){ String s = Optional.ofNullable(str).get(); //get方法可以获取被包装的对象引用，但是如果为空的话，会抛出异常 System.out.println(s);} 我们可以对于这种有可能为空的情况进行处理，如果为空，那么就返回另一个备选方案： 1234private static void test(String str){ String s = Optional.ofNullable(str).orElse(\"我是为null的情况备选方案\"); System.out.println(s);} 是不是感觉很方便？我们还可以将包装的类型直接转换为另一种类型： 1234567private static void test(String str){ Integer i = Optional .ofNullable(str) .map(String::length) //使用map来进行映射，将当前类型转换为其他类型，或者是进行处理 .orElse(-1); System.out.println(i);} 当然，Optional的方法比较多，这里就不一一介绍了。 数据结构基础注意：本部分内容难度很大，推荐计算机专业课程《数据结构与算法》作为前置学习课程。本部分介绍数据结构只是为了为后面的集合类型做准备。 学习集合类之前，我们还有最关键的内容需要学习，同第二章一样，自底向上才是最佳的学习方向，比起直接带大家认识集合类，不如先了解一下数据结构，只有了解了数据结构基础，才能更好地学习集合类，同时，数据结构也是你以后深入学习JDK源码的必备条件（学习不要快餐式）当然，我们主要是讲解Java，数据结构作为铺垫作用，所以我们只会讲解关键的部分，其他部分可以在数据结构与算法篇视频教程中详细学习。 在计算机科学中，数据结构是一种数据组织、管理和存储的格式,它可以帮助我们实现对数据高效的访问和修改。更准确地说,数据结构是数据值的集合，可以体现数据值之间的关系，以及可以对数据进行应用的函数或操作。 通俗地说，我们需要去学习在计算机中如何去更好地管理我们的数据，才能让我们对我们的数据控制更加灵活！ 比如现在我们需要保存100个学生的数据，那么你首先想到的肯定是使用数组吧！没错，没有什么比数组更适合存放这100个学生的数据了，但是如果我们现在有了新的需求呢？我们不仅仅是存放这些数据，我们还希望能够将这些数据按顺序存放，支持在某个位置插入一条数据、删除一条数据、修改一条数据等，这时候，数组就显得有些乏力了。 数组无法做到这么高级的功能，那么我们就需要定义一种更加高级的数据结构来做到，我们可以使用线性表（Linear List） 线性表是由同一类型的数据元素构成的有序序列的线性结构。线性表中元素的个数就是线性表的长度，表的起始位置称为表头，表的结束位置称为表尾，当一个线性表中没有元素时，称为空表。 线性表一般需要包含以下功能： 获取指定位置上的元素：直接获取线性表指定位置i上的元素。 插入元素：在指定位置i上插入一个元素。 删除元素：删除指定位置i上的一个元素。 获取长度：返回线性表的长度。 也就是说，现在我们需要设计的是一种功能完善的表结构，它不像是数组那么低级，而是真正意义上的表： 简单来说它就是列表，比如我们的菜单，我们在点菜时就需要往菜单列表中添加菜品或是删除菜品，这时列表就很有用了，因为数组长度固定、操作简单，而我们添加菜品、删除菜品这些操作又要求长度动态变化、操作多样。 那么，如此高级的数据结构，我们该如何去实现呢？实现线性表的结构一般有两种，一种是顺序存储实现，还有一种是链式存储实现，我们先来看第一种，也是最简单的的一种。 线性表：顺序表前面我们说到，既然数组无法实现这样的高级表结构，那么我就基于数组，对其进行强化，也就是说，我们存放数据还是使用数组，但是我们可以为其编写一些额外的操作来强化为线性表，像这样底层依然采用顺序存储实现的线性表，我们称为顺序表。 这里我们可以先定义一个新的类型： 12345public class ArrayList&lt;E&gt; { //泛型E，因为表中要存的具体数据类型待定 int capacity = 10; //当前顺序表的容量 int size = 0; //当前已经存放的元素数量 private Object[] array = new Object[capacity]; //底层存放数据的数组} 顺序表的插入和删除操作，其实就是： 当插入元素时，需要将插入位置给腾出来，也就是将后面的所有元素向后移，同样的，如果要删除元素，那么也需要将所有的元素向前移动，顺序表是紧凑的，不能出现空位。 所以说我们可以来尝试实现一下，首先是插入方法： 123456public void add(E element, int index){ //插入方法需要支持在指定下标位置插入 for (int i = size; i &gt; index; i--) //从后往前，一个一个搬运元素 array[i] = array[i - 1]; array[index] = element; //腾出位置之后，直接插入元素放到对应位置上 size++; //插入完成之后，记得将size自增} 只不过这样并不完美，因为我们的插入操作并不是在任何位置都支持插入的，我们允许插入的位置只能是 [0, size] 这个范围内 所以说我们需要在插入之前进行判断： 12345678public void add(E element, int index){ if(index &lt; 0 || index &gt; size) //插入之前先判断插入位置是否合法 throw new IndexOutOfBoundsException(\"插入位置非法，合法的插入位置为：0 ~ \"+size); for (int i = size; i &gt; index; i--) array[i] = array[i - 1]; array[index] = element; size++;} 我们来测试一下吧： 1234public static void main(String[] args) { ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(10, 1); //一上来只能在第一个位置插入，第二个位置肯定是非法的} 于是就成功得到异常： 只不过依然不够完美，万一我们的顺序表装满了咋办？所以说，我们在插入元素之前，需要进行判断，如果已经装满了，那么我们需要先扩容之后才能继续插入新的元素： 123456789101112131415public void add(E element, int index){ if(index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException(\"插入位置非法，合法的插入位置为：0 ~ \"+size); if(capacity == size) { int newCapacity = capacity + (capacity &gt;&gt; 1); //扩容规则就按照原本容量的1.5倍来吧 Object[] newArray = new Object[newCapacity]; //创建一个新的数组来存放更多的元素 System.arraycopy(array, 0, newArray, 0, size); //使用arraycopy快速拷贝原数组内容到新的数组 array = newArray; //更换为新的数组 capacity = newCapacity; //容量变成扩容之后的 } for (int i = size; i &gt; index; i--) array[i] = array[i - 1]; array[index] = element; size++;} 我们来重写一下toString方法打印当前存放的元素： 12345public String toString() { StringBuilder builder = new StringBuilder(); for (int i = 0; i &lt; size; i++) builder.append(array[i]).append(\" \"); return builder.toString();} 可以看到，我们的底层数组会自动扩容，便于我们使用： 123456public static void main(String[] args) { ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 20; i++) list.add(i, i); System.out.println(list);} 我们接着来看删除操作，其实操作差不多，只需要将后面的覆盖到前面就可以了： 12345678@SuppressWarnings(\"unchecked\") //屏蔽未经检查警告public E remove(int index){ //删除对应位置上的元素，注意需要返回被删除的元素 E e = (E) array[index]; //因为存放的是Object类型，这里需要强制类型转换为E for (int i = index; i &lt; size; i++) //从前往后，挨个往前搬一位 array[i] = array[i + 1]; size--; //删完记得将size-- return e;} 同样的，我们需要对删除的合法范围进行判断： 所以说我们也来进行一下判断： 12345678910@SuppressWarnings(\"unchecked\")public E remove(int index){ if(index &lt; 0 || index &gt; size - 1) throw new IndexOutOfBoundsException(\"删除位置非法，合法的插入位置为：0 ~ \"+(size - 1)); E e = (E) array[index]; for (int i = index; i &lt; size; i++) array[i] = array[i + 1]; size--; return e;} 因为删除不需要考虑容量的问题，所以说这里的删除操作就编写完成了。 当然，我们还得支持获取指定下标位置上的元素，这个就简单了，直接从数组中那就行了： 12345678910@SuppressWarnings(\"unchecked\")public E get(int index){ if(index &lt; 0 || index &gt; size - 1) //在插入之前同样要进行范围检查 throw new IndexOutOfBoundsException(\"非法的位置，合法的位置为：0 ~ \"+(size - 1)); return (E) array[index]; //直接返回就完事}public int size(){ //获取当前存放的元素数量 return size;} 是不是感觉顺便表其实还是挺简单的，也就是一个数组多了一些操作罢了。 线性表：链表前面我们介绍了如何使用数组实现线性表，我们接着来看第二种方式，我们可以使用链表来实现，那么什么是链表呢？ 链表不同于顺序表，顺序表底层采用数组作为存储容器，需要分配一块连续且完整的内存空间进行使用，而链表则不需要，它通过一个指针来连接各个分散的结点，形成了一个链状的结构，每个结点存放一个元素，以及一个指向下一个结点的指针，通过这样一个一个相连，最后形成了链表。它不需要申请连续的空间，只需要按照顺序连接即可，虽然物理上可能不相邻，但是在逻辑上依然是每个元素相邻存放的，这样的结构叫做链表（单链表）。 链表分为带头结点的链表和不带头结点的链表，戴头结点的链表就是会有一个头结点指向后续的整个链表，但是头结点不存放数据： 而不带头结点的链表就像上面那样，第一个节点就是存放数据的结点，一般设计链表都会采用带头结点的结构，因为操作更加方便。 我们来尝试定义一下： 1234567891011121314public class LinkedList&lt;E&gt; { //链表的头结点，用于连接之后的所有结点 private final Node&lt;E&gt; head = new Node&lt;&gt;(null); private int size = 0; //当前的元素数量还是要存一下，方便后面操作 private static class Node&lt;E&gt; { //结点类，仅供内部使用 E element; //每个结点都存放元素 Node&lt;E&gt; next; //以及指向下一个结点的引用 public Node(E element) { this.element = element; } }} 接着我们来设计一下链表的插入和删除，我们前面实现了顺序表的插入，那么链表的插入该怎么做呢？ 我们可以先修改新插入的结点的后继结点（也就是下一个结点）指向，指向原本在这个位置的结点： 接着我们可以将前驱结点（也就是上一个结点）的后继结点指向修改为我们新插入的结点： 这样，我们就成功插入了一个新的结点，现在新插入的结点到达了原本的第二个位置上： 按照这个思路，我们来实现一下，首先设计一下方法： 123456789public void add(E element, int index){ Node&lt;E&gt; prev = head; //先找到对应位置的前驱结点 for (int i = 0; i &lt; index; i++) prev = prev.next; Node&lt;E&gt; node = new Node&lt;&gt;(element); //创建新的结点 node.next = prev.next; //先让新的节点指向原本在这个位置上的结点 prev.next = node; //然后让前驱结点指向当前结点 size++; //完事之后一样的，更新size} 我们来重写一下toString方法看看能否正常插入： 12345678910@Overridepublic String toString() { StringBuilder builder = new StringBuilder(); Node&lt;E&gt; node = head.next; //从第一个结点开始，一个一个遍历，遍历一个就拼接到字符串上去 while (node != null) { builder.append(node.element).append(\" \"); node = node.next; } return builder.toString();} 可以看到我们的插入操作是可以正常工作的： 1234567public static void main(String[] args) { LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); list.add(10, 0); list.add(30, 0); list.add(20, 1); System.out.println(list);} 只不过还不够完美，跟之前一样，我们还得考虑插入位置是否合法： 1234567891011public void add(E element, int index){ if(index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException(\"插入位置非法，合法的插入位置为：0 ~ \"+size); Node&lt;E&gt; prev = head; for (int i = 0; i &lt; index; i++) prev = prev.next; Node&lt;E&gt; node = new Node&lt;&gt;(element); node.next = prev.next; prev.next = node; size++;} 插入操作完成之后，我们接着来看删除操作，那么我们如何实现删除操作呢？实际上也会更简单一些，我们可以直接将待删除节点的前驱结点指向修改为待删除节点的下一个： 这样，在逻辑上来说，待删除结点其实已经不在链表中了，所以我们只需要释放掉待删除结点占用的内存空间就行了： 那么我们就按照这个思路来编写一下程序： 1234567891011public E remove(int index){ if(index &lt; 0 || index &gt; size - 1) //同样的，先判断位置是否合法 throw new IndexOutOfBoundsException(\"删除位置非法，合法的删除位置为：0 ~ \"+(size - 1)); Node&lt;E&gt; prev = head; for (int i = 0; i &lt; index; i++) //同样需要先找到前驱结点 prev = prev.next; E e = prev.next.element; //先把待删除结点存放的元素取出来 prev.next = prev.next.next; //可以删了 size--; //记得size-- return e;} 是不是感觉还是挺简单的？这样，我们就成功完成了链表的删除操作。 我们接着来实现一下获取对应位置上的元素： 123456789101112public E get(int index){ if(index &lt; 0 || index &gt; size - 1) throw new IndexOutOfBoundsException(\"非法的位置，合法的位置为：0 ~ \"+(size - 1)); Node&lt;E&gt; node = head; while (index-- &gt;= 0) //这里直接让index减到-1为止 node = node.next; return node.element;}public int size(){ return size;} 这样，我们的链表就编写完成了，实际上只要理解了那种结构，其实还是挺简单的。 问题：什么情况下使用顺序表，什么情况下使用链表呢？ 通过分析顺序表和链表的特性我们不难发现，链表在随机访问元素时，需要通过遍历来完成，而顺序表则利用数组的特性直接访问得到，所以，当我们读取数据多于插入或是删除数据的情况下时，使用顺序表会更好。 而顺序表在插入元素时就显得有些鸡肋了，因为需要移动后续元素，整个移动操作会浪费时间，而链表则不需要，只需要修改结点 指向即可完成插入，所以在频繁出现插入或删除的情况下，使用链表会更好。 虽然单链表使用起来也比较方便，不过有一个问题就是，如果我们想要操作某一个结点，比如删除或是插入，那么由于单链表的性质，我们只能先去找到它的前驱结点，才能进行。为了解决这种查找前驱结点非常麻烦的问题，我们可以让结点不仅保存指向后续结点的指针，同时也保存指向前驱结点的指针： 这样我们无论在哪个结点，都能够快速找到对应的前驱结点，就很方便了，这样的链表我们成为双向链表（双链表） 线性表：栈栈（也叫堆栈，Stack）是一种特殊的线性表，它只能在在表尾进行插入和删除操作，就像下面这样： 也就是说，我们只能在一端进行插入和删除，当我们依次插入1、2、3、4这四个元素后，连续进行四次删除操作，删除的顺序刚好相反：4、3、2、1，我们一般将其竖着看： 底部称为栈底，顶部称为栈顶，所有的操作只能在栈顶进行，也就是说，被压在下方的元素，只能等待其上方的元素出栈之后才能取出，就像我们往箱子里里面放的书一样，因为只有一个口取出里面的物品，所以被压在下面的书只能等上面的书被拿出来之后才能取出，这就是栈的思想，它是一种先进后出的数据结构（FILO，First In, Last Out） 实现栈也是非常简单的，可以基于我们前面的顺序表或是链表，这里我们需要实现两个新的操作： pop：出栈操作，从栈顶取出一个元素。 push：入栈操作，向栈中压入一个新的元素。 栈可以使用顺序表实现，也可以使用链表实现，这里我们就使用链表，实际上使用链表会更加的方便，我们可以直接将头结点指向栈顶结点，而栈顶结点连接后续的栈内结点： 当有新的元素入栈，只需要在链表头部插入新的结点即可，我们来尝试编写一下： 12345678910111213public class LinkedStack&lt;E&gt; { private final Node&lt;E&gt; head = new Node&lt;&gt;(null); //大体内容跟链表类似 private static class Node&lt;E&gt; { E element; Node&lt;E&gt; next; public Node(E element) { this.element = element; } }} 接着我们来编写一下入栈操作： 代码如下： 12345public void push(E element){ Node&lt;E&gt; node = new Node&lt;&gt;(element); //直接创建新结点 node.next = head.next; //新结点的下一个变成原本的栈顶结点 head.next = node; //头结点的下一个改成新的结点} 这样，我们就可以轻松实现入栈操作了。其实出栈也是同理，所以我们只需要将第一个元素移除即可： 1234567public E pop(){ if(head.next == null) //如果栈已经没有元素了，那么肯定是没办法取的 throw new NoSuchElementException(\"栈为空\"); E e = head.next.element; //先把待出栈元素取出来 head.next = head.next.next; //直接让头结点的下一个指向下一个的下一个 return e;} 我们来测试一下吧： 123456789public static void main(String[] args) { LinkedStack&lt;String&gt; stack = new LinkedStack&lt;&gt;(); stack.push(\"AAA\"); stack.push(\"BBB\"); stack.push(\"CCC\"); System.out.println(stack.pop()); System.out.println(stack.pop()); System.out.println(stack.pop());} 可以看到，入栈顺序和出栈顺序是完全相反的： 其实还是挺简单的。 线性表：队列前面我们学习了栈，栈中元素只能栈顶出入，它是一种特殊的线性表，同样的，队列（Queue）也是一种特殊的线性表。 就像我们在超市、食堂需要排队一样，我们总是排成一列，先到的人就排在前面，后来的人就排在后面，越前面的人越先完成任务，这就是队列，队列有队头和队尾： 秉承先来后到的原则，队列中的元素只能从队尾进入，只能从队首出去，也就是说，入队顺序为1、2、3、4，那么出队顺序也一定是1、2、3、4，所以队列是一种先进先出（FIFO，First In, First Out）的数据结构。 队列也可以使用链表和顺序表来实现，只不过使用链表的话就不需要关心容量之类的问题了，会更加灵活一些： 注意我们需要同时保存队首和队尾两个指针，因为是单链表，所以队首需要存放指向头结点的指针，因为需要的是前驱结点，而队尾则直接是指向尾结点的指针即可，后面只需要直接在后面拼接就行。 当有新的元素入队时，只需要拼在队尾就行了，同时队尾指针也要后移一位： 出队时，只需要移除队首指向的下一个元素即可： 那么我们就按照这个思路，来编写一下代码吧： 12345678910111213141516171819202122232425262728public class LinkedQueue&lt;E&gt; { private final Node&lt;E&gt; head = new Node&lt;&gt;(null); public void offer(E element){ //入队操作 Node&lt;E&gt; last = head; while (last.next != null) //入队直接丢到最后一个结点的屁股后面就行了 last = last.next; last.next = new Node&lt;&gt;(element); } public E poll(){ //出队操作 if(head.next == null) //如果队列已经没有元素了，那么肯定是没办法取的 throw new NoSuchElementException(\"队列为空\"); E e = head.next.element; head.next = head.next.next; //直接从队首取出 return e; } private static class Node&lt;E&gt; { E element; Node&lt;E&gt; next; public Node(E element) { this.element = element; } }} 其实使用起来还是挺简单的，我们来测试一下吧： 123456789public static void main(String[] args) { LinkedQueue&lt;String&gt; stack = new LinkedQueue&lt;&gt;(); stack.offer(\"AAA\"); stack.offer(\"BBB\"); stack.offer(\"CCC\"); System.out.println(stack.poll()); System.out.println(stack.poll()); System.out.println(stack.poll());} 可以看到，队列遵从先进先出，入队顺序和出队顺序是一样的。 树：二叉树树是一种全新的数据结构，它就像一棵树的树枝一样，不断延伸。 在我们的程序中，想要表示出一棵树，就可以像下面这样连接： 可以看到，现在一个结点下面可能会连接多个节点，并不断延伸，就像树枝一样，每个结点都有可能是一个分支点，延伸出多个分支，从位于最上方的结点开始不断向下，而这种数据结构，我们就称为树（Tree）注意分支只能向后单独延伸，之后就分道扬镳了，不能与其他分支上的结点相交！ 我们一般称位于最上方的结点为树的根结点（Root）因为整棵树正是从这里开始延伸出去的。 每个结点连接的子结点数目（分支的数目），我们称为结点的度（Degree），而各个结点度的最大值称为树的度。 每个结点延伸下去的下一个结点都可以称为一棵子树（SubTree）比如结点B及其之后延伸的所有分支合在一起，就是一棵A的子树。 每个结点的层次（Level）按照从上往下的顺序，树的根结点为1，每向下一层+1，比如G的层次就是3，整棵树中所有结点的最大层次，就是这颗树的深度（Depth），比如上面这棵树的深度为4，因为最大层次就是4。 由于整棵树错综复杂，所以说我们需要先规定一下结点之间的称呼，就像族谱那样： 与当前结点直接向下相连的结点，我们称为子结点（Child），比如B、C、D结点，都是A的子结点，就像族谱中的父子关系一样，下一代一定是子女，相反的，那么A就是B、C、D的父结点（Parent），也可以叫双亲结点。 如果某个节点没有任何的子结点（结点度为0时）那么我们称这个结点为叶子结点（因为已经到头了，后面没有分支了，这时就该树枝上长叶子了那样）比如K、L、F、G、M、I、J结点，都是叶子结点。 如果两个结点的父结点是同一个，那么称这两个节点为兄弟结点（Sibling）比如B和C就是兄弟结点，因为都是A的孩子。 从根结点开始一直到某个结点的整条路径的所有结点，都是这个结点的祖先结点（Ancestor）比如L的祖先结点就是A、B、E 那么在了解了树的相关称呼之后，相信各位就应该对树有了一定的了解，虽然概念比较多，但是还请各位一定记住，不然后面就容易听懵。 而我们本章需要着重讨论的是二叉树（Binary Tree）它是一种特殊的树，它的度最大只能为2，所以我们称其为二叉树，一棵二叉树大概长这样： 并且二叉树任何结点的子树是有左右之分的，不能颠倒顺序，比如A结点左边的子树，称为左子树，右边的子树称为右子树。 当然，对于某些二叉树我们有特别的称呼，比如，在一棵二叉树中，所有分支结点都存在左子树和右子树，且叶子结点都在同一层： 这样的二叉树我们称为满二叉树，可以看到整棵树都是很饱满的，没有出现任何度为1的结点，当然，还有一种特殊情况： 可以看到只有最后一层有空缺，并且所有的叶子结点是按照从左往右的顺序排列的，这样的二叉树我们一般称其为完全二叉树，所以，一棵满二叉树，一定是一棵完全二叉树。 我们接着来看看二叉树在程序中的表示形式，我们在前面使用链表的时候，每个结点不仅存放对应的数据，而且会存放一个指向下一个结点的引用： 而二叉树也可以使用这样的链式存储形式，只不过现在一个结点需要存放一个指向左子树的引用和一个指向右子树的引用了： 通过这种方式，我们就可以通过连接不同的结点形成一颗二叉树了，这样也更便于我们去理解它，我们首先定义一个类： 12345678public class TreeNode&lt;E&gt; { public E element; public TreeNode&lt;E&gt; left, right; public TreeNode(E element){ this.element = element; }} 比如我们现在想要构建一颗像这样的二叉树： 首先我们需要创建好这几个结点： 12345678public static void main(String[] args) { TreeNode&lt;Character&gt; a = new TreeNode&lt;&gt;('A'); TreeNode&lt;Character&gt; b = new TreeNode&lt;&gt;('B'); TreeNode&lt;Character&gt; c = new TreeNode&lt;&gt;('C'); TreeNode&lt;Character&gt; d = new TreeNode&lt;&gt;('D'); TreeNode&lt;Character&gt; e = new TreeNode&lt;&gt;('E'); } 接着我们从最上面开始，挨着进行连接，首先是A这个结点： 1234567public static void main(String[] args) { ... a.left = b; a.right = c; b.left = d; b.right = e;} 这样的话，我们就成功构建好了这棵二叉树，比如现在我们想通过根结点访问到D： 1System.out.println(a.left.left.element); 断点调试也可以看的很清楚： 这样，我们就通过使用链式结构，成功构建出了一棵二叉树。 接着我们来看看如何遍历一棵二叉树，也就是说我们想要访问二叉树的每一个结点，由于树形结构特殊，遍历顺序并不唯一，所以一共有四种访问方式：前序遍历、中序遍历、后序遍历、层序遍历。不同的访问方式输出都结点顺序也不同。 首先我们来看最简单的前序遍历： 前序遍历是一种勇往直前的态度，走到哪就遍历到那里，先走左边再走右边，比如上面的这个图，首先会从根节点开始： 从A开始，先左后右，那么下一个就是B，然后继续走左边，是D，现在ABD走完之后，B的左边结束了，那么就要开始B的右边了，所以下一个是E，E结束之后，现在A的左子树已经全部遍历完成了，然后就是右边，接着就是C，C没有左子树了，那么只能走右边了，最后输出F，所以上面这个二叉树的前序遍历结果为：ABDECF 打印根节点 前序遍历左子树 前序遍历右子树 我们不难发现规律，整棵二叉树（包括子树）的根节点一定是出现在最前面的，比如A在最前面，A的左子树根结点B也是在最前面的。我们现在就来尝试编写一下代码实现一下，先把二叉树构建出来： 12345678910111213public static void main(String[] args) { TreeNode&lt;Character&gt; a = new TreeNode&lt;&gt;('A'); TreeNode&lt;Character&gt; b = new TreeNode&lt;&gt;('B'); TreeNode&lt;Character&gt; c = new TreeNode&lt;&gt;('C'); TreeNode&lt;Character&gt; d = new TreeNode&lt;&gt;('D'); TreeNode&lt;Character&gt; e = new TreeNode&lt;&gt;('E'); TreeNode&lt;Character&gt; f = new TreeNode&lt;&gt;('F'); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f;} 组装好之后，我们来实现一下前序遍历的方法： 123private static &lt;T&gt; void preOrder(TreeNode&lt;T&gt; root){ System.out.print(root.element + \" \"); //首先肯定要打印，这个是必须的} 打印完成之后，我们就按照先左后右的规则往后遍历下一个结点，这里我们就直接使用递归来完成： 12345private static &lt;T&gt; void preOrder(TreeNode&lt;T&gt; root){ System.out.print(root.element + \" \"); preOrder(root.left); //先走左边 preOrder(root.right); //再走右边} 不过还没完，我们的递归肯定是需要一个终止条件的，不可能无限地进行下去，如果已经走到底了，那么就不能再往下走了，所以： 123456private static &lt;T&gt; void preOrder(TreeNode&lt;T&gt; root){ if(root == null) return; System.out.print(root.element); preOrder(root.left); preOrder(root.right);} 最后我们来测试一下吧： 1234public static void main(String[] args) { ... preOrder(a);} 可以看到结果为： 这样我们就通过一个简单的递归操作完成了对一棵二叉树的前序遍历，如果不太好理解，建议结合调试进行观察。 那么前序遍历我们了解完了，接着就是中序遍历了，中序遍历在顺序上与前序遍历不同，前序遍历是走到哪就打印到哪，而中序遍历需要先完成整个左子树的遍历后再打印，然后再遍历其右子树。 我们还是以上面的二叉树为例： 首先需要先不断遍历左子树，走到最底部，但是沿途并不进行打印，而是到底之后，再打印，所以第一个打印的是D，接着由于没有右子树，所以我们回到B，此时再打印B，然后再去看B的右结点E，由于没有左子树和右子树了，所以直接打印E，左边遍历完成，接着回到A，打印A，然后对A的右子树重复上述操作。所以说遍历的基本规则还是一样的，只是打印值的时机发生了改变。 中序遍历左子树 打印结点 中序遍历右子树 所以这棵二叉树的中序遍历结果为：DBEACF，我们可以发现一个规律，就是在某个结点的左子树中所有结点，其中序遍历结果也是按照这样的规律排列的，比如A的左子树中所有结点，中序遍历结果中全部都在A的左边，右子树中所有的结点，全部都在A的右边（这个规律很关键，后面在做一些算法题时会用到） 那么怎么才能将打印调整到左子树全部遍历结束之后呢？其实很简单： 123456private static &lt;T&gt; void inOrder(TreeNode&lt;T&gt; root){ if(root == null) return; inOrder(root.left); //先完成全部左子树的遍历 System.out.print(root.element); //等待左子树遍历完成之后再打印 inOrder(root.right); //然后就是对右子树进行遍历} 我们只需要将打印放到左子树遍历之后即可，这样打印出来的结果就是中序遍历的结果了： 这样，我们就实现了二叉树的中序遍历，实际上还是很好理解的。 接着我们来看一下后序遍历，后序遍历继续将打印的时机延后，需要等待左右子树全部遍历完成，才会去进行打印。 首先还是一路向左，到达结点D，此时结点D没有左子树了，接着看结点D还有没有右子树，发现也没有，左右子树全部遍历完成，那么此时再打印D，同样的，D完事之后就回到B了，此时接着看B的右子树，发现有结点E，重复上述操作，E也打印出来了，接着B的左右子树全部OK，那么再打印B，接着A的左子树就完事了，现在回到A，看到A的右子树，继续重复上述步骤，当A的右子树也遍历结束后，最后再打印A结点。 后序遍历左子树 后序遍历右子树 打印结点 所以最后的遍历顺序为：DEBFCA，不难发现，整棵二叉树（包括子树）根结点一定是在后面的，比如A在所有的结点的后面，B在其子节点D、E的后面，这一点恰恰和前序遍历相反（注意不是得到的结果相反，是规律相反） 所以，按照这个思路，我们来编写一下后序遍历： 123456private static &lt;T&gt; void postOrder(TreeNode&lt;T&gt; root){ if(root == null) return; postOrder(root.left); postOrder(root.right); System.out.print(root.element); //时机延迟到最后} 结果如下： 最后我们来看层序遍历，实际上这种遍历方式是我们人脑最容易理解的，它是按照每一层在进行遍历： 层序遍历实际上就是按照从上往下每一层，从左到右的顺序打印每个结点，比如上面的这棵二叉树，那么层序遍历的结果就是：ABCDEF，像这样一层一层的挨个输出。 虽然理解起来比较简单，但是如果让你编程写出来，该咋搞？是不是感觉有点无从下手？ 我们可以利用队列来实现层序遍历，首先将根结点存入队列中，接着循环执行以下步骤： 进行出队操作，得到一个结点，并打印结点的值。 将此结点的左右孩子结点依次入队。 不断重复以上步骤，直到队列为空。 我们来分析一下，首先肯定一开始A在里面： 接着开始不断重复上面的步骤，首先是将队首元素出队，打印A，然后将A的左右孩子依次入队： 现在队列中有B、C两个结点，继续重复上述操作，B先出队，打印B，然后将B的左右孩子依次入队： 现在队列中有C、D、E这三个结点，继续重复，C出队并打印，然后将F入队： 我们发现，这个过程中，打印的顺序正好就是我们层序遍历的顺序，所以说队列还是非常有用的，这里我们可以直接把之前的队列拿来用。那么现在我们就来上代码吧，首先是之前的队列： 1234567891011121314151617181920212223242526272829303132public class LinkedQueue&lt;E&gt; { private final Node&lt;E&gt; head = new Node&lt;&gt;(null); public void offer(E element){ Node&lt;E&gt; last = head; while (last.next != null) last = last.next; last.next = new Node&lt;&gt;(element); } public E poll(){ if(head.next == null) throw new NoSuchElementException(\"队列为空\"); E e = head.next.element; head.next = head.next.next; return e; } public boolean isEmpty(){ //这里多写了一个判断队列为空的操作，方便之后使用 return head.next == null; //直接看头结点后面还有没有东西就行了 } private static class Node&lt;E&gt; { E element; Node&lt;E&gt; next; public Node(E element) { this.element = element; } }} 我们来尝试编写一下层序遍历： 12345678910private static &lt;T&gt; void levelOrder(TreeNode&lt;T&gt; root){ LinkedQueue&lt;TreeNode&lt;T&gt;&gt; queue = new LinkedQueue&lt;&gt;(); //创建一个队列 queue.offer(root); //将根结点丢进队列 while (!queue.isEmpty()) { //如果队列不为空，就一直不断地取出来 TreeNode&lt;T&gt; node = queue.poll(); //取一个出来 System.out.print(node.element); //打印 if(node.left != null) queue.offer(node.left); //如果左右孩子不为空，直接将左右孩子丢进队列 if(node.right != null) queue.offer(node.right); }} 可以看到结果就是层序遍历的结果： 当然，使用递归也可以实现，但是需要单独存放结果然后单独输出，不是很方便，所以说这里就不演示了。 树：二叉查找树和平衡二叉树注意：本部分只进行理论介绍，不做代码实现。 还记得我们开篇讲到的二分搜索算法吗？通过不断缩小查找范围，最终我们可以以很高的效率找到有序数组中的目标位置。而二叉查找树则利用了类似的思想，我们可以借助其来像二分搜索那样快速查找。 二叉查找树也叫二叉搜索树或是二叉排序树，它具有一定的规则： 左子树中所有结点的值，均小于其根结点的值。 右子树中所有结点的值，均大于其根结点的值。 二叉搜索树的子树也是二叉搜索树。 一棵二叉搜索树长这样： 这棵树的根结点为18，而其根结点左边子树的根结点为10，包括后续结点，都是满足上述要求的。二叉查找树满足左边一定比当前结点小，右边一定比当前结点大的规则，比如我们现在需要在这颗树种查找值为15的结点： 从根结点18开始，因为15小于18，所以从左边开始找。 接着来到10，发现10比15小，所以继续往右边走。 来到15，成功找到。 实际上，我们在对普通二叉树进行搜索时，可能需要挨个进行查看比较，而有了二叉搜索树，查找效率就大大提升了，它就像我们前面的二分搜索那样。 利用二叉查找树，我们在搜索某个值的时候，效率会得到巨大提升。但是虽然看起来比较完美，也是存在缺陷的，比如现在我们依次将下面的值插入到这棵二叉树中： 120 15 13 8 6 3 在插入完成后，我们会发现这棵二叉树竟然长这样： 因为根据我们之前编写的插入规则，小的一律往左边放，现在正好来的就是这样一串递减的数字，最后就组成了这样的一棵只有一边的二叉树，这种情况，与其说它是一棵二叉树，不如说就是一个链表，如果这时我们想要查找某个结点，那么实际上查找的时间并没有得到任何优化，直接就退化成线性查找了。 所以，二叉查找树只有在理想情况下，查找效率才是最高的，而像这种极端情况，就性能而言几乎没有任何的提升。我们理想情况下，这样的效率是最高的： 所以，我们在进行结点插入时，需要尽可能地避免这种一边倒的情况，这里就需要引入平衡二叉树的概念了。实际上我们发现，在插入时如果不去维护二叉树的平衡，某一边只会无限制地延伸下去，出现极度不平衡的情况，而我们理想中的二叉查找树左右是尽可能保持平衡的，平衡二叉树（AVL树）就是为了解决这样的问题而生的。 它的性质如下： 平衡二叉树一定是一棵二叉查找树。 任意结点的左右子树也是一棵平衡二叉树。 从根节点开始，左右子树都高度差不能超过1，否则视为不平衡。 可以看到，这些性质规定了平衡二叉树需要保持高度平衡，这样我们的查找效率才不会因为数据的插入而出现降低的情况。二叉树上节点的左子树高度 减去 右子树高度， 得到的结果称为该节点的平衡因子（Balance Factor），比如： 通过计算平衡因子，我们就可以快速得到是否出现失衡的情况。比如下面的这棵二叉树，正在执行插入操作： 可以看到，当插入之后，不再满足平衡二叉树的定义时，就出现了失衡的情况，而对于这种失衡情况，为了继续保持平衡状态，我们就需要进行处理了。我们可能会遇到以下几种情况导致失衡： 根据插入结点的不同偏向情况，分为LL型、LR型、RR型、RL型。针对于上面这几种情况，我们依次来看一下如何进行调整，使得这棵二叉树能够继续保持平衡： 动画网站：https://www.cs.usfca.edu/~galles/visualization/AVLtree.html（实在不理解可以看看动画是怎么走的） LL型调整（右旋） 首先我们来看这种情况，这是典型的LL型失衡，为了能够保证二叉树的平衡，我们需要将其进行旋转来维持平衡，去纠正最小不平衡子树即可。那么怎么进行旋转呢？对于LL型失衡，我们只需要进行右旋操作，首先我们先找到最小不平衡子树，注意是最小的那一个： 可以看到根结点的平衡因子是2，是目前最小的出现不平衡的点，所以说从根结点开始向左的三个结点需要进行右旋操作，右旋需要将这三个结点中间的结点作为新的根结点，而其他两个结点现在变成左右子树： 这样，我们就完成了右旋操作，可以看到右旋之后，所有的结点继续保持平衡，并且依然是一棵二叉查找树。 RR型调整（左旋） 前面我们介绍了LL型以及右旋解决方案，相反的，当遇到RR型时，我们只需要进行左旋操作即可： 操作和上面是一样的，只不过现在反过来了而已： 这样，我们就完成了左旋操作，使得这棵二叉树继续保持平衡状态了。 RL型调整（先右旋，再左旋） 剩下两种类型比较麻烦，需要旋转两次才行。我们来看看RL型长啥样： 可以看到现在的形状是一个回旋镖形状的，先右后左的一个状态，也就是RL型，针对于这种情况，我们需要先进行右旋操作，注意这里的右旋操作针对的是后两个结点： 其中右旋和左旋的操作，与之前一样，该怎么分配左右子树就怎么分配，完成两次旋转后，可以看到二叉树重新变回了平衡状态。 LR型调整（先左旋，再右旋） 和上面一样，我们来看看LR型长啥样，其实就是反着的： 形状是先向左再向右，这就是典型的LR型了，我们同样需要对其进行两次旋转： 这里我们先进行的是左旋，然后再进行的右旋，这样二叉树就能继续保持平衡了。 这样，我们只需要在插入结点时注意维护整棵树的平衡因子，保证其处于稳定状态，这样就可以让这棵树一直处于高度平衡的状态，不会再退化了。 树：红黑树注意：本部分只进行理论介绍，不做代码实现。 很多人都说红黑树难，其实就那几条规则，跟着我推一遍其实还是很简单的，当然前提是一定要把前面的平衡二叉树搞明白。 前面我们讲解了二叉平衡树，通过在插入结点时维护树的平衡，这样就不会出现极端情况使得整棵树的查找效率急剧降低了。但是这样是否开销太大了一点，因为一旦平衡因子的绝对值超过1那么就失衡，这样每插入一个结点，就有很大的概率会导致失衡，我们能否不这么严格，但同时也要在一定程度上保证平衡呢？这就要提到红黑树了。 在线动画网站：https://www.cs.usfca.edu/~galles/visualization/RedBlack.html 红黑树也是二叉查找树的一种，它大概长这样，可以看到结点有红有黑： 它并不像平衡二叉树那样严格要求高度差不能超过1，而是只需要满足五个规则即可，它的规则如下： 规则1：每个结点可以是黑色或是红色。 规则2：根结点一定是黑色。 规则3：红色结点的父结点和子结点不能为红色，也就是说不能有两个连续的红色。 规则4：所有的空结点都是黑色（空结点视为NIL，红黑树中是将空节点视为叶子结点） 规则5：每个结点到空节点（NIL）路径上出现的黑色结点的个数都相等。 它相比平衡二叉树，通过不严格平衡和改变颜色，就能在一定程度上减少旋转次数，这样的话对于整体性能是有一定提升的，只不过我们在插入结点时，就有点麻烦了，我们需要同时考虑变色和旋转这两个操作了，但是会比平衡二叉树更简单。 那么什么时候需要变色，什么时候需要旋转呢？我们通过一个简单例子来看看： 首先这棵红黑树只有一个根结点，因为根结点必须是黑色，所以说直接变成黑色。现在我们要插入一个新的结点了，所有新插入的结点，默认情况下都是红色： 所以新来的结点7根据规则就直接放到11的左边就行了，然后注意7的左右两边都是NULL，那么默认都是黑色，这里就不画出来了。同样的，我们往右边也来一个： 现在我们继续插入一个结点： 插入结点4之后，此时违反了红黑树的规则3，因为红色结点的父结点和子结点不能为红色，此时为了保持以红黑树的性质，我们就需要进行颜色变换才可以，那么怎么进行颜色变换呢？我们只需要直接将父结点和其兄弟结点同时修改为黑色（为啥兄弟结点也需要变成黑色？因为要满足性质5）然后将爷爷结点改成红色即可： 当然这里还需注意一下，因为爷爷结点正常情况会变成红色，相当于新来了个红色的，这时还得继续往上看有没有破坏红黑树的规则才可以，直到没有为止，比如这里就破坏了性质一，爷爷结点现在是根结点（不是根结点就不需要管了），必须是黑色，所以说还要给它改成黑色才算结束： 接着我们继续插入结点： 此时又来了一个插在4左边的结点，同样是连续红色，我们需要进行变色才可以讲解问题，但是我们发现，如果变色的话，那么从11开始到所有NIL结点经历的黑色结点数量就不对了： 所以说对于这种父结点为红色，父结点的兄弟结点为黑色（NIL视为黑色）的情况，变色无法解决问题了，那么我们只能考虑旋转了，旋转规则和我们之前讲解的平衡二叉树是一样的，这实际上是一种LL型失衡： 同样的，如果遇到了LR型失衡，跟前面一样，先左旋在右旋，然后进行变色即可： 而RR型和RL型同理，这里就不进行演示了，可以看到，红黑树实际上也是通过颜色规则在进行旋转调整的，当然旋转和变色的操作顺序可以交换。所以，在插入时比较关键的判断点如下： 如果整棵树为NULL，直接作为根结点，变成黑色。 如果父结点是黑色，直接插入就完事。 如果父结点为红色，且父结点的兄弟结点也是红色，直接变色即可（但是注意得继续往上看有没有破坏之前的结构） 如果父结点为红色，但父结点的兄弟结点为黑色，需要先根据情况（LL、RR、LR、RL）进行旋转，然后再变色。 在了解这些步骤之后，我们其实已经可以尝试去编写一棵红黑树出来了，当然代码太过复杂，这里就不演示了。 哈希表在之前，我们已经学习了多种查找数据的方式，比如最简单的，如果数据量不大的情况下，我们可以直接通过顺序查找的方式在集合中搜索我们想要的元素；当数据量较大时，我们可以使用二分搜索来快速找到我们想要的数据，不过需要要求数据按照顺序排列，并且不允许中途对集合进行修改。 在学习完树形结构篇之后，我们可以利用二叉查找树来建立一个便于我们查找的树形结构，甚至可以将其优化为平衡二叉树或是红黑树来进一步提升稳定性。 这些都能够极大地帮助我们查找数据，而散列表，则是我们数据结构系列内容的最后一块重要知识。 散列（Hashing）通过散列函数（哈希函数）将要参与检索的数据与散列值（哈希值）关联起来，生成一种便于搜索的数据结构，我们称其为散列表（哈希表），也就是说，现在我们需要将一堆数据保存起来，这些数据会通过哈希函数进行计算，得到与其对应的哈希值，当我们下次需要查找这些数据时，只需要再次计算哈希值就能快速找到对应的元素了： 散列函数也叫哈希函数，哈希函数可以对一个目标计算出其对应的哈希值，并且，只要是同一个目标，无论计算多少次，得到的哈希值都是一样的结果，不同的目标计算出的结果介乎都不同。哈希函数在现实生活中应用十分广泛，比如很多下载网站都提供下载文件的MD5码校验，可以用来判别文件是否完整，哈希函数多种多样，目前应用最为广泛的是SHA-1和MD5，比如我们在下载IDEA之后，会看到有一个验证文件SHA-256校验和的选项，我们可以点进去看看： 点进去之后，得到： 1e54a026da11d05d9bb0172f4ef936ba2366f985b5424e7eecf9e9341804d65bf *ideaIU-2022.2.1.dmg 这一串由数字和小写字母随意组合的一个字符串，就是安装包文件通过哈希算法计算得到的结果，那么这个东西有什么用呢？我们的网络可能有时候会出现卡顿的情况，导致我们下载的文件可能会出现不完整的情况，因为哈希函数对同一个文件计算得到的结果是一样的，我们可以在本地使用同样的哈希函数去计算下载文件的哈希值，如果与官方一致，那么就说明是同一个文件，如果不一致，那么说明文件在传输过程中出现了损坏。 可见，哈希函数在这些地方就显得非常实用，在我们的生活中起了很大的作用，它也可以用于布隆过滤器和负载均衡等场景，这里不多做介绍了。 前面我们介绍了散列函数，我们知道可以通过散列函数计算一个目标的哈希值，那么这个哈希值计算出来有什么用呢，对我们的程序设计有什么意义呢？我们可以利用哈希值的特性，设计一张全新的表结构，这种表结构是专为哈希设立的，我们称其为哈希表（散列表） 我们可以将这些元素保存到哈希表中，而保存的位置则与其对应的哈希值有关，哈希值是通过哈希函数计算得到的，我们只需要将对应元素的关键字（一般是整数）提供给哈希函数就可以进行计算了，一般比较简单的哈希函数就是取模操作，哈希表长度是多少（长度最好是一个素数），模就是多少： 比如现在我们需要插入一个新的元素（关键字为17）到哈希表中： 插入的位置为计算出来的哈希值，比如上面是8，那么就在下标位置8插入元素，同样的，我们继续插入27： 这样，我们就可以将多种多样的数据保存到哈希表中了，注意保存的数据是无序的，因为我们也不清楚计算完哈希值最后会放到哪个位置。那么如果现在我们想要从哈希表中查找数据呢？比如我们现在需要查找哈希表中是否有14这个元素： 同样的，直接去看哈希值对应位置上看看有没有这个元素，如果没有，那么就说明哈希表中没有这个元素。可以看到，哈希表在查找时只需要进行一次哈希函数计算就能直接找到对应元素的存储位置，效率极高。 我们来尝试编写一下： 1234567891011121314151617181920public class HashTable&lt;E&gt; { private final int TABLE_SIZE = 10; private final Object[] TABLE = new Object[TABLE_SIZE]; public void insert(E element){ int index = hash(element); TABLE[index] = element; } public boolean contains(E element){ int index = hash(element); return TABLE[index] == element; } private int hash(Object object){ //哈希函数，计算出存放的位置 int hashCode = object.hashCode(); //每一个对象都有一个独一无二的哈希值，可以通过hashCode方法得到（只有极小的概率会出现相同的情况） return hashCode % TABLE_SIZE; }} 这样，我们就实现了一个简单的哈希表和哈希函数，通过哈希表，我们可以将数据的查找时间复杂度提升到常数阶。 前面我介绍了哈希函数，通过哈希函数计算得到一个目标的哈希值，但是在某些情况下，哈希值可能会出现相同的情况： 比如现在同时插入14和23这两个元素，他们两个计算出来的哈希值是一样的，都需要在5号下标位置插入，这时就出现了打架的情况，那么到底是把哪一个放进去呢？这种情况，我们称为哈希碰撞（哈希冲突） 这种问题是很严重的，因为哈希函数的设计不同，难免会出现这种情况，这种情况是不可避免的，我们只能通过使用更加高级的哈希函数来尽可能避免这种情况，但是无法完全避免。当然，如果要完全解决这种问题，我们还需要去寻找更好的方法。这里我们只介绍一种比较重要的，会在后面集合类中用到的方案。 实际上常见的哈希冲突解决方案是链地址法，当出现哈希冲突时，我们依然将其保存在对应的位置上，我们可以将其连接为一个链表的形式： 当表中元素变多时，差不多就变成了这样，我们一般将其横过来看： 通过结合链表的形式，哈希冲突问题就可以得到解决了，但是同时也会出现一定的查找开销，因为现在有了链表，我们得挨个往后看才能找到，当链表变得很长时，查找效率也会变低，此时我们可以考虑结合其他的数据结构来提升效率。比如当链表长度达到8时，自动转换为一棵平衡二叉树或是红黑树，这样就可以在一定程度上缓解查找的压力了。 123456789101112131415161718192021222324252627282930313233343536373839404142public class HashTable&lt;E&gt; { private final int TABLE_SIZE = 10; private final Node&lt;E&gt;[] TABLE = new Node[TABLE_SIZE]; public HashTable(){ for (int i = 0; i &lt; TABLE_SIZE; i++) TABLE[i] = new Node&lt;&gt;(null); } public void insert(E element){ int index = hash(element); Node&lt;E&gt; prev = TABLE[index]; while (prev.next != null) prev = prev.next; prev.next = new Node&lt;&gt;(element); } public boolean contains(E element){ int index = hash(element); Node&lt;E&gt; node = TABLE[index].next; while (node != null) { if(node.element == element) return true; node = node.next; } return false; } private int hash(Object object){ int hashCode = object.hashCode(); return hashCode % TABLE_SIZE; } private static class Node&lt;E&gt; { private final E element; private Node&lt;E&gt; next; private Node(E element){ this.element = element; } }} 实际上这种方案代码写起来也会更简单，使用也更方便一些。 至此，数据结构相关内容，我们就讲解到这里，学习这些数据结构，实际上也是为了方便各位小伙伴对于后续结合类的学习，因为集合类的底层实现就是这些数据结构。 实战练习合理利用集合类，我们可以巧妙地解决各种各样的难题。 反转链表本题来自LeetCode：206. 反转链表 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 示例 1： 输入：head = [1,2,3,4,5]输出：[5,4,3,2,1] 示例 2： 输入：head = [1,2]输出：[2,1] 这道题依然是考察各位小伙伴对于链表相关操作的掌握程度，我们如何才能将一个链表的顺序进行反转，关键就在于如何修改每个节点的指针指向。 括号匹配问题本题来自LeetCode：20. 有效的括号 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 示例 1： 输入：s = “()”输出：true 示例 2： 输入：s = “()[]{}”输出：true 示例 3： 输入：s = “(]”输出：false 示例 4： 输入：s = “([)]”输出：false 示例 5： 输入：s = “{[]}”输出：true 题干很明确，就是需要我们去对这些括号完成匹配，如果给定字符串中的括号无法完成一一匹配的话，那么就表示匹配失败。实际上这种问题我们就可以利用前面学习的栈这种数据结构来解决，我们可以将所有括号的左半部分放入栈中，当遇到右半部分时，进行匹配，如果匹配失败，那么就失败，如果匹配成功，那么就消耗一个左半部分，直到括号消耗完毕。 实现计算器输入一个计算公式（含加减乘除运算符，没有负数但是有小数）得到结果，比如输入：1+4*3/1.321，得到结果为：2.2 现在请你设计一个Java程序，实现计算器。","categories":[],"tags":[]},{"title":"","slug":"白马Java/JavaSE笔记（七）重制版","date":"2025-09-07T23:26:13.331Z","updated":"2025-09-07T23:28:25.711Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/0.html","excerpt":"多线程与反射前面我们已经讲解了JavaSE的大部分核心内容，最后一章，我们还将继续学习JavaSE中提供的各种高级特性。这些高级特性对于我们之后的学习，会有着举足轻重的作用。 多线程注意：本章节会涉及到 操作系统 相关知识。 在了解多线程之前，让我们回顾一下操作系统中提到的进程概念： 进程是程序执行的实体，每一个进程都是一个应用程序（比如我们运行QQ、浏览器、LOL、网易云音乐等软件），都有自己的内存空间，CPU一个核心同时只能处理一件事情，当出现多个进程需要同时运行时，CPU一般通过时间片轮转调度算法，来实现多个进程的同时运行。","text":"多线程与反射前面我们已经讲解了JavaSE的大部分核心内容，最后一章，我们还将继续学习JavaSE中提供的各种高级特性。这些高级特性对于我们之后的学习，会有着举足轻重的作用。 多线程注意：本章节会涉及到 操作系统 相关知识。 在了解多线程之前，让我们回顾一下操作系统中提到的进程概念： 进程是程序执行的实体，每一个进程都是一个应用程序（比如我们运行QQ、浏览器、LOL、网易云音乐等软件），都有自己的内存空间，CPU一个核心同时只能处理一件事情，当出现多个进程需要同时运行时，CPU一般通过时间片轮转调度算法，来实现多个进程的同时运行。 在早期的计算机中，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。但是，如果我希望两个任务同时进行，就必须运行两个进程，由于每个进程都有一个自己的内存空间，进程之间的通信就变得非常麻烦（比如要共享某些数据）而且执行不同进程会产生上下文切换，非常耗时，那么能否实现在一个进程中就能够执行多个任务呢？ 后来，线程横空出世，一个进程可以有多个线程，线程是程序执行中一个单一的顺序控制流程，现在线程才是程序执行流的最小单元，各个线程之间共享程序的内存空间（也就是所在进程的内存空间），上下文切换速度也高于进程。 在Java中，我们从开始，一直以来编写的都是单线程应用程序（运行main()方法的内容），也就是说只能同时执行一个任务（无论你是调用方法、还是进行计算，始终都是依次进行的，也就是同步的），而如果我们希望同时执行多个任务（两个方法同时在运行或者是两个计算同时在进行，也就是异步的），就需要用到Java多线程框架。实际上一个Java程序启动后，会创建很多线程，不仅仅只运行一个主线程： 12345678public static void main(String[] args) { ThreadMXBean bean = ManagementFactory.getThreadMXBean(); long[] ids = bean.getAllThreadIds(); ThreadInfo[] infos = bean.getThreadInfo(ids); for (ThreadInfo info : infos) { System.out.println(info.getThreadName()); }} 关于除了main线程默认以外的线程，涉及到JVM相关底层原理，在这里不做讲解，了解就行。 线程的创建和启动通过创建Thread对象来创建一个新的线程，Thread构造方法中需要传入一个Runnable接口的实现（其实就是编写要在另一个线程执行的内容逻辑）同时Runnable只有一个未实现方法，因此可以直接使用lambda表达式： 123456789101112131415@FunctionalInterfacepublic interface Runnable { /** * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used * to create a thread, starting the thread causes the object's * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing * thread. * &lt;p&gt; * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run();} 创建好后，通过调用start()方法来运行此线程： 123456public static void main(String[] args) { Thread t = new Thread(() -&gt; { //直接编写逻辑 System.out.println(\"我是另一个线程！\"); }); t.start(); //调用此方法来开始执行此线程} 可能上面的例子看起来和普通的单线程没两样，那我们先来看看下面这段代码的运行结果： 12345678910111213public static void main(String[] args) { Thread t = new Thread(() -&gt; { System.out.println(\"我是线程：\"+Thread.currentThread().getName()); System.out.println(\"我正在计算 0-10000 之间所有数的和...\"); int sum = 0; for (int i = 0; i &lt;= 10000; i++) { sum += i; } System.out.println(\"结果：\"+sum); }); t.start(); System.out.println(\"我是主线程！\");} 我们发现，这段代码执行输出结果并不是按照从上往下的顺序了，因为他们分别位于两个线程，他们是同时进行的！如果你还是觉得很疑惑，我们接着来看下面的代码运行结果： 1234567891011121314public static void main(String[] args) { Thread t1 = new Thread(() -&gt; { for (int i = 0; i &lt; 50; i++) { System.out.println(\"我是一号线程：\"+i); } }); Thread t2 = new Thread(() -&gt; { for (int i = 0; i &lt; 50; i++) { System.out.println(\"我是二号线程：\"+i); } }); t1.start(); t2.start();} 我们可以看到打印实际上是在交替进行的，也证明了他们是在同时运行！ 注意：我们发现还有一个run方法，也能执行线程里面定义的内容，但是run是直接在当前线程执行，并不是创建一个线程执行！ 实际上，线程和进程差不多，也会等待获取CPU资源，一旦获取到，就开始按顺序执行我们给定的程序，当需要等待外部IO操作（比如Scanner获取输入的文本），就会暂时处于休眠状态，等待通知，或是调用sleep()方法来让当前线程休眠一段时间： 123456789public static void main(String[] args) throws InterruptedException { System.out.println(\"l\"); Thread.sleep(1000); //休眠时间，以毫秒为单位，1000ms = 1s System.out.println(\"b\"); Thread.sleep(1000); System.out.println(\"w\"); Thread.sleep(1000); System.out.println(\"nb!\");} 我们也可以使用stop()方法来强行终止此线程： 12345678910public static void main(String[] args) throws InterruptedException { Thread t = new Thread(() -&gt; { Thread me = Thread.currentThread(); //获取当前线程对象 for (int i = 0; i &lt; 50; i++) { System.out.println(\"打印:\"+i); if(i == 20) me.stop(); //此方法会直接终止此线程 } }); t.start();} 虽然stop()方法能够终止此线程，但是并不是所推荐的做法，有关线程中断相关问题，我们会在后面继续了解。 思考：猜猜以下程序输出结果： 12345678910111213141516private static int value = 0;public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -&gt; { for (int i = 0; i &lt; 10000; i++) value++; System.out.println(\"线程1完成\"); }); Thread t2 = new Thread(() -&gt; { for (int i = 0; i &lt; 10000; i++) value++; System.out.println(\"线程2完成\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value);} 我们发现，value最后的值并不是我们理想的结果，有关为什么会出现这种问题，在我们学习到线程锁的时候，再来探讨。 线程的休眠和中断我们前面提到，一个线程处于运行状态下，线程的下一个状态会出现以下情况： 当CPU给予的运行时间结束时，会从运行状态回到就绪（可运行）状态，等待下一次获得CPU资源。 当线程进入休眠 / 阻塞(如等待IO请求) / 手动调用wait()方法时，会使得线程处于等待状态，当等待状态结束后会回到就绪状态。 当线程出现异常或错误 / 被stop() 方法强行停止 / 所有代码执行结束时，会使得线程的运行终止。 而这个部分我们着重了解一下线程的休眠和中断，首先我们来了解一下如何使得线程进如休眠状态： 123456789101112public static void main(String[] args) { Thread t = new Thread(() -&gt; { try { System.out.println(\"l\"); Thread.sleep(1000); //sleep方法是Thread的静态方法，它只作用于当前线程（它知道当前线程是哪个） System.out.println(\"b\"); //调用sleep后，线程会直接进入到等待状态，直到时间结束 } catch (InterruptedException e) { e.printStackTrace(); } }); t.start();} 通过调用sleep()方法来将当前线程进入休眠，使得线程处于等待状态一段时间。我们发现，此方法显示声明了会抛出一个InterruptedException异常，那么这个异常在什么时候会发生呢？ 12345678910111213141516public static void main(String[] args) { Thread t = new Thread(() -&gt; { try { Thread.sleep(10000); //休眠10秒 } catch (InterruptedException e) { e.printStackTrace(); } }); t.start(); try { Thread.sleep(3000); //休眠3秒，一定比线程t先醒来 t.interrupt(); //调用t的interrupt方法 } catch (InterruptedException e) { e.printStackTrace(); }} 我们发现，每一个Thread对象中，都有一个interrupt()方法，调用此方法后，会给指定线程添加一个中断标记以告知线程需要立即停止运行或是进行其他操作，由线程来响应此中断并进行相应的处理，我们前面提到的stop()方法是强制终止线程，这样的做法虽然简单粗暴，但是很有可能导致资源不能完全释放，而类似这样的发送通知来告知线程需要中断，让线程自行处理后续，会更加合理一些，也是更加推荐的做法。我们来看看interrupt的用法： 123456789101112131415161718public static void main(String[] args) { Thread t = new Thread(() -&gt; { System.out.println(\"线程开始运行！\"); while (true){ //无限循环 if(Thread.currentThread().isInterrupted()){ //判断是否存在中断标志 break; //响应中断 } } System.out.println(\"线程被中断了！\"); }); t.start(); try { Thread.sleep(3000); //休眠3秒，一定比线程t先醒来 t.interrupt(); //调用t的interrupt方法 } catch (InterruptedException e) { e.printStackTrace(); }} 通过isInterrupted()可以判断线程是否存在中断标志，如果存在，说明外部希望当前线程立即停止，也有可能是给当前线程发送一个其他的信号，如果我们并不是希望收到中断信号就是结束程序，而是通知程序做其他事情，我们可以在收到中断信号后，复位中断标记，然后继续做我们的事情： 123456789101112131415161718public static void main(String[] args) { Thread t = new Thread(() -&gt; { System.out.println(\"线程开始运行！\"); while (true){ if(Thread.currentThread().isInterrupted()){ //判断是否存在中断标志 System.out.println(\"发现中断信号，复位，继续运行...\"); Thread.interrupted(); //复位中断标记（返回值是当前是否有中断标记，这里不用管） } } }); t.start(); try { Thread.sleep(3000); //休眠3秒，一定比线程t先醒来 t.interrupt(); //调用t的interrupt方法 } catch (InterruptedException e) { e.printStackTrace(); }} 复位中断标记后，会立即清除中断标记。那么，如果现在我们想暂停线程呢？我们希望线程暂时停下，比如等待其他线程执行完成后，再继续运行，那这样的操作怎么实现呢？ 1234567891011121314public static void main(String[] args) { Thread t = new Thread(() -&gt; { System.out.println(\"线程开始运行！\"); Thread.currentThread().suspend(); //暂停此线程 System.out.println(\"线程继续运行！\"); }); t.start(); try { Thread.sleep(3000); //休眠3秒，一定比线程t先醒来 t.resume(); //恢复此线程 } catch (InterruptedException e) { e.printStackTrace(); }} 虽然这样很方便地控制了线程的暂停状态，但是这两个方法我们发现实际上也是不推荐的做法，它很容易导致死锁！有关为什么被弃用的原因，我们会在线程锁继续探讨。 线程的优先级实际上，Java程序中的每个线程并不是平均分配CPU时间的，为了使得线程资源分配更加合理，Java采用的是抢占式调度方式，优先级越高的线程，优先使用CPU资源！我们希望CPU花费更多的时间去处理更重要的任务，而不太重要的任务，则可以先让出一部分资源。线程的优先级一般分为以下三种： MIN_PRIORITY 最低优先级 MAX_PRIORITY 最高优先级 NOM_PRIORITY 常规优先级 1234567public static void main(String[] args) { Thread t = new Thread(() -&gt; { System.out.println(\"线程开始运行！\"); }); t.start(); t.setPriority(Thread.MIN_PRIORITY); //通过使用setPriority方法来设定优先级} 优先级越高的线程，获得CPU资源的概率会越大，并不是说一定优先级越高的线程越先执行！ 线程的礼让和加入我们还可以在当前线程的工作不重要时，将CPU资源让位给其他线程，通过使用yield()方法来将当前资源让位给其他同优先级线程： 123456789101112131415161718192021public static void main(String[] args) { Thread t1 = new Thread(() -&gt; { System.out.println(\"线程1开始运行！\"); for (int i = 0; i &lt; 50; i++) { if(i % 5 == 0) { System.out.println(\"让位！\"); Thread.yield(); } System.out.println(\"1打印：\"+i); } System.out.println(\"线程1结束！\"); }); Thread t2 = new Thread(() -&gt; { System.out.println(\"线程2开始运行！\"); for (int i = 0; i &lt; 50; i++) { System.out.println(\"2打印：\"+i); } }); t1.start(); t2.start();} 观察结果，我们发现，在让位之后，尽可能多的在执行线程2的内容。 当我们希望一个线程等待另一个线程执行完成后再继续进行，我们可以使用join()方法来实现线程的加入： 12345678910111213141516171819202122232425public static void main(String[] args) { Thread t1 = new Thread(() -&gt; { System.out.println(\"线程1开始运行！\"); for (int i = 0; i &lt; 50; i++) { System.out.println(\"1打印：\"+i); } System.out.println(\"线程1结束！\"); }); Thread t2 = new Thread(() -&gt; { System.out.println(\"线程2开始运行！\"); for (int i = 0; i &lt; 50; i++) { System.out.println(\"2打印：\"+i); if(i == 10){ try { System.out.println(\"线程1加入到此线程！\"); t1.join(); //在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容 } catch (InterruptedException e) { e.printStackTrace(); } } } }); t1.start(); t2.start();} 我们发现，线程1加入后，线程2等待线程1待执行的内容全部执行完成之后，再继续执行的线程2内容。注意，线程的加入只是等待另一个线程的完成，并不是将另一个线程和当前线程合并！我们来看看： 12345678910111213141516171819202122232425public static void main(String[] args) { Thread t1 = new Thread(() -&gt; { System.out.println(Thread.currentThread().getName()+\"开始运行！\"); for (int i = 0; i &lt; 50; i++) { System.out.println(Thread.currentThread().getName()+\"打印：\"+i); } System.out.println(\"线程1结束！\"); }); Thread t2 = new Thread(() -&gt; { System.out.println(\"线程2开始运行！\"); for (int i = 0; i &lt; 50; i++) { System.out.println(\"2打印：\"+i); if(i == 10){ try { System.out.println(\"线程1加入到此线程！\"); t1.join(); //在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容 } catch (InterruptedException e) { e.printStackTrace(); } } } }); t1.start(); t2.start();} 实际上，t2线程只是暂时处于等待状态，当t1执行结束时，t2才开始继续执行，只是在效果上看起来好像是两个线程合并为一个线程在执行而已。 线程锁和线程同步在开始讲解线程同步之前，我们需要先了解一下多线程情况下Java的内存管理： 线程之间的共享变量（比如之前悬念中的value变量）存储在主内存（main memory）中，每个线程都有一个私有的工作内存（本地内存），工作内存中存储了该线程以读/写共享变量的副本。它类似于我们在计算机组成原理中学习的多核心处理器高速缓存机制： 高速缓存通过保存内存中数据的副本来提供更加快速的数据访问，但是如果多个处理器的运算任务都涉及同一块内存区域，就可能导致各自的高速缓存数据不一致，在写回主内存时就会发生冲突，这就是引入高速缓存引发的新问题，称之为：缓存一致性。 实际上，Java的内存模型也是这样类似设计的，当我们同时去操作一个共享变量时，如果仅仅是读取还好，但是如果同时写入内容，就会出现问题！好比说一个银行，如果我和我的朋友同时在银行取我账户里面的钱，难道取1000还可能吐2000出来吗？我们需要一种更加安全的机制来维持秩序，保证数据的安全性！ 比如我们可以来看看下面这个问题： 12345678910111213141516private static int value = 0;public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -&gt; { for (int i = 0; i &lt; 10000; i++) value++; System.out.println(\"线程1完成\"); }); Thread t2 = new Thread(() -&gt; { for (int i = 0; i &lt; 10000; i++) value++; System.out.println(\"线程2完成\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value);} 实际上，当两个线程同时读取value的时候，可能会同时拿到同样的值，而进行自增操作之后，也是同样的值，再写回主内存后，本来应该进行2次自增操作，实际上只执行了一次！ 通过synchronized关键字来创造一个线程锁，首先我们来认识一下synchronized代码块，它需要在括号中填入一个内容，必须是一个对象或是一个类，我们在value自增操作外套上同步代码块： 123456789101112131415161718192021222324private static int value = 0;public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -&gt; { for (int i = 0; i &lt; 10000; i++) { synchronized (Main.class){ //使用synchronized关键字创建同步代码块 value++; } } System.out.println(\"线程1完成\"); }); Thread t2 = new Thread(() -&gt; { for (int i = 0; i &lt; 10000; i++) { synchronized (Main.class){ value++; } } System.out.println(\"线程2完成\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value);} 我们发现，现在得到的结果就是我们想要的内容了，因为在同步代码块执行过程中，拿到了我们传入对象或类的锁（传入的如果是对象，就是对象锁，不同的对象代表不同的对象锁，如果是类，就是类锁，类锁只有一个，实际上类锁也是对象锁，是Class类实例，但是Class类实例同样的类无论怎么获取都是同一个），但是注意两个线程必须使用同一把锁！ 当一个线程进入到同步代码块时，会获取到当前的锁，而这时如果其他使用同样的锁的同步代码块也想执行内容，就必须等待当前同步代码块的内容执行完毕，在执行完毕后会自动释放这把锁，而其他的线程才能拿到这把锁并开始执行同步代码块里面的内容（实际上synchronized是一种悲观锁，随时都认为有其他线程在对数据进行修改，后面在JUC篇视频教程中我们还会讲到乐观锁，如CAS算法） 那么我们来看看，如果使用的是不同对象的锁，那么还能顺利进行吗？ 1234567891011121314151617181920212223242526private static int value = 0;public static void main(String[] args) throws InterruptedException { Main main1 = new Main(); Main main2 = new Main(); Thread t1 = new Thread(() -&gt; { for (int i = 0; i &lt; 10000; i++) { synchronized (main1){ value++; } } System.out.println(\"线程1完成\"); }); Thread t2 = new Thread(() -&gt; { for (int i = 0; i &lt; 10000; i++) { synchronized (main2){ value++; } } System.out.println(\"线程2完成\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value);} 当对象不同时，获取到的是不同的锁，因此并不能保证自增操作的原子性，最后也得不到我们想要的结果。 synchronized关键字也可以作用于方法上，调用此方法时也会获取锁： 1234567891011121314151617181920private static int value = 0;private static synchronized void add(){ value++;}public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -&gt; { for (int i = 0; i &lt; 10000; i++) add(); System.out.println(\"线程1完成\"); }); Thread t2 = new Thread(() -&gt; { for (int i = 0; i &lt; 10000; i++) add(); System.out.println(\"线程2完成\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value);} 我们发现实际上效果是相同的，只不过这个锁不用你去给，如果是静态方法，就是使用的类锁，而如果是普通成员方法，就是使用的对象锁。通过灵活的使用synchronized就能很好地解决我们之前提到的问题了。 死锁其实死锁的概念在操作系统中也有提及，它是指两个线程相互持有对方需要的锁，但是又迟迟不释放，导致程序卡住： 我们发现，线程A和线程B都需要对方的锁，但是又被对方牢牢把握，由于线程被无限期地阻塞，因此程序不可能正常终止。我们来看看以下这段代码会得到什么结果： 123456789101112131415161718192021222324252627282930public static void main(String[] args) throws InterruptedException { Object o1 = new Object(); Object o2 = new Object(); Thread t1 = new Thread(() -&gt; { synchronized (o1){ try { Thread.sleep(1000); synchronized (o2){ System.out.println(\"线程1\"); } } catch (InterruptedException e) { e.printStackTrace(); } } }); Thread t2 = new Thread(() -&gt; { synchronized (o2){ try { Thread.sleep(1000); synchronized (o1){ System.out.println(\"线程2\"); } } catch (InterruptedException e) { e.printStackTrace(); } } }); t1.start(); t2.start();} 所以，我们在编写程序时，一定要注意，不要出现这种死锁的情况。那么我们如何去检测死锁呢？我们可以利用jstack命令来检测死锁，首先利用jps找到我们的java进程： 1234567891011121314151617181920212223nagocoler@NagodeMacBook-Pro ~ % jps51592 Launcher51690 Jps14955 51693 Mainnagocoler@NagodeMacBook-Pro ~ % jstack 51693...Java stack information for the threads listed above:===================================================\"Thread-1\": at com.test.Main.lambda$main$1(Main.java:46) - waiting to lock &lt;0x000000076ad27fc0&gt; (a java.lang.Object) - locked &lt;0x000000076ad27fd0&gt; (a java.lang.Object) at com.test.Main$$Lambda$2/1867750575.run(Unknown Source) at java.lang.Thread.run(Thread.java:748)\"Thread-0\": at com.test.Main.lambda$main$0(Main.java:34) - waiting to lock &lt;0x000000076ad27fd0&gt; (a java.lang.Object) - locked &lt;0x000000076ad27fc0&gt; (a java.lang.Object) at com.test.Main$$Lambda$1/396873410.run(Unknown Source) at java.lang.Thread.run(Thread.java:748)Found 1 deadlock. jstack自动帮助我们找到了一个死锁，并打印出了相关线程的栈追踪信息，同样的，使用jconsole也可以进行监测。 因此，前面说不推荐使用 suspend()去挂起线程的原因，是因为suspend()在使线程暂停的同时，并不会去释放任何锁资源。其他线程都无法访问被它占用的锁。直到对应的线程执行resume()方法后，被挂起的线程才能继续，从而其它被阻塞在这个锁的线程才可以继续执行。但是，如果resume()操作出现在suspend()之前执行，那么线程将一直处于挂起状态，同时一直占用锁，这就产生了死锁。 wait和notify方法其实我们之前可能就发现了，Object类还有三个方法我们从来没有使用过，分别是wait()、notify()以及notifyAll()，他们其实是需要配合synchronized来使用的（实际上锁就是依附于对象存在的，每个对象都应该有针对于锁的一些操作，所以说就这样设计了）当然，只有在同步代码块中才能使用这些方法，正常情况下会报错，我们来看看他们的作用是什么： 123456789101112131415161718192021222324252627public static void main(String[] args) throws InterruptedException { Object o1 = new Object(); Thread t1 = new Thread(() -&gt; { synchronized (o1){ try { System.out.println(\"开始等待\"); o1.wait(); //进入等待状态并释放锁 System.out.println(\"等待结束！\"); } catch (InterruptedException e) { e.printStackTrace(); } } }); Thread t2 = new Thread(() -&gt; { synchronized (o1){ System.out.println(\"开始唤醒！\"); o1.notify(); //唤醒处于等待状态的线程 for (int i = 0; i &lt; 50; i++) { System.out.println(i); } //唤醒后依然需要等待这里的锁释放之前等待的线程才能继续 } }); t1.start(); Thread.sleep(1000); t2.start();} 我们可以发现，对象的wait()方法会暂时使得此线程进入等待状态，同时会释放当前代码块持有的锁，这时其他线程可以获取到此对象的锁，当其他线程调用对象的notify()方法后，会唤醒刚才变成等待状态的线程（这时并没有立即释放锁）。注意，必须是在持有锁（同步代码块内部）的情况下使用，否则会抛出异常！ notifyAll其实和notify一样，也是用于唤醒，但是前者是唤醒所有调用wait()后处于等待的线程，而后者是看运气随机选择一个。 ThreadLocal的使用既然每个线程都有一个自己的工作内存，那么能否只在自己的工作内存中创建变量仅供线程自己使用呢？ 我们可以使用ThreadLocal类，来创建工作内存中的变量，它将我们的变量值存储在内部（只能存储一个变量），不同的线程访问到ThreadLocal对象时，都只能获取到当前线程所属的变量。 1234567891011121314public static void main(String[] args) throws InterruptedException { ThreadLocal&lt;String&gt; local = new ThreadLocal&lt;&gt;(); //注意这是一个泛型类，存储类型为我们要存放的变量类型 Thread t1 = new Thread(() -&gt; { local.set(\"lbwnb\"); //将变量的值给予ThreadLocal System.out.println(\"变量值已设定！\"); System.out.println(local.get()); //尝试获取ThreadLocal中存放的变量 }); Thread t2 = new Thread(() -&gt; { System.out.println(local.get()); //尝试获取ThreadLocal中存放的变量 }); t1.start(); Thread.sleep(3000); //间隔三秒 t2.start();} 上面的例子中，我们开启两个线程分别去访问ThreadLocal对象，我们发现，第一个线程存放的内容，第一个线程可以获取，但是第二个线程无法获取，我们再来看看第一个线程存入后，第二个线程也存放，是否会覆盖第一个线程存放的内容： 123456789101112131415161718192021public static void main(String[] args) throws InterruptedException { ThreadLocal&lt;String&gt; local = new ThreadLocal&lt;&gt;(); //注意这是一个泛型类，存储类型为我们要存放的变量类型 Thread t1 = new Thread(() -&gt; { local.set(\"lbwnb\"); //将变量的值给予ThreadLocal System.out.println(\"线程1变量值已设定！\"); try { Thread.sleep(2000); //间隔2秒 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"线程1读取变量值：\"); System.out.println(local.get()); //尝试获取ThreadLocal中存放的变量 }); Thread t2 = new Thread(() -&gt; { local.set(\"yyds\"); //将变量的值给予ThreadLocal System.out.println(\"线程2变量值已设定！\"); }); t1.start(); Thread.sleep(1000); //间隔1秒 t2.start();} 我们发现，即使线程2重新设定了值，也没有影响到线程1存放的值，所以说，不同线程向ThreadLocal存放数据，只会存放在线程自己的工作空间中，而不会直接存放到主内存中，因此各个线程直接存放的内容互不干扰。 我们发现在线程中创建的子线程，无法获得父线程工作内存中的变量： 12345678910public static void main(String[] args) { ThreadLocal&lt;String&gt; local = new ThreadLocal&lt;&gt;(); Thread t = new Thread(() -&gt; { local.set(\"lbwnb\"); new Thread(() -&gt; { System.out.println(local.get()); }).start(); }); t.start();} 我们可以使用InheritableThreadLocal来解决： 12345678910public static void main(String[] args) { ThreadLocal&lt;String&gt; local = new InheritableThreadLocal&lt;&gt;(); Thread t = new Thread(() -&gt; { local.set(\"lbwnb\"); new Thread(() -&gt; { System.out.println(local.get()); }).start(); }); t.start();} 在InheritableThreadLocal存放的内容，会自动向子线程传递。 定时器我们有时候会有这样的需求，我希望定时执行任务，比如3秒后执行，其实我们可以通过使用Thread.sleep()来实现： 123456789101112131415161718192021222324public static void main(String[] args) { new TimerTask(() -&gt; System.out.println(\"我是定时任务！\"), 3000).start(); //创建并启动此定时任务}static class TimerTask{ Runnable task; long time; public TimerTask(Runnable runnable, long time){ this.task = runnable; this.time = time; } public void start(){ new Thread(() -&gt; { try { Thread.sleep(time); task.run(); //休眠后再运行 } catch (InterruptedException e) { e.printStackTrace(); } }).start(); }} 我们通过自行封装一个TimerTask类，并在启动时，先休眠3秒钟，再执行我们传入的内容。那么现在我们希望，能否循环执行一个任务呢？比如我希望每隔1秒钟执行一次代码，这样该怎么做呢？ 1234567891011121314151617181920212223242526public static void main(String[] args) { new TimerLoopTask(() -&gt; System.out.println(\"我是定时任务！\"), 3000).start(); //创建并启动此定时任务}static class TimerLoopTask{ Runnable task; long loopTime; public TimerLoopTask(Runnable runnable, long loopTime){ this.task = runnable; this.loopTime = loopTime; } public void start(){ new Thread(() -&gt; { try { while (true){ //无限循环执行 Thread.sleep(loopTime); task.run(); //休眠后再运行 } } catch (InterruptedException e) { e.printStackTrace(); } }).start(); }} 现在我们将单次执行放入到一个无限循环中，这样就能一直执行了，并且按照我们的间隔时间进行。 但是终究是我们自己实现，可能很多方面还没考虑到，Java也为我们提供了一套自己的框架用于处理定时任务： 123456789public static void main(String[] args) { Timer timer = new Timer(); //创建定时器对象 timer.schedule(new TimerTask() { //注意这个是一个抽象类，不是接口，无法使用lambda表达式简化，只能使用匿名内部类 @Override public void run() { System.out.println(Thread.currentThread().getName()); //打印当前线程名称 } }, 1000); //执行一个延时任务} 我们可以通过创建一个Timer类来让它进行定时任务调度，我们可以通过此对象来创建任意类型的定时任务，包延时任务、循环定时任务等。我们发现，虽然任务执行完成了，但是我们的程序并没有停止，这是因为Timer内存维护了一个任务队列和一个工作线程： 12345678910111213141516public class Timer { /** * The timer task queue. This data structure is shared with the timer * thread. The timer produces tasks, via its various schedule calls, * and the timer thread consumes, executing timer tasks as appropriate, * and removing them from the queue when they're obsolete. */ private final TaskQueue queue = new TaskQueue(); /** * The timer thread. */ private final TimerThread thread = new TimerThread(queue); ...} TimerThread继承自Thread，是一个新创建的线程，在构造时自动启动： 1234public Timer(String name) { thread.setName(name); thread.start();} 而它的run方法会循环地读取队列中是否还有任务，如果有任务依次执行，没有的话就暂时处于休眠状态： 123456789101112131415161718192021222324252627public void run() { try { mainLoop(); } finally { // Someone killed this Thread, behave as if Timer cancelled synchronized(queue) { newTasksMayBeScheduled = false; queue.clear(); // Eliminate obsolete references } }}/** * The main timer loop. (See class comment.) */private void mainLoop() { try { TimerTask task; boolean taskFired; synchronized(queue) { // Wait for queue to become non-empty while (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled) //当队列为空同时没有被关闭时，会调用wait()方法暂时处于等待状态，当有新的任务时，会被唤醒。 queue.wait(); if (queue.isEmpty()) break; //当被唤醒后都没有任务时，就会结束循环，也就是结束工作线程 ...} newTasksMayBeScheduled实际上就是标记当前定时器是否关闭，当它为false时，表示已经不会再有新的任务到来，也就是关闭，我们可以通过调用cancel()方法来关闭它的工作线程： 1234567public void cancel() { synchronized(queue) { thread.newTasksMayBeScheduled = false; queue.clear(); queue.notify(); //唤醒wait使得工作线程结束 }} 因此，我们可以在使用完成后，调用Timer的cancel()方法以正常退出我们的程序： 12345678910public static void main(String[] args) { Timer timer = new Timer(); timer.schedule(new TimerTask() { @Override public void run() { System.out.println(Thread.currentThread().getName()); timer.cancel(); //结束 } }, 1000);} 守护线程不要把操作系统重的守护进程和守护线程相提并论！ 守护进程在后台运行运行，不需要和用户交互，本质和普通进程类似。而守护线程就不一样了，当其他所有的非守护线程结束之后，守护线程自动结束，也就是说，Java中所有的线程都执行完毕后，守护线程自动结束，因此守护线程不适合进行IO操作，只适合打打杂： 1234567891011121314151617public static void main(String[] args) throws InterruptedException{ Thread t = new Thread(() -&gt; { while (true){ try { System.out.println(\"程序正常运行中...\"); Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); t.setDaemon(true); //设置为守护线程（必须在开始之前，中途是不允许转换的） t.start(); for (int i = 0; i &lt; 5; i++) { Thread.sleep(1000); }} 在守护线程中产生的新线程也是守护的： 1234567891011121314151617181920public static void main(String[] args) throws InterruptedException{ Thread t = new Thread(() -&gt; { Thread it = new Thread(() -&gt; { while (true){ try { System.out.println(\"程序正常运行中...\"); Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); it.start(); }); t.setDaemon(true); //设置为守护线程（必须在开始之前，中途是不允许转换的） t.start(); for (int i = 0; i &lt; 5; i++) { Thread.sleep(1000); }} 再谈集合类集合类中有一个东西是Java8新增的Spliterator接口，翻译过来就是：可拆分迭代器（Splitable Iterator）和Iterator一样，Spliterator也用于遍历数据源中的元素，但它是为了并行执行而设计的。Java 8已经为集合框架中包含的所有数据结构提供了一个默认的Spliterator实现。在集合跟接口Collection中提供了一个spliterator()方法用于获取可拆分迭代器。 其实我们之前在讲解集合类的根接口时，就发现有这样一个方法： 123default Stream&lt;E&gt; parallelStream() { return StreamSupport.stream(spliterator(), true); //parallelStream就是利用了可拆分迭代器进行多线程操作} 并行流，其实就是一个多线程执行的流，它通过默认的ForkJoinPool实现（这里不讲解原理），它可以提高你的多线程任务的速度。 123456public static void main(String[] args) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1, 4, 5, 2, 9, 3, 6, 0)); list .parallelStream() //获得并行流 .forEach(i -&gt; System.out.println(Thread.currentThread().getName()+\" -&gt; \"+i));} 我们发现，forEach操作的顺序，并不是我们实际List中的顺序，同时每次打印也是不同的线程在执行！我们可以通过调用forEachOrdered()方法来使用单线程维持原本的顺序： 123456public static void main(String[] args) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1, 4, 5, 2, 9, 3, 6, 0)); list .parallelStream() //获得并行流 .forEachOrdered(System.out::println);} 我们之前还发现，在Arrays数组工具类中，也包含大量的并行方法： 12345public static void main(String[] args) { int[] arr = new int[]{1, 4, 5, 2, 9, 3, 6, 0}; Arrays.parallelSort(arr); //使用多线程进行并行排序，效率更高 System.out.println(Arrays.toString(arr));} 更多地使用并行方法，可以更加充分地发挥现代计算机多核心的优势，但是同时需要注意多线程产生的异步问题！ 12345678public static void main(String[] args) { int[] arr = new int[]{1, 4, 5, 2, 9, 3, 6, 0}; Arrays.parallelSetAll(arr, i -&gt; { System.out.println(Thread.currentThread().getName()); return arr[i]; }); System.out.println(Arrays.toString(arr));} 因为多线程的加入，我们之前认识的集合类都废掉了： 123456789101112131415public static void main(String[] args) throws InterruptedException { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); new Thread(() -&gt; { for (int i = 0; i &lt; 1000; i++) { list.add(i); //两个线程同时操作集合类进行插入操作 } }).start(); new Thread(() -&gt; { for (int i = 1000; i &lt; 2000; i++) { list.add(i); } }).start(); Thread.sleep(2000); System.out.println(list.size());} 我们发现，有些时候运气不好，得到的结果并不是2000个元素，而是： 因为之前的集合类，并没有考虑到多线程运行的情况，如果两个线程同时执行，那么有可能两个线程同一时间都执行同一个方法，这种情况下就很容易出问题： 12345public boolean add(E e) { ensureCapacityInternal(size + 1); // 当数组容量更好还差一个满的时候，这个时候两个线程同时走到了这里，因为都判断为没满，所以说没有进行扩容，但是实际上两个线程都要插入一个元素进来 elementData[size++] = e; //当两个线程同时在这里插入元素，直接导致越界访问 return true;} 当然，在Java早期的时候，还有一些老的集合类，这些集合类都是线程安全的： 1234567891011121314151617public static void main(String[] args) throws InterruptedException { Vector&lt;Integer&gt; list = new Vector&lt;&gt;(); //我们可以使用Vector代替List使用 //Hashtable&lt;Integer, String&gt; 也可以使用Hashtable来代替Map new Thread(() -&gt; { for (int i = 0; i &lt; 1000; i++) { list.add(i); } }).start(); new Thread(() -&gt; { for (int i = 1000; i &lt; 2000; i++) { list.add(i); } }).start(); Thread.sleep(1000); System.out.println(list.size());} 因为这些集合类中的每一个方法都加了锁，所以说不会出现多线程问题，但是这些老的集合类现在已经不再使用了，我们会在JUC篇视频教程中介绍专用于并发编程的集合类。 通过对Java多线程的了解，我们就具备了利用多线程解决问题的思维！ 实战：生产者与消费者所谓的生产者消费者模型，是通过一个容器来解决生产者和消费者的强耦合问题。通俗的讲，就是生产者在不断的生产，消费者也在不断的消费，可是消费者消费的产品是生产者生产的，这就必然存在一个中间容器，我们可以把这个容器想象成是一个货架，当货架空的时候，生产者要生产产品，此时消费者在等待生产者往货架上生产产品，而当货架有货物的时候，消费者可以从货架上拿走商品，生产者此时等待货架出现空位，进而补货，这样不断的循环。 通过多线程编程，来模拟一个餐厅的2个厨师和3个顾客，假设厨师炒出一个菜的时间为3秒，顾客吃掉菜品的时间为4秒。 反射注意：本章节涉及到JVM相关底层原理，难度会有一些大。 反射就是把Java类中的各个成分映射成一个个的Java对象。即在运行状态中，对于任意一个类，都能够知道这个类所有的属性和方法，对于任意一个对象，都能调用它的任意一个方法和属性。这种动态获取信息及动态调用对象方法的功能叫Java的反射机制。 简而言之，我们可以通过反射机制，获取到类的一些属性，包括类里面有哪些字段，有哪些方法，继承自哪个类，甚至还能获取到泛型！它的权限非常高，慎重使用！ Java类加载机制在学习Java的反射机制之前，我们需要先了解一下类的加载机制，一个类是如何被加载和使用的： 在Java程序启动时，JVM会将一部分类（class文件）先加载（并不是所有的类都会在一开始加载），通过ClassLoader将类加载，在加载过程中，会将类的信息提取出来（存放在元空间中，JDK1.8之前存放在永久代），同时也会生成一个Class对象存放在内存（堆内存），注意此Class对象只会存在一个，与加载的类唯一对应！ 为了方便各位小伙伴理解，你们就直接理解为默认情况下（仅使用默认类加载器）每个类都有且只有一个唯一的Class对象存放在JVM中，我们无论通过什么方式访问，都是始终是那一个对象。Class对象中包含我们类的一些信息，包括类里面有哪些方法、哪些变量等等。 Class类详解通过前面，我们了解了类的加载，同时会提取一个类的信息生成Class对象存放在内存中，而反射机制其实就是利用这些存放的类信息，来获取类的信息和操作类。那么如何获取到每个类对应的Class对象呢，我们可以通过以下方式： 12345public static void main(String[] args) throws ClassNotFoundException { Class&lt;String&gt; clazz = String.class; //使用class关键字，通过类名获取 Class&lt;?&gt; clazz2 = Class.forName(\"java.lang.String\"); //使用Class类静态方法forName()，通过包名.类名获取，注意返回值是Class&lt;?&gt; Class&lt;?&gt; clazz3 = new String(\"cpdd\").getClass(); //通过实例对象获取} 注意Class类也是一个泛型类，只有第一种方法，能够直接获取到对应类型的Class对象，而以下两种方法使用了?通配符作为返回值，但是实际上都和第一个返回的是同一个对象： 123456Class&lt;String&gt; clazz = String.class; //使用class关键字，通过类名获取Class&lt;?&gt; clazz2 = Class.forName(\"java.lang.String\"); //使用Class类静态方法forName()，通过包名.类名获取，注意返回值是Class&lt;?&gt;Class&lt;?&gt; clazz3 = new String(\"cpdd\").getClass();System.out.println(clazz == clazz2);System.out.println(clazz == clazz3); 通过比较，验证了我们一开始的结论，在JVM中每个类始终只存在一个Class对象，无论通过什么方法获取，都是一样的。现在我们再来看看这个问题： 1234public static void main(String[] args) { Class&lt;?&gt; clazz = int.class; //基本数据类型有Class对象吗？ System.out.println(clazz);} 迷了，不是每个类才有Class对象吗，基本数据类型又不是类，这也行吗？实际上，基本数据类型也有对应的Class对象（反射操作可能需要用到），而且我们不仅可以通过class关键字获取，其实本质上是定义在对应的包装类中的： 1234567891011121314/** * The {@code Class} instance representing the primitive type * {@code int}. * * @since JDK1.1 */@SuppressWarnings(\"unchecked\")public static final Class&lt;Integer&gt; TYPE = (Class&lt;Integer&gt;) Class.getPrimitiveClass(\"int\");/* * Return the Virtual Machine's Class object for the named * primitive type */static native Class&lt;?&gt; getPrimitiveClass(String name); //C++实现，并非Java定义 每个包装类中（包括Void），都有一个获取原始类型Class方法，注意，getPrimitiveClass获取的是原始类型，并不是包装类型，只是可以使用包装类来表示。 1234public static void main(String[] args) { Class&lt;?&gt; clazz = int.class; System.out.println(Integer.TYPE == int.class);} 通过对比，我们发现实际上包装类型都有一个TYPE，其实也就是基本类型的Class，那么包装类的Class和基本类的Class一样吗？ 123public static void main(String[] args) { System.out.println(Integer.TYPE == Integer.class);} 我们发现，包装类型的Class对象并不是基本类型Class对象。数组类型也是一种类型，只是编程不可见，因此我们可以直接获取数组的Class对象： 12345678public static void main(String[] args) { Class&lt;String[]&gt; clazz = String[].class; System.out.println(clazz.getName()); //获取类名称（得到的是包名+类名的完整名称） System.out.println(clazz.getSimpleName()); System.out.println(clazz.getTypeName()); System.out.println(clazz.getClassLoader()); //获取它的类加载器 System.out.println(clazz.cast(new Integer(\"10\"))); //强制类型转换} 下节课，我们将开始对Class对象的使用进行讲解。 Class对象与多态正常情况下，我们使用instanceof进行类型比较： 1234public static void main(String[] args) { String str = \"\"; System.out.println(str instanceof String);} 它可以判断一个对象是否为此接口或是类的实现或是子类，而现在我们有了更多的方式去判断类型： 1234public static void main(String[] args) { String str = \"\"; System.out.println(str.getClass() == String.class); //直接判断是否为这个类型} 如果需要判断是否为子类或是接口/抽象类的实现，我们可以使用asSubClass()方法： 1234public static void main(String[] args) { Integer i = 10; i.getClass().asSubclass(Number.class); //当Integer不是Number的子类时，会产生异常} 通过getSuperclass()方法，我们可以获取到父类的Class对象： 1234public static void main(String[] args) { Integer i = 10; System.out.println(i.getClass().getSuperclass());} 也可以通过getGenericSuperclass()获取父类的原始类型的Type： 123456public static void main(String[] args) { Integer i = 10; Type type = i.getClass().getGenericSuperclass(); System.out.println(type); System.out.println(type instanceof Class);} 我们发现Type实际上是Class类的父接口，但是获取到的Type的实现并不一定是Class。 同理，我们也可以像上面这样获取父接口： 12345678910public static void main(String[] args) { Integer i = 10; for (Class&lt;?&gt; anInterface : i.getClass().getInterfaces()) { System.out.println(anInterface.getName()); } for (Type genericInterface : i.getClass().getGenericInterfaces()) { System.out.println(genericInterface.getTypeName()); }} 是不是感觉反射功能很强大？几乎类的所有信息都可以通过反射获得。 创建类对象既然我们拿到了类的定义，那么是否可以通过Class对象来创建对象、调用方法、修改变量呢？当然是可以的，那我们首先来探讨一下如何创建一个类的对象： 1234567891011public static void main(String[] args) throws InstantiationException, IllegalAccessException { Class&lt;Student&gt; clazz = Student.class; Student student = clazz.newInstance(); student.test();}static class Student{ public void test(){ System.out.println(\"萨日朗\"); }} 通过使用newInstance()方法来创建对应类型的实例，返回泛型T，注意它会抛出InstantiationException和IllegalAccessException异常，那么什么情况下会出现异常呢？ 12345678910111213141516public static void main(String[] args) throws InstantiationException, IllegalAccessException { Class&lt;Student&gt; clazz = Student.class; Student student = clazz.newInstance(); student.test();}static class Student{ public Student(String text){ } public void test(){ System.out.println(\"萨日朗\"); }} 当类默认的构造方法被带参构造覆盖时，会出现InstantiationException异常，因为newInstance()只适用于默认无参构造。 1234567891011121314public static void main(String[] args) throws InstantiationException, IllegalAccessException { Class&lt;Student&gt; clazz = Student.class; Student student = clazz.newInstance(); student.test();}static class Student{ private Student(){} public void test(){ System.out.println(\"萨日朗\"); }} 当默认无参构造的权限不是public时，会出现IllegalAccessException异常，表示我们无权去调用默认构造方法。在JDK9之后，不再推荐使用newInstance()方法了，而是使用我们接下来要介绍到的，通过获取构造器，来实例化对象： 1234567891011121314public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { Class&lt;Student&gt; clazz = Student.class; Student student = clazz.getConstructor(String.class).newInstance(\"what's up\"); student.test();}static class Student{ public Student(String str){} public void test(){ System.out.println(\"萨日朗\"); }} 通过获取类的构造方法（构造器）来创建对象实例，会更加合理，我们可以使用getConstructor()方法来获取类的构造方法，同时我们需要向其中填入参数，也就是构造方法需要的类型，当然我们这里只演示了。那么，当访问权限不是public的时候呢？ 1234567891011121314public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { Class&lt;Student&gt; clazz = Student.class; Student student = clazz.getConstructor(String.class).newInstance(\"what's up\"); student.test();}static class Student{ private Student(String str){} public void test(){ System.out.println(\"萨日朗\"); }} 我们发现，当访问权限不足时，会无法找到此构造方法，那么如何找到非public的构造方法呢？ 12345Class&lt;Student&gt; clazz = Student.class;Constructor&lt;Student&gt; constructor = clazz.getDeclaredConstructor(String.class);constructor.setAccessible(true); //修改访问权限Student student = constructor.newInstance(\"what's up\");student.test(); 使用getDeclaredConstructor()方法可以找到类中的非public构造方法，但是在使用之前，我们需要先修改访问权限，在修改访问权限之后，就可以使用非public方法了（这意味着，反射可以无视权限修饰符访问类的内容） 调用类方法我们可以通过反射来调用类的方法（本质上还是类的实例进行调用）只是利用反射机制实现了方法的调用，我们在包下创建一个新的类： 1234567package com.test;public class Student { public void test(String str){ System.out.println(\"萨日朗\"+str); }} 这次我们通过forName(String)来找到这个类并创建一个新的对象： 1234567public static void main(String[] args) throws ReflectiveOperationException { Class&lt;?&gt; clazz = Class.forName(\"com.test.Student\"); Object instance = clazz.newInstance(); //创建出学生对象 Method method = clazz.getMethod(\"test\", String.class); //通过方法名和形参类型获取类中的方法 method.invoke(instance, \"what's up\"); //通过Method对象的invoke方法来调用方法} 通过调用getMethod()方法，我们可以获取到类中所有声明为public的方法，得到一个Method对象，我们可以通过Method对象的invoke()方法（返回值就是方法的返回值，因为这里是void，返回值为null）来调用已经获取到的方法，注意传参。 我们发现，利用反射之后，在一个对象从构造到方法调用，没有任何一处需要引用到对象的实际类型，我们也没有导入Student类，整个过程都是反射在代替进行操作，使得整个过程被模糊了，过多的使用反射，会极大地降低后期维护性。 同构造方法一样，当出现非public方法时，我们可以通过反射来无视权限修饰符，获取非public方法并调用，现在我们将test()方法的权限修饰符改为private： 12345678public static void main(String[] args) throws ReflectiveOperationException { Class&lt;?&gt; clazz = Class.forName(\"com.test.Student\"); Object instance = clazz.newInstance(); //创建出学生对象 Method method = clazz.getDeclaredMethod(\"test\", String.class); //通过方法名和形参类型获取类中的方法 method.setAccessible(true); method.invoke(instance, \"what's up\"); //通过Method对象的invoke方法来调用方法} Method和Constructor都和Class一样，他们存储了方法的信息，包括方法的形式参数列表，返回值，方法的名称等内容，我们可以直接通过Method对象来获取这些信息： 1234567public static void main(String[] args) throws ReflectiveOperationException { Class&lt;?&gt; clazz = Class.forName(\"com.test.Student\"); Method method = clazz.getDeclaredMethod(\"test\", String.class); //通过方法名和形参类型获取类中的方法 System.out.println(method.getName()); //获取方法名称 System.out.println(method.getReturnType()); //获取返回值类型} 当方法的参数为可变参数时，我们该如何获取方法呢？实际上，我们在之前就已经提到过，可变参数实际上就是一个数组，因此我们可以直接使用数组的class对象表示： 1Method method = clazz.getDeclaredMethod(\"test\", String[].class); 反射非常强大，尤其是我们提到的越权访问，但是请一定谨慎使用，别人将某个方法设置为private一定有他的理由，如果实在是需要使用别人定义为private的方法，就必须确保这样做是安全的，在没有了解别人代码的整个过程就强行越权访问，可能会出现无法预知的错误。 修改类的属性我们还可以通过反射访问一个类中定义的成员字段也可以修改一个类的对象中的成员字段值，通过getField()方法来获取一个类定义的指定字段： 12345678910public static void main(String[] args) throws ReflectiveOperationException { Class&lt;?&gt; clazz = Class.forName(\"com.test.Student\"); Object instance = clazz.newInstance(); Field field = clazz.getField(\"i\"); //获取类的成员字段i field.set(instance, 100); //将类实例instance的成员字段i设置为100 Method method = clazz.getMethod(\"test\"); method.invoke(instance);} 在得到Field之后，我们就可以直接通过set()方法为某个对象，设定此属性的值，比如上面，我们就为instance对象设定值为100，当访问private字段时，同样可以按照上面的操作进行越权访问： 1234567891011public static void main(String[] args) throws ReflectiveOperationException { Class&lt;?&gt; clazz = Class.forName(\"com.test.Student\"); Object instance = clazz.newInstance(); Field field = clazz.getDeclaredField(\"i\"); //获取类的成员字段i field.setAccessible(true); field.set(instance, 100); //将类实例instance的成员字段i设置为100 Method method = clazz.getMethod(\"test\"); method.invoke(instance);} 现在我们已经知道，反射几乎可以把一个类的老底都给扒出来，任何属性，任何内容，都可以被反射修改，无论权限修饰符是什么，那么，如果我的字段被标记为final呢？现在在字段i前面添加final关键字，我们再来看看效果： 1private final int i = 10; 这时，当字段为final时，就修改失败了！当然，通过反射可以直接将final修饰符直接去除，去除后，就可以随意修改内容了，我们来尝试修改Integer的value值： 1234567891011121314public static void main(String[] args) throws ReflectiveOperationException { Integer i = 10; Field field = Integer.class.getDeclaredField(\"value\"); Field modifiersField = Field.class.getDeclaredField(\"modifiers\"); //这里要获取Field类的modifiers字段进行修改 modifiersField.setAccessible(true); modifiersField.setInt(field,field.getModifiers()&amp;~Modifier.FINAL); //去除final标记 field.setAccessible(true); field.set(i, 100); //强行设置值 System.out.println(i);} 我们可以发现，反射非常暴力，就连被定义为final字段的值都能强行修改，几乎能够无视一切阻拦。我们来试试看修改一些其他的类型： 1234567891011public static void main(String[] args) throws ReflectiveOperationException { List&lt;String&gt; i = new ArrayList&lt;&gt;(); Field field = ArrayList.class.getDeclaredField(\"size\"); field.setAccessible(true); field.set(i, 10); i.add(\"测试\"); //只添加一个元素 System.out.println(i.size()); //大小直接变成11 i.remove(10); //瞎移除都不带报错的，淦} 实际上，整个ArrayList体系由于我们的反射操作，导致被破坏，因此它已经无法正常工作了！ 再次强调，在进行反射操作时，必须注意是否安全，虽然拥有了创世主的能力，但是我们不能滥用，我们只能把它当做一个不得已才去使用的工具！ 类加载器我们接着来介绍一下类加载器，实际上类加载器就是用于加载一个类的，但是类加载器并不是只有一个。 思考：既然说Class对象和加载的类唯一对应，那如果我们手动创建一个与JDK包名一样，同时类名也保持一致，JVM会加载这个类吗？ 1234567package java.lang;public class String { //JDK提供的String类也是 public static void main(String[] args) { System.out.println(\"我姓🐴，我叫🐴nb\"); }} 我们发现，会出现以下报错： 12错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为: public static void main(String[] args) 但是我们明明在自己写的String类中定义了main方法啊，为什么会找不到此方法呢？实际上这是ClassLoader的双亲委派机制在保护Java程序的正常运行： 实际上类最开始是由BootstarpClassLoader进行加载，BootstarpClassLoader用于加载JDK提供的类，而我们自己编写的类实际上是AppClassLoader加载的，只有BootstarpClassLoader都没有加载的类，才会让AppClassLoader来加载，因此我们自己编写的同名包同名类不会被加载，而实际要去启动的是真正的String类，也就自然找不到main方法了。 12345678public class Main { public static void main(String[] args) { System.out.println(Main.class.getClassLoader()); //查看当前类的类加载器 System.out.println(Main.class.getClassLoader().getParent()); //父加载器 System.out.println(Main.class.getClassLoader().getParent().getParent()); //爷爷加载器 System.out.println(String.class.getClassLoader()); //String类的加载器 }} 由于BootstarpClassLoader是C++编写的，我们在Java中是获取不到的。 既然通过ClassLoader就可以加载类，那么我们可以自己手动将class文件加载到JVM中吗？先写好我们定义的类： 123456789package com.test;public class Test { public String text; public void test(String str){ System.out.println(text+\" &gt; 我是测试方法！\"+str); }} 通过javac命令，手动编译一个.class文件： 1nagocoler@NagodeMacBook-Pro HelloWorld % javac src/main/java/com/test/Test.java 编译后，得到一个class文件，我们把它放到根目录下，然后编写一个我们自己的ClassLoader，因为普通的ClassLoader无法加载二进制文件，因此我们编写一个自定义的来让它支持： 123456789101112131415//定义一个自己的ClassLoaderstatic class MyClassLoader extends ClassLoader{ public Class&lt;?&gt; defineClass(String name, byte[] b){ return defineClass(name, b, 0, b.length); //调用protected方法，支持载入外部class文件 }}public static void main(String[] args) throws IOException { MyClassLoader classLoader = new MyClassLoader(); FileInputStream stream = new FileInputStream(\"Test.class\"); byte[] bytes = new byte[stream.available()]; stream.read(bytes); Class&lt;?&gt; clazz = classLoader.defineClass(\"com.test.Test\", bytes); //类名必须和我们定义的保持一致 System.out.println(clazz.getName()); //成功加载外部class文件} 现在，我们就将此class文件读取并解析为Class了，现在我们就可以对此类进行操作了（注意，我们无法在代码中直接使用此类型，因为它是我们直接加载的），我们来试试看创建一个此类的对象并调用其方法： 1234567try { Object obj = clazz.newInstance(); Method method = clazz.getMethod(\"test\", String.class); //获取我们定义的test(String str)方法 method.invoke(obj, \"哥们这瓜多少钱一斤？\");}catch (Exception e){ e.printStackTrace();} 我们来试试看修改成员字段之后，再来调用此方法： 123456789try { Object obj = clazz.newInstance(); Field field = clazz.getField(\"text\"); //获取成员变量 String text; field.set(obj, \"华强\"); Method method = clazz.getMethod(\"test\", String.class); //获取我们定义的test(String str)方法 method.invoke(obj, \"哥们这瓜多少钱一斤？\");}catch (Exception e){ e.printStackTrace();} 通过这种方式，我们就可以实现外部加载甚至是网络加载一个类，只需要把类文件传递即可，这样就无需再将代码写在本地，而是动态进行传递，不仅可以一定程度上防止源代码被反编译（只是一定程度上，想破解你代码有的是方法），而且在更多情况下，我们还可以对byte[]进行加密，保证在传输过程中的安全性。 注解注意：注解跟我们之前讲解的注释完全不是一个概念，不要搞混了。 其实我们在之前就接触到注解了，比如@Override表示重写父类方法（当然不加效果也是一样的，此注解在编译时会被自动丢弃）注解本质上也是一个类，只不过它的用法比较特殊。 注解可以被标注在任意地方，包括方法上、类名上、参数上、成员属性上、注解定义上等，就像注释一样，它相当于我们对某样东西的一个标记。而与注释不同的是，注解可以通过反射在运行时获取，注解也可以选择是否保留到运行时。 预设注解JDK预设了以下注解，作用于代码： @Override - 检查（仅仅是检查，不保留到运行时）该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。 @Deprecated - 标记过时方法。如果使用该方法，会报编译警告。 @SuppressWarnings - 指示编译器去忽略注解中声明的警告（仅仅编译器阶段，不保留到运行时） @FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。 @SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。 元注解元注解是作用于注解上的注解，用于我们编写自定义的注解： @Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。 @Documented - 标记这些注解是否包含在用户文档中。 @Target - 标记这个注解应该是哪种 Java 成员。 @Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类) @Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。 看了这么多预设的注解，你们肯定眼花缭乱了，那我们来看看@Override是如何定义的： 1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override {} 该注解由@Target限定为只能作用于方法上，ElementType是一个枚举类型，用于表示此枚举的作用域，一个注解可以有很多个作用域。@Retention表示此注解的保留策略，包括三种策略，在上述中有写到，而这里定义为只在代码中。一般情况下，自定义的注解需要定义1个@Retention和1-n个@Target。 既然了解了元注解的使用和注解的定义方式，我们就来尝试定义一个自己的注解： 1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Test {} 这里我们定义一个Test注解，并将其保留到运行时，同时此注解可以作用于方法或是类上： 1234567@Testpublic class Main { @Test public static void main(String[] args) { }} 这样，一个最简单的注解就被我们创建了。 注解的使用我们还可以在注解中定义一些属性，注解的属性也叫做成员变量，注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型： 12345@Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)public @interface Test { String value();} 默认只有一个属性时，我们可以将其名字设定为value，否则，我们需要在使用时手动指定注解的属性名称，使用value则无需填入： 12345@Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)public @interface Test { String test();} 123456public class Main { @Test(test = \"\") public static void main(String[] args) { }} 我们也可以使用default关键字来为这些属性指定默认值： 12345@Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)public @interface Test { String value() default \"都看到这里了，给个三连吧！\";} 当属性存在默认值时，使用注解的时候可以不用传入属性值。当属性为数组时呢？ 12345@Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)public @interface Test { String[] value();} 当属性为数组，我们在使用注解传参时，如果数组里面只有一个内容，我们可以直接传入一个值，而不是创建一个数组： 1234@Test(\"关注点了吗\")public static void main(String[] args) { } 123456public class Main { @Test({\"value1\", \"value2\"}) //多个值时就使用花括号括起来 public static void main(String[] args) { }} 反射获取注解既然我们的注解可以保留到运行时，那么我们来看看，如何获取我们编写的注解，我们需要用到反射机制： 123456789public static void main(String[] args) { Class&lt;Student&gt; clazz = Student.class; for (Annotation annotation : clazz.getAnnotations()) { System.out.println(annotation.annotationType()); //获取类型 System.out.println(annotation instanceof Test); //直接判断是否为Test Test test = (Test) annotation; System.out.println(test.value()); //获取我们在注解中写入的内容 }} 通过反射机制，我们可以快速获取到我们标记的注解，同时还能获取到注解中填入的值，那么我们来看看，方法上的标记是不是也可以通过这种方式获取注解： 123456789public static void main(String[] args) throws NoSuchMethodException { Class&lt;Student&gt; clazz = Student.class; for (Annotation annotation : clazz.getMethod(\"test\").getAnnotations()) { System.out.println(annotation.annotationType()); //获取类型 System.out.println(annotation instanceof Test); //直接判断是否为Test Test test = (Test) annotation; System.out.println(test.value()); //获取我们在注解中写入的内容 }} 无论是方法、类、还是字段，都可以使用getAnnotations()方法（还有几个同名的）来快速获取我们标记的注解。 所以说呢，这玩意学来有啥用？丝毫get不到这玩意的用处。其实不是，现阶段作为初学者，还体会不到注解带来的快乐，在接触到Spring和SpringBoot等大型框架后，相信各位就能感受到注解带来的魅力了。 结束语Java的学习对你来说可能是枯燥的，可能是漫长的，也有可能是有趣的，无论如何，你终于是完成了全部内容的学习，可喜可贺。 实际上很多人一开始跟着你们一起在进行学习，但是他们因为各种原因，最后还是没有走完这条路。坚持不一定会成功，但坚持到别人坚持不下去，那么你至少已经成功了一半了，坚持到最后的人运气往往都不会太差。 希望各位小伙伴能够在之后的学习中砥砺前行！","categories":[],"tags":[]},{"title":"","slug":"白马Java/JavaSE笔记（三）重置版","date":"2025-09-07T23:26:13.331Z","updated":"2025-09-07T23:28:25.711Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/0.html","excerpt":"面向对象基础篇我们在前面已经学习了面向过程编程，也可以自行编写出简单的程序了。我们接着就需要认识 面向对象程序设计（Object Oriented Programming）它是我们在Java语言中要学习的重要内容，面向对象也是高级语言的一大重要特性。 面向对象是新手成长的一道分水岭，有的人秒懂，有的人直到最后都无法理解。 这一章开始难度就上来了，所以说请各位小伙伴一定认真。 类与对象类的概念我们在生活中其实已经听说过很多了。 人类、鸟类、鱼类… 所谓类，就是对一类事物的描述，是抽象的、概念上的定义，比如鸟类，就泛指所有具有鸟类特征的动物。比如人类，不同的人，有着不同的性格、不同的爱好、不同的样貌等等，但是他们根本上都是人，所以说可以将他们抽象描述为人类。 对象是某一类事物实际存在的每个个体，因而也被称为实例（instance）我们每个人都是人类的一个实际存在的个体。","text":"面向对象基础篇我们在前面已经学习了面向过程编程，也可以自行编写出简单的程序了。我们接着就需要认识 面向对象程序设计（Object Oriented Programming）它是我们在Java语言中要学习的重要内容，面向对象也是高级语言的一大重要特性。 面向对象是新手成长的一道分水岭，有的人秒懂，有的人直到最后都无法理解。 这一章开始难度就上来了，所以说请各位小伙伴一定认真。 类与对象类的概念我们在生活中其实已经听说过很多了。 人类、鸟类、鱼类… 所谓类，就是对一类事物的描述，是抽象的、概念上的定义，比如鸟类，就泛指所有具有鸟类特征的动物。比如人类，不同的人，有着不同的性格、不同的爱好、不同的样貌等等，但是他们根本上都是人，所以说可以将他们抽象描述为人类。 对象是某一类事物实际存在的每个个体，因而也被称为实例（instance）我们每个人都是人类的一个实际存在的个体。 所以说，类就是抽象概念的人，而对象，就是具体的某一个人。 A：是谁拿走了我的手机？ B：是个人。（某一个类） A：我还知道是个人呢，具体是谁呢？ B：是XXX。（具体某个对象） 而我们在Java中，也可以像这样进行编程，我们可以定义一个类，然后进一步创建许多这个类的实例对象。像这种编程方式，我们称为面向对象编程。 类的定义与对象创建前面我们介绍了什么是类，什么是对象，首先我们就来看看如何去定义一个类。 比如现在我们想要定义一个人类，我们可以右键src目录，点击创建新的类： 我们在对类进行命名时，一般使用英文单词，并且首字母大写，跟变量命名一样，不能出现任何的特殊字符。 可以看到，现在我们的目录下有了两个.java源文件，其中一个是默认创建的Main.java，还有一个是我们刚刚创建的类。 我们来看看创建好之后，一个类写了哪些内容： 123public class Person { } 可以发现，这不是跟一开始创建的Main中写的格式一模一样吗？没错，Main也是一个类，只不过我们一直都将其当做主类在使用，也就是编写主方法的类，关于方法我们会在后面进行介绍。 现在我们就创建好了一个类，既然是人类，那么肯定有人相关的一些属性，比如名字、性别、年龄等等，那么怎么才能给这个类添加一些属性呢？ 我们可以将这些属性直接作为类的成员变量（成员变量相当于是这个类所具有的属性，每个实例创建出来之后，这些属性都可能会各不相同）定义到类中。 12345public class Person { //这里定义的人类具有三个属性，名字、年龄、性别 String name; //直接在类中定义变量，表示类具有的属性 int age; String sex;} 可能会有小伙伴疑问，这些变量啥时候被赋值呢？实际上这些变量只有在一个具体的对象中才可以使用。 那么现在人类的属性都规定好了，我们就可以尝试创建一个实例对象了，实例对应的应该是一个具体的人： 1new 类名(); 1234public static void main(String[] args) { new Person(); //我们可以使用new关键字来创建某个类的对象，注意new后面需要跟上 类名() //这里创建出来的，就是一个具体的人了} 实际上整个流程为： 只不过这里仅仅是创建出了这样的一个对象，我们目前没有办法去操作这个对象，比如想要修改或是获取这个人的名字等等。 对象的使用既然现在我们知道如何创建对象，那么我们怎么去访问这个对象呢，比如我现在想要去查看或是修改它的名字。 我们同样可以使用一个变量来指代某个对象，只不过引用类型的变量，存储的是对象的引用，而不是对象本身： 1234567public static void main(String[] args) { //这里的a存放的是具体的某个值 int a = 10; //创建一个变量指代我们刚刚创建好的对象，变量的类型就是对应的类名 //这里的p存放的是对象的引用，而不是本体，我们可以通过对象的引用来间接操作对象 Person p = new Person();} 至于为什么对象类型的变量存放的是对象的引用，比如： 1234public static void main(String[] args) { Person p1 = new Person(); Person p2 = p1;} 这里，我们将变量p2赋值为p1的值，那么实际上只是传递了对象的引用，而不是对象本身的复制，这跟我们前面的基本数据类型有些不同，p2和p1都指向的是同一个对象（如果你学习过C语言，它就类似于指针一样的存在） 我们可以来测试一下： 12345public static void main(String[] args) { Person p1 = new Person(); Person p2 = p1; System.out.println(p1 == p2); //使用 == 可以判断两个变量引用的是不是同一个对象} 但是如果我们像这样去编写： 12345public static void main(String[] args) { Person p1 = new Person(); //这两个变量分别引用的是不同的两个对象 Person p2 = new Person(); System.out.println(p1 == p2); //如果两个变量存放的是不同对象的引用，那么肯定就是不一样的了} 实际上我们之前使用的String类型，也是一个引用类型，我们会在下一章详细讨论。我们在上一章介绍的都是基本类型，而类使用的都是引用类型。 现在我们有了对象的引用之后，我们就可以进行操作了： 我们可以直接访问对象的一些属性，也就是我们在类中定义好的那些，对于不同的对象，这些属性都具体存放值也会不同。 比如我们可以修改对象的名字： 12345public static void main(String[] args) { Person p = new Person(); p.name = \"小明\"; //要访问对象的属性，我们需要使用 . 运算符 System.out.println(p.name); //直接打印对象的名字，就是我们刚刚修改好的结果了} 注意，不同对象的属性是分开独立存放的，每个对象都有一个自己的空间，修改一个对象的属性并不会影响到其他对象： 1234567public static void main(String[] args) { Person p1 = new Person(); Person p2 = new Person(); p1.name = \"小明\"; //这个修改的是第一个对象的属性 p2.name = \"大明\"; //这里修改的是第二个对象的属性 System.out.println(p1.name); //这里我们获取的是第一个对象的属性} 关于对象类型的变量，我们也可以不对任何对象进行引用： 123public static void main(String[] args) { Person p1 = null; //null是一个特殊的值，它表示空，也就是不引用任何的对象} 注意，如果不引用任何的对象，那肯定是不应该去通过这个变量去操作所引用的对象的（都没有引用对象，我操作谁啊我） 虽然这样可以编译通过，但是在运行时会出现问题： 12345public static void main(String[] args) { Person p = null; //此时变量没有引用任何对象 p.name = \"小红\"; //我任性，就是要操作 System.out.println(p.name);} 我们来尝试运行一下这段代码： 此时程序在运行的过程中，出现了异常，虽然我们还没有学习到异常，但是各位可以将异常理解为程序在运行过程中出现了问题，此时不得不终止程序退出。 这里出现的是空指针异常，很明显是因为我们去操作一个值为null的变量导致的。在我们以后的学习中，这个异常是出现频率最高的。 我们来看最后一个问题，对象创建成功之后，它的属性没有进行赋值，但是我们前面说了，变量使用之前需要先赋值，那么创建对象之后能否直接访问呢？ 123456public static void main(String[] args) { Person p = new Person(); System.out.println(\"name = \"+p.name); System.out.println(\"age = \"+p.age); System.out.println(\"sex = \"+p.sex);} 我们来看看运行结果： 我们可以看到，如果直接创建对象，那么对象的属性都会存在初始值，如果是基本类型，那么默认是统一为0（如果是boolean的话，默认值为false）如果是引用类型，那么默认是null。 方法创建与使用前面我们介绍了类的定义以及对象的创建和使用。 现在我们的类有了属性，我们可以为创建的这些对象设定不同的属性值，比如每个人的名字都不一样，性别不一样，年龄不一样等等。只不过光有属性还不行，对象还需要具有一定的行为，就像我们人可以行走，可以跳跃，可以思考一样。 而对象也可以做出一些行为，我们可以通过定义方法来实现（在C语言中叫做函数） 方法是语句的集合，是为了完成某件事情而存在的。完成某件事情，可以有结果，也可以做了就做了，不返回结果。比如计算两个数字的和，我们需要得到计算后的结果，所以说方法需要有返回值；又比如，我们只想吧数字打印在控制台，只需要打印就行，不用给我结果，所以说方法不需要有返回值。 方法的定义如下： 123返回值类型 方法名称() { 方法体...} 首先是返回值类型，也就是说这个方法完成任务之后，得到的结果的数据类型（可以是基本类型，也可以是引用类型）当然，如果没有返回值，只是完成任务，那么可以使用void表示没有返回值，比如我们现在给人类编写一个自我介绍的行为： 12345678910111213public class Person { String name; int age; String sex; //自我介绍只需要完成就行，没有返回值，所以说使用void void hello(){ //完成自我介绍需要执行的所有代码就在这个花括号中编写 //这里编写代码跟我们之前在main中是一样的（实际上main就是一个函数） //自我介绍需要用到当前对象的名字和年龄，我们直接使用成员变量即可，变量的值就是当前对象的存放值 System.out.println(\"我叫 \"+name+\" 今年 \"+age+\" 岁了！\"); }} 注意，方法名称同样可以随便起，但是规则跟变量的命名差不多，也是尽量使用小写字母开头的单词，如果是多个单词，一般使用驼峰命名法最规范。 现在我们给人类定义好了一个方法（行为）那么怎么才能让对象执行这个行为呢？ 123456public static void main(String[] args) { Person p = new Person(); p.name = \"小明\"; p.age = 18; p.hello(); //我们只需要使用 . 运算符，就可以执行定义好的方法了，只需要 .方法名称() 即可} 像这样执行定义好的方法，我们一般称为方法的调用，我们来看看效果： 比如现在我们要让人类学会加法运算，我们也可以通过定义一个方法的形式来完成，只不过，要完成加法运算，我们需要别人给人类提供两个参与加法运算的值才可以，所以我们这里就要用到参数了： 123456//我们的方法需要别人提供参与运算的值才可以//我们可以为方法设定参数，在调用方法时，需要外部传入参数才可以//参数的定义需要在小括号内部编写，类似于变量定义，需要填写 类型和参数名称，多个参数用逗号隔开int sum(int a, int b){ //这里需要两个int类型的参数进行计算} 那么现在参数从外部传入之后，我们怎么使用呢？ 123int sum(int a, int b){ //这里的参数，相当于我们在函数中定义了两个局部变量，我们可以直接在方法中使用 int c = a + b; //直接c = a + b} 那么现在计算完成了，我们该怎么将结果传递到外面呢？首先函数的返回值是int类型，我们只需要使用return关键字来返回一个int类型的结果就可以了： 12345int sum(int a, int b){ int c = a + b; return c; //return后面紧跟需要返回的结果，这样就可以将计算结果丢出去了 //带返回值的方法，是一定要有一个返回结果的！否则无法通过编译！} 我们来测试一下吧： 1234567public static void main(String[] args) { Person p = new Person(); p.name = \"小明\"; p.age = 18; int result = p.sum(10, 20); //现在我们要让这个对象帮我们计算10 + 20的结果 System.out.println(result); //成功得到30，实际上这里的println也是在调用方法进行打印操作} 注意：方法定义时编写的参数，我们一般称为形式参数，而调用方法实际传入的参数，我们成为实际参数。 是不是越来越感觉我们真的在跟一个对象进行交互？只要各位有了这样的体验，基本上就已经摸到面向对象的门路了。 关于return关键字，我们还需要进行进一步的介绍。 在我们使用return关键字之后，方法就会直接结束并返回结果，所以说在这之后编写的任何代码，都是不可到达的： 在return后编写代码，会导致编译不通过，因为存在不可达语句。 如果我们的程序中出现了分支语句，那么必须保证每一个分支都有返回值才可以： 只要有任何一个分支缺少了return语句，都无法正常通过编译，总之就是必须考虑到所有的情况，任何情况下都必须要有返回值。 当然，如果方法没有返回值，我们也可以使用return语句，不需要跟上任何内容，只不过这种情况下使用，仅仅是为了快速结束方法的执行： 1234void test(int a){ if(a == 10) return; //当a等于10时直接结束方法，后面无论有没有代码都不会执行了 System.out.println(\"Hello World!\"); //不是的情况就正常执行} 最后我们来讨论一下参数的传递问题： 123void test(int a){ //我们可以设置参数来让外部的数据传入到函数内部 System.out.println(a);} 实际上参数的传递，会在调用方法的时候，对参数的值进行复制，方法中的参数变量，不是我们传入的变量本身，我们来下面的这个例子： 12345void swap(int a, int b){ //这个函数的目的很明显，就是为了交换a和b的值 int tmp = a; a = b; b = a;} 那么我们来测试一下： 123456public static void main(String[] args) { Person p = new Person(); int a = 5, b = 9; //外面也叫a和b p.swap(a, b); System.out.println(\"a = \"+a+\", b = \"+b); //最后的结果会变成什么样子呢？} 我们来看看结果是什么： 我们发现a和b的值并没有发生交换，但是按照我们的方法逻辑来说，应该是会交换才对，这是为什么呢？实际上这里仅仅是将值复制给了函数里面的变量而已（相当于是变量的赋值） 所以说我们交换的仅仅是方法中的a和b，参数传递仅仅是值传递，我们是没有办法直接操作到外面的a和b的。 那么各位小伙伴看看下面的例子： 123void modify(Person person){ person.name = \"lbwnb\"; //修改对象的名称} 123456public static void main(String[] args) { Person p = new Person(); p.name = \"小明\"; //先在外面修改一次 p.modify(p); //调用方法再修改一次 System.out.println(p.name); //请问最后name会是什么？} 我们来看看结果： 不对啊，前面不是说只是值传递吗，怎么这里又可以修改成功呢？ 确实，这里同样是进行的值传递，只不过各位小伙伴别忘了，我们前面可是说的清清楚楚，引用类型的变量，仅仅存放的是对象的引用，而不是对象本身。那么这里进行了值传递，相当于将对象的引用复制到了方法内部的变量中，而这个内部的变量，依然是引用的同一个对象，所以说这里在方法内操作，相当于直接操作外面的定义对象。 方法进阶使用有时候我们的方法中可能会出现一些与成员变量重名的变量： 1234//我们希望使用这个方法，来为当前对象设定名字void setName(String name) { } 此时类中定义的变量名称也是name，那么我们是否可以这样编写呢： 123void setName(String name) { name = name; //出现重名时，优先使用作用域最接近的，这里实际上是将方法参数的局部变量name赋值为本身} 我们来测试一下： 12345public static void main(String[] args) { Person p = new Person(); p.setName(\"小明\"); System.out.println(p.name);} 我们发现，似乎这样做并没有任何的效果，name依然是没有修改的状态。那么当出现重名的时候，因为默认情况下会优先使用作用域最近的变量，我们怎么才能表示要使用的变量是类的成员变量呢？ 12Person p = new Person();p.name = \"小明\"; //我们之前在外面使用时，可以直接通过对象.属性的形式访问到 同样的，我们如果想要在方法中访问到当前对象的属性，那么可以使用this关键字，来明确表示当前类的示例对象本身： 123void setName(String name) { this.name = name; //让当前对象的name变量值等于参数传入的值} 这样就可以修改成功了，当然，如果方法内没有变量出现重名的情况，那么默认情况下可以不使用this关键字来明确表示当前对象： 123String getName() { return name; //这里没有使用this，但是当前作用域下只有对象属性的name变量，所以说直接就使用了} 我们接着来看方法的重载。 有些时候，参数类型可能会多种多样，我们的方法需要能够同时应对多种情况： 123int sum(int a, int b){ return a + b;} 1234public static void main(String[] args) { Person p = new Person(); System.out.println(p.sum(10, 20)); //这里可以正常计算两个整数的和} 但是要是我们现在不仅要让人类会计算整数，还要会计算小数呢？ 当我们使用小数时，可以看到，参数要求的是int类型，那么肯定会出现错误，这个方法只能用于计算整数。此时，为了让这个方法支持使用小数进行计算，我们可以将这个方法进行重载。 一个类中可以包含多个同名的方法，但是需要的形式参数不一样，方法的返回类型，可以相同，也可以不同，但是仅返回类型不同，是不允许的！ 1234567int sum(int a, int b){ return a + b;}double sum(double a, double b){ //为了支持小数加法，我们可以进行一次重载 return a + b;} 这样就可以正常使用了： 12345public static void main(String[] args) { Person p = new Person(); //当方法出现多个重载的情况，在调用时会自动进行匹配，选择合适的方法进行调用 System.out.println(p.sum(1.5, 2.2));} 包括我们之前一直在使用的println方法，其实也是重载了很多次的，因为要支持各种值的打印。 注意，如果仅仅是返回值的不同，是不支持重载的： 当然，方法之间是可以相互调用的： 1234567void test(){ System.out.println(\"我是test\"); //实际上这里也是调用另一个方法}void say(){ test(); //在一个方法内调用另一个方法} 如果我们这样写的话： 1234567void test(){ say();}void say(){ test();} 各位猜猜看会出现什么情况？ 此时又出现了一个我们不认识的异常，实际上什么原因导致的我们自己都很清楚，方法之间一直在相互调用，没有一个出口。 方法自己也可以调用自己： 123void test(){ test();} 像这样自己调用自己的行为，我们称为递归调用，如果直接这样编写，会跟上面一样，出现栈溢出错误。但是如果我们给其合理地设置出口，就不会出现这种问题，比如我们想要计算从1加到n的和： 1234int test(int n){ if(n == 0) return 0; return test(n - 1) + n; //返回的结果是下一层返回的结果+当前这一层的n} 是不是感觉很巧妙？实际上递归调用在很多情况下能够快速解决一些很麻烦的问题，我们会在后面继续了解。 构造方法我们接着来看一种比较特殊的方法，构造方法。 我们前面创建对象，都是直接使用new关键字就能直接搞定了，但是我们发现，对象在创建之后，各种属性都是默认值，那么能否实现在对象创建时就为其指定名字、年龄、性别呢？要在对象创建时进行处理，我们可以使用构造方法（构造器）来完成。 实际上每个类都有一个默认的构造方法，我们可以来看看反编译的结果： 12345678public class Person { String name; int age; String sex; public Person() { //反编译中，多出来了这样一个方法，这其实就是构造方法 }} 构造方法不需要填写返回值，并且方法名称与类名相同，默认情况下每个类都会自带一个没有任何参数的无参构造方法（只是不用我们去写，编译出来就自带）当然，我们也可以手动声明，对其进行修改： 1234567891011public class Person { String name; int age; String sex; Person(){ //构造方法不需要指定返回值，并且方法名称与类名相同 name = \"小明\"; //构造方法会在对象创建时执行，我们可以将各种需要初始化的操作都在这里进行处理 age = 18; sex = \"男\"; }} 构造方法会在new的时候自动执行： 1234public static void main(String[] args) { Person p = new Person(); //这里的new Person()其实就是在调用无参构造方法 System.out.println(p.name);} 当然，我们也可以为构造方法设定参数： 1234567891011public class Person { String name; int age; String sex; Person(String name, int age, String sex){ //跟普通方法是一样的 this.name = name; this.age = age; this.sex = sex; }} 注意，在我们自己定义一个构造方法之后，会覆盖掉默认的那一个无参构造方法，除非我们手动重载一个无参构造，否则要创建这个类的对象，必须调用我们自己定义的构造方法： 1234public static void main(String[] args) { Person p = new Person(\"小明\", 18, \"男\"); //调用自己定义的带三个参数的构造方法 System.out.println(p.name);} 我们可以去看看反编译的结果，会发现此时没有无参构造了，而是只剩下我们自己编写的。 当然，要给成员变量设定初始值，我们不仅可以通过构造方法，也可以直接在定义时赋值： 12345public class Person { String name = \"未知\"; //直接赋值，那么对象构造好之后，属性默认就是这个值 int age = 10; String sex = \"男\";} 这里需要特别注意，成员变量的初始化，并不是在构造方法之前之后，而是在这之前就已经完成了： 123456Person(String name, int age, String sex){ System.out.println(age); //在赋值之前看看是否有初始值 this.name = name; this.age = age; this.sex = sex;} 我们也可以在类中添加代码块，代码块同样会在对象构造之前进行，在成员变量初始化之后执行： 12345678910111213141516public class Person { String name; int age; String sex; { System.out.println(\"我是代码块\"); //代码块中的内容会在对象创建时仅执行一次 } Person(String name, int age, String sex){ System.out.println(\"我被构造了\"); this.name = name; this.age = age; this.sex = sex; }} 只不过一般情况下使用代码块的频率比较低，标准情况下还是通过构造方法进行进行对象初始化工作，所以说这里做了解就行了。 静态变量和静态方法前面我们已经了解了类的大部分特性，一个类可以具有多种属性、行为，包括对象该如何创建，我们可以通过构造方法进行设定，我们可以通过类创建对象，每个对象都会具有我们在类中设定好的属性，包括我们设定好的行为，所以说类就像是一个模板，我们可以通过这个模板快速捏造出一个又一个的对象。我们接着来看比较特殊的静态特性。 静态的内容，我们可以理解为是属于这个类的，也可以理解为是所有对象共享的内容。我们通过使用static关键字来声明一个变量或一个方法为静态的，一旦被声明为静态，那么通过这个类创建的所有对象，操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。 123456public class Person { String name; int age; String sex; static String info; //这里我们定义一个info静态变量} 我们来测试一下： 123456public static void main(String[] args) { Person p1 = new Person(); Person p2 = new Person(); p1.info = \"杰哥你干嘛\"; System.out.println(p2.info); //可以看到，由于静态属性是属于类的，因此无论通过什么方式改变，都改变的是同一个目标} 所以说一般情况下，我们并不会通过一个具体的对象去修改和使用静态属性，而是通过这个类去使用： 1234public static void main(String[] args) { Person.info = \"让我看看\"; System.out.println(Person.info);} 同样的，我们可以将方法标记为静态： 123static void test(){ System.out.println(\"我是静态方法\");} 静态方法同样是属于类的，而不是具体的某个对象，所以说，就像下面这样： 因为静态方法属于类的，所以说我们在静态方法中，无法获取成员变量的值： 成员变量是某个具体对象拥有的属性，就像小明这个具体的人的名字才叫小明，而静态方法是类具有的，并不是具体对象的，肯定是没办法访问到的。同样的，在静态方法中，无法使用this关键字，因为this关键字代表的是当前的对象本身。 但是静态方法是可以访问到静态变量的： 12345static String info;static void test(){ System.out.println(\"静态变量的值为：\"+info);} 因为他们都属于类，所以说肯定是可以访问到的。 我们也可以将代码块变成静态的： 12345static String info;static { //静态代码块可以用于初始化静态变量 info = \"测试\";} 那么，静态变量，是在什么时候进行初始化的呢？ 我们在一开始介绍了，我们实际上是将.class文件丢给JVM去执行的，而每一个.class文件其实就是我们编写的一个类，我们在Java中使用一个类之前，JVM并不会在一开始就去加载它，而是在需要时才会去加载（优化）一般遇到以下情况时才会会加载类： 访问类的静态变量，或者为静态变量赋值 new 创建类的实例（隐式加载） 调用类的静态方法 子类初始化时 其他的情况会在讲到反射时介绍 所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载。 我们可以来测试一下： 1234567891011121314151617181920212223242526272829public class Person { String name = test(); //这里我们用test方法的返回值作为变量的初始值，便于观察 int age; String sex; { System.out.println(\"我是普通代码块\"); } Person(){ System.out.println(\"我是构造方法\"); } String test(){ System.out.println(\"我是成员变量初始化\"); return \"小明\"; } static String info = init(); //这里我们用init静态方法的返回值作为变量的初始值，便于观察 static { System.out.println(\"我是静态代码块\"); } static String init(){ System.out.println(\"我是静态变量初始化\"); return \"test\"; }} 现在我们在主方法中创建一个对象，观察这几步是怎么在执行的： 可以看到，确实是静态内容在对象构造之前的就完成了初始化，实际上就是类初始化时完成的。 当然，如果我们直接访问类的静态变量： 123public static void main(String[] args) { System.out.println(Person.info);} 那么此时同样会使得类初始化，进行加载： 可以看到，在使用时，确实是先将静态内容初始化之后，才得到值的。当然，如果我们压根就没有去使用这个类，那么也不会被初始化了。 有关类与对象的基本内容，我们就全部讲解完毕了。 包和访问控制通过前面的学习，我们知道该如何创建和使用类。 包声明和导入包其实就是用来区分类位置的东西，也可以用来将我们的类进行分类（类似于C++中的namespace）随着我们的程序不断变大，可能会创建各种各样的类，他们可能会做不同的事情，那么这些类如果都放在一起的话，有点混乱，我们可以通过包的形式将这些类进行分类存放。 包的命名规则同样是英文和数字的组合，最好是一个域名的格式，比如我们经常访问的www.baidu.com，后面的baidu.com就是域名，我们的包就可以命名为com.baidu，当然，各位小伙伴现在还没有自己的域名，所以说我们随便起一个名称就可以了。其中的.就是用于分割的，对应多个文件夹，比如com.test： 我们可以将类放入到包中： 我们之前都是直接创建的类，所以说没有包这个概念，但是现在，我们将类放到包中，就需要注意了： 1234567package com.test; //在放入包中，需要在类的最上面添加package关键字来指明当前类所处的包public class Main { //将Main类放到com.test这个包中 public static void main(String[] args) { }} 这里又是一个新的关键字package，这个是用于指定当前类所处的包的，注意，所处的包和对应的目录是一一对应的。 不同的类可以放在不同的包下： 当我们使用同一个包中的类时，直接使用即可（之前就是直接使用的，因为都直接在一个缺省的包中）而当我们需要使用其他包中的类时，需要先进行导入才可以： 123456789package com.test;import com.test.entity.Person; //使用import关键字导入其他包中的类public class Main { public static void main(String[] args) { Person person = new Person(); //只有导入之后才可以使用，否则编译器不知道这个类从哪来的 }} 这里使用了import关键字导入我们需要使用的类，当然，只有在类不在同一个包下时才需要进行导入，如果一个包中有多个类，我们可以使用*表示导入这个包中全部的类： 1import com.test.entity.*; 实际上我们之前一直在使用的System类，也是在一个包中的： 123456789101112131415161718192021222324252627282930313233343536373839package java.lang;import java.io.*;import java.lang.reflect.Executable;import java.lang.annotation.Annotation;import java.security.AccessControlContext;import java.util.Properties;import java.util.PropertyPermission;import java.util.StringTokenizer;import java.util.Map;import java.security.AccessController;import java.security.PrivilegedAction;import java.security.AllPermission;import java.nio.channels.Channel;import java.nio.channels.spi.SelectorProvider;import sun.nio.ch.Interruptible;import sun.reflect.CallerSensitive;import sun.reflect.Reflection;import sun.security.util.SecurityConstants;import sun.reflect.annotation.AnnotationType;import jdk.internal.util.StaticProperty;/** * The &lt;code&gt;System&lt;/code&gt; class contains several useful class fields * and methods. It cannot be instantiated. * * &lt;p&gt;Among the facilities provided by the &lt;code&gt;System&lt;/code&gt; class * are standard input, standard output, and error output streams; * access to externally defined properties and environment * variables; a means of loading files and libraries; and a utility * method for quickly copying a portion of an array. * * @author unascribed * @since JDK1.0 */public final class System { ...} 可以看到它是属于java.lang这个包下的类，并且这个类也导入了很多其他包中的类在进行使用。那么，为什么我们在使用这个类时，没有导入呢？实际上Java中会默认导入java.lang这个包下的所有类，因此我们不需要手动指定。 IDEA非常智能，我们在使用项目中定义的类时，会自动帮我们将导入补全，所以说代码写起来非常高效。 注意，在不同包下的类，即使类名相同，也是不同的两个类： 1234package com.test.entity;public class String { //我们在自己的包中也建一个名为String的类} 当我们在使用时： ![image-20220921121404900](/Users/nagocoler/Library/Application Support/typora-user-images/image-20220921121404900.png) 由于默认导入了系统自带的String类，并且也导入了我们自己定义的String类，那么此时就出现了歧义，编译器不知道到底我们想用的是哪一个String类，所以说我们需要明确指定： 12345public class Main { public static void main(java.lang.String[] args) { //主方法的String参数是java.lang包下的，我们需要明确指定一下，只需要在类名前面添加包名就行了 com.test.entity.String string = new com.test.entity.String(); }} 我们只需要在类名前面把完整的包名也给写上，就可以表示这个是哪一个包里的类了，当然，如果没有出现歧义，默认情况下包名是可以省略的，可写可不写。 可能各位小伙伴会发现一个问题，为什么对象的属性访问不了了？ 编译器说name属性在这个类中不是public，无法在外部进行访问，这是什么情况呢？这里我们就要介绍的到Java的访问权限控制了。 访问权限控制实际上Java中是有访问权限控制的，就是我们个人的隐私的一样，我不允许别人随便来查看我们的隐私，只有我们自己同意的情况下，才能告诉别人我们的名字、年龄等隐私信息。 所以说Java中引入了访问权限控制（可见性），我们可以为成员变量、成员方法、静态变量、静态方法甚至是类指定访问权限，不同的访问权限，有着不同程度的访问限制： private - 私有，标记为私有的内容无法被除当前类以外的任何位置访问。 什么都不写 - 默认，默认情况下，只能被类本身和同包中的其他类访问。 protected - 受保护，标记为受保护的内容可以能被类本身和同包中的其他类访问，也可以被子类访问（子类我们会在下一章介绍） public - 公共，标记为公共的内容，允许在任何地方被访问。 这四种访问权限，总结如下表： 当前类 同一个包下的类 不同包下的子类 不同包下的类 public ✅ ✅ ✅ ✅ protected ✅ ✅ ✅ ❌ 默认 ✅ ✅ ❌ ❌ private ✅ ❌ ❌ ❌ 比如我们刚刚出现的情况，就是因为是默认的访问权限，所以说在当前包以外的其他包中无法访问，但是我们可以提升它的访问权限，来使得外部也可以访问： 12345public class Person { public String name; //在name变量前添加public关键字，将其可见性提升为公共等级 int age; String sex;} 这样我们就可以在外部正常使用这个属性了： 1234public static void main(String[] args) { Person person = new Person(); System.out.println(person.name); //正常访问到成员变量} 实际上如果各位小伙伴观察仔细的话，会发现我们创建出来的类自带的访问等级就是public： 12345package com.test.entity;public class Person { //class前面有public关键字} 也就是说这个类实际上可以在任何地方使用，但是我们也可以将其修改为默认的访问等级： 12345package com.test.entity;class Person { //去掉public变成默认等级 } 如果是默认等级的话，那么在外部同样是无法访问的： 但是注意，我们创建的普通类不能是protected或是private权限，因为我们目前所使用的普通类要么就是只给当前的包内使用，要么就是给外面都用，如果是private谁都不能用，那这个类定义出来干嘛呢？ 如果某个类中存在静态方法或是静态变量，那么我们可以通过静态导入的方式将其中的静态方法或是静态变量直接导入使用，但是同样需要有访问权限的情况下才可以： 123456789public class Person { String name; int age; String sex; public static void test(){ System.out.println(\"我是静态方法！\"); }} 我们来尝试一下静态导入： 1234567import static com.test.entity.Person.test; //静态导入test方法public class Main { public static void main(String[] args) { test(); //直接使用就可以，就像在这个类定义的方法一样 }} 至此，有关包相关的内容，我们就讲解到这里。 封装、继承和多态封装、继承和多态是面向对象编程的三大特性。 封装，把对象的属性和方法结合成一个独立的整体，隐藏实现细节，并提供对外访问的接口。 继承，从已知的一个类中派生出一个新的类，叫子类。子类实现了父类所有非私有化的属性和方法，并根据实际需求扩展出新的行为。 多态，多个不同的对象对同一消息作出响应，同一消息根据不同的对象而采用各种不同的方法。 正是这三大特性，让我们的Java程序更加生动形象。 类的封装封装的目的是为了保证变量的安全性，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员，如果不进行封装，类中的实例变量可以直接查看和修改，可能给整个代码带来不好的影响，因此在编写类时一般将成员变量私有化，外部类需要使用Getter和Setter方法来查看和设置变量。 我们可以将之前的类进行改进： 1234567891011121314151617181920212223public class Person { private String name; //现在类的属性只能被自己直接访问 private int age; private String sex; public Person(String name, int age, String sex) { //构造方法也要声明为公共，否则对象都构造不了 this.name = name; this.age = age; this.sex = sex; } public String getName() { return name; //想要知道这个对象的名字，必须通过getName()方法来获取，并且得到的只是名字值，外部无法修改 } public String getSex() { return sex; } public int getAge() { return age; }} 我们可以来试一下： 1234public static void main(String[] args) { Person person = new Person(\"小明\", 18, \"男\"); System.out.println(person.getName()); //只能通过调用getName()方法来获取名字} 也就是说，外部现在只能通过调用我定义的方法来获取成员属性，而我们可以在这个方法中进行一些额外的操作，比如小明可以修改名字，但是名字中不能包含”小”这个字： 1234public void setName(String name) { if(name.contains(\"小\")) return; this.name = name;} 我们甚至还可以将构造方法改成私有的，需要通过我们的内部的方式来构造对象： 1234567891011public class Person { private String name; private int age; private String sex; private Person(){} //不允许外部使用new关键字创建对象 public static Person getInstance() { //而是需要使用我们的独特方法来生成对象并返回 return new Person(); }} 通过这种方式，我们可以实现单例模式： 1234567891011public class Test { private static Test instance; private Test(){} public static Test getInstance() { if(instance == null) instance = new Test(); return instance; }} 单例模式就是全局只能使用这一个对象，不能创建更多的对象，我们就可以封装成这样，关于单例模式的详细介绍，还请各位小伙伴在《Java设计模式》视频教程中再进行学习。 封装思想其实就是把实现细节给隐藏了，外部只需知道这个方法是什么作用，而无需关心实现，要用什么由类自己来做，不需要外面来操作类内部的东西去完成，封装就是通过访问权限控制来实现的。 类的继承前面我们介绍了类的封装，我们接着来看一个非常重要特性：继承。 在定义不同类的时候存在一些相同属性，为了方便使用可以将这些共同属性抽象成一个父类，在定义其他子类时可以继承自该父类，减少代码的重复定义，子类可以使用父类中非私有的成员。 比如说我们一开始使用的人类，那么实际上人类根据职业划分，所掌握的技能也会不同，比如画家会画画，歌手会唱，舞者会跳，Rapper会rap，运动员会篮球，我们可以将人类这个大类根据职业进一步地细分出来： 实际上这些划分出来的类，本质上还是人类，也就是说人类具有的属性，这些划分出来的类同样具有，但是，这些划分出来的类同时也会拥有他们自己独特的技能。在Java中，我们可以创建一个类的子类来实现上面的这种效果： 12345public class Person { //先定义一个父类 String name; int age; String sex;} 接着我们可以创建各种各样的子类，想要继承一个类，我们只需要使用extends关键字即可： 123public class Worker extends Person{ //工人类 } 123public class Student extends Person{ //学生类} 类的继承可以不断向下，但是同时只能继承一个类，同时，标记为final的类不允许被继承： 123public final class Person { //class前面添加final关键字表示这个类已经是最终形态，不能继承 } 当一个类继承另一个类时，属性会被继承，可以直接访问父类中定义的属性，除非父类中将属性的访问权限修改为private，那么子类将无法访问（但是依然是继承了这个属性的）： 12345public class Student extends Person{ public void study(){ System.out.println(\"我的名字是 \"+name+\"，我在学习！\"); //可以直接访问父类中定义的name属性 }} 同样的，在父类中定义的方法同样会被子类继承： 123456789public class Person { String name; int age; String sex; public void hello(){ System.out.println(\"我叫 \"+name+\"，今年 \"+age+\" 岁了!\"); }} 子类直接获得了此方法，当我们创建一个子类对象时就可以直接使用这个方法： 12345public static void main(String[] args) { Student student = new Student(); student.study(); //子类不仅有自己的独特技能 student.hello(); //还继承了父类的全部技能} 是不是感觉非常人性化，子类继承了父类的全部能力，同时还可以扩展自己的独特能力，就像一句话说的： 龙生龙凤生凤，老鼠儿子会打洞。 如果父类存在一个有参构造方法，子类必须在构造方法中调用： 123456789101112131415161718public class Person { protected String name; //因为子类需要用这些属性，所以说我们就将这些变成protected，外部不允许访问 protected int age; protected String sex; protected String profession; //构造方法也改成protected，只能子类用 protected Person(String name, int age, String sex, String profession) { this.name = name; this.age = age; this.sex = sex; this.profession = profession; } public void hello(){ System.out.println(\"[\"+profession+\"] 我叫 \"+name+\"，今年 \"+age+\" 岁了!\"); }} 可以看到，此时两个子类都报错了： 因为子类在构造时，不仅要初始化子类的属性，还需要初始化父类的属性，所以说在默认情况下，子类其实是调用了父类的构造方法的，只是在无参的情况下可以省略，但是现在父类构造方法需要参数，那么我们就需要手动指定了： 既然现在父类需要三个参数才能构造，那么子类需要按照同样的方式调用父类的构造方法： 123456789public class Student extends Person{ public Student(String name, int age, String sex) { //因为学生职业已经确定，所以说学生直接填写就可以了 super(name, age, sex, \"学生\"); //使用super代表父类，父类的构造方法就是super() } public void study(){ System.out.println(\"我的名字是 \"+name+\"，我在学习！\"); }} 123456public class Worker extends Person{ public Worker(String name, int age, String sex) { super(name, age, sex, \"工人\"); //父类构造调用必须在最前面 System.out.println(\"工人构造成功！\"); //注意，在调用父类构造方法之前，不允许执行任何代码，只能在之后执行 }} 我们在使用子类时，可以将其当做父类来使用： 1234public static void main(String[] args) { Person person = new Student(\"小明\", 18, \"男\"); //这里使用父类类型的变量，去引用一个子类对象（向上转型） person.hello(); //父类对象的引用相当于当做父类来使用，只能访问父类对象的内容} 虽然我们这里使用的是父类类型引用的对象，但是这并不代表子类就彻底变成父类了，这里仅仅只是当做父类使用而已。 我们也可以使用强制类型转换，将一个被当做父类使用的子类对象，转换回子类： 12345public static void main(String[] args) { Person person = new Student(\"小明\", 18, \"男\"); Student student = (Student) person; //使用强制类型转换（向下转型） student.study();} 但是注意，这种方式只适用于这个对象本身就是对应的子类才可以，如果本身都不是这个子类，或者说就是父类，那么会出现问题： 12345public static void main(String[] args) { Person person = new Worker(\"小明\", 18, \"男\"); //实际创建的是Work类型的对象 Student student = (Student) person; student.study();} 此时直接出现了类型转换异常，因为本身不是这个类型，强转也没用。 那么如果我们想要判断一下某个变量所引用的对象到底是什么类，那么该怎么办呢？ 123456789public static void main(String[] args) { Person person = new Student(\"小明\", 18, \"男\"); if(person instanceof Student) { //我们可以使用instanceof关键字来对类型进行判断 System.out.println(\"对象是 Student 类型的\"); } if(person instanceof Person) { System.out.println(\"对象是 Person 类型的\"); }} 如果变量所引用的对象是对应类型或是对应类型的子类，那么instanceof都会返回true，否则返回false。 最后我们需要来特别说明一下，子类是可以定义和父类同名的属性的： 1234567public class Worker extends Person{ protected String name; //子类中同样可以定义name属性 public Worker(String name, int age, String sex) { super(name, age, sex, \"工人\"); }} 此时父类的name属性和子类的name属性是同时存在的，那么当我们在子类中直接使用时： 123public void work(){ System.out.println(\"我是 \"+name+\"，我在工作！\"); //这里的name，依然是作用域最近的哪一个，也就是在当前子类中定义的name属性，而不是父类的name属性} 所以说，我们在使用时，实际上这里得到的结果为null： 那么，在子类存在同名变量的情况下，怎么去访问父类的呢？我们同样可以使用super关键字来表示父类： 123public void work(){ System.out.println(\"我是 \"+super.name+\"，我在工作！\"); //这里使用super.name来表示需要的是父类的name变量} 这样得到的结果就不一样了： 但是注意，没有super.super这种用法，也就是说如果存在多级继承的话，那么最多只能通过这种方法访问到父类的属性（包括继承下来的属性） 顶层Object类实际上所有类都默认继承自Object类，除非手动指定继承的类型，但是依然改变不了最顶层的父类是Object类。所有类都包含Object类中的方法，比如： 我们发现，除了我们自己在类中编写的方法之外，还可以调用一些其他的方法，那么这些方法不可能无缘无故地出现，肯定同样是因为继承得到的，那么这些方法是继承谁得到的呢？ 1234public class Person extends Object{ //除非我们手动指定要继承的类是什么，实际上默认情况下所有的类都是继承自Object的，只是可以省略} 所以说我们的继承结构差不多就是： 既然所有的类都默认继承自Object，我们来看看这个类里面有哪些内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Object { private static native void registerNatives(); //标记为native的方法是本地方法，底层是由C++实现的 static { registerNatives(); //这个类在初始化时会对类中其他本地方法进行注册，本地方法不是我们SE中需要学习的内容，我们会在JVM篇视频教程中进行介绍 } //获取当前的类型Class对象，这个我们会在最后一章的反射中进行讲解，目前暂时不会用到 public final native Class&lt;?&gt; getClass(); //获取对象的哈希值，我们会在第五章集合类中使用到，目前各位小伙伴就暂时理解为会返回对象存放的内存地址 public native int hashCode(); //判断当前对象和给定对象是否相等，默认实现是直接用等号判断，也就是直接判断是否为同一个对象 public boolean equals(Object obj) { return (this == obj); } //克隆当前对象，可以将复制一个完全一样的对象出来，包括对象的各个属性 protected native Object clone() throws CloneNotSupportedException; //将当前对象转换为String的形式，默认情况下格式为 完整类名@十六进制哈希值 public String toString() { return getClass().getName() + \"@\" + Integer.toHexString(hashCode()); } //唤醒一个等待当前对象锁的线程，有关锁的内容，我们会在第六章多线程部分中讲解，目前暂时不会用到 public final native void notify(); //唤醒所有等待当前对象锁的线程，同上 public final native void notifyAll(); //使得持有当前对象锁的线程进入等待状态，同上 public final native void wait(long timeout) throws InterruptedException; //同上 public final void wait(long timeout, int nanos) throws InterruptedException { ... } //同上 public final void wait() throws InterruptedException { ... } //当对象被判定为已经不再使用的“垃圾”时，在回收之前，会由JVM来调用一次此方法进行资源释放之类的操作，这同样不是SE中需要学习的内容，这个方法我们会在JVM篇视频教程中详细介绍，目前暂时不会用到 protected void finalize() throws Throwable { }} 这里我们可以尝试调用一下Object为我们提供的toString()方法： 12345public static void main(String[] args) { Person person = new Student(\"小明\", 18, \"男\"); String str = person.toString(); System.out.println(str);} 这里就是按照上面说的格式进行打印： 当然，我们直接可以给println传入一个Object类型的对象： 1234567public void println(Object x) { String s = String.valueOf(x); //这里同样会调用对象的toString方法，所以说跟上面效果是一样的 synchronized (this) { print(s); newLine(); }} 有小伙伴肯定会好奇，这里不是接受的一个Object类型的值的，为什么任意类型都可以传入呢？因为所有类型都是继承自Object，如果方法接受的参数是一个引用类型的值，那只要是这个类的对象或是这个类的子类的对象，都可以作为参数传入。 我们也可以试试看默认提供的equals方法： 12345public static void main(String[] args) { Person p1 = new Student(\"小明\", 18, \"男\"); Person p2 = new Student(\"小明\", 18, \"男\"); System.out.println(p1.equals(p2));} 因为默认比较的是两个对象是否为同一个对象，所以说这里得到的肯定是false，但是有些情况下，实际上我们所希望的情况是如果名字、年龄、性别都完全相同，那么这肯定是同一个人，但是这里却做不到这样的判断，我们需要修改一下equals方法的默认实现来完成，这就要用到方法的重写了。 方法的重写注意，方法的重写不同于之前的方法重载，不要搞混了，方法的重载是为某个方法提供更多种类，而方法的重写是覆盖原有的方法实现，比如我们现在不希望使用Object类中提供的equals方法，那么我们就可以将其重写了： 123456789101112131415public class Person{ ... @Override //重写方法可以添加 @Override 注解，有关注解我们会在最后一章进行介绍，这个注解默认情况下可以省略 public boolean equals(Object obj) { //重写方法要求与父类的定义完全一致 if(obj == null) return false; //如果传入的对象为null，那肯定不相等 if(obj instanceof Person) { //只有是当前类型的对象，才能进行比较，要是都不是这个类型还比什么 Person person = (Person) obj; //先转换为当前类型，接着我们对三个属性挨个进行比较 return this.name.equals(person.name) &amp;&amp; //字符串内容的比较，不能使用==，必须使用equals方法 this.age == person.age &amp;&amp; //基本类型的比较跟之前一样，直接== this.sex.equals(person.sex); } return false; }} 在重写Object提供的equals方法之后，就会按照我们的方式进行判断了： 12345public static void main(String[] args) { Person p1 = new Student(\"小明\", 18, \"男\"); Person p2 = new Student(\"小明\", 18, \"男\"); System.out.println(p1.equals(p2)); //此时由于三个属性完全一致，所以说判断结果为真，即使是两个不同的对象} 有时候为了方便查看对象的各个属性，我们可以将Object类提供的toString方法重写了： 123456789@Overridepublic String toString() { //使用IDEA可以快速生成 return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + \", sex='\" + sex + '\\'' + \", profession='\" + profession + '\\'' + '}';} 这样，我们直接打印对象时，就会打印出对象的各个属性值了： 1234public static void main(String[] args) { Person person = new Student(\"小明\", 18, \"男\"); System.out.println(person);} 注意，静态方法不支持重写，因为它是属于类本身的，但是它可以被继承。 基于这种方法可以重写的特性，对于一个类定义的行为，不同的子类可以出现不同的行为，比如考试，学生考试可以得到A，而工人去考试只能得到D： 123456789public class Person { ... public void exam(){ System.out.println(\"我是考试方法\"); } ...} 12345678public class Student extends Person{ ... @Override public void exam() { System.out.println(\"我是学生，我就是小镇做题家，拿个 A 轻轻松松\"); }} 12345678public class Worker extends Person{ ... @Override public void exam() { System.out.println(\"我是工人，做题我并不擅长，只能得到 D\"); }} 这样，不同的子类，对于同一个方法会产生不同的结果： 1234567public static void main(String[] args) { Person person = new Student(\"小明\", 18, \"男\"); person.exam(); person = new Worker(\"小强\", 18, \"男\"); person.exam();} 这其实就是面向对象编程中多态特性的一种体现。 注意，我们如果不希望子类重写某个方法，我们可以在方法前添加final关键字，表示这个方法已经是最终形态： 123public final void exam(){ System.out.println(\"我是考试方法\");} 或者，如果父类中方法的可见性为private，那么子类同样无法访问，也就不能重写，但是可以定义同名方法： 虽然这里可以编译通过，但是并不是对父类方法的重写，仅仅是子类自己创建的一个新方法。 还有，我们在重写父类方法时，如果希望调用父类原本的方法实现，那么同样可以使用super关键字： 12345@Overridepublic void exam() { super.exam(); //调用父类的实现 System.out.println(\"我是工人，做题我并不擅长，只能得到 D\");} 然后就是访问权限的问题，子类在重写父类方法时，不能降低父类方法中的可见性： 123public void exam(){ System.out.println(\"我是考试方法\");} 因为子类实际上可以当做父类使用，如果子类的访问权限比父类还低，那么在被当做父类使用时，就可能出现无视访问权限调用的情况，这样肯定是不行的，但是相反的，我们可以在子类中提升权限： 123protected void exam(){ System.out.println(\"我是考试方法\");} 1234@Overridepublic void exam() { //将可见性提升为public System.out.println(\"我是工人，做题我并不擅长，只能得到 D\");} 可以看到作为子类时就可以正常调用，但是如果将其作为父类使用，因为访问权限不足所有就无法使用，总之，子类重写的方法权限不能比父类还低。 抽象类在我们学习了类的继承之后，实际上我们会发现，越是处于顶层定义的类，实际上可以进一步地进行抽象，比如我们前面编写的考试方法： 123protected void exam(){ System.out.println(\"我是考试方法\");} 这个方法再子类中一定会被重写，所以说除非子类中调用父类的实现，否则一般情况下永远都不会被调用，就像我们说一个人会不会考试一样，实际上人怎么考试是一个抽象的概念，而学生怎么考试和工人怎么考试，才是具体的一个实现，所以说，我们可以将人类进行进一步的抽象，让某些方法完全由子类来实现，父类中不需要提供实现。 要实现这样的操作，我们可以将人类变成抽象类，抽象类比类还要抽象： 123456789101112131415public abstract class Person { //通过添加abstract关键字，表示这个类是一个抽象类 protected String name; //大体内容其实普通类差不多 protected int age; protected String sex; protected String profession; protected Person(String name, int age, String sex, String profession) { this.name = name; this.age = age; this.sex = sex; this.profession = profession; } public abstract void exam(); //抽象类中可以具有抽象方法，也就是说这个方法只有定义，没有方法体} 而具体的实现，需要由子类来完成，而且如果是子类，必须要实现抽象类中所有抽象方法： 1234567891011public class Worker extends Person{ public Worker(String name, int age, String sex) { super(name, age, sex, \"工人\"); } @Override public void exam() { //子类必须要实现抽象类所有的抽象方法，这是强制要求的，否则会无法通过编译 System.out.println(\"我是工人，做题我并不擅长，只能得到 D\"); }} 抽象类由于不是具体的类定义（它是类的抽象）可能会存在某些方法没有实现，因此无法直接通过new关键字来直接创建对象： 要使用抽象类，我们只能去创建它的子类对象。 抽象类一般只用作继承使用，当然，抽象类的子类也可以是一个抽象类： 12345678910public abstract class Student extends Person{ //如果抽象类的子类也是抽象类，那么可以不用实现父类中的抽象方法 public Student(String name, int age, String sex) { super(name, age, sex, \"学生\"); } @Override //抽象类中并不是只能有抽象方法，抽象类中也可以有正常方法的实现 public void exam() { System.out.println(\"我是学生，我就是小镇做题家，拿个 A 轻轻松松\"); }} 注意，抽象方法的访问权限不能为private： 因为抽象方法一定要由子类实现，如果子类都访问不了，那么还有什么意义呢？所以说不能为私有。 接口接口甚至比抽象类还抽象，他只代表某个确切的功能！也就是只包含方法的定义，甚至都不是一个类！接口一般只代表某些功能的抽象，接口包含了一些列方法的定义，类可以实现这个接口，表示类支持接口代表的功能（类似于一个插件，只能作为一个附属功能加在主体上，同时具体实现还需要由主体来实现） 咋一看，这啥意思啊，什么叫支持接口代表的功能？实际上接口的目标就是将类所具有某些的行为抽象出来。 比如说，对于人类的不同子类，学生和老师来说，他们都具有学习这个能力，既然都有，那么我们就可以将学习这个能力，抽象成接口来进行使用，只要是实现这个接口的类，都有学习的能力： 123public interface Study { //使用interface表示这是一个接口 void study(); //接口中只能定义访问权限为public抽象方法，其中public和abstract关键字可以省略} 我们可以让类实现这个接口： 12345678910public class Student extends Person implements Study { //使用implements关键字来实现接口 public Student(String name, int age, String sex) { super(name, age, sex, \"学生\"); } @Override public void study() { //实现接口时，同样需要将接口中所有的抽象方法全部实现 System.out.println(\"我会学习！\"); }} 12345678910public class Teacher extends Person implements Study { protected Teacher(String name, int age, String sex) { super(name, age, sex, \"教师\"); } @Override public void study() { System.out.println(\"我会加倍学习！\"); }} 接口不同于继承，接口可以同时实现多个： 123public class Student extends Person implements Study, A, B, C { //多个接口的实现使用逗号隔开 } 所以说有些人说接口其实就是Java中的多继承，但是我个人认为这种说法是错的，实际上实现接口更像是一个类的功能列表，作为附加功能存在，一个类可以附加很多个功能，接口的使用和继承的概念有一定的出入，顶多说是多继承的一种替代方案。 接口跟抽象类一样，不能直接创建对象，但是我们也可以将接口实现类的对象以接口的形式去使用： 当做接口使用时，只有接口中定义的方法和Object类的方法，无法使用类本身的方法和父类的方法。 接口同样支持向下转型： 1234567public static void main(String[] args) { Study study = new Teacher(\"小王\", 27, \"男\"); if(study instanceof Teacher) { //直接判断引用的对象是不是Teacher类型 Teacher teacher = (Teacher) study; //强制类型转换 teacher.study(); }} 这里的使用其实跟之前的父类是差不多的。 从Java8开始，接口中可以存在方法的默认实现： 1234567public interface Study { void study(); default void test() { //使用default关键字为接口中的方法添加默认实现 System.out.println(\"我是默认实现\"); }} 如果方法在接口中存在默认实现，那么实现类中不强制要求进行实现。 接口不同于类，接口中不允许存在成员变量和成员方法，但是可以存在静态变量和静态方法，在接口中定义的变量只能是： 123456789public interface Study { public static final int a = 10; //接口中定义的静态变量只能是public static final的 public static void test(){ //接口中定义的静态方法也只能是public的 System.out.println(\"我是静态方法\"); } void study();} 跟普通的类一样，我们可以直接通过接口名.的方式使用静态内容： 1234public static void main(String[] args) { System.out.println(Study.a); Study.test();} 接口是可以继承自其他接口的： 123public interface A exetnds B { } 并且接口没有继承数量限制，接口支持多继承： 123public interface A exetnds B, C, D { } 接口的继承相当于是对接口功能的融合罢了。 最后我们来介绍一下Object类中提供的克隆方法，为啥要留到这里才来讲呢？因为它需要实现接口才可以使用： 1234package java.lang;public interface Cloneable { //这个接口中什么都没定义} 实现接口后，我们还需要将克隆方法的可见性提升一下，不然还用不了： 123456789101112131415public class Student extends Person implements Study, Cloneable { //首先实现Cloneable接口，表示这个类具有克隆的功能 public Student(String name, int age, String sex) { super(name, age, sex, \"学生\"); } @Override public Object clone() throws CloneNotSupportedException { //提升clone方法的访问权限 return super.clone(); //因为底层是C++实现，我们直接调用父类的实现就可以了 } @Override public void study() { System.out.println(\"我会学习！\"); }} 接着我们来尝试一下，看看是不是会得到一个一模一样的对象： 1234567public static void main(String[] args) throws CloneNotSupportedException { //这里向上抛出一下异常，还没学异常，所以说照着写就行了 Student student = new Student(\"小明\", 18, \"男\"); Student clone = (Student) student.clone(); //调用clone方法，得到一个克隆的对象 System.out.println(student); System.out.println(clone); System.out.println(student == clone);} 可以发现，原对象和克隆对象，是两个不同的对象，但是他们的各种属性都是完全一样的： 通过实现接口，我们就可以很轻松地完成对象的克隆了，在我们之后的学习中，还会经常遇到接口的使用。 注意：以下内容为选学内容，在设计模式篇视频教程中有详细介绍。 克隆操作可以完全复制一个对象的所有属性，但是像这样的拷贝操作其实也分为浅拷贝和深拷贝。 浅拷贝：对于类中基本数据类型，会直接复制值给拷贝对象；对于引用类型，只会复制对象的地址，而实际上指向的还是原来的那个对象，拷贝个基莫。 深拷贝：无论是基本类型还是引用类型，深拷贝会将引用类型的所有内容，全部拷贝为一个新的对象，包括对象内部的所有成员变量，也会进行拷贝。 那么clone方法出来的克隆对象，是深拷贝的结果还是浅拷贝的结果呢？ 12345public static void main(String[] args) throws CloneNotSupportedException { Student student = new Student(\"小明\", 18, \"男\"); Student clone = (Student) student.clone(); System.out.println(student.name == clone.name);} 可以看到，虽然Student对象成功拷贝，但是其内层对象并没有进行拷贝，依然只是对象引用的复制，所以Java为我们提供的clone方法只会进行浅拷贝。 枚举类假设现在我们想给小明添加一个状态（跑步、学习、睡觉），外部可以实时获取小明的状态： 123456789101112public class Student extends Person implements Study { private String status; //状态，可以是跑步、学习、睡觉这三个之中的其中一种 public String getStatus() { return status; } public void setStatus(String status) { this.status = status; }} 但是这样会出现一个问题，如果我们仅仅是存储字符串，似乎外部可以不按照我们规则，传入一些其他的字符串。这显然是不够严谨的，有没有一种办法，能够更好地去实现这样的状态标记呢？我们希望开发者拿到使用的就是我们预先定义好的状态，所以，我们可以使用枚举类来完成： 123public enum Status { //enum表示这是一个枚举类，枚举类的语法稍微有一些不一样 RUNNING, STUDY, SLEEP; //直接写每个状态的名字即可，最后面分号可以不打，但是推荐打上} 使用枚举类也非常方便，就像使用普通类型那样： 123456789private Status status; //类型变成刚刚定义的枚举类public Status getStatus() { return status;}public void setStatus(Status status) { this.status = status;} 这样，别人在使用时，就能很清楚地知道我们支持哪些了： 枚举类型使用起来就非常方便了，其实枚举类型的本质就是一个普通的类，但是它继承自Enum类，我们定义的每一个状态其实就是一个public static final的Status类型成员变量： 123456789//这里使用javap命令对class文件进行反编译得到 Compiled from \"Status.java\"public final class com.test.Status extends java.lang.Enum&lt;com.test.Status&gt; { public static final com.test.Status RUNNING; public static final com.test.Status STUDY; public static final com.test.Status SLEEP; public static com.test.Status[] values(); public static com.test.Status valueOf(java.lang.String); static {};} 既然枚举类型是普通的类，那么我们也可以给枚举类型添加独有的成员方法： 123456789101112public enum Status { RUNNING(\"睡觉\"), STUDY(\"学习\"), SLEEP(\"睡觉\"); //无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法） private final String name; //枚举的成员变量 Status(String name){ //覆盖原有构造方法（默认private，只能内部使用！） this.name = name; } public String getName() { //获取封装的成员变量 return name; }} 这样，枚举就可以按照我们想要的中文名称打印了： 12345public static void main(String[] args) { Student student = new Student(\"小明\", 18, \"男\"); student.setStatus(Status.RUNNING); System.out.println(student.getStatus().getName());} 枚举类还自带一些继承下来的实用方法，比如获取枚举类中的所有枚举，只不过这里用到了数组，我们会在下一章进行介绍。 至此，面向对象基础内容就全部讲解完成了，下一章我们还将继续讲解面向对象的其他内容。","categories":[],"tags":[]},{"title":"","slug":"白马Java/JavaSE笔记（二）重制版","date":"2025-09-07T23:26:13.331Z","updated":"2025-09-07T23:28:25.711Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/0.html","excerpt":"面向过程篇前面我们已经认识了Java语言的相关特性，并且已经成功配置好了开发环境，从这节课开始，我们就可以正式进入到Java语言的学习当中了。Java语言是一门面向对象的语言，但是在面向对象之前，我们还得先学会如何面向过程编程。 Java程序基础首先我们还是从最基本的Java程序基础开始讲解。 程序代码基本结构还记得我们之前使用的示例代码吗？ 12345public class Main { public static void main(String[] args) { System.out.println(\"Hello World!\"); }} 这段代码要实现的功能很简单，就是将 Hello World 输出到控制台就行。","text":"面向过程篇前面我们已经认识了Java语言的相关特性，并且已经成功配置好了开发环境，从这节课开始，我们就可以正式进入到Java语言的学习当中了。Java语言是一门面向对象的语言，但是在面向对象之前，我们还得先学会如何面向过程编程。 Java程序基础首先我们还是从最基本的Java程序基础开始讲解。 程序代码基本结构还记得我们之前使用的示例代码吗？ 12345public class Main { public static void main(String[] args) { System.out.println(\"Hello World!\"); }} 这段代码要实现的功能很简单，就是将 Hello World 输出到控制台就行。 由于我们还没有学习到类的相关性质，所以在第二章之前，各位小伙伴直接记住固定模式即可，首先我们创建的源文件名称需要为Main.java然后编写的代码第一行： 123public class Main { } 注意需要区分大小写，Java语言严格区分大小写，如果我们没有按照规则来编写，那么就会出现红色波浪线报错： 只要源代码中存在报错的地方，就无法正常完成编译得到二进制文件，会提示构建失败： 注意最后还有一个花括号，并且此花括号是成对出现的，一一对应。 所以说各位小伙伴在编写代码时一定要注意大小写。然后第二行，准确的说是最外层花括号内部就是： 123public static void main(String[] args) { } 这是我们整个Java程序的入口点，我们称为主方法（如果你学习过C肯定能够联想到主函数，只不过Java中不叫函数，叫方法）最后也会有一个花括号成对出现，而在主方法的花括号中编写的代码，就是按照从上往下的顺序依次执行的。 比如我们之前编写的： 1System.out.println(\"Hello World!\"); 这段代码的意思就是将双引号括起来的内容（字符串，我们会在后面进行讲解）输出（打印）到控制台上，可以看到最后还加上了一个;符号，表示这一句代码结束。我们每一段代码结束时都需要加上一个分号表示这一句的结束，就像我们写作文一样。 比如下面的代码，我们就可以实现先打印Hello World!，然后再打印YYDS!到控制台。 123456public class Main { public static void main(String[] args) { System.out.println(\"Hello World!\"); System.out.println(\"YYDS!\"); }} 效果如下： 如果两段代码没有加上分号分割，那么编译器会认为这两段代码是同一句代码中的，即使出现换行或者是空格： 这里IDEA很聪明，会提醒我们这里少加了分号，所以说这个IDEA能够在初期尽可能地帮助新手。 再比如下面的代码： 这里我们尝试在中途换行和添加空格，因为没有添加分号，所以说编译器依然会认为是一行代码，因此编译不会出现错误，能够正常通过。当然，为了代码写得工整和规范，我们一般不会随意进行换行编写或者是添加没必要的空格。 同样的，如果添加了分号，即使在同一行，也会被认为是两句代码： 如果在同一行就是从左往右的顺序，得到的结果跟上面是一样的。 注释我们在编写代码时，可能有些时候需要标记一下这段代码表示什么意思： 但是如果直接写上文字的话，会导致编译不通过，因为这段文字也会被认为是程序的一部分。 这种情况，我们就可以告诉编译器，这段文字是我们做的笔记，并不是程序的一部分，那么要怎么告诉编译器这不是代码呢？很简单，我们只需要在前面加上双斜杠就可以了： 添加双斜杠之后（自动变成了灰色），后续的文本内容只要没有发生换行，那么都会被认为是一段注释，并不属于程序，在编译时会被直接忽略，之后这段注释也不会存在于程序中。但是一旦发生换行那就不行了： 那要是此时注释很多，一行写不完，我们想要编写很多行的注释呢？我们可以使用多行注释标记： 12345678910public class Main { public static void main(String[] args) { /* 这里面的内容 无论多少行 都可以 */ System.out.println(\"Hello World!\"); }} 多行可以使用/*和*/的组合来囊括需要编写的注释内容。 当然还有一种方式就是使用/**来进行更加详细的文档注释： 这种注释可以用来自动生成文档，当我们鼠标移动到Main上时，会显示相关的信息，我们可以自由添加一些特殊的注释，比如作者、时间等信息，也可以是普通的文字信息。 变量与常量我们的程序不可能永远都只进行上面那样的简单打印操作，有些时候可能需要计算某些数据，此时我们就需要用到变量了。 那么，什么是变量呢？我们在数学中其实已经学习过变量了： 变量，指值可以变的量。变量以非数字的符号来表达，一般用拉丁字母。变量的用处在于能一般化描述指令的方式。结果只能使用真实的值，指令只能应用于某些情况下。变量能够作为某特定种类的值中任何一个的保留器。 比如一个公式 $x^2 + 6 = 22$ 此时x就是一个变量，变量往往代表着某个值，比如这里的x就代表的是4这个值。在Java中，我们也可以让变量去代表一个具体的值，并且变量的值是可以发生变化的。 要声明一个变量，我们需要使用以下格式： 1[数据类型] [变量名称]; 这里的数据类型我们会在下节课开始逐步讲解，比如整数就是int类型，不同类型的变量可以存储不同的类型的值。后面的变量名称顾名思义，就像x一样，这个名称我们可以随便起一个，但是注意要满足以下要求： 标识符可以由大小写字母、数字、下划线(_)和美元符号($)组成，但是不能以数字开头。 变量不能重复定义，大小写敏感，比如A和a就是两个不同的变量。 不能有空格、@、#、+、-、/ 等符号。 应该使用有意义的名称，达到见名知意的目的（一般我们采用英文单词），最好以小写字母开头。 不可以是 true 和 false。 不能与Java语言的关键字或是基本数据类型重名，关键字列表如下： ![image-20220916224014438](/Users/nagocoler/Library/Application Support/typora-user-images/image-20220916224014438.png) 当然各位小伙伴没必要刻意去进行记忆，我们会在学习的过程中逐步认识到这些关键字。新手要辨别一个单词是否为关键字，只需要通过IDEA的高亮颜色进行区分即可，比如： 深色模式下，关键字会高亮为橙色，浅色模式下会高亮为深蓝色，普通的代码都是正常的灰白色。 比如现在我们想要定义一个变量a，那么就可以这样编写： 12345public class Main { public static void main(String[] args) { int a; //声明一个整数类型变量a }} 但是这个变量一开始没有任何值，比如现在我们要让这个变量表示10，那么就可以将10赋值给这个变量： 123public static void main(String[] args) { int a = 10; //直接在定义变量后面添加 = 10，表示这个变量的初始值为10，这里的10就是一个常量数字} 或者我们可以在使用时再对其进行赋值： 1234public static void main(String[] args) { int a; a = 10; //使用时再赋值也可以} 是不是感觉跟数学差不多？这种写法对于我们人来说，实际上是很好理解的，意思表达很清晰。 我们可以一次性定义多个变量，比如现在我们想定义两个int类型的变量： 123public static void main(String[] args) { int a, b; //定义变量a和变量b，中间使用逗号隔开就行了} 或者两个变量单独声明也可以： 1234public static void main(String[] args) { int a; //分两句进行声明 int b;} 为了更直观地查看变量的值，我们可以直接将变量的值也给打印到控制台： 12345public static void main(String[] args) { int a = 666; System.out.println(a); //之前我们在小括号写的是\"\"，现在我们直接将变量给进去就可以打印变量的值了 System.out.println(888); //甚至直接输出一个常量值都可以} 得到结果： 变量的值也可以在中途进行修改： 12345public static void main(String[] args) { int a = 666; a = 777; System.out.println(a); //这里打印得到的值就是777了} 变量的值也可以直接指定为其他变量的值： 12345public static void main(String[] args) { int a = 10; int b = a; //直接让b等于a，那么a的值就会给到b System.out.println(b); //这里输出的就是10了} 我们还可以让变量与数值之间做加减法（运算符会在后面详细介绍）： 12345public static void main(String[] args) { int a = 9; //a初始值为9 a = a + 1; //a = a + 1也就是将a+1的结果赋值给a，跟数学是一样的，很好理解对吧 System.out.println(a); //最后得到的结果就是10了} 有时候我们希望变量的值一直保持不变，我们就可以将其指定为常量，这里我们介绍Java中第一个需要认识的关键字： 1234public static void main(String[] args) { final int a = 666; //在变量前面添加final关键字，表示这是一个常量 a = 777; //常量的值不允许发生修改} 编译时出现： 常量的值只有第一次赋值可以修改，其他任何情况下都不行： 1234public static void main(String[] args) { final int a; a = 777; //第一次赋值} 至此，Java的基础语法部分介绍完毕，下一部分我们将开始介绍Java中的几大基本数据类型。 基本数据类型我们的程序中可能需要表示各种各样的数据，比如整数、小数、字符等等，这一部分我们将探索Java中的八大基本数据类型。只不过在开始之前，我们还需要先补充一点简单的计算机小知识。 计算机中的二进制表示在计算机中，所有的内容都是二进制形式表示。十进制是以10为进位，如9+1=10；二进制则是满2进位（因为我们的计算机是电子的，电平信号只有高位和低位，你也可以暂且理解为通电和不通电，高电平代表1，低电平代表0，由于只有0和1，因此只能使用2进制表示我们的数字！）比如1+1=10=2^1+0，一个位也叫一个bit，8个bit称为1字节，16个bit称为一个字，32个bit称为一个双字，64个bit称为一个四字，我们一般采用字节来描述数据大小。 注意这里的bit跟我们生活中的网速MB/s是不一样的，小b代表的是bit，大B代表的是Byte字节（8bit = 1Byte字节），所以说我们办理宽带的时候，100Mbps这里的b是小写的，所以说实际的网速就是100/8 = 12.5 MB/s了。 十进制的7 -&gt; 在二进制中为 111 = 2^2 + 2^1 + 2^0 现在有4个bit位，最大能够表示多大的数字呢？ 最小：0000 =&gt; 0 最大：1111 =&gt; 2^3 + 2^2 + 2^1 + 2^0 =&gt; 8 + 4 + 2 + 1 = 15 在Java中，无论是小数还是整数，他们都要带有符号（和C语言不同，C语言有无符号数）所以，首位就作为我们的符号位，还是以4个bit为例，首位现在作为符号位（1代表负数，0代表正数）： 最小：1111 =&gt; -(2^2 + 2^1 + 2^0) =&gt; -7 最大：0111 =&gt; +(2^2 + 2^1 + 2^0) =&gt; +7 =&gt; 7 现在，我们4bit能够表示的范围变为了-7~+7，这样的表示方式称为原码。虽然原码表示简单，但是原码在做加减法的时候，很麻烦！以4bit位为例： 1+(-1) = 0001 + 1001 = 怎么让计算机去计算？（虽然我们知道该去怎么算，但是计算机不知道！） 我们得创造一种更好的表示方式！于是我们引入了反码： 正数的反码是其本身 负数的反码是在其原码的基础上, 符号位不变，其余各个位取反 经过上面的定义，我们再来进行加减法： 1+(-1) = 0001 + 1110 = 1111 =&gt; -0 （直接相加，这样就简单多了！） 思考：1111代表-0，0000代表+0，在我们实数的范围内，0有正负之分吗？0既不是正数也不是负数，那么显然这样的表示依然不够合理！根据上面的问题，我们引入了最终的解决方案，那就是补码，定义如下： 正数的补码就是其本身 （不变！） 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1（即在反码的基础上+1，此时1000表示-8） 对补码再求一次补码就可得该补码对应的原码。 比如-7原码为1111，反码为1000，补码就是1001了，-6原码为1110，反码为1001，补码就是1010。所以在补码下，原本的1000就作为新增的最小值-8存在。 所以现在就已经能够想通，-0已经被消除了！我们再来看上面的运算： 1+(-1) = 0001 + 1111 = (1)0000 =&gt; +0 （现在无论你怎么算，也不会有-0了！） 所以现在，1111代表的不再是-0，而是-1，相应的，由于消除-0，负数多出来一个可以表示的数（1000拿去表示-8了），那么此时4bit位能够表示的范围是：-8~+7（Java使用的就是补码！）在了解了计算机底层的数据表示形式之后，我们再来学习这些基本数据类型就会很轻松了。 整数类形整数类型是最容易理解的类型！既然我们知道了计算机中的二进制数字是如何表示的，那么我们就可以很轻松的以二进制的形式来表达我们十进制的内容了。 在Java中，整数类型包括以下几个： byte 字节型 （8个bit，也就是1个字节）范围：-128~+127 short 短整形（16个bit，也就是2个字节）范围：-32768~+32767 int 整形（32个bit，也就是4个字节）最常用的类型：-2147483648 ~ +2147483647 long 长整形（64个bit，也就是8个字节）范围：-9223372036854775808 ~ +9223372036854775807 这里我们来使用一下，其实这几种变量都可以正常表示整数： 1234public static void main(String[] args) { short a = 10; System.out.println(a);} 因为都可以表示整数，所以说我们可以将小的整数类型值传递给大的整数类型： 12345public static void main(String[] args) { short a = 10; int b = a; //小的类型可以直接传递给表示范围更大的类型 System.out.println(b);} 反之会出现报错： 这是由于我们在将小的整数类型传递给大的整数类型时发生了隐式类型转换，只要是从存储范围小的类型到存储范围大的类型，都支持隐式类型转换，它可以自动将某种类型的值，转换为另一种类型，比如上面就是将short类型的值转换为了int类型的值。 隐式类型转换不仅可以发生在整数之间，也可以是其他基本数据类型之间，我们后面会逐步介绍。 实际上我们在为变量赋一个常量数值时，也发生了隐式类型转换，比如： 123public static void main(String[] args) { byte b = 10; //这里的整数常量10，实际上默认情况下是int类型，但是由于正好在对应类型可以表示的范围内，所以说直接转换为了byte类型的值} 由于直接编写的整数常量值默认为int，这里需要特别注意一下，比如下面这种情况： 按照long类型的规定，实际上是可以表示这么大的数字的，但是为什么这里报错了呢？这是因为我们直接在代码中写的常量数字，默认情况下就是int类型，这么大肯定是表示不下的，如果需要将其表示为一个long类型的常量数字，那么需要在后面添加大写或是小写的L才可以。 123public static void main(String[] args) { long a = 922337203685477580L; //这样就可以正常编译通过了} 当然，针对于这种很长的数字，为了提升辨识度，我们可以使用下划线分割每一位： 123public static void main(String[] args) { int a = 1_000_000; //当然这里依然表示的是1000000，没什么区别，但是辨识度会更高} 我们也可以以8进制或是16进制表示一个常量值： 1234public static void main(String[] args) { System.out.println(0xAF); System.out.println(032);} 十六进制：以0x开头的都是十六进制表示法，十六进制满16进一，但是由于我们的数学只提供了0-9这十个数字，10、11、12…15该如何表示呢，我们使用英文字母A按照顺序开始表示，A表示10、B表示11…F表示15。比如上面的0xA实际上就是我们十进制中的10。 八进制：以0开头的都是八进制表示法，八进制就是满8进一，所以说只能使用0-7这几个数字，比如上面的012实际上就是十进制的10。 我们最后再来看一个问题： 12345public static void main(String[] args) { int a = 2147483647; //int最大值 a = a + 1; //继续加 System.out.println(a);} 此时a的值已经来到了int类型所能表示的最大值了，那么如果此时再继续+1，各位小伙伴觉得会发生什么？可以看到结果很奇怪： 什么情况？？？怎么正数加1还变成负数了？请各位小伙伴回想一下我们之前讲解的原码、反码和补码。 我们先来看看，当int为最大值时，二进制表示形式为什么： 2147483647 = 01111111 11111111 11111111 11111111（第一个是符号位0，其他的全部为1，就是正数的最大值） 那么此时如果加1，会进位成： 10000000 00000000 00000000 00000000 各位想一想，符号位为1，那么此时表示的不就是一个负数了吗？我们回想一下负数的补码表示规则，瞬间就能明白了，这不就是补码形式下的最小值了吗？ 所以说最后的结果就是int类型的最小值：-2147483648，是不是感觉了解底层原理会更容易理解这是为什么。 浮点类型前面我们介绍了整数类型，我们接着来看看浮点类型，在Java中也可以轻松地使用小数。 首先来看看Java中的小数类型包含哪些： float 单精度浮点型 （32bit，4字节） double 双精度浮点型（64bit，8字节） 那么小数在计算机中又是如何存放的呢？相较于整数，要稍微复杂一点： 根据国际标准 IEEE 754，任意一个二进制浮点数 V 可以表示成下面的形式：$$V = (-1)^S \\times M \\times 2^E$$ $(-1)^S$ 表示符号位，当 S=0，V 为正数；当 S=1，V 为负数。 M 表示有效数字，大于等于 1，小于 2，但整数部分的 1 不变，因此可以省略。（例如尾数为1111010，那么M实际上就是1.111010，尾数首位必须是1，1后面紧跟小数点，如果出现0001111这样的情况，去掉前面的0，移动1到首位，随着时间的发展，IEEE 754标准默认第一位为1，故为了能够存放更多数据，就舍去了第一位，比如保存1.0101 的时候， 只保存 0101，这样能够多存储一位数据） $2^E$ 表示指数位。（用于移动小数点，所以说才称为浮点型） 比如， 对于十进制的 5.25 对应的二进制为：101.01，相当于：$1.0101 \\times 2^2$。所以，S 为 0，M 为 1.0101，E 为 2。因此，对于浮点类型，最大值和最小值不仅取决于符号和尾数，还有它的阶码，所以浮点类型的大致取值范围： 单精度：$±3.40282347 \\times 10^{38}$ 双精度：$±1.79769313486231570 \\times 10^{308}$ 我们可以直接创建浮点类型的变量： 123public static void main(String[] args) { double a = 10.5, b = 66; //整数类型常量也可以隐式转换到浮点类型} 注意，跟整数类型常量一样，小数类型常量默认都是double类型，所以说如果我们直接给一个float类型赋值： 由于float类型的精度不如double，如果直接给其赋一个double类型的值，会直接出现错误。 同样的，我们可以给常量后面添加大写或小写的F来表示这是一个float类型的常量值： 123public static void main(String[] args) { float f = 9.9F; //这样就可以正常编译通过了} 但是反之，由于double精度更大，所以说可以直接接收float类型的值： 12345public static void main(String[] args) { float f = 9.9F; double a = f; //隐式类型转换为double值 System.out.println(a);} 只不过由于精度问题，最后的打印结果： 这种情况是正常的，因为浮点类型并不保证能够精确计算，我们会在下一章介绍 BigDecimal 和 BigInteger，其中BigDecimal更适合需要精确计算的场景。 我们最后来看看下面的例子： 12345public static void main(String[] args) { long l = 21731371236768L; float f = l; //这里能编译通过吗？ System.out.println(f);} 此时我们发现，long类型的值居然可以直接丢给float类型隐式类型转换，很明显float只有32个bit位，而long有足足64个，这是什么情况？怎么大的还可以隐式转换为小的？这是因为虽然float空间没有那么大，但是由于是浮点类型，指数可以变化，最大的数值表示范围实际上是大于long类型的，虽然会丢失精度，但是确实可以表示这么大的数。 所以说我们来总结一下隐式类型转换规则：byte→short(char)→int→long→float→double 字符类型字符类型也是一个重要的基本数据类型，它可以表示计算机中的任意一个字符（包括中文、英文、标点等一切可以显示出来的字符） char 字符型（16个bit，也就是2字节，它不带符号）范围是0 ~ 65535 可以看到char类型依然存储的是数字，那么它是如何表示每一个字符的呢？实际上每个数字在计算机中都会对应一个字符，首先我们需要介绍ASCII码： 比如我们的英文字母A要展示出来，那就是一个字符的形式，而其对应的ASCII码值为65，所以说当char为65时，打印出来的结果就是大写的字母A了： 1234public static void main(String[] args) { char c = 65; System.out.println(c);} 得到结果为： 或者我们也可以直接写一个字符常量值赋值： 1234public static void main(String[] args) { char c = 'A'; //字符常量值需要使用单引号囊括，并且内部只能有一个字符 System.out.println(c);} 这种写法效果与上面是一样的。 不过，我们回过来想想，这里的字符表里面不就128个字符吗，那char干嘛要两个字节的空间来存放呢？我们发现表中的字符远远没有我们所需要的那么多，这里只包含了一些基础的字符，中文呢？那么多中文字符（差不多有6000多个），用ASCII编码表那128个肯定是没办法全部表示的，但是我们现在需要在电脑中使用中文。这时，我们就需要扩展字符集了。 我们可以使用两个甚至多个字节来表示一个中文字符，这样我们能够表示的数量就大大增加了，GB2132方案规定当连续出现两个大于127的字节时（注意不考虑符号位，此时相当于是第一个bit位一直为1了），表示这是一个中文字符（所以为什么常常有人说一个英文字符占一字节，一个中文字符占两个字节），这样我们就可以表示出超过7000种字符了，不仅仅是中文，甚至中文标点、数学符号等，都可以被正确的表示出来。 不过这样能够表示的内容还是不太够，除了那些常见的汉字之外，还有很多的生僻字，比如龘、錕、釿、拷这类的汉字，后来干脆直接只要第一个字节大于127，就表示这是一个汉字的开始，无论下一个字节是什么内容（甚至原来的128个字符也被编到新的表中），这就是Windows至今一直在使用的默认GBK编码格式。 虽然这种编码方式能够很好的解决中文无法表示的问题，但是由于全球还有很多很多的国家以及很多很多种语言，所以我们的最终目标是能够创造一种可以表示全球所有字符的编码方式，整个世界都使用同一种编码格式，这样就可以同时表示全球的语言了。所以这时就出现了一个叫做ISO的（国际标准化组织）组织，来定义一套编码方案来解决所有国家的编码问题，这个新的编码方案就叫做Unicode（准确的说应该是规定的字符集，包含了几乎全世界所有语言的字符），规定每个字符必须使用两个字节，即用16个bit位来表示所有的字符（也就是说原来的那128个字符也要强行用两位来表示） 但是这样的话实际上是很浪费资源的，因为这样很多字符都不会用到两字节来保存，肯定不能直接就这样去表示，这会导致某些字符浪费了很多空间，我们需要一个更加好用的具体的字符编码方式。所以最后就有了UTF-8编码格式（它是Unicode字符集的一个编码规则），区分每个字符的开始是根据字符的高位字节来区分的，比如用一个字节表示的字符，第一个字节高位以“0”开头；用两个字节表示的字符，第一个字节的高位为以“110”开头，后面一个字节以“10开头”；用三个字节表示的字符，第一个字节以“1110”开头，后面俩字节以“10”开头；用四个字节表示的字符，第一个字节以“11110”开头，后面的三个字节以“10”开头： 110000011 10000110 //这就是一个连续出现都大于127的字节（注意这里是不考虑符号位的） 所以如果我们的程序需要表示多种语言，最好采用UTF-8编码格式，随着更多的字符加入，实际上两个字节也装不下了，可能需要3个甚至4个字节才能表示某些符号，后来就有了UTF-16编码格式，Java在运行时采用的就是UTF-16，几乎全世界的语言用到的字符都可以表示出来。 Unicode符号范围（十六进制） UTF-8编码方式(二进制) 0000 0000 ~ 0000 007F 0xxxxxxx 0000 0080 ~ 0000 07FF 110xxxxx 10xxxxxx 0000 0800 ~ 0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 0001 0000 ~ 0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 注意：Unicode 是“字符集”，也就是有哪些字符，而UTF-8、UTF-16 是“编码规则”，也就是怎么对这些字符编码，怎么以二进制的形式保存，千万不要搞混了。 简而言之，char实际上需要两个字节才能表示更多种类的字符，所以，char类型可以直接表示一个中文字符： 1234public static void main(String[] args) { int a = '淦'; //使用int类型接收字符类型常量值可以直接转换为对应的编码 System.out.println(a);} 得到结果为： Java程序在编译为.class文件之后，会采用UTF-8的编码格式，支持的字符也非常多，所以你甚至可以直接把变量名写成中文，依然可以编译通过： 介绍完了字符之后，我们接着来看看字符串，其实字符串我们在一开始就已经接触到了。字符虽然可以表示一个中文，但是它没办法表示多个字符： 但是实际上我们使用率最高的还是多个字符的情况，我们需要打印一连串的字符。这个时候，我们就可以使用字符串了： 123public static void main(String[] args) { String str = \"啊这\"; //字符串需要使用双引号囊括，字符串中可以包含0-N个字符} 注意，这里使用的类型是String类型，这种类型并不是基本数据类型，它是对象类型，我们会在下一章继续对其进行介绍，这里我们只需要简单了解一下就可以了。 布尔类型布尔类型是Java中的一个比较特殊的类型，它并不是存放数字的，而是状态，它有下面的两个状态： true - 真 false - 假 布尔类型（boolean）只有true和false两种值，也就是要么为真，要么为假，布尔类型的变量通常用作流程控制判断语句（不同于C语言，C语言中一般使用0表示false，除0以外的所有数都表示true）布尔类型占据的空间大小并未明确定义，而是根据不同的JVM会有不同的实现。 1234public static void main(String[] args) { boolean b = true; //值只能是true或false System.out.println(b);} 如果给一个其他的值，会无法编译通过： 至此，基本数据类型的介绍就结束了。 运算符前面我们介绍了多种多样的基本数据类型，但是光有这些基本数据类型还不够，我们还需要让这些数据之间进行运算，才可以真正意义上发挥计算机的作用。 要完成计算，我们需要借助运算符来完成，实际上我们在数学中就已经接触过多种多样的运算符了。 比如：+ - × ÷ 这些运算符都是我们在初等数学中学习的，而使用规则也很简单，我们只需要将需要进行运算的两个数放到运算符的两边就可以了： 比如：10 ÷ 2 上面运算的结果就是5了，而在Java中，我们同样可以使用这样的方式来进行运算。 赋值运算符首先我们还是来回顾一下之前认识的老朋友：赋值运算符。 赋值运算符可以直接给某个变量赋值： 123public static void main(String[] args) { int a = 666; //使用等号进行赋值运算} 使用规则为：赋值运算符的左边必须是一个可以赋值的目标，比如变量，右边可以是任意满足要求的值，包括变量。 当然，赋值运算符并不只是单纯的赋值，它是有结果的： 1234public static void main(String[] args) { int a; int b = a = 777;} 当出现连续使用赋值运算符时，按照从右往左的顺序进行计算，首先是a = 777，计算完成后，a的值就变成了777，计算完成后，会得到计算结果（赋值运算的计算结果就是赋的值本身，就像1 + 1的结果是2一样，a = 1的结果就是1）此时继续进行赋值计算，那么b就被赋值为a = 777的计算结果，同样的也是 777 了。 所以，使用连等可以将一连串变量都赋值为最右边的值。 算术运算符算术运算符也就是我们初等数学中认识的这些运算符，包括加减乘除，当然Java还支持取模运算，算术运算同样需要左右两边都有一个拿来计算的目标。 1234public static void main(String[] args) { int a = 1 + 1; System.out.println(a);} 可以看到a赋值为1+1的结果，所以说最后a就是2了。 当然变量也是可以参与到算术运算中： 12345public static void main(String[] args) { int a = 3; int b = a - 10; System.out.println(b);} 不同类型之间也可以进行运算： 123456public static void main(String[] args) { int a = 5; short b = 10; int c = a + b; //不同类型的整数一起运算，小类型需要转换为大类型，short、byte、char一律转换为int再进行计算（无论算式中有无int，都需要转换），结果也是int；如果算式中出现了long类型，那么全部都需要转换到long类型再进行计算，结果也是long，反正就是依大的来} 因为运算时会发生隐式类型转换，所以说这里b自动转换为了int类型进行计算，所以说最后得到结果也一定是转换后的类型： 小数和整数一起计算同样会发生隐式类型转换： 因为小数表示范围更广，所以说整数会被转换为小数再进行计算，而最后的结果也肯定是小数了。 我们也可以将加减号作为正负符号使用，比如我们现在需要让a变成自己的相反数： 12345public static void main(String[] args) { int a = 10; a = -a; //减号此时作为负号运算符在使用，会将右边紧跟的目标变成相反数 System.out.println(a); //这里就会得到-10了} 同样的，正号也可以使用，但是似乎没什么卵用： 12345public static void main(String[] args) { int a = 10; a = +a; //正号本身在数学中就是可以省略的存在，所以Java中同样如此 System.out.println(a);} 注意加法支持对字符串的拼接： 1234public static void main(String[] args) { String str = \"伞兵\" + \"lbw\"; //我们可以使用加号来拼接两个字符串 System.out.println(str);} 最后这个字符串就变成了拼接后的结果了： 字符串不仅可以跟字符串拼接，也可以跟基本数据类型拼接： 1234public static void main(String[] args) { String str = \"伞兵\" + true + 1.5 + 'A'; System.out.println(str);} 最后就可以得到对应的结果了： 当然，除了加减法之外乘除法也是支持的： 12345public static void main(String[] args) { int a = 8, b = 2; System.out.println(a * b); //乘法使用*表示乘号 System.out.println(a / b); //除法就是一个/表示除号} 注意，两个整数在进行除法运算时，得到的结果也是整数（会直接砍掉小数部分，注意不是四舍五入） 1234public static void main(String[] args) { int a = 8, b = 5; System.out.println(a / b);} 上面是两个int类型的值进行的除法运算，正常情况下8除以5应该得到1.6，但是由于结果也是整数，所以说最后小数部分被丢弃： 但是如果是两个小数一起计算的话，因为结果也是小数，所以说就可以准确得到结果： 1234public static void main(String[] args) { double a = 8.0, b = 5.0; System.out.println(a / b);} 同样的，整数和小数一起计算，由于所有的整数范围都比小数小，根据我们上一部分介绍的转换规则，整数和小数一起计算时，所有的整数都会变成小数参与运算，所以说最后的结果也就是小数了，同样可以得到正确的结果： 12345public static void main(String[] args) { double a = 8.0; int b = 5; System.out.println(a / b);} 那么问题来了，现在我们有两个整数需要进行计算，但是我们就是希望可以得到一个小数的结果该怎么办呢？ 12345public static void main(String[] args) { int a = 8, b = 5; double c = a; //我们可以将其先隐式转换为小数类型，再那转换后的小数变量去参与计算 System.out.println(c / b); //同样可以得到正确结果} 在下一节，我们将介绍强制类型转换，通过使用强制类型转换，我们可以更轻松地让整数计算出小数的结果。 除了最基本的加减乘除操作，我们也可以进行取模操作： 1234public static void main(String[] args) { int a = 10; System.out.println(a % 3); //比如这里对a进行取模操作，实际上就是计算除以3的余数} 比如上面的是 10 % 3 得到的结果就是10除以3最后的余数1，取模操作也是非常好用的。 比如我们查看某个数是否为双数，只需要将其对2进行取模操作即可，因为如果是双数一定是可以整除的，如果是单数一定会余1： 123public static void main(String[] args) { System.out.println(17 % 2); //17不是双数，所以说最后会得到1} 注意，运算符之间是有优先级之分的，比如乘除法优先级高于加减法： 123public static void main(String[] args) { System.out.println(10 + 3 * 4);} 上面的算式按照数学中的规则，应该先计算3 * 4，然后再进行加法计算，而Java中同样遵循这样的规律。我们来总结一下到目前为止所有学习到的运算符相关性质： 优先级 运算符 结合性（出现同优先级运算符时） 1 -(负号) +(正号) 从右向左 2 * / % 从左往右 3 +(加法，包括字符串) -(减法) 从左往右 4 = 从右向左 比如下面的结果： 123456789101112public static void main(String[] args) { int a = 10; int b = a = 8 * -a + 10; /* 1. 正负号优先级最高，所有首先计算的是-a，得到-10 2. 其次是乘除号优先级更高，所以说这里计算 8 * -10，得到 -80 3. 然后是加减法，-80 + 10 = -70 4. 最后是赋值运算，因为等号运算符从右往左结合，先算a = -70的结果就是 -70 5. 最后b就是 -70 */ System.out.println(b);} 通过使用这些基本算术运算符，我们就可以更加快速地计算我们想要的结果了。 括号运算符前面我们介绍了算术运算符，我们接着来看括号运算符。 我们常常在数学中使用括号提升某些运算的优先级，比如： (1 + 7) × (3 - 6) = -24 虽然加法优先级比乘法要低但是我们给其添加括号之后，相当于提升了内部加法运算的优先级，所以说需要先计算括号中的再去计算括号外的，Java同样满足这个要求。 我们可以通过添加括号的方式来提升某些运算的优先级： 1234567891011public static void main(String[] args) { int a = 10; int b = (a = 8) * (-a + 10); /* 1. 括号的优先级是最高的，我们需要先计算括号中的内容，如果存在多个括号，就从左往右计算 2. 首先是 a = 8，计算完成之后a变成8，并且运算结果也为8 3. 然后是后面的加法，-a就是-8，加上10就是2 4. 最后才是乘法，左边此时是8，右边是2，最后结果为16 */ System.out.println(b);} 所以，通过添加括号，就可以更加灵活的控制计算。 当然，括号是可以嵌套的，这一点跟数学中也是一样的，只不过我们不需要使用方括号和花括号，一律使用小括号就行了。 在嵌套的情况下，会优先计算最内层括号中的算式： 1234public static void main(String[] args) { int b = (2 + (3 + 1) * 3) * 2; System.out.println(b);} 这里会优先计算 3 + 1的结果，然后由于第二层都在一个括号中，所以说按照正常优先级计算，2 + 4 * 3 = 14，最后来到最外层14*2 = 28，计算结束。 括号除了可以用来提升运算优先级，也可以用作强制类型转换，前面我们介绍了隐式类型转换，但是隐式类型转换存在局限性，比如此时我们希望将一个大的类型转换为一个小的类型： 正常情况下无法编译通过，但是实际上a的值并没有超出short的范围，理论上是可以直接给到b存放的，此时我们就可以使用强制类型转换： 1234public static void main(String[] args) { int a = 10; short b = (short) a; //在括号中填写上强制转换的类型，就可以强制转换到对应的类型了} 只不过强制类型转换存在一定的风险，比如： 12345public static void main(String[] args) { int a = 128; //已经超出byte的范围了 byte b = (byte) a; //此时强制类型转换为byte类型，那么只会保留byte能够表示的bit位 System.out.println(b);} 比如这里的128： 00000000 00000000 00000000 10000000 -&gt; byte只有一个字节，所以说只保留最后8位 -&gt; 10000000 这里的10000000，由于第一个位置是符号位，导致此时直接变成了byte的最小值： 所以说强制类型转换只有在明确不会出现问题的情况下，才可以使用。当然，强制类型转换也可以用在后面的类中，我们将会在下一章继续探讨。 有了强制类型转换，我们就可以很轻松地让两个整数计算出小数的结果了： 1234567public static void main(String[] args) { int a = 8, b = 5; double c = a/(double)b; //强制类型转换的优先级跟正负号一样 //计算时，只需要将其中一者转换为double类型，此时按照隐式类型转换规则，全都会变成double参与运算，所以结果也就是小数了 System.out.println(c);} 各位思考一下下面的这种情况可以正确得到小数的结果吗？ 12345public static void main(String[] args) { int a = 8, b = 5; double c = (double) (a/b); System.out.println(c);} 不能得到，因为括号将a/b的运算优先进行了，此时得到的结果已经是一个整数结果，再转换为double毫无意义。 最后我们还是来总结一下目前遇到的所有运算符： 优先级 运算符 结合性 1 ( ) 从左向右 2 - + (强制类型转换) 从右向左 3 * / % 从左向右 4 +(加法，包括字符串) -(减法) 从左向右 5 = 从右向左 自增自减运算符注意：这一节很容易搞晕，请务必记清楚顺序！ 有时候我们可能需要让变量自己进行增加操作，比如我们现在想要进行跳绳计数，每转动一圈，计数+1，当我们想要对一个变量进行这样的自增操作时，可以： 12345public static void main(String[] args) { int a = 8; a = a + 1; //让a等于a本身+1，相当于自增了1 System.out.println(a); //得到9} 当然，除了这种方式，我们也可以使用自增自减运算符： 123456public static void main(String[] args) { int a = 8; a++; //自增运算符就是两个加号连在一起，效果跟上面是一样的，a都会自增1 a--; //自减不用我多说了吧 System.out.println(a);} 自增自减运算符可以放到操作数的前后： 12345public static void main(String[] args) { int a = 8; ++a; //自增运算符在前在后最终效果都是让a自增1，是一样的 System.out.println(a);} 自增自减操作同样是有结果的，注意，这两种方式自增操作的结果不一样，我们来看下面的例子： 12345public static void main(String[] args) { int a = 8; int b = a++; //先出结果，再自增 System.out.println(b); //b得到的是a自增前的值} 12345public static void main(String[] args) { int a = 8; int b = ++a; //先自增，再出结果 System.out.println(b); //b得到的是a自增之后的结果} 第一个结果为8，而第二个结果却是9，这是因为，自增运算符放在前面，是先自增再得到结果，而自增运算符放到后面，是先出结果再自增（自减同理），这个新手很容易记混，所以说一定要分清楚。 自增自减运算符的优先级与正负号等价比如： 123456789public static void main(String[] args) { int a = 8; int b = -a++ + ++a; //我们首先来看前面的a，因为正负号和自增是同一个优先级，结合性是从右往左，所以说先计算a++ //a++的结果还是8，然后是负号，得到-8 //接着是后面的a，因为此时a已经经过前面变成9了，所以说++a就是先自增，再得到10 //最后得到的结果为 -8 + 10 = 2 System.out.println(b);} 一般情况下，除了考试为了考察各位小伙伴对运算符的优先级和结合性的理解，会出现这种恶心人的写法之外，各位小伙伴尽量不要去写这种难以阅读的东西。 当然，有些时候我们并不是希望以1进行自增，可能希望以其他的数进行自增操作，除了按照之前的方式老老实实写之外： 12345public static void main(String[] args) { int a = 8; a = a + 4; System.out.println(a);} 我们可以将其缩写： 12345public static void main(String[] args) { int a = 8; a += 4; //加号和等号连在一起，与a = a + 4效果完全一样 System.out.println(a);} 并且结果也是操作之后的结果： 12345public static void main(String[] args) { int a = 8; int b = a += 4; //+=的运算结果就是自增之后的结果 System.out.println(b); //所以b就是12} 不止加法，包括我们前面介绍的全部算术运算符，都是支持这种缩写的： 12345public static void main(String[] args) { int a = 8; a *= 9; //跟 a = a * 9 等价 System.out.println(a); //得到72} 是不是感觉能够编写更简洁的代码了？ 优先级 运算符 结合性 1 ( ) 从左向右 2 - + (强制类型转换) ++ – 从右向左 3 * / % 从左向右 4 +(加法，包括字符串) -(减法) 从左向右 5 = += -= *= /= %= 从右向左 位运算符我们接着来看位运算符，它比较偏向于底层，但是只要各位小伙伴前面的计算机二进制表示听明白了，这里就不是问题。 我们可以使用位运算符直接以二进制形式操作目标，位运算符包括：&amp; | ^ ~ 我们先来看按位与&amp;，比如下面的两个数： 12345public static void main(String[] args) { int a = 9, b = 3; int c = a &amp; b; //进行按位与运算 System.out.println(c);} 按位与实际上就是让这两个数每一位都进行比较，如果这一位两个数都是1，那么结果就是1，否则就是0： a = 9 = 1001 b = 3 = 0011 c = 1 = 0001（因为只有最后一位，两个数都是1，所以说结果最后一位是1，其他都是0） 同样的，按位或，其实就是只要任意一个为1（不能同时为0）那么结果就是1： 12345public static void main(String[] args) { int a = 9, b = 3; int c = a | b; System.out.println(c);} a = 9 = 1001 b = 3 = 0011 c =11= 1011（只要上下有一个是1或者都是1，那结果就是1） 按位异或符号很多小伙伴会以为是乘方运算，但是Java中并没有乘方运算符，^是按位异或运算符，不要记错了。 12345public static void main(String[] args) { int a = 9, b = 3; int c = a ^ b; System.out.println(c);} 异或的意思就是只有两边不相同的情况下，结果才是1，也就是说一边是1一边是0的情况： a = 9 = 1001 b = 3 = 0011 c =10= 1010（从左往右第二位、第四位要么两个都是0，要么两个都是1，所以说结果为0） 按位取反操作跟前面的正负号一样，只操作一个数，最好理解，如果这一位上是1，变成0，如果是0，变成1： 1234public static void main(String[] args) { byte c = ~127; System.out.println(c);} 127 = 01111111 -128 = 10000000 所以说计算的结果就是-128了。 除了以上的四个运算符之外，还有位移运算符，比如： 1234public static void main(String[] args) { byte c = 1 &lt;&lt; 2; //两个连续的小于符号，表示左移运算 System.out.println(c);} 1 = 00000001 4 = 00000100（左移两位之后，1跑到前面去了，尾部使用0填充，此时就是4） 我们发现，左移操作每进行一次，结果就会x2，所以说，除了直接使用*进行乘2的运算之外，我们也可以使用左移操作来完成。 同样的，右移操作就是向右移动每一位咯： 1234public static void main(String[] args) { byte c = 8 &gt;&gt; 2; System.out.println(c);} 8 = 00001000 2 = 00000010（右移两位之后，1跑到后面去了，头部使用符号位数字填充，此时变成2） 跟上面一样，右移操作可以快速进行除以2的计算。 对于负数来说，左移和右移操作不会改变其符号位上的数字，符号位不受位移操作影响： 1234public static void main(String[] args) { byte c = -4 &gt;&gt; 1; System.out.println(c);} -4 = 11111100 -2 = 11111110（前面这一长串1都被推到后面一位了，因为是负数，头部需要使用符号位数字来进行填充） 我们来总结一下： 左移操作&lt;&lt;：高位直接丢弃，低位补0 右移操作&gt;&gt;：低位直接丢弃，符号位是什么高位补什么 我们也可以使用考虑符号位的右移操作，一旦考虑符号位，那么符号会被移动： 1234public static void main(String[] args) { int c = -1 &gt;&gt; 1; //正常的右移操作，高位补1，所以说移了还是-1 System.out.println(c);} 1234public static void main(String[] args) { int c = -1 &gt;&gt;&gt; 1; //无符号右移是三个大于符号连在一起，移动会直接考虑符号位 System.out.println(c);} 比如： -1 = 11111111 11111111 11111111 11111111 右移： 01111111 11111111 11111111 11111111（无符号右移使用0填充高位） 此时得到的结果就是正数的最大值 2147483647 了，注意，不存在无符号左移。 位移操作也可以缩写： 12345public static void main(String[] args) { int c = -1; c = c &lt;&lt; 2; System.out.println(c);} 可以缩写为： 12345public static void main(String[] args) { int c = -1; c &lt;&lt;= 2; //直接运算符连上等号即可，跟上面是一样的 System.out.println(c);} 最后我们还是来总结一下优先级： 优先级 运算符 结合性 1 ( ) 从左向右 2 ~ - + (强制类型转换) ++ – 从右向左 3 * / % 从左向右 4 + - 从左向右 5 &lt;&lt; &gt;&gt; &gt;&gt;&gt; 从左向右 6 &amp; 从左向右 7 ^ 从左向右 8 | 从左向右 9 = += -= *= /= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= 从右向左 关系运算符到目前为止，我们发现有一个基本数据类型很低调，在前面的计算中boolean类型一直都没有机会出场，而接下来就是它的主场。 我们可以对某些事物进行判断，比如我们想判断两个变量谁更大，我们可以使用关系运算符： 1234public static void main(String[] args) { int a = 10, b = 20; boolean c = a &gt; b; //进行判断，如果a &gt; b那么就会得到true，否则会得到false} 关系判断的结果只可能是真或是假，所以说得到的结果是一个boolean类型的值。 关系判断运算符包括： 123456&gt; 大于&lt; 小于== 等于（注意是两个等号连在一起，不是一个等号，使用时不要搞混了）!= 不等于&gt;= 大于等于&lt;= 小于等于 关系运算符的计算还是比较简单的。 逻辑运算符前面我们介绍了简单的关系运算符，我们可以通过对关系的判断得到真或是假的结果，但是只能进行简单的判断，如果此时我们想要判断a是否小于等于100且大于等于60，就没办法了： 注意不能像这样进行判断，这是错误的语法，同时只能使用其中一种关系判断运算符。 为了解决这种问题，我们可以使用逻辑运算符，逻辑运算符包括： 123&amp;&amp; 与运算，要求两边同时为true才能返回true|| 或运算，要求两边至少要有一个为true才能返回true! 非运算，一般放在表达式最前面，表达式用括号扩起来，表示对表达式的结果进行反转 现在，我们就可以使用逻辑运算符进行复杂条件判断： 1234public static void main(String[] args) { int a = 10; boolean b = 100 &gt;= a &amp;&amp; a &gt;= 60; //我们可以使用与运算符连接两个判断表达式} 与运算符要求左右两边同时为真，得到的结果才是真，否则一律为假，上面的判断虽然满足第一个判断表达式，但是不满足第二个，所以说得到的结果就是false。 我们再来看下面的这个例子： 1234public static void main(String[] args) { int a = 150; boolean b = 100 &gt;= a &amp;&amp; a &gt;= 60; //此时上来就不满足条件} 这个例子中，第一个判断表达式就得到了false，此时不会再继续运行第二个表达式，而是直接得到结果false（逻辑运算符会出现短路的情况，只要第一个不是真，就算第二个是真也不可能了，所以说为了效率，后续就不用再判断了，在使用时一定要注意这一点） 同样的，比如我们现在要判断a要么大于10，要么小于0，这种关系就是一个或的关系： 1234public static void main(String[] args) { int a = 150; boolean b = a &lt; 0 || a &gt; 10; //或运算要求两边只要有至少一边满足，结果就为true，如果都不满足，那么就是false} 或运算同样会出现短路的情况，比如下面的例子： 1234public static void main(String[] args) { int a = -9; boolean b = a &lt; 0 || a &gt; 10; //此时上来就满足条件} 因为第一个判断表达式就直接得到了true，那么第二个表达式无论是真还是假，结果都一定是true，所以说没必要继续向后进行判断了，直接得到结果true。 我们来看看下面的结果是什么： 12345public static void main(String[] args) { int a = 10; boolean b = a++ &gt; 10 &amp;&amp; ++a == 12; System.out.println(\"a = \"+a + \", b = \"+b);} 得到结果为： 这是为什么呢？很明显我们的判断中a进行了两次自增操作，但是最后a的结果却是11，这是因为第一个表达式判断的结果为false，由于此时进行的是与运算，所以说直接短路，不会再继续判断了，因此第二个表达式就不会执行。 当然，除了与运算和或运算，还有一个非运算，这个就比较简单了，它可以将结果变成相反的样子，比如： 1234public static void main(String[] args) { int a = 10; boolean b = !(a &gt; 5); //对a&gt;5的判断结果，进行非运算} 因为上面的a &gt; 5判断为真，此时进行非运算会得到相反的结果，所以说最后b就是false了。 最后我们还需要介绍一个叫做三元运算符的东西，三元运算符可以根据判断条件，返回不同的结果，比如我们想要判断： 当a &gt; 10时，给b赋值’A’ 当a &lt;= 10时，给b赋值’B’ 我们就可以使用三元运算符来完成： 12345public static void main(String[] args) { int a = 10; char b = a &gt; 10 ? 'A' : 'B'; //三元运算符需要三个内容，第一个是判断语句，第二个是满足判断语句的值，第三个是不满足判断语句的值 System.out.println(b);} 三元运算符： 1判断语句 ? 结果1 : 结果2 因此，上面的判断为假，所以说返回的是结果2，那么最后b得到的就是B这个字符了。 最后，我们来总结整个运算符板块学习到的所有运算符： 优先级 运算符 结合性 1 ( ) 从左向右 2 ~ - + (强制类型转换) ++ – 从右向左 3 * / % 从左向右 4 + - 从左向右 5 &lt;&lt; &gt;&gt; &gt;&gt;&gt; 从左向右 6 &gt; &lt; &gt;= &lt;= 从左向右 7 == != 从左向右 8 &amp; 从左向右 9 ^ 从左向右 10 | 从左向右 11 &amp;&amp; 从左向右 12 || 从左向右 13 ? : 从右向左 14 = += -= *= /= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= 从右向左 至此，我们已经学习了Java基础部分中所有的运算符。 流程控制我们的程序都是从上往下依次运行的，但是，仅仅是这样还不够，我们需要更加高级的控制语句来使得程序更加有趣。比如，判断一个整数变量，大于1则输出yes，小于1则输出no，这时我们就需要用到选择结构来帮助我们完成条件的判断和程序的分支走向。学习过C语言就很轻松！ 在前面我们介绍了运算符，我们可以通过逻辑运算符和关系运算符对某些条件进行判断，并得到真或是假的结果。这一部分我们将继续使用这些运算符进行各种判断。 代码块与作用域在开始流程控制语句之前，我们先来介绍一下代码块和作用域。 不知道各位小伙伴是否在一开始就注意到了，为什么程序中会有一些成对出现的花括号？这些花括号代表什么意思呢？ 12345public class Main { //外层花括号 public static void main(String[] args) { //内层花括号开始 } //内层花括号结束} 我们可以在花括号中编写一句又一句的代码，实际上这些被大括号囊括起来的内容，我们就称为块（代码块），一个代码块中可以包含多行代码，我们可以在里面做各种各样的事情，比如定义变量、进行计算等等。 我们可以自由地创建代码块： 1234567public static void main(String[] args) { //现目前这个阶段，我们还是在主方法中编写代码，不要跑去外面写 System.out.println(\"外层\"); { //自由创建代码块 int a = 10; System.out.println(a); }} 虽然创建了代码块，但实际上程序依然是按照从上到下的顺序在进行的，所以说这里还是在逐行运行，即使使用花括号囊括。那咋一看这不就是没什么卵用吗？我们来看看变量。 我们创建的变量，实际上是有作用域的，并不是在任何地方都可以使用，比如： 变量的使用范围，仅限于其定义时所处的代码块，一旦超出对应的代码块区域，那么就相当于没有这个变量了。 1234567public static void main(String[] args) { int a = 10; //此时变量在最外层定义 { System.out.println(a); //处于其作用域内部的代码块可以使用 } System.out.println(a); //这里肯定也可以使用} 我们目前所创建的变量都是局部变量（有范围限制），后面我们会介绍更多种类型的变量，了解了代码块及作用域之后，我们就可以正式开启流程控制语句的学习了。 选择结构某些时候，我们希望进行判断，只有在条件为真时，才执行某些代码，这种情况就需要使用到选择分支语句，首先我们来认识一下if语句： 1if (条件判断) 判断成功执行的代码; 123456public static void main(String[] args) { int a = 15; if(a == 15) //只有当a判断等于15时，才会执行下面的打印语句 System.out.println(\"Hello World!\"); System.out.println(\"我是外层\"); //if只会对紧跟着的一行代码生效，后续的内容无效} if会进行判断，只有判断成功时才会执行紧跟着的语句，否则会直接跳过，注意，如果我们想要在if中执行多行代码，需要使用代码块将这些代码囊括起来（实际上代码块就是将多条语句复合到一起）所以说，我们以后使用if时，如果分支中有多行代码需要执行，就需要添加花括号，如果只有一行代码，花括号可以直接省略，包括我们后面会讲到的else、while、for语句都是这样的。 12345678public static void main(String[] args) { int a = 15; if(a &gt; 10) { //只有判断成功时，才会执行下面的代码块中内容，否则直接跳过 System.out.println(\"a大于10\"); System.out.println(\"a的值为：\"+a); } System.out.println(\"我是外层\");} 如果我们希望判断条件为真时执行某些代码，条件为假时执行另一些代码，我们可以在后面继续添加else语句： 1234567891011public static void main(String[] args) { int a = 15; if(a &gt; 10) { //只有判断成功时，才会执行下面的代码块中内容，否则直接跳过 System.out.println(\"a大于10\"); System.out.println(\"a的值为：\"+a); } else { //当判断不成功时，会执行else代码块中的代码 System.out.println(\"a小于10\"); System.out.println(\"a的值为：\"+a); } System.out.println(\"我是外层\");} if-else语句就像两个分支，跟据不同的判断情况从而决定下一步该做什么，这跟我们之前认识的三元运算符性质比较类似。 那如果此时我们需要判断多个分支呢？比如我们现在希望判断学生的成绩，不同分数段打印的等级不一样，比如90以上就是优秀，70以上就是良好，60以上是及格，其他的都是不及格，那么这种我们又该如何判断呢？要像这样进行连续判断，我们需要使用else-if来完成： 1234567891011public static void main(String[] args) { int score = 2; if(score &gt;= 90) //90分以上才是优秀 System.out.println(\"优秀\"); else if (score &gt;= 70) //当上一级if判断失败时，会继续判断这一级 System.out.println(\"良好\"); else if (score &gt;= 60) System.out.println(\"及格\"); else //当之前所有的if都判断失败时，才会进入到最后的else语句中 System.out.println(\"不及格\");} 当然，if分支语句还支持嵌套使用，比如我们现在希望低于60分的同学需要补习，0-30分需要补Java，30-60分需要补C++，这时我们就需要用到嵌套： 123456789public static void main(String[] args) { int score = 2; if(score &lt; 60) { //先判断不及格 if(score &gt; 30) //在内层再嵌套一个if语句进行进一步的判断 System.out.println(\"学习C++\"); else System.out.println(\"学习Java\"); }} 除了if自己可以进行嵌套使用之外，其他流程控制语句同样可以嵌套使用，也可以与其他流程控制语句混合嵌套使用。这样，我们就可以灵活地使用if来进行各种条件判断了。 前面我们介绍了if语句，我们可以通过一个if语句轻松地进行条件判断，然后根据对应的条件，来执行不同的逻辑，当然除了这种方式之外，我们也可以使用switch语句来实现，它更适用于多分支的情况： 12345switch (目标) { //我们需要传入一个目标，比如变量，或是计算表达式等 case 匹配值: //如果目标的值等于我们这里给定的匹配值，那么就执行case后面的代码 代码... break; //代码执行结束后需要使用break来结束，否则会溜到下一个case继续执行代码} 比如现在我们要根据学生的等级进行分班，学生有ABC三个等级： 1234567891011121314public static void main(String[] args) { char c = 'A'; switch (c) { //这里目标就是变量c case 'A': //分别指定ABC三个匹配值，并且执行不同的代码 System.out.println(\"去尖子班！准备冲刺985大学！\"); break; //执行完之后一定记得break，否则会继续向下执行下一个case中的代码 case 'B': System.out.println(\"去平行班！准备冲刺一本！\"); break; case 'C': System.out.println(\"去职高深造。\"); break; }} switch可以精准匹配某个值，但是它不能进行范围判断，比如我们要判断分数段，这时用switch就很鸡肋了。 当然除了精准匹配之外，其他的情况我们可以用default来表示： 12345switch (目标) { case: ... default: 其他情况下执行的代码} 我们还是以刚才那个例子为例： 12345678910111213141516public static void main(String[] args) { char c = 'A'; switch (c) { case 'A': System.out.println(\"去尖子班！\"); break; case 'B': System.out.println(\"去平行班！\"); break; case 'C': System.out.println(\"去差生班！\"); break; default: //其他情况一律就是下面的代码了 System.out.println(\"去读职高，分流\"); }} 当然switch中可以继续嵌套其他的流程控制语句，比如if： 12345678910111213public static void main(String[] args) { char c = 'A'; switch (c) { case 'A': if(c == 'A') { //嵌套一个if语句 System.out.println(\"去尖子班！\"); } break; case 'B': System.out.println(\"去平行班！\"); break; }} 目前，我们已经认识了两种选择分支结构语句。 循环结构通过前面的学习，我们了解了如何使用分支语句来根据不同的条件执行不同的代码，我们接着来看第二种重要的流程控制语句：循环语句。 我们在某些时候，可能需要批量执行某些代码： 12345public static void main(String[] args) { System.out.println(\"伞兵一号卢本伟准备就绪！\"); //把这句话给我打印三遍 System.out.println(\"伞兵一号卢本伟准备就绪！\"); System.out.println(\"伞兵一号卢本伟准备就绪！\");} 遇到这种情况，我们由于还没学习循环语句，那么就只能写N次来实现这样的多次执行。但是如果此时要求我们将一句话打印100遍、1000遍、10000遍，那么我们岂不是光CV代码就要搞一下午？ 现在，要解决这种问题，我们可以使用for循环语句来多次执行： 1for (表达式1;表达式2;表达式3) 循环体; 介绍一下详细规则： 表达式1：在循环开始时仅执行一次。 表达式2：每次循环开始前会执行一次，要求为判断语句，用于判断是否可以结束循环，若结果为真，那么继续循环，否则结束循环。 表达式3：每次循环完成后会执行一次。 循环体：每次循环都会执行一次循环体。 一个标准的for循环语句写法如下： 12345public static void main(String[] args) { //比如我们希望让刚刚的打印执行3次 for (int i = 0; i &lt; 3; i++) //这里我们在for语句中定义一个变量i，然后每一轮i都会自增，直到变成3为止 System.out.println(\"伞兵一号卢本伟准备就绪！\"); //这样，就会执行三轮循环，每轮循环都会执行紧跟着的这一句打印} 我们可以使用调试来观察每一轮的变化，调试模式跟普通的运行一样，也会执行我们的Java程序，但是我们可以添加断点，也就是说当代码运行到断点位置时，会在这里暂停，我们可以观察当代码执行到这个位置时各个变量的值： 调试模式在我们后面的学习中非常重要，影响深远，所以说各位小伙伴一定要学会。调试也很简单，我们只需要点击右上角的调试选项即可（图标像一个小虫子一样，因为调试的英文名称是Debug） 调试开始时，我们可以看到程序在断点位置暂停了： 此时我们可以观察到当前的局部变量i的值，也可以直接在下方的调试窗口中查看： 随着循环的进行，i的值也会逐渐自增： 当i增长到2时，此时来到最后一轮循环，再继续向下运行，就不再满足循环条件了，所以说此时就会结束循环。 当然，如果要执行多条语句的话，只需要使用花括号囊括就行了： 1234for (int i = 0; i &lt; 3; i++) { System.out.println(\"伞兵一号卢本伟准备就绪！\"); System.out.println(\"当前i的值为：\"+i);} 注意这里的i仅仅是for循环语句中创建的变量，所以说其作用域被限制在了循环体中，一旦离开循环体，那么就无法使用了： 但是我们可以将i的创建放到外面： 12345678public static void main(String[] args) { int i = 0; //在外面创建变量i，这样全部范围内都可以使用了 for (; i &lt; 3; i++) { //for循环的三个表达式并不一定需要编写 System.out.println(\"伞兵一号卢本伟准备就绪！\"); System.out.println(\"当前i的值为：\"+i); } System.out.println(\"当前i的值为：\"+i);} 和之前的if一样，for循环同样支持嵌套使用： 12345public static void main(String[] args) { for (int i = 0; i &lt; 3; i++) //外层循环执行3次 for (int j = 0; j &lt; 3; j++) //内层循环也执行3次 System.out.println(\"1！5！\");} 上面的代码中，外层循环会执行3轮，而整个循环体又是一个循环语句，那么也就是说，每一轮循环都会执行里面的整个循环，里面的整个循环会执行3，那么总共就会执行3 x 3次，也就是9次打印语句。 实际上，for循环的三个表达式并不一定需要编写，我们甚至可以三个都不写： 1234public static void main(String[] args) { for (;;) //如果什么都不写，相当于没有结束条件，这将会导致无限循环 System.out.println(\"伞兵一号卢本伟准备就绪！\");} 如果没有表达式2，那么整个for循环就没有结束条件，默认会判定为真，此时就会出现无限循环的情况（无限循环是很危险的，因为它会疯狂地消耗CPU资源来执行循环，可能很快你的CPU就满载了，一定要避免） 当然，我们也可以在循环过程中提前终止或是加速循环的进行，这里我们需要认识两个新的关键字： 1234567public static void main(String[] args) { for (int i = 0; i &lt; 3; i++) { if(i == 1) continue; //比如我们希望当i等于1时跳过这一轮，不执行后面的打印 System.out.println(\"伞兵一号卢本伟准备就绪！\"); System.out.println(\"当前i的值为：\"+i); }} 我们可以使用continue关键字来跳过本轮循环，直接开启下一轮。这里的跳过是指，循环体中，无论后面有没有未执行的代码，一律不执行，比如上面的判断如果成功，那么将执行continue进行跳过，虽然后面还有打印语句，但是不会再去执行了，而是直接结束当前循环，开启下一轮。 在某些情况下，我们可能希望提前结束循环： 12345for (int i = 0; i &lt; 3; i++) { if(i == 1) break; //我们希望当i等于1时提前结束 System.out.println(\"伞兵一号卢本伟准备就绪！\"); System.out.println(\"当前i的值为：\"+i);} 我们可以使用break关键字来提前终止整个循环，和上面一样，本轮循环中无论后续还有没有未执行的代码，都不会执行了，而是直接结束整个循环，跳出到循环外部。 虽然使用break和continue关键字能够更方便的控制循环，但是注意在多重循环嵌套下，它只对离它最近的循环生效（就近原则）： 123456for (int i = 1; i &lt; 4; ++i) { for (int j = 1; j &lt; 4; ++j) { if(i == j) continue; //当i == j时加速循环 System.out.println(i+\", \"+j); }} 这里的continue加速的对象并不是外层的for，而是离它最近的内层for循环，break也是同样的规则： 123456for (int i = 1; i &lt; 4; ++i) { for (int j = 1; j &lt; 4; ++j) { if(i == j) break; //当i == j时终止循环 System.out.println(i+\", \"+j); }} 那么，要是我们就是想要终止或者是加速外层循环呢？我们可以为循环语句打上标记： 123456outer: for (int i = 1; i &lt; 4; ++i) { //在循环语句前，添加 标签: 来进行标记 inner: for (int j = 1; j &lt; 4; ++j) { if(i == j) break outer; //break后紧跟要结束的循环标记，当i == j时终止外层循环 System.out.println(i+\", \"+j); }} 如果一个代码块中存在多个循环，那么直接对当前代码块的标记执行break时会直接跳出整个代码块： 12345678910outer: { //直接对整个代码块打标签 for (int i = 0; i &lt; 10; i++) { if (i == 7){ System.out.println(\"Test\"); break outer; //执行break时，会直接跳出整个代码块，而不是第一个循环 } } System.out.println(\"？？？\");} 虽然效果挺奇特的，但是一般情况下没人这么玩，所以说了解就行了。 前面我们介绍了for循环语句，我们接着来看第二种while循环，for循环要求我们填写三个表达式，而while相当于是一个简化版本，它只需要我们填写循环的维持条件即可，比如： 1while(循环条件) 循环体; 相比for循环，while循环更多的用在不明确具体的结束时机的情况下，而for循环更多用于明确知道循环的情况，比如我们现在明确要进行循环10次，此时用for循环会更加合适一些，又比如我们现在只知道当i大于10时需要结束循环，但是i在循环多少次之后才不满足循环条件我们并不知道，此时使用while就比较合适了。 1234567public static void main(String[] args) { int i = 100; //比如现在我们想看看i不断除以2得到的结果会是什么，但是循环次数我们并不明确 while (i &gt; 0) { //现在唯一知道的是循环条件，只要大于0那么就可以继续除 System.out.println(i); i /= 2; //每次循环都除以2 }} 上面的这种情况就非常适合使用while循环。 和for循环一样，while也支持使用break和continue来进行循环的控制，以及嵌套使用： 12345678public static void main(String[] args) { int i = 100; while (i &gt; 0) { if(i &lt; 10) break; System.out.println(i); i /= 2; }} 我们也可以反转循环判断的时机，可以先执行循环内容，然后再做循环条件判断，这里要用到do-while语句： 1234567public static void main(String[] args) { int i = 0; //比如现在我们想看看i不断除以2得到的结果会是什么，但是循环次数我们并不明确 do { //无论满不满足循环条件，先执行循环体里面的内容 System.out.println(\"Hello World!\"); i++; } while (i &lt; 10); //再做判断，如果判断成功，开启下一轮循环，否则结束} 至此，面向过程相关的内容就讲解完毕了，从下一章开始，我们将进入面向对象编程的学习（类、数组、字符串） 实战练习面向过程的内容全部学习完成，我们来做几个练习题吧！ 寻找水仙花数 “水仙花数（Narcissistic number）也被称为超完全数字不变数（pluperfect digital invariant, PPDI）、自恋数、自幂数、阿姆斯壮数或阿姆斯特朗数（Armstrong number），水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身。例如：1^3 + 5^3+ 3^3 = 153。” 现在请你设计一个Java程序，打印出所有1000以内的水仙花数。 打印九九乘法表 现在我们要做的是在我们的程序中，也打印出这样的一个乘法表出来，请你设计一个Java程序来实现它。 斐波那契数列 斐波那契数列（Fibonacci sequence），又称黄金分割数列，因数学家莱昂纳多·斐波那契（Leonardo Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：F(0)=0，F(1)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 2，n ∈ N*）在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用，为此，美国数学会从 1963 年起出版了以《斐波纳契数列季刊》为名的一份数学杂志，用于专门刊载这方面的研究成果。 斐波那契数列：1，1，2，3，5，8，13，21，34，55，89…，不难发现一个规律，实际上从第三个数开始，每个数字的值都是前两个数字的和，现在请你设计一个Java程序，可以获取斐波那契数列上任意一位的数字，比如获取第5个数，那么就是5。 1234567public static void main(String[] args) { int target = 7, result; //target是要获取的数，result是结果 //请在这里实现算法 System.out.println(result);}","categories":[],"tags":[]},{"title":"","slug":"白马Java/JavaSE笔记（六）重制版","date":"2025-09-07T23:26:13.331Z","updated":"2025-09-07T23:28:25.714Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/0.html","excerpt":"集合类与IO前面我们已经把基础介绍完了，从这节课开始，我们就正式进入到集合类的讲解中。 集合类集合类是Java中非常重要的存在，使用频率极高。集合其实与我们数学中的集合是差不多的概念，集合表示一组对象，每一个对象我们都可以称其为元素。不同的集合有着不同的性质，比如一些集合允许重复的元素，而另一些则不允许，一些集合是有序的，而其他则是无序的。 集合类其实就是为了更好地组织、管理和操作我们的数据而存在的，包括列表、集合、队列、映射等数据结构。从这一块开始，我们会从源码角度给大家讲解（先从接口定义对于集合需要实现哪些功能开始说起，包括这些集合类的底层机制是如何运作的）不仅仅是教会大家如何去使用。 集合跟数组一样，可以表示同样的一组元素，但是他们的相同和不同之处在于： 它们都是容器，都能够容纳一组元素。","text":"集合类与IO前面我们已经把基础介绍完了，从这节课开始，我们就正式进入到集合类的讲解中。 集合类集合类是Java中非常重要的存在，使用频率极高。集合其实与我们数学中的集合是差不多的概念，集合表示一组对象，每一个对象我们都可以称其为元素。不同的集合有着不同的性质，比如一些集合允许重复的元素，而另一些则不允许，一些集合是有序的，而其他则是无序的。 集合类其实就是为了更好地组织、管理和操作我们的数据而存在的，包括列表、集合、队列、映射等数据结构。从这一块开始，我们会从源码角度给大家讲解（先从接口定义对于集合需要实现哪些功能开始说起，包括这些集合类的底层机制是如何运作的）不仅仅是教会大家如何去使用。 集合跟数组一样，可以表示同样的一组元素，但是他们的相同和不同之处在于： 它们都是容器，都能够容纳一组元素。 不同之处： 数组的大小是固定的，集合的大小是可变的。 数组可以存放基本数据类型，但集合只能存放对象。 数组存放的类型只能是一种，但集合可以有不同种类的元素。 集合根接口Java中已经帮我们将常用的集合类型都实现好了，我们只需要直接拿来用就行了，比如我们之前学习的顺序表： 12345678import java.util.ArrayList; //集合类基本都是在java.util包下定义的public class Main { public static void main(String[] args) { ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"树脂666\"); }} 当然，我们会在这一部分中认识大部分Java为我们提供的集合类。所有的集合类最终都是实现自集合根接口的，比如我们下面就会讲到的ArrayList类，它的祖先就是Collection接口： 这个接口定义了集合类的一些基本操作，我们来看看有哪些方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; { //-------这些是查询相关的操作---------- //获取当前集合中的元素数量 int size(); //查看当前集合是否为空 boolean isEmpty(); //查询当前集合中是否包含某个元素 boolean contains(Object o); //返回当前集合的迭代器，我们会在后面介绍 Iterator&lt;E&gt; iterator(); //将集合转换为数组的形式 Object[] toArray(); //支持泛型的数组转换，同上 &lt;T&gt; T[] toArray(T[] a); //-------这些是修改相关的操作---------- //向集合中添加元素，不同的集合类具体实现可能会对插入的元素有要求， //这个操作并不是一定会添加成功，所以添加成功返回true，否则返回false boolean add(E e); //从集合中移除某个元素，同样的，移除成功返回true，否则false boolean remove(Object o); //-------这些是批量执行的操作---------- //查询当前集合是否包含给定集合中所有的元素 //从数学角度来说，就是看给定集合是不是当前集合的子集 boolean containsAll(Collection&lt;?&gt; c); //添加给定集合中所有的元素 //从数学角度来说，就是将当前集合变成当前集合与给定集合的并集 //添加成功返回true，否则返回false boolean addAll(Collection&lt;? extends E&gt; c); //移除给定集合中出现的所有元素，如果某个元素在当前集合中不存在，那么忽略这个元素 //从数学角度来说，就是求当前集合与给定集合的差集 //移除成功返回true，否则false boolean removeAll(Collection&lt;?&gt; c); //Java8新增方法，根据给定的Predicate条件进行元素移除操作 default boolean removeIf(Predicate&lt;? super E&gt; filter) { Objects.requireNonNull(filter); boolean removed = false; final Iterator&lt;E&gt; each = iterator(); //这里用到了迭代器，我们会在后面进行介绍 while (each.hasNext()) { if (filter.test(each.next())) { each.remove(); removed = true; } } return removed; } //只保留当前集合中在给定集合中出现的元素，其他元素一律移除 //从数学角度来说，就是求当前集合与给定集合的交集 //移除成功返回true，否则false boolean retainAll(Collection&lt;?&gt; c); //清空整个集合，删除所有元素 void clear(); //-------这些是比较以及哈希计算相关的操作---------- //判断两个集合是否相等 boolean equals(Object o); //计算当前整个集合对象的哈希值 int hashCode(); //与迭代器作用相同，但是是并行执行的，我们会在下一章多线程部分中进行介绍 @Override default Spliterator&lt;E&gt; spliterator() { return Spliterators.spliterator(this, 0); } //生成当前集合的流，我们会在后面进行讲解 default Stream&lt;E&gt; stream() { return StreamSupport.stream(spliterator(), false); } //生成当前集合的并行流，我们会在下一章多线程部分中进行介绍 default Stream&lt;E&gt; parallelStream() { return StreamSupport.stream(spliterator(), true); }} 可以看到，在这个接口中对于集合相关的操作，还是比较齐全的，那么我们接着就来看看它的实现类。 List列表首先我们需要介绍的是List列表（线性表），线性表支持随机访问，相比之前的Collection接口定义，功能还会更多一些。首先介绍ArrayList，我们已经知道，它的底层是用数组实现的，内部维护的是一个可动态进行扩容的数组，也就是我们之前所说的顺序表，跟我们之前自己写的ArrayList相比，它更加的规范，并且功能更加强大，同时实现自List接口。 List是集合类型的一个分支，它的主要特性有： 是一个有序的集合，插入元素默认是插入到尾部，按顺序从前往后存放，每个元素都有一个自己的下标位置 列表中允许存在重复元素 在List接口中，定义了列表类型需要支持的全部操作，List直接继承自前面介绍的Collection接口，其中很多地方重新定义了一次Collection接口中定义的方法，这样做是为了更加明确方法的具体功能，当然，为了直观，我们这里就省略掉： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//List是一个有序的集合类，每个元素都有一个自己的下标位置//List中可插入重复元素//针对于这些特性，扩展了Collection接口中一些额外的操作public interface List&lt;E&gt; extends Collection&lt;E&gt; { ... //将给定集合中所有元素插入到当前结合的给定位置上（后面的元素就被挤到后面去了，跟我们之前顺序表的插入是一样的） boolean addAll(int index, Collection&lt;? extends E&gt; c); ... //Java 8新增方法，可以对列表中每个元素都进行处理，并将元素替换为处理之后的结果 default void replaceAll(UnaryOperator&lt;E&gt; operator) { Objects.requireNonNull(operator); final ListIterator&lt;E&gt; li = this.listIterator(); //这里同样用到了迭代器 while (li.hasNext()) { li.set(operator.apply(li.next())); } } //对当前集合按照给定的规则进行排序操作，这里同样只需要一个Comparator就行了 @SuppressWarnings({\"unchecked\", \"rawtypes\"}) default void sort(Comparator&lt;? super E&gt; c) { Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c); ListIterator&lt;E&gt; i = this.listIterator(); for (Object e : a) { i.next(); i.set((E) e); } } ... //-------- 这些是List中独特的位置直接访问操作 -------- //获取对应下标位置上的元素 E get(int index); //直接将对应位置上的元素替换为给定元素 E set(int index, E element); //在指定位置上插入元素，就跟我们之前的顺序表插入是一样的 void add(int index, E element); //移除指定位置上的元素 E remove(int index); //------- 这些是List中独特的搜索操作 ------- //查询某个元素在当前列表中的第一次出现的下标位置 int indexOf(Object o); //查询某个元素在当前列表中的最后一次出现的下标位置 int lastIndexOf(Object o); //------- 这些是List的专用迭代器 ------- //迭代器我们会在下一个部分讲解 ListIterator&lt;E&gt; listIterator(); //迭代器我们会在下一个部分讲解 ListIterator&lt;E&gt; listIterator(int index); //------- 这些是List的特殊转换 ------- //返回当前集合在指定范围内的子集 List&lt;E&gt; subList(int fromIndex, int toIndex); ...} 可以看到，在List接口中，扩展了大量列表支持的操作，其中最突出的就是直接根据下标位置进行的增删改查操作。而在ArrayList中，底层就是采用数组实现的，跟我们之前的顺序表思路差不多： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable{ //默认的数组容量 private static final int DEFAULT_CAPACITY = 10; ... //存放数据的底层数组，这里的transient关键字我们会在后面I/O中介绍用途 transient Object[] elementData; //记录当前数组元素数的 private int size; //这是ArrayList的其中一个构造方法 public ArrayList(int initialCapacity) { if (initialCapacity &gt; 0) { this.elementData = new Object[initialCapacity]; //根据初始化大小，创建当前列表 } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); } } ... public boolean add(E e) { ensureCapacityInternal(size + 1); // 这里会判断容量是否充足，不充足需要扩容 elementData[size++] = e; return true; } ... //默认的列表最大长度为Integer.MAX_VALUE - 8 //JVM都C++实现中，在数组的对象头中有一个_length字段，用于记录数组的长 //度，所以这个8就是存了数组_length字段（这个只做了解就行） private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; private void grow(int minCapacity) { int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //扩容规则跟我们之前的是一样的，也是1.5倍 if (newCapacity - minCapacity &lt; 0) //要是扩容之后的大小还没最小的大小大，那么直接扩容到最小的大小 newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) //要是扩容之后比最大的大小还大，需要进行大小限制 newCapacity = hugeCapacity(minCapacity); //调整为限制的大小 elementData = Arrays.copyOf(elementData, newCapacity); //使用copyOf快速将内容拷贝到扩容后的新数组中并设定为新的elementData底层数组 }} 一般的，如果我们要使用一个集合类，我们会使用接口的引用： 123456public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); //使用接口的引用来操作具体的集合类实现，是为了方便日后如果我们想要更换不同的集合类实现，而且接口中本身就已经定义了主要的方法，所以说没必要直接用实现类 list.add(\"科技与狠活\"); //使用add添加元素 list.add(\"上头啊\"); System.out.println(list); //打印集合类，可以得到一个非常规范的结果} 可以看到，打印集合类的效果，跟我们使用Arrays工具类是一样的： 集合的各种功能我们都可以来测试一下，特别注意一下，我们在使用Integer时，要注意传参问题： 123456public static void main(String[] args) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(10); //添加Integer的值10 list.remove((Integer) 10); //注意，不能直接用10，默认情况下会认为传入的是int类型值，删除的是下标为10的元素，我们这里要删除的是刚刚传入的值为10的Integer对象 System.out.println(list); //可以看到，此时元素成功被移除} 那要是这样写呢？ 123456public static void main(String[] args) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(new Integer(10)); //添加的是一个对象 list.remove(new Integer(10)); //删除的是另一个对象 System.out.println(list);} 可以看到，结果依然是删除成功，这是因为集合类在删除元素时，只会调用equals方法进行判断是否为指定元素，而不是进行等号判断，所以说一定要注意，如果两个对象使用equals方法相等，那么集合中就是相同的两个对象： 12345678910111213//ArrayList源码部分public boolean remove(Object o) { if (o == null) { ... } else { for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) { //这里只是对两个对象进行equals判断 fastRemove(index); return true; //只要判断成功，直接认为就是要删除的对象，删除就完事 } } return false;} 列表中允许存在相同元素，所以说我们可以添加两个一模一样的： 1234567public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); String str = \"哟唉嘛干你\"; list.add(str); list.add(str); System.out.println(list);} 那要是此时我们删除对象呢，是一起删除还是只删除一个呢？ 12345678public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); String str = \"哟唉嘛干你\"; list.add(str); list.add(str); list.remove(str); System.out.println(list);} 可以看到，这种情况下，只会删除排在前面的第一个元素。 集合类是支持嵌套使用的，一个集合中可以存放多个集合，套娃嘛，谁不会： 12345public static void main(String[] args) { List&lt;List&lt;String&gt;&gt; list = new LinkedList&lt;&gt;(); list.add(new LinkedList&lt;&gt;()); //集合中的每一个元素就是一个集合，这个套娃是可以一直套下去的 System.out.println(list.get(0).isEmpty());} 在Arrays工具类中，我们可以快速生成一个只读的List： 1234public static void main(String[] args) { List&lt;String&gt; list = Arrays.asList(\"A\", \"B\", \"C\"); //非常方便 System.out.println(list);} 注意，这个生成的List是只读的，不能进行修改操作，只能使用获取内容相关的方法，否则抛出 UnsupportedOperationException 异常。要生成正常使用的，我们可以将这个只读的列表作为参数传入： 1234public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(\"A\", \"B\", \"C\")); System.out.println(list);} 当然，也可以利用静态代码块： 12345678public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;String&gt;() {{ //使用匿名内部类（匿名内部类在Java8无法使用钻石运算符，但是之后的版本可以） add(\"A\"); add(\"B\"); add(\"C\"); }}; System.out.println(list);} 这里我们接着介绍另一个列表实现类，LinkedList同样是List的实现类，只不过它是采用的链式实现，也就是我们之前讲解的链表，只不过它是一个双向链表，也就是同时保存两个方向： 1234567891011121314151617181920212223242526272829303132public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable{ transient int size = 0; //引用首结点 transient Node&lt;E&gt; first; //引用尾结点 transient Node&lt;E&gt; last; //构造方法，很简单，直接创建就行了 public LinkedList() { } ... private static class Node&lt;E&gt; { //内部使用的结点类 E item; Node&lt;E&gt; next; //不仅保存指向下一个结点的引用，还保存指向上一个结点的引用 Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) { this.item = element; this.next = next; this.prev = prev; } } ...} LinkedList的使用和ArrayList的使用几乎相同，各项操作的结果也是一样的，在什么使用使用ArrayList和LinkedList，我们需要结合具体的场景来决定，尽可能的扬长避短。 只不过LinkedList不仅可以当做List来使用，也可以当做双端队列使用，我们会在后面进行详细介绍。 迭代器我们接着来介绍迭代器，实际上我们的集合类都是支持使用foreach语法的： 123456public static void main(String[] args) { List&lt;String&gt; list = Arrays.asList(\"A\", \"B\", \"C\"); for (String s : list) { //集合类同样支持这种语法 System.out.println(s); }} 但是由于仅仅是语法糖，实际上编译之后： 12345678910public static void main(String[] args) { List&lt;String&gt; list = Arrays.asList(\"A\", \"B\", \"C\"); Iterator var2 = list.iterator(); //这里使用的是List的迭代器在进行遍历操作 while(var2.hasNext()) { String s = (String)var2.next(); System.out.println(s); }} 那么这个迭代器是一个什么东西呢？我们来研究一下： 123456public static void main(String[] args) { List&lt;String&gt; list = Arrays.asList(\"A\", \"B\", \"C\"); //通过调用iterator方法快速获取当前集合的迭代器 //Iterator迭代器本身也是一个接口，由具体的集合实现类来根据情况实现 Iterator&lt;String&gt; iterator = list.iterator();} 通过使用迭代器，我们就可以实现对集合中的元素的进行遍历，就像我们遍历数组那样，它的运作机制大概是： 一个新的迭代器就像上面这样，默认有一个指向集合中第一个元素的指针： 每一次next操作，都会将指针后移一位，直到完成每一个元素的遍历，此时再调用next将不能再得到下一个元素。至于为什么要这样设计，是因为集合类的实现方案有很多，可能是链式存储，也有可能是数组存储，不同的实现有着不同的遍历方式，而迭代器则可以将多种多样不同的集合类遍历方式进行统一，只需要各个集合类根据自己的情况进行对应实现就行了。 我们来看看这个接口的源码定义了哪些操作： 12345678910111213141516171819public interface Iterator&lt;E&gt; { //看看是否还有下一个元素 boolean hasNext(); //遍历当前元素，并将下一个元素作为待遍历元素 E next(); //移除上一个被遍历的元素（某些集合不支持这种操作） default void remove() { throw new UnsupportedOperationException(\"remove\"); } //对剩下的元素进行自定义遍历操作 default void forEachRemaining(Consumer&lt;? super E&gt; action) { Objects.requireNonNull(action); while (hasNext()) action.accept(next()); }} 在ArrayList和LinkedList中，迭代器的实现也不同，比如ArrayList就是直接按下标访问： 12345public E next() { ... cursor = i + 1; //移动指针 return (E) elementData[lastRet = i]; //直接返回指针所指元素} LinkedList就是不断向后寻找结点： 123456public E next() { ... next = next.next; //向后继续寻找结点 nextIndex++; return lastReturned.item; //返回结点内部存放的元素} 虽然这两种列表的实现不同，遍历方式也不同，但是都是按照迭代器的标准进行了实现，所以说，我们想要遍历一个集合中所有的元素，那么就可以直接使用迭代器来完成，而不需要关心集合类是如何实现，我们该怎么去遍历： 1234567public static void main(String[] args) { List&lt;String&gt; list = Arrays.asList(\"A\", \"B\", \"C\"); Iterator&lt;String&gt; iterator = list.iterator(); while (iterator.hasNext()) { //每次循环一定要判断是否还有元素剩余 System.out.println(iterator.next()); //如果有就可以继续获取到下一个元素 }} 注意，迭代器的使用是一次性的，用了之后就不能用了，如果需要再次进行遍历操作，那么需要重新生成一个迭代器对象。为了简便，我们可以直接使用foreach语法来快速遍历集合类，效果是完全一样的： 123456public static void main(String[] args) { List&lt;String&gt; list = Arrays.asList(\"A\", \"B\", \"C\"); for (String s : list) { System.out.println(s); }} 在Java8提供了一个支持Lambda表达式的forEach方法，这个方法接受一个Consumer，也就是对遍历的每一个元素进行的操作： 1234public static void main(String[] args) { List&lt;String&gt; list = Arrays.asList(\"A\", \"B\", \"C\"); list.forEach(System.out::println);} 这个效果跟上面的写法是完全一样的，因为forEach方法内部本质上也是迭代器在处理，这个方法是在Iterable接口中定义的： 123456default void forEach(Consumer&lt;? super T&gt; action) { Objects.requireNonNull(action); for (T t : this) { //foreach语法遍历每一个元素 action.accept(t); //调用Consumer的accept来对每一个元素进行消费 }} 那么我们来看一下，Iterable这个接口又是是什么东西？ 我们来看看定义了哪些内容： 123456789101112131415161718//注意这个接口是集合接口的父接口，不要跟之前的迭代器接口搞混了public interface Iterable&lt;T&gt; { //生成当前集合的迭代器，在Collection接口中重复定义了一次 Iterator&lt;T&gt; iterator(); //Java8新增方法，因为是在顶层接口中定义的，因此所有的集合类都有这个方法 default void forEach(Consumer&lt;? super T&gt; action) { Objects.requireNonNull(action); for (T t : this) { action.accept(t); } } //这个方法会在多线程部分中进行介绍，暂时不做讲解 default Spliterator&lt;T&gt; spliterator() { return Spliterators.spliteratorUnknownSize(iterator(), 0); }} 得益于Iterable提供的迭代器生成方法，实际上只要是实现了迭代器接口的类（我们自己写的都行），都可以使用foreach语法： 12345678910111213141516public class Test implements Iterable&lt;String&gt;{ //这里我们随便写一个类，让其实现Iterable接口 @Override public Iterator&lt;String&gt; iterator() { return new Iterator&lt;String&gt;() { //生成一个匿名的Iterator对象 @Override public boolean hasNext() { //这里随便写的，直接返回true，这将会导致无限循环 return true; } @Override public String next() { //每次就直接返回一个字符串吧 return \"测试\"; } }; }} 可以看到，直接就支持这种语法了，虽然我们这个是自己写的，并不是集合类： 123456public static void main(String[] args) { Test test = new Test(); for (String s : test) { System.out.println(s); }} 是不是感觉集合类的设计非常巧妙？ 我们这里再来介绍一下ListIterator，这个迭代器是针对于List的强化版本，增加了更多方便的操作，因为List是有序集合，所以它支持两种方向的遍历操作，不仅能从前向后，也可以从后向前： 12345678910111213141516171819202122232425262728public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; { //原本就有的 boolean hasNext(); //原本就有的 E next(); //查看前面是否有已经遍历的元素 boolean hasPrevious(); //跟next相反，这里是倒着往回遍历 E previous(); //返回下一个待遍历元素的下标 int nextIndex(); //返回上一个已遍历元素的下标 int previousIndex(); //原本就有的 void remove(); //将上一个已遍历元素修改为新的元素 void set(E e); //在遍历过程中，插入新的元素到当前待遍历元素之前 void add(E e);} 我们来测试一下吧： 1234567public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(\"A\", \"B\", \"C\")); ListIterator&lt;String&gt; iterator = list.listIterator(); iterator.next(); //此时得到A iterator.set(\"X\"); //将A原本位置的上的元素设定为成新的 System.out.println(list);} 这种迭代器因为能够双向遍历，所以说可以反复使用。 Queue和Deque通过前面的学习，我们已经了解了List的使用，其中LinkedList除了可以直接当做列表使用之外，还可以当做其他的数据结构使用，可以看到它不仅仅实现了List接口： 1234public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable{ 这个Deque接口是干嘛的呢？我们先来看看它的继承结构： 我们先来看看队列接口，它扩展了大量队列相关操作： 1234567891011121314151617181920public interface Queue&lt;E&gt; extends Collection&lt;E&gt; { //队列的添加操作，是在队尾进行插入（只不过List也是一样的，默认都是尾插） //如果插入失败，会直接抛出异常 boolean add(E e); //同样是添加操作，但是插入失败不会抛出异常 boolean offer(E e); //移除队首元素，但是如果队列已经为空，那么会抛出异常 E remove(); //同样是移除队首元素，但是如果队列为空，会返回null E poll(); //仅获取队首元素，不进行出队操作，但是如果队列已经为空，那么会抛出异常 E element(); //同样是仅获取队首元素，但是如果队列为空，会返回null E peek();} 我们可以直接将一个LinkedList当做一个队列来使用： 1234567public static void main(String[] args) { Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); //当做队列使用，还是很方便的 queue.offer(\"AAA\"); queue.offer(\"BBB\"); System.out.println(queue.poll()); System.out.println(queue.poll());} 我们接着来看双端队列，实际上双端队列就是队列的升级版，我们一个普通的队列就是： 普通队列中从队尾入队，队首出队，而双端队列允许在队列的两端进行入队和出队操作： 利用这种特性，双端队列既可以当做普通队列使用，也可以当做栈来使用，我们来看看Java中是如何定义的Deque双端队列接口的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//在双端队列中，所有的操作都有分别对应队首和队尾的public interface Deque&lt;E&gt; extends Queue&lt;E&gt; { //在队首进行插入操作 void addFirst(E e); //在队尾进行插入操作 void addLast(E e); //不用多说了吧？ boolean offerFirst(E e); boolean offerLast(E e); //在队首进行移除操作 E removeFirst(); //在队尾进行移除操作 E removeLast(); //不用多说了吧？ E pollFirst(); E pollLast(); //获取队首元素 E getFirst(); //获取队尾元素 E getLast(); //不用多说了吧？ E peekFirst(); E peekLast(); //从队列中删除第一个出现的指定元素 boolean removeFirstOccurrence(Object o); //从队列中删除最后一个出现的指定元素 boolean removeLastOccurrence(Object o); // *** 队列中继承下来的方法操作是一样的，这里就不列出了 *** ... // *** 栈相关操作已经帮助我们定义好了 *** //将元素推向栈顶 void push(E e); //将元素从栈顶出栈 E pop(); // *** 集合类中继承的方法这里也不多种介绍了 *** ... //生成反向迭代器，这个迭代器也是单向的，但是是next方法是从后往前进行遍历的 Iterator&lt;E&gt; descendingIterator();} 我们可以来测试一下，比如我们可以直接当做栈来进行使用： 1234567public static void main(String[] args) { Deque&lt;String&gt; deque = new LinkedList&lt;&gt;(); deque.push(\"AAA\"); deque.push(\"BBB\"); System.out.println(deque.pop()); System.out.println(deque.pop());} 可以看到，得到的顺序和插入顺序是完全相反的，其实只要各位理解了前面讲解的数据结构，就很简单了。我们来测试一下反向迭代器和正向迭代器： 1234567891011public static void main(String[] args) { Deque&lt;String&gt; deque = new LinkedList&lt;&gt;(); deque.addLast(\"AAA\"); deque.addLast(\"BBB\"); Iterator&lt;String&gt; descendingIterator = deque.descendingIterator(); System.out.println(descendingIterator.next()); Iterator&lt;String&gt; iterator = deque.iterator(); System.out.println(iterator.next());} 可以看到，正向迭代器和反向迭代器的方向是完全相反的。 当然，除了LinkedList实现了队列接口之外，还有其他的实现类，但是并不是很常用，这里做了解就行了： 1234public static void main(String[] args) { Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;(); //数组实现的栈和队列 Queue&lt;String&gt; queue = new PriorityQueue&lt;&gt;(); //优先级队列} 这里需要介绍一下优先级队列，优先级队列可以根据每一个元素的优先级，对出队顺序进行调整，默认情况按照自然顺序： 123456789public static void main(String[] args) { Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(); queue.offer(10); queue.offer(4); queue.offer(5); System.out.println(queue.poll()); System.out.println(queue.poll()); System.out.println(queue.poll());} 可以看到，我们的插入顺序虽然是10/4/5，但是出队顺序是按照优先级来的，类似于VIP用户可以优先结束排队。我们也可以自定义比较规则，同样需要给一个Comparator的实现： 123456789public static void main(String[] args) { Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;((a, b) -&gt; b - a); //按照从大到小顺序出队 queue.offer(10); queue.offer(4); queue.offer(5); System.out.println(queue.poll()); System.out.println(queue.poll()); System.out.println(queue.poll());} 只不过需要注意的是，优先级队列并不是队列中所有的元素都是按照优先级排放的，优先级队列只能保证出队顺序是按照优先级进行的，我们可以打印一下： 想要了解优先级队列的具体是原理，可以在《数据结构与算法》篇视频教程中学习大顶堆和小顶堆。 Set集合前面我们已经介绍了列表，我们接着来看Set集合，这种集合类型比较特殊，我们先来看看Set的定义： 1234567891011121314151617181920212223242526272829303132public interface Set&lt;E&gt; extends Collection&lt;E&gt; { // Set集合中基本都是从Collection直接继承过来的方法，只不过对这些方法有更加特殊的定义 int size(); boolean isEmpty(); boolean contains(Object o); Iterator&lt;E&gt; iterator(); Object[] toArray(); &lt;T&gt; T[] toArray(T[] a); //添加元素只有在当前Set集合中不存在此元素时才会成功，如果插入重复元素，那么会失败 boolean add(E e); //这个同样是删除指定元素 boolean remove(Object o); boolean containsAll(Collection&lt;?&gt; c); //同样是只能插入那些不重复的元素 boolean addAll(Collection&lt;? extends E&gt; c); boolean retainAll(Collection&lt;?&gt; c); boolean removeAll(Collection&lt;?&gt; c); void clear(); boolean equals(Object o); int hashCode(); //这个方法我们同样会放到多线程中进行介绍 @Override default Spliterator&lt;E&gt; spliterator() { return Spliterators.spliterator(this, Spliterator.DISTINCT); }} 我们发现接口中定义的方法都是Collection中直接继承的，因此，Set支持的功能其实也就和Collection中定义的差不多，只不过： 不允许出现重复元素 不支持随机访问（不允许通过下标访问） 首先认识一下HashSet，它的底层就是采用哈希表实现的（我们在这里先不去探讨实现原理，因为底层实质上是借用的一个HashMap在实现，这个需要我们学习了Map之后再来讨论）我们可以非常高效的从HashSet中存取元素，我们先来测试一下它的特性： 123456public static void main(String[] args) { Set&lt;String&gt; set = new HashSet&lt;&gt;(); System.out.println(set.add(\"AAA\")); //这里我们连续插入两个同样的字符串 System.out.println(set.add(\"AAA\")); System.out.println(set); //可以看到，最后实际上只有一个成功插入了} 在Set接口中并没有定义支持指定下标位置访问的添加和删除操作，我们只能简单的删除Set中的某个对象： 123456public static void main(String[] args) { Set&lt;String&gt; set = new HashSet&lt;&gt;(); System.out.println(set.add(\"AAA\")); System.out.println(set.remove(\"AAA\")); System.out.println(set);} 由于底层采用哈希表实现，所以说无法维持插入元素的顺序： 12345public static void main(String[] args) { Set&lt;String&gt; set = new HashSet&lt;&gt;(); set.addAll(Arrays.asList(\"A\", \"0\", \"-\", \"+\")); System.out.println(set);} 那要是我们就是想要使用维持顺序的Set集合呢？我们可以使用LinkedHashSet，LinkedHashSet底层维护的不再是一个HashMap，而是LinkedHashMap，它能够在插入数据时利用链表自动维护顺序，因此这样就能够保证我们插入顺序和最后的迭代顺序一致了。 12345public static void main(String[] args) { Set&lt;String&gt; set = new LinkedHashSet&lt;&gt;(); set.addAll(Arrays.asList(\"A\", \"0\", \"-\", \"+\")); System.out.println(set);} 还有一种Set叫做TreeSet，它会在元素插入时进行排序： 1234567public static void main(String[] args) { TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); set.add(1); set.add(3); set.add(2); System.out.println(set);} 可以看到最后得到的结果并不是我们插入顺序，而是按照数字的大小进行排列。当然，我们也可以自定义排序规则： 1234567public static void main(String[] args) { TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;((a, b) -&gt; b - a); //同样是一个Comparator set.add(1); set.add(3); set.add(2); System.out.println(set);} 目前，Set集合只是粗略的进行了讲解，但是学习Map之后，我们还会回来看我们Set的底层实现，所以说最重要的还是Map。本节只需要记住Set的性质、使用即可。 Map映射什么是映射？我们在高中阶段其实已经学习过映射（Mapping）了，映射指两个元素的之间相互“对应”的关系，也就是说，我们的元素之间是两两对应的，是以键值对的形式存在。 而Map就是为了实现这种数据结构而存在的，我们通过保存键值对的形式来存储映射关系，就可以轻松地通过键找到对应的映射值，比如现在我们要保存很多学生的信息，而这些学生都有自己的ID，我们可以将其以映射的形式保存，将ID作为键，学生详细信息作为值，这样我们就可以通过学生的ID快速找到对应学生的信息了。 在Map中，这些映射关系被存储为键值对，我们先来看看Map接口中定义了哪些操作： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//Map并不是Collection体系下的接口，而是单独的一个体系，因为操作特殊//这里需要填写两个泛型参数，其中K就是键的类型，V就是值的类型，比如上面的学生信息，ID一般是int，那么键就是Integer类型的，而值就是学生信息，所以说值是学生对象类型的public interface Map&lt;K,V&gt; { //-------- 查询相关操作 -------- //获取当前存储的键值对数量 int size(); //是否为空 boolean isEmpty(); //查看Map中是否包含指定的键 boolean containsKey(Object key); //查看Map中是否包含指定的值 boolean containsValue(Object value); //通过给定的键，返回其映射的值 V get(Object key); //-------- 修改相关操作 -------- //向Map中添加新的映射关系，也就是新的键值对 V put(K key, V value); //根据给定的键，移除其映射关系，也就是移除对应的键值对 V remove(Object key); //-------- 批量操作 -------- //将另一个Map中的所有键值对添加到当前Map中 void putAll(Map&lt;? extends K, ? extends V&gt; m); //清空整个Map void clear(); //-------- 其他视图操作 -------- //返回Map中存放的所有键，以Set形式返回 Set&lt;K&gt; keySet(); //返回Map中存放的所有值 Collection&lt;V&gt; values(); //返回所有的键值对，这里用的是内部类Entry在表示 Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet(); //这个是内部接口Entry，表示一个键值对 interface Entry&lt;K,V&gt; { //获取键值对的键 K getKey(); //获取键值对的值 V getValue(); //修改键值对的值 V setValue(V value); //判断两个键值对是否相等 boolean equals(Object o); //返回当前键值对的哈希值 int hashCode(); ... } ...} 当然，Map中定义了非常多的方法，尤其是在Java 8之后新增的大量方法，我们会在后面逐步介绍的。 我们可以来尝试使用一下Map，实际上非常简单，这里我们使用最常见的HashMap，它的底层采用哈希表实现： 123456public static void main(String[] args) { Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1, \"小明\"); //使用put方法添加键值对，返回值我们会在后面讨论 map.put(2, \"小红\"); System.out.println(map.get(2)); //使用get方法根据键获取对应的值} 注意，Map中无法添加相同的键，同样的键只能存在一个，即使值不同。如果出现键相同的情况，那么会覆盖掉之前的： 123456public static void main(String[] args) { Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1, \"小明\"); map.put(1, \"小红\"); //这里的键跟之前的是一样的，这样会导致将之前的键值对覆盖掉 System.out.println(map.get(1));} 为了防止意外将之前的键值对覆盖掉，我们可以使用： 123456public static void main(String[] args) { Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1, \"小明\"); map.putIfAbsent(1, \"小红\"); //Java8新增操作，只有在不存在相同键的键值对时才会存放 System.out.println(map.get(1));} 还有，我们在获取一个不存在的映射时，默认会返回null作为结果： 12345public static void main(String[] args) { Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1, \"小明\"); //Map中只有键为1的映射 System.out.println(map.get(3)); //此时获取键为3的值，那肯定是没有的，所以说返回null} 我们也可以为这种情况添加一个预备方案，当Map中不存在时，可以返回一个备选的返回值： 12345public static void main(String[] args) { Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1, \"小明\"); System.out.println(map.getOrDefault(3, \"备胎\")); //Java8新增操作，当不存在对应的键值对时，返回备选方案} 同样的，因为HashMap底层采用哈希表实现，所以不维护顺序，我们在获取所有键和所有值时，可能会是乱序的： 123456789public static void main(String[] args) { Map&lt;String , String&gt; map = new HashMap&lt;&gt;(); map.put(\"0\", \"十七张\"); map.put(\"+\", \"牌\"); map.put(\"P\", \"你能秒我\"); System.out.println(map); System.out.println(map.keySet()); System.out.println(map.values());} 如果需要维护顺序，我们同样可以使用LinkedHashMap，它的内部对插入顺序进行了维护： 123456789public static void main(String[] args) { Map&lt;String , String&gt; map = new LinkedHashMap&lt;&gt;(); map.put(\"0\", \"十七张\"); map.put(\"+\", \"牌\"); map.put(\"P\", \"你能秒我\"); System.out.println(map); System.out.println(map.keySet()); System.out.println(map.values());} 实际上Map的使用还是挺简单的，我们接着来看看Map的底层是如何实现的，首先是最简单的HashMap，我们前面已经说过了，它的底层采用的是哈希表，首先回顾我们之前学习的哈希表，我们当时说了，哈希表可能会出现哈希冲突，这样保存的元素数量就会存在限制，而我们可以通过连地址法解决这种问题，最后哈希表就长这样了： 实际上这个表就是一个存放头结点的数组+若干结点，而HashMap也是这样的，我们来看看这里面是怎么定义的： 12345678910111213141516171819202122232425public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable { ... static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { //内部使用结点，实际上就是存放的映射关系 final int hash; final K key; //跟我们之前不一样，我们之前一个结点只有键，而这里的结点既存放键也存放值，当然计算哈希还是使用键 V value; Node&lt;K,V&gt; next; ... } ... transient Node&lt;K,V&gt;[] table; //这个就是哈希表本体了，可以看到跟我们之前的写法是一样的，也是头结点数组，只不过HashMap中没有设计头结点（相当于没有头结点的链表） final float loadFactor; //负载因子，这个东西决定了HashMap的扩容效果 public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; //当我们创建对象时，会使用默认的负载因子，值为0.75 } ... } 可以看到，实际上底层大致结构跟我们之前学习的差不多，只不过多了一些特殊的东西： HashMap支持自动扩容，哈希表的大小并不是一直不变的，否则太过死板 HashMap并不是只使用简单的链地址法，当链表长度到达一定限制时，会转变为效率更高的红黑树结构 我们来研究一下它的put方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public V put(K key, V value) { //这里计算完键的哈希值之后，调用的另一个方法进行映射关系存放 return putVal(hash(key), key, value, false, true);}final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) //如果底层哈希表没初始化，先初始化 n = (tab = resize()).length; //通过resize方法初始化底层哈希表，初始容量为16，后续会根据情况扩容，底层哈希表的长度永远是2的n次方 //因为传入的哈希值可能会很大，这里同样是进行取余操作 //(n - 1) &amp; hash 等价于 hash % n 这里的i就是最终得到的下标位置了 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); //如果这个位置上什么都没有，那就直接放一个新的结点 else { //这种情况就是哈希冲突了 Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; //如果上来第一个结点的键的哈希值跟当前插入的键的哈希值相同，键也相同，说明已经存放了相同键的键值对了，那就执行覆盖操作 ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //这里直接将待插入结点等于原本冲突的结点，一会直接覆盖 else if (p instanceof TreeNode) //如果第一个结点是TreeNode类型的，说明这个链表已经升级为红黑树了 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); //在红黑树中插入新的结点 else { for (int binCount = 0; ; ++binCount) { //普通链表就直接在链表尾部插入 if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); //找到尾部，直接创建新的结点连在后面 if (binCount &gt;= TREEIFY_THRESHOLD - 1) //如果当前链表的长度已经很长了，达到了阈值 treeifyBin(tab, hash); //那么就转换为红黑树来存放 break; //直接结束 } if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) //同样的，如果在向下找的过程中发现已经存在相同键的键值对了，直接结束，让p等于e一会覆盖就行了 break; p = e; } } if (e != null) { // 如果e不为空，只有可能是前面出现了相同键的情况，其他情况e都是null，所有直接覆盖就行 V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; //覆盖之后，会返回原本的被覆盖值 } } ++modCount; if (++size &gt; threshold) //键值对size计数自增，如果超过阈值，会对底层哈希表数组进行扩容 resize(); //调用resize进行扩容 afterNodeInsertion(evict); return null; //正常插入键值对返回值为null} 是不是感觉只要前面的数据结构听懂了，这里简直太简单。根据上面的推导，我们在正常插入一个键值对时，会得到null返回值，而冲突时会得到一个被覆盖的值： 12345public static void main(String[] args) { Map&lt;String , String&gt; map = new HashMap&lt;&gt;(); System.out.println(map.put(\"0\", \"十七张\")); System.out.println(map.put(\"0\", \"慈善家\"));} 现在我们知道，当HashMap的一个链表长度过大时，会自动转换为红黑树： 但是这样始终治标不治本，受限制的始终是底层哈希表的长度，我们还需要进一步对底层的这个哈希表进行扩容才可以从根本上解决问题，我们来看看resize()方法： 1234567891011121314151617181920212223242526272829final Node&lt;K,V&gt;[] resize() { Node&lt;K,V&gt;[] oldTab = table; //先把下面这几个旧的东西保存一下 int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; //这些是新的容量和扩容阈值 if (oldCap &gt; 0) { //如果旧容量大于0，那么就开始扩容 if (oldCap &gt;= MAXIMUM_CAPACITY) { //如果旧的容量已经大于最大限制了，那么直接给到 Integer.MAX_VALUE threshold = Integer.MAX_VALUE; return oldTab; //这种情况不用扩了 } else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) //新的容量等于旧容量的2倍，同样不能超过最大值 newThr = oldThr &lt;&lt; 1; //新的阈值也提升到原来的两倍 } else if (oldThr &gt; 0) // 旧容量不大于0只可能是还没初始化，这个时候如果阈值大于0，直接将新的容量变成旧的阈值 newCap = oldThr; else { // 默认情况下阈值也是0，也就是我们刚刚无参new出来的时候 newCap = DEFAULT_INITIAL_CAPACITY; //新的容量直接等于默认容量16 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); //阈值为负载因子乘以默认容量，负载因子默认为0.75，也就是说只要整个哈希表用了75%的容量，那么就进行扩容，至于为什么默认是0.75，原因很多，这里就不解释了，反正作为新手，这些都是大佬写出来的，我们用就完事。 } ... threshold = newThr; @SuppressWarnings({\"rawtypes\",\"unchecked\"}) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; //将底层数组变成新的扩容之后的数组 if (oldTab != null) { //如果旧的数组不为空，那么还需要将旧的数组中所有元素全部搬到新的里面去 ... //详细过程就不介绍了 }} 是不是感觉自己有点了解HashMap的运作机制了，其实并不是想象中的那么难，因为这些东西再怎么都是人写的。 而LinkedHashMap是直接继承自HashMap，具有HashMap的全部性质，同时得益于每一个节点都是一个双向链表，在插入键值对时，同时保存了插入顺序： 123456static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; { //LinkedHashMap中的结点实现 Entry&lt;K,V&gt; before, after; //这里多了一个指向前一个结点和后一个结点的引用 Entry(int hash, K key, V value, Node&lt;K,V&gt; next) { super(hash, key, value, next); }} 这样我们在遍历LinkedHashMap时，顺序就同我们的插入顺序一致。当然，也可以使用访问顺序，也就是说对于刚访问过的元素，会被排到最后一位。 当然还有一种比较特殊的Map叫做TreeMap，就像它的名字一样，就是一个Tree，它的内部直接维护了一个红黑树（没有使用哈希表）因为它会将我们插入的结点按照规则进行排序，所以说直接采用红黑树会更好，我们在创建时，直接给予一个比较规则即可，跟之前的TreeSet是一样的： 1234567public static void main(String[] args) { Map&lt;Integer , String&gt; map = new TreeMap&lt;&gt;((a, b) -&gt; b - a); map.put(0, \"单走\"); map.put(1, \"一个六\"); map.put(3, \"**\"); System.out.println(map);} 现在我们倒回来看之前讲解的HashSet集合，实际上它的底层很简单： 123456789101112131415161718192021222324252627282930public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable{ private transient HashMap&lt;E,Object&gt; map; //对，你没看错，底层直接用map来做事 // 因为Set只需要存储Key就行了，所以说这个对象当做每一个键值对的共享Value private static final Object PRESENT = new Object(); //直接构造一个默认大小为16负载因子0.75的HashMap public HashSet() { map = new HashMap&lt;&gt;(); } ... //你会发现所有的方法全是替身攻击 public Iterator&lt;E&gt; iterator() { return map.keySet().iterator(); } public int size() { return map.size(); } public boolean isEmpty() { return map.isEmpty(); }} 通过观察HashSet的源码发现，HashSet几乎都在操作内部维护的一个HashMap，也就是说，HashSet只是一个表壳，而内部维护的HashMap才是灵魂！就像你进了公司，在外面花钱请别人帮你写公司的业务，你只需要坐着等别人写好然后你自己拿去交差就行了。所以说，HashSet利用了HashMap内部的数据结构，轻松地就实现了Set定义的全部功能！ 再来看TreeSet，实际上用的就是我们的TreeMap： 123456789101112131415161718public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable{ //底层需要一个NavigableMap，就是自动排序的Map private transient NavigableMap&lt;E,Object&gt; m; //不用我说了吧 private static final Object PRESENT = new Object(); ... //直接使用TreeMap解决问题 public TreeSet() { this(new TreeMap&lt;E,Object&gt;()); } ...} 同理，这里就不多做阐述了。 我们接着来看看Map中定义的哪些杂七杂八的方法，首先来看看compute方法： 123456789101112public static void main(String[] args) { Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1, \"A\"); map.put(2, \"B\"); map.compute(1, (k, v) -&gt; { //compute会将指定Key的值进行重新计算，若Key不存在，v会返回null return v+\"M\"; //这里返回原来的value+M }); map.computeIfPresent(1, (k, v) -&gt; { //当Key存在时存在则计算并赋予新的值 return v+\"M\"; //这里返回原来的value+M }); System.out.println(map);} 也可以使用computeIfAbsent，当不存在Key时，计算并将键值对放入Map中： 123456789public static void main(String[] args) { Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1, \"A\"); map.put(2, \"B\"); map.computeIfAbsent(0, (k) -&gt; { //若不存在则计算并插入新的值 return \"M\"; //这里返回M }); System.out.println(map);} merge方法用于处理数据： 1234567891011121314151617181920212223242526272829303132333435363738394041public static void main(String[] args) { List&lt;Student&gt; students = Arrays.asList( new Student(\"yoni\", \"English\", 80), new Student(\"yoni\", \"Chiness\", 98), new Student(\"yoni\", \"Math\", 95), new Student(\"taohai.wang\", \"English\", 50), new Student(\"taohai.wang\", \"Chiness\", 72), new Student(\"taohai.wang\", \"Math\", 41), new Student(\"Seely\", \"English\", 88), new Student(\"Seely\", \"Chiness\", 89), new Student(\"Seely\", \"Math\", 92) ); Map&lt;String, Integer&gt; scoreMap = new HashMap&lt;&gt;(); //merge方法可以对重复键的值进行特殊操作，比如我们想计算某个学生的所有科目分数之后，那么就可以像这样： students.forEach(student -&gt; scoreMap.merge(student.getName(), student.getScore(), Integer::sum)); scoreMap.forEach((k, v) -&gt; System.out.println(\"key:\" + k + \"总分\" + \"value:\" + v));}static class Student { private final String name; private final String type; private final int score; public Student(String name, String type, int score) { this.name = name; this.type = type; this.score = score; } public String getName() { return name; } public int getScore() { return score; } public String getType() { return type; }} replace方法可以快速替换某个映射的值： 123456public static void main(String[] args) { Map&lt;Integer , String&gt; map = new HashMap&lt;&gt;(); map.put(0, \"单走\"); map.replace(0, \"&gt;&gt;&gt;\"); //直接替换为新的 System.out.println(map);} 也可以精准匹配： 123456public static void main(String[] args) { Map&lt;Integer , String&gt; map = new HashMap&lt;&gt;(); map.put(0, \"单走\"); map.replace(0, \"巴卡\", \"玛卡\"); //只有键和值都匹配时，才进行替换 System.out.println(map);} 包括remove方法，也支持键值同时匹配： 123456public static void main(String[] args) { Map&lt;Integer , String&gt; map = new HashMap&lt;&gt;(); map.put(0, \"单走\"); map.remove(0, \"单走\"); //只有同时匹配时才移除 System.out.println(map);} 是不是感觉学习了Map之后，涨了不少姿势？ Stream流Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。 它看起来就像一个工厂的流水线一样！我们就可以把一个Stream当做流水线处理： 12345678910111213141516171819public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"A\"); list.add(\"B\"); list.add(\"C\"); //移除为B的元素 Iterator&lt;String&gt; iterator = list.iterator(); while (iterator.hasNext()){ if(iterator.next().equals(\"B\")) iterator.remove(); } //Stream操作 list = list //链式调用 .stream() //获取流 .filter(e -&gt; !e.equals(\"B\")) //只允许所有不是B的元素通过流水线 .collect(Collectors.toList()); //将流水线中的元素重新收集起来，变回List System.out.println(list);} 可能从上述例子中还不能感受到流处理带来的便捷，我们通过下面这个例子来感受一下： 1234567891011121314151617public static void main(String[] args) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); list.add(3); list = list .stream() .distinct() //去重（使用equals判断） .sorted((a, b) -&gt; b - a) //进行倒序排列 .map(e -&gt; e+1) //每个元素都要执行+1操作 .limit(2) //只放行前两个元素 .collect(Collectors.toList()); System.out.println(list);} 当遇到大量的复杂操作时，我们就可以使用Stream来快速编写代码，这样不仅代码量大幅度减少，而且逻辑也更加清晰明了（如果你学习过SQL的话，你会发现它更像一个Sql语句） 注意：不能认为每一步是直接依次执行的！我们可以断点测试一下： 12345678910111213141516List&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.add(1);list.add(2);list.add(3);list.add(3);list = list .stream() .distinct() //断点 .sorted((a, b) -&gt; b - a) .map(e -&gt; { System.out.println(\"&gt;&gt;&gt; \"+e); //断点 return e+1; }) .limit(2) //断点 .collect(Collectors.toList()); 实际上，stream会先记录每一步操作，而不是直接开始执行内容，当整个链式调用完成后，才会依次进行，也就是说需要的时候，工厂的机器才会按照预定的流程启动。 接下来，我们用一堆随机数来进行更多流操作的演示： 123456789public static void main(String[] args) { Random random = new Random(); //没想到吧，Random支持直接生成随机数的流 random .ints(-100, 100) //生成-100~100之间的，随机int型数字（本质上是一个IntStream） .limit(10) //只获取前10个数字（这是一个无限制的流，如果不加以限制，将会无限进行下去！） .filter(i -&gt; i &lt; 0) //只保留小于0的数字 .sorted() //默认从小到大排序 .forEach(System.out::println); //依次打印} 我们可以生成一个统计实例来帮助我们快速进行统计： 12345678910public static void main(String[] args) { Random random = new Random(); //Random是一个随机数工具类 IntSummaryStatistics statistics = random .ints(0, 100) .limit(100) .summaryStatistics(); //获取语法统计实例 System.out.println(statistics.getMax()); //快速获取最大值 System.out.println(statistics.getCount()); //获取数量 System.out.println(statistics.getAverage()); //获取平均值} 普通的List只需要一个方法就可以直接转换到方便好用的IntStream了： 1234567891011public static void main(String[] args) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(1); list.add(2); list.add(3); list.add(4); list.stream() .mapToInt(i -&gt; i) //将每一个元素映射为Integer类型（这里因为本来就是Integer） .summaryStatistics();} 我们还可以通过flat来对整个流进行进一步细分： 1234567891011public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"A,B\"); list.add(\"C,D\"); list.add(\"E,F\"); //我们想让每一个元素通过,进行分割，变成独立的6个元素 list = list .stream() //生成流 .flatMap(e -&gt; Arrays.stream(e.split(\",\"))) //分割字符串并生成新的流 .collect(Collectors.toList()); //汇成新的List System.out.println(list); //得到结果} 我们也可以只通过Stream来完成所有数字的和，使用reduce方法： 1234567891011public static void main(String[] args) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); int sum = list .stream() .reduce((a, b) -&gt; a + b) //计算规则为：a是上一次计算的值，b是当前要计算的参数，这里是求和 .get(); //我们发现得到的是一个Optional类实例，通过get方法返回得到的值 System.out.println(sum);} 可能，作为新手来说，一次性无法接受这么多内容，但是在各位以后的开发中，就会慢慢使用到这些东西了。 Collections工具类我们在前面介绍了Arrays，它是一个用于操作数组的工具类，它给我们提供了大量的工具方法。 既然数组操作都这么方便了，集合操作能不能也安排点高级的玩法呢？那必须的，JDK为我们准备的Collocations类就是专用于集合的工具类，比如我们想快速求得List中的最大值和最小值： 12345public static void main(String[] args) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Collections.max(list); Collections.min(list);} 同样的，我们可以对一个集合进行二分搜索（注意，集合的具体类型，必须是实现Comparable接口的类）： 1234public static void main(String[] args) { List&lt;Integer&gt; list = Arrays.asList(2, 3, 8, 9, 10, 13); System.out.println(Collections.binarySearch(list, 8));} 我们也可以对集合的元素进行快速填充，注意这个填充是对集合中已有的元素进行覆盖： 12345public static void main(String[] args) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1,2,3,4,5)); Collections.fill(list, 6); System.out.println(list);} 如果集合中本身没有元素，那么fill操作不会生效。 有些时候我们可能需要生成一个空的集合类返回，那么我们可以使用emptyXXX来快速生成一个只读的空集合： 12345public static void main(String[] args) { List&lt;Integer&gt; list = Collections.emptyList(); //Collections.singletonList() 会生成一个只有一个元素的List list.add(10); //不支持，会直接抛出异常} 我们也可以将一个可修改的集合变成只读的集合： 12345public static void main(String[] args) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1,2,3,4,5)); List&lt;Integer&gt; newList = Collections.unmodifiableList(list); newList.add(10); //不支持，会直接抛出异常} 我们也可以寻找子集合的位置： 1234public static void main(String[] args) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1,2,3,4,5)); System.out.println(Collections.indexOfSubList(list, Arrays.asList(4, 5)));} 得益于泛型的类型擦除机制，实际上最后只要是Object的实现类都可以保存到集合类中，那么就会出现这种情况： 123456public static void main(String[] args) { //使用原始类型接收一个Integer类型的ArrayList List list = new ArrayList&lt;&gt;(Arrays.asList(1,2,3,4,5)); list.add(\"aaa\"); //我们惊奇地发现，这玩意居然能存字符串进去 System.out.println(list);} 没错，由于泛型机制上的一些漏洞，实际上对应类型的集合类有可能会存放其他类型的值，泛型的类型检查只存在于编译阶段，只要我们绕过这个阶段，在实际运行时，并不会真的进行类型检查，要解决这种问题很简单，就是在运行时进行类型检查： 123456public static void main(String[] args) { List list = new ArrayList&lt;&gt;(Arrays.asList(1,2,3,4,5)); list = Collections.checkedList(list, Integer.class); //这里的.class关键字我们会在后面反射中介绍，表示Integer这个类型 list.add(\"aaa\"); System.out.println(list);} checkedXXX可以将给定集合类进行包装，在运行时同样会进行类型检查，如果通过上面的漏洞插入一个本不应该是当前类型集合支持的类型，那么会直接抛出类型转换异常： 是不是感觉这个工具类好像还挺好用的？实际上在我们的开发中，这个工具类也经常被使用到。 Java I/O注意：这块会涉及到操作系统和计算机组成原理相关内容。 I/O简而言之，就是输入输出，那么为什么会有I/O呢？其实I/O无时无刻都在我们的身边，比如读取硬盘上的文件，网络文件传输，鼠标键盘输入，也可以是接受单片机发回的数据，而能够支持这些操作的设备就是I/O设备。 我们可以大致看一下整个计算机的总线结构： 常见的I/O设备一般是鼠标、键盘这类通过USB进行传输的外设或者是通过Sata接口或是M.2连接的硬盘。一般情况下，这些设备是由CPU发出指令通过南桥芯片间接进行控制，而不是由CPU直接操作。 而我们在程序中，想要读取这些外部连接的I/O设备中的内容，就需要将数据传输到内存中。而需要实现这样的操作，单单凭借一个小的程序是无法做到的，而操作系统（如：Windows/Linux/MacOS）就是专门用于控制和管理计算机硬件和软件资源的软件，我们需要读取一个IO设备的内容时，就可以向操作系统发出请求，由操作系统帮助我们来和底层的硬件交互以完成我们的读取/写入请求。 从读取硬盘文件的角度来说，不同的操作系统有着不同的文件系统（也就是文件在硬盘中的存储排列方式，如Windows就是NTFS、MacOS就是APFS），硬盘只能存储一个个0和1这样的二进制数据，至于0和1如何排列，各自又代表什么意思，就是由操作系统的文件系统来决定的。从网络通信角度来说，网络信号通过网卡等设备翻译为二进制信号，再交给系统进行读取，最后再由操作系统来给到程序。 （传统的SATA硬盘就是通过SATA线与电脑主板相连，这样才可以读取到数据） JDK提供了一套用于IO操作的框架，为了方便我们开发者使用，就定义了一个像水流一样，根据流的传输方向和读取单位，分为字节流InputStream和OutputStream以及字符流Reader和Writer的IO框架，当然，这里的Stream并不是前面集合框架认识的Stream，这里的流指的是数据流，通过流，我们就可以一直从流中读取数据，直到读取到尽头，或是不断向其中写入数据，直到我们写入完成，而这类IO就是我们所说的BIO， 字节流一次读取一个字节，也就是一个byte的大小，而字符流顾名思义，就是一次读取一个字符，也就是一个char的大小（在读取纯文本文件的时候更加适合），有关这两种流，会在后面详细介绍，这个章节我们需要学习16个关键的流。 文件字节流要学习和使用IO，首先就要从最易于理解的读取文件开始说起。 首先介绍一下FileInputStream，我们可以通过它来获取文件的输入流： 12345678public static void main(String[] args) { try { //注意，IO相关操作会有很多影响因素，有可能出现异常，所以需要明确进行处理 FileInputStream inputStream = new FileInputStream(\"路径\"); //路径支持相对路径和绝对路径 } catch (FileNotFoundException e) { e.printStackTrace(); }} 相对路径是在当前运行目录（就是你在哪个目录运行java命令启动Java程序的）的路径下寻找文件，而绝对路径，是从根目录开始寻找。路径分割符支持使用/或是\\\\，但是不能写为\\因为它是转义字符！比如在Windows下： 12C://User/lbw/nb 这个就是一个绝对路径，因为是从盘符开始的test/test 这个就是一个相对路径，因为并不是从盘符开始的，而是一个直接的路径 在Linux和MacOS下： 12/root/tmp 这个就是一个绝对路径，绝对路径以/开头test/test 这个就是一个相对路径，不是以/开头的 当然，这个其实还是很好理解的，我们在使用时注意一下就行了。 在使用完成一个流之后，必须关闭这个流来完成对资源的释放，否则资源会被一直占用： 1234567891011121314public static void main(String[] args) { FileInputStream inputStream = null; //定义可以先放在try外部 try { inputStream = new FileInputStream(\"路径\"); } catch (FileNotFoundException e) { e.printStackTrace(); } finally { try { //建议在finally中进行，因为关闭流是任何情况都必须要执行的！ if(inputStream != null) inputStream.close(); } catch (IOException e) { e.printStackTrace(); } }} 虽然这样的写法才是最保险的，但是显得过于繁琐了，尤其是finally中再次嵌套了一个try-catch块，因此在JDK1.7新增了try-with-resource语法，用于简化这样的写法（本质上还是和这样的操作一致，只是换了个写法） 12345678910public static void main(String[] args) { //注意，这种语法只支持实现了AutoCloseable接口的类！ try(FileInputStream inputStream = new FileInputStream(\"路径\")) { //直接在try()中定义要在完成之后释放的资源 } catch (IOException e) { //这里变成IOException是因为调用close()可能会出现，而FileNotFoundException是继承自IOException的 e.printStackTrace(); } //无需再编写finally语句块，因为在最后自动帮我们调用了close()} 之后为了方便，我们都使用此语法进行教学。 现在我们拿到了文件的输入流，那么怎么才能读取文件里面的内容呢？我们可以使用read方法： 12345678910public static void main(String[] args) { //test.txt：a try(FileInputStream inputStream = new FileInputStream(\"test.txt\")) { //使用read()方法进行字符读取 System.out.println((char) inputStream.read()); //读取一个字节的数据（英文字母只占1字节，中文占2字节） System.out.println(inputStream.read()); //唯一一个字节的内容已经读完了，再次读取返回-1表示没有内容了 }catch (IOException e){ e.printStackTrace(); }} 使用read可以直接读取一个字节的数据，注意，流的内容是有限的，读取一个少一个。我们如果想一次性全部读取的话，可以直接使用一个while循环来完成： 1234567891011public static void main(String[] args) { //test.txt：abcd try(FileInputStream inputStream = new FileInputStream(\"test.txt\")) { int tmp; while ((tmp = inputStream.read()) != -1){ //通过while循环来一次性读完内容 System.out.println((char)tmp); } }catch (IOException e){ e.printStackTrace(); }} 使用available方法能查看当前可读的剩余字节数量（注意：并不一定真实的数据量就是这么多，尤其是在网络I/O操作时，这个方法只能进行一个预估也可以说是暂时能一次性可以读取的数量，当然在磁盘IO下，一般情况都是真实的数据量） 12345try(FileInputStream inputStream = new FileInputStream(\"test.txt\")) { System.out.println(inputStream.available()); //查看剩余数量}catch (IOException e){ e.printStackTrace();} 当然，一个一个读取效率太低了，那能否一次性全部读取呢？我们可以预置一个合适容量的byte[]数组来存放： 12345678910public static void main(String[] args) { //test.txt：abcd try(FileInputStream inputStream = new FileInputStream(\"test.txt\")) { byte[] bytes = new byte[inputStream.available()]; //我们可以提前准备好合适容量的byte数组来存放 System.out.println(inputStream.read(bytes)); //一次性读取全部内容（返回值是读取的字节数） System.out.println(new String(bytes)); //通过String(byte[])构造方法得到字符串 }catch (IOException e){ e.printStackTrace(); }} 也可以控制要读取数量： 1System.out.println(inputStream.read(bytes, 1, 2)); //第二个参数是从给定数组的哪个位置开始放入内容，第三个参数是读取流中的字节数 注意：一次性读取同单个读取一样，当没有任何数据可读时，依然会返回-1 通过skip()方法可以跳过指定数量的字节： 123456789public static void main(String[] args) { //test.txt：abcd try(FileInputStream inputStream = new FileInputStream(\"test.txt\")) { System.out.println(inputStream.skip(1)); System.out.println((char) inputStream.read()); //跳过了一个字节 }catch (IOException e){ e.printStackTrace(); }} 注意：FileInputStream是不支持reset()的，虽然有这个方法，但是这里先不提及。 既然有输入流，那么文件输出流也是必不可少的： 12345678public static void main(String[] args) { //输出流也需要在最后调用close()方法，并且同样支持try-with-resource try(FileOutputStream outputStream = new FileOutputStream(\"output.txt\")) { //注意：若此文件不存在，会直接创建这个文件！ }catch (IOException e){ e.printStackTrace(); }} 输出流没有read()操作而是write()操作，使用方法同输入流一样，只不过现在的方向变为我们向文件里写入内容： 12345678910public static void main(String[] args) { try(FileOutputStream outputStream = new FileOutputStream(\"output.txt\")) { outputStream.write('c'); //同read一样，可以直接写入内容 outputStream.write(\"lbwnb\".getBytes()); //也可以直接写入byte[] outputStream.write(\"lbwnb\".getBytes(), 0, 1); //同上输入流 outputStream.flush(); //建议在最后执行一次刷新操作（强制写入）来保证数据正确写入到硬盘文件中 }catch (IOException e){ e.printStackTrace(); }} 那么如果是我只想在文件尾部进行追加写入数据呢？我们可以调用另一个构造方法来实现： 12345678public static void main(String[] args) { try(FileOutputStream outputStream = new FileOutputStream(\"output.txt\", true)) { //true表示开启追加模式 outputStream.write(\"lb\".getBytes()); //现在只会进行追加写入，而不是直接替换原文件内容 outputStream.flush(); }catch (IOException e){ e.printStackTrace(); }} 利用输入流和输出流，就可以轻松实现文件的拷贝了： 123456789101112public static void main(String[] args) { try(FileOutputStream outputStream = new FileOutputStream(\"output.txt\"); FileInputStream inputStream = new FileInputStream(\"test.txt\")) { //可以写入多个 byte[] bytes = new byte[10]; //使用长度为10的byte[]做传输媒介 int tmp; //存储本地读取字节数 while ((tmp = inputStream.read(bytes)) != -1){ //直到读取完成为止 outputStream.write(bytes, 0, tmp); //写入对应长度的数据到输出流 } }catch (IOException e){ e.printStackTrace(); }} 文件字符流字符流不同于字节，字符流是以一个具体的字符进行读取，因此它只适合读纯文本的文件，如果是其他类型的文件不适用： 12345678public static void main(String[] args) { try(FileReader reader = new FileReader(\"test.txt\")){ reader.skip(1); //现在跳过的是一个字符 System.out.println((char) reader.read()); //现在是按字符进行读取，而不是字节，因此可以直接读取到中文字符 }catch (IOException e){ e.printStackTrace(); }} 同理，字符流只支持char[]类型作为存储： 123456789public static void main(String[] args) { try(FileReader reader = new FileReader(\"test.txt\")){ char[] str = new char[10]; reader.read(str); System.out.println(str); //直接读取到char[]中 }catch (IOException e){ e.printStackTrace(); }} 既然有了Reader肯定也有Writer： 12345678910public static void main(String[] args) { try(FileWriter writer = new FileWriter(\"output.txt\")){ writer.getEncoding(); //支持获取编码（不同的文本文件可能会有不同的编码类型） writer.write('牛'); writer.append('牛'); //其实功能和write一样 writer.flush(); //刷新 }catch (IOException e){ e.printStackTrace(); }} 我们发现不仅有write()方法，还有一个append()方法，但是实际上他们效果是一样的，看源码： 1234public Writer append(char c) throws IOException { write(c); return this;} append支持像StringBuilder那样的链式调用，返回的是Writer对象本身。 练习：尝试一下用Reader和Writer来拷贝纯文本文件。 这里需要额外介绍一下File类，它是专门用于表示一个文件或文件夹，只不过它只是代表这个文件，但并不是这个文件本身。通过File对象，可以更好地管理和操作硬盘上的文件。 123456789public static void main(String[] args) { File file = new File(\"test.txt\"); //直接创建文件对象，可以是相对路径，也可以是绝对路径 System.out.println(file.exists()); //此文件是否存在 System.out.println(file.length()); //获取文件的大小 System.out.println(file.isDirectory()); //是否为一个文件夹 System.out.println(file.canRead()); //是否可读 System.out.println(file.canWrite()); //是否可写 System.out.println(file.canExecute()); //是否可执行} 通过File对象，我们就能快速得到文件的所有信息，如果是文件夹，还可以获取文件夹内部的文件列表等内容： 12345File file = new File(\"/\");System.out.println(Arrays.toString(file.list())); //快速获取文件夹下的文件名称列表for (File f : file.listFiles()){ //所有子文件的File对象 System.out.println(f.getAbsolutePath()); //获取文件的绝对路径} 如果我们希望读取某个文件的内容，可以直接将File作为参数传入字节流或是字符流： 123456File file = new File(\"test.txt\");try (FileInputStream inputStream = new FileInputStream(file)){ //直接做参数 System.out.println(inputStream.available());}catch (IOException e){ e.printStackTrace();} 练习：尝试拷贝文件夹下的所有文件到另一个文件夹 缓冲流虽然普通的文件流读取文件数据非常便捷，但是每次都需要从外部I/O设备去获取数据，由于外部I/O设备的速度一般都达不到内存的读取速度，很有可能造成程序反应迟钝，因此性能还不够高，而缓冲流正如其名称一样，它能够提供一个缓冲，提前将部分内容存入内存（缓冲区）在下次读取时，如果缓冲区中存在此数据，则无需再去请求外部设备。同理，当向外部设备写入数据时，也是由缓冲区处理，而不是直接向外部设备写入。 要创建一个缓冲字节流，只需要将原本的流作为构造参数传入BufferedInputStream即可： 1234567public static void main(String[] args) { try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\"test.txt\"))){ //传入FileInputStream System.out.println((char) bufferedInputStream.read()); //操作和原来的流是一样的 }catch (IOException e){ e.printStackTrace(); }} 实际上进行I/O操作的并不是BufferedInputStream，而是我们传入的FileInputStream，而BufferedInputStream虽然有着同样的方法，但是进行了一些额外的处理然后再调用FileInputStream的同名方法，这样的写法称为装饰者模式，我们会在设计模式篇中详细介绍。我们可以来观察一下它的close方法源码： 12345678910111213public void close() throws IOException { byte[] buffer; while ( (buffer = buf) != null) { if (bufUpdater.compareAndSet(this, buffer, null)) { //CAS无锁算法，并发会用到，暂时不需要了解 InputStream input = in; in = null; if (input != null) input.close(); return; } // Else retry in case a new buf was CASed in fill() }} 实际上这种模式是父类FilterInputStream提供的规范，后面我们还会讲到更多FilterInputStream的子类。 我们可以发现在BufferedInputStream中还存在一个专门用于缓存的数组： 123456/** * The internal buffer array where the data is stored. When necessary, * it may be replaced by another array of * a different size. */protected volatile byte buf[]; I/O操作一般不能重复读取内容（比如键盘发送的信号，主机接收了就没了），而缓冲流提供了缓冲机制，一部分内容可以被暂时保存，BufferedInputStream支持reset()和mark()操作，首先我们来看看mark()方法的介绍： 12345678910111213141516171819/** * Marks the current position in this input stream. A subsequent * call to the &lt;code&gt;reset&lt;/code&gt; method repositions this stream at * the last marked position so that subsequent reads re-read the same bytes. * &lt;p&gt; * The &lt;code&gt;readlimit&lt;/code&gt; argument tells this input stream to * allow that many bytes to be read before the mark position gets * invalidated. * &lt;p&gt; * This method simply performs &lt;code&gt;in.mark(readlimit)&lt;/code&gt;. * * @param readlimit the maximum limit of bytes that can be read before * the mark position becomes invalid. * @see java.io.FilterInputStream#in * @see java.io.FilterInputStream#reset() */public synchronized void mark(int readlimit) { in.mark(readlimit);} 当调用mark()之后，输入流会以某种方式保留之后读取的readlimit数量的内容，当读取的内容数量超过readlimit则之后的内容不会被保留，当调用reset()之后，会使得当前的读取位置回到mark()调用时的位置。 123456789101112public static void main(String[] args) { try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\"test.txt\"))){ bufferedInputStream.mark(1); //只保留之后的1个字符 System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); bufferedInputStream.reset(); //回到mark时的位置 System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); }catch (IOException e) { e.printStackTrace(); }} 我们发现虽然后面的部分没有保存，但是依然能够正常读取，其实mark()后保存的读取内容是取readlimit和BufferedInputStream类的缓冲区大小两者中的最大值，而并非完全由readlimit确定。因此我们限制一下缓冲区大小，再来观察一下结果： 123456789101112public static void main(String[] args) { try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\"test.txt\"), 1)){ //将缓冲区大小设置为1 bufferedInputStream.mark(1); //只保留之后的1个字符 System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); //已经超过了readlimit，继续读取会导致mark失效 bufferedInputStream.reset(); //mark已经失效，无法reset() System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); }catch (IOException e) { e.printStackTrace(); }} 了解完了BufferedInputStream之后，我们再来看看BufferedOutputStream，其实和BufferedInputStream原理差不多，只是反向操作： 12345678public static void main(String[] args) { try (BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(\"output.txt\"))){ outputStream.write(\"lbwnb\".getBytes()); outputStream.flush(); }catch (IOException e) { e.printStackTrace(); }} 操作和FileOutputStream一致，这里就不多做介绍了。 既然有缓冲字节流，那么肯定也有缓冲字符流，缓冲字符流和缓冲字节流一样，也有一个专门的缓冲区，BufferedReader构造时需要传入一个Reader对象： 1234567public static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\"test.txt\"))){ System.out.println((char) reader.read()); }catch (IOException e) { e.printStackTrace(); }} 使用和reader也是一样的，内部也包含一个缓存数组： 1private char cb[]; 相比Reader更方便的是，它支持按行读取： 1234567public static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\"test.txt\"))){ System.out.println(reader.readLine()); //按行读取 }catch (IOException e) { e.printStackTrace(); }} 读取后直接得到一个字符串，当然，它还能把每一行内容依次转换为集合类提到的Stream流： 123456789101112public static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\"test.txt\"))){ reader .lines() .limit(2) .distinct() .sorted() .forEach(System.out::println); }catch (IOException e) { e.printStackTrace(); }} 它同样也支持mark()和reset()操作： 12345678910public static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\"test.txt\"))){ reader.mark(1); System.out.println((char) reader.read()); reader.reset(); System.out.println((char) reader.read()); }catch (IOException e) { e.printStackTrace(); }} BufferedReader处理纯文本文件时就更加方便了，BufferedWriter在处理时也同样方便： 123456789public static void main(String[] args) { try (BufferedWriter reader = new BufferedWriter(new FileWriter(\"output.txt\"))){ reader.newLine(); //使用newLine进行换行 reader.write(\"汉堡做滴彳亍不彳亍\"); //可以直接写入一个字符串 reader.flush(); //清空缓冲区 }catch (IOException e) { e.printStackTrace(); }} 合理使用缓冲流，可以大大提高我们程序的运行效率，只不过现在初学阶段，很少会有机会接触到实际的应用场景。 转换流有时会遇到这样一个很麻烦的问题：我这里读取的是一个字符串或是一个个字符，但是我只能往一个OutputStream里输出，但是OutputStream又只支持byte类型，如果要往里面写入内容，进行数据转换就会很麻烦，那么能否有更加简便的方式来做这样的事情呢？ 1234567public static void main(String[] args) { try(OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(\"test.txt\"))){ //虽然给定的是FileOutputStream，但是现在支持以Writer的方式进行写入 writer.write(\"lbwnb\"); //以操作Writer的样子写入OutputStream }catch (IOException e){ e.printStackTrace(); }} 同样的，我们现在只拿到了一个InputStream，但是我们希望能够按字符的方式读取，我们就可以使用InputStreamReader来帮助我们实现： 1234567public static void main(String[] args) { try(InputStreamReader reader = new InputStreamReader(new FileInputStream(\"test.txt\"))){ //虽然给定的是FileInputStream，但是现在支持以Reader的方式进行读取 System.out.println((char) reader.read()); }catch (IOException e){ e.printStackTrace(); }} InputStreamReader和OutputStreamWriter本质也是Reader和Writer，因此可以直接放入BufferedReader来实现更加方便的操作。 打印流打印流其实我们从一开始就在使用了，比如System.out就是一个PrintStream，PrintStream也继承自FilterOutputStream类因此依然是装饰我们传入的输出流，但是它存在自动刷新机制，例如当向PrintStream流中写入一个字节数组后自动调用flush()方法。PrintStream也永远不会抛出异常，而是使用内部检查机制checkError()方法进行错误检查。最方便的是，它能够格式化任意的类型，将它们以字符串的形式写入到输出流。 1public final static PrintStream out = null; 可以看到System.out也是PrintStream，不过默认是向控制台打印，我们也可以让它向文件中打印： 1234567public static void main(String[] args) { try(PrintStream stream = new PrintStream(new FileOutputStream(\"test.txt\"))){ stream.println(\"lbwnb\"); //其实System.out就是一个PrintStream }catch (IOException e){ e.printStackTrace(); }} 我们平时使用的println方法就是PrintStream中的方法，它会直接打印基本数据类型或是调用对象的toString()方法得到一个字符串，并将字符串转换为字符，放入缓冲区再经过转换流输出到给定的输出流上。 因此实际上内部还包含这两个内容： 123456/** * Track both the text- and character-output streams, so that their buffers * can be flushed without flushing the entire stream. */private BufferedWriter textOut;private OutputStreamWriter charOut; 与此相同的还有一个PrintWriter，不过他们的功能基本一致，PrintWriter的构造方法可以接受一个Writer作为参数，这里就不再做过多阐述了。 而我们之前使用的Scanner，使用的是系统提供的输入流： 123public static void main(String[] args) { Scanner scanner = new Scanner(System.in); //系统输入流，默认是接收控制台输入} 我们也可以使用Scanner来扫描其他的输入流： 123public static void main(String[] args) throws FileNotFoundException { Scanner scanner = new Scanner(new FileInputStream(\"秘制小汉堡.txt\")); //将文件内容作为输入流进行扫描} 相当于直接扫描文件中编写的内容，同样可以读取。 数据流数据流DataInputStream也是FilterInputStream的子类，同样采用装饰者模式，最大的不同是它支持基本数据类型的直接读取： 1234567public static void main(String[] args) { try (DataInputStream dataInputStream = new DataInputStream(new FileInputStream(\"test.txt\"))){ System.out.println(dataInputStream.readBoolean()); //直接将数据读取为任意基本数据类型 }catch (IOException e) { e.printStackTrace(); }} 用于写入基本数据类型： 1234567public static void main(String[] args) { try (DataOutputStream dataOutputStream = new DataOutputStream(new FileOutputStream(\"output.txt\"))){ dataOutputStream.writeBoolean(false); }catch (IOException e) { e.printStackTrace(); }} 注意，写入的是二进制数据，并不是写入的字符串，使用DataInputStream可以读取，一般他们是配合一起使用的。 对象流既然基本数据类型能够读取和写入基本数据类型，那么能否将对象也支持呢？ObjectOutputStream不仅支持基本数据类型，通过对对象的序列化操作，以某种格式保存对象，来支持对象类型的IO，注意：它不是继承自FilterInputStream的。 1234567891011121314151617181920public static void main(String[] args) { try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"output.txt\")); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"output.txt\"))){ People people = new People(\"lbw\"); outputStream.writeObject(people); outputStream.flush(); people = (People) inputStream.readObject(); System.out.println(people.name); }catch (IOException | ClassNotFoundException e) { e.printStackTrace(); }}static class People implements Serializable{ //必须实现Serializable接口才能被序列化 String name; public People(String name){ this.name = name; }} 在我们后续的操作中，有可能会使得这个类的一些结构发生变化，而原来保存的数据只适用于之前版本的这个类，因此我们需要一种方法来区分类的不同版本： 123456789static class People implements Serializable{ private static final long serialVersionUID = 123456; //在序列化时，会被自动添加这个属性，它代表当前类的版本，我们也可以手动指定版本。 String name; public People(String name){ this.name = name; }} 当发生版本不匹配时，会无法反序列化为对象： 123456789java.io.InvalidClassException: com.test.Main$People; local class incompatible: stream classdesc serialVersionUID = 123456, local class serialVersionUID = 1234567 at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:699) at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:2003) at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1850) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2160) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1667) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:503) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:461) at com.test.Main.main(Main.java:27) 如果我们不希望某些属性参与到序列化中进行保存，我们可以添加transient关键字： 12345678910111213141516171819202122public static void main(String[] args) { try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"output.txt\")); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"output.txt\"))){ People people = new People(\"lbw\"); outputStream.writeObject(people); outputStream.flush(); people = (People) inputStream.readObject(); System.out.println(people.name); //虽然能得到对象，但是name属性并没有保存，因此为null }catch (IOException | ClassNotFoundException e) { e.printStackTrace(); }}static class People implements Serializable{ private static final long serialVersionUID = 1234567; transient String name; public People(String name){ this.name = name; }} 其实我们可以看到，在一些JDK内部的源码中，也存在大量的transient关键字，使得某些属性不参与序列化，取消这些不必要保存的属性，可以节省数据空间占用以及减少序列化时间。 实战：图书管理系统要求实现一个图书管理系统（控制台），支持以下功能：保存书籍信息（要求持久化），查询、添加、删除、修改书籍信息。","categories":[],"tags":[]},{"title":"","slug":"白马Java/JavaSE笔记（四）重制版","date":"2025-09-07T23:26:13.331Z","updated":"2025-09-07T23:28:25.714Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/0.html","excerpt":"面向对象高级篇经过前面的学习，我们已经了解了面向对象编程的大部分基础内容，这一部分，我们将继续探索面向对象编程过程中一些常用的东西。 基本类型包装类Java并不是纯面向对象的语言，虽然Java语言是一个面向对象的语言，但是Java中的基本数据类型却不是面向对象的。Java中的基本类型，如果想通过对象的形式去使用他们，Java提供的基本类型包装类，使得Java能够更好的体现面向对象的思想，同时也使得基本类型能够支持对象操作！ 包装类介绍所有的包装类层次结构如下： 其中能够表示数字的基本类型包装类，继承自Number类，对应关系如下表：","text":"面向对象高级篇经过前面的学习，我们已经了解了面向对象编程的大部分基础内容，这一部分，我们将继续探索面向对象编程过程中一些常用的东西。 基本类型包装类Java并不是纯面向对象的语言，虽然Java语言是一个面向对象的语言，但是Java中的基本数据类型却不是面向对象的。Java中的基本类型，如果想通过对象的形式去使用他们，Java提供的基本类型包装类，使得Java能够更好的体现面向对象的思想，同时也使得基本类型能够支持对象操作！ 包装类介绍所有的包装类层次结构如下： 其中能够表示数字的基本类型包装类，继承自Number类，对应关系如下表： byte -&gt; Byte boolean -&gt; Boolean short -&gt; Short char -&gt; Character int -&gt; Integer long -&gt; Long float -&gt; Float double -&gt; Double 我们可以直接使用，这里我们以Integer类为例： 123public static void main(String[] args) { Integer i = new Integer(10); //将10包装为一个Integer类型的变量} 包装类实际上就是将我们的基本数据类型，封装成一个类（运用了封装的思想）我们可以来看看Integer类中是怎么写的： 12345private final int value; //类中实际上就靠这个变量在存储包装的值public Integer(int value) { this.value = value;} 包装类型支持自动装箱，我们可以直接将一个对应的基本类型值作为对应包装类型引用变量的值： 123public static void main(String[] args) { Integer i = 10; //将int类型值作为包装类型使用} 这是怎么做到的？为什么一个对象类型的值可以直接接收一个基本类类型的值？实际上这里就是自动装箱： 123public static void main(String[] args) { Integer i = Integer.valueOf(10); //上面的写法跟这里是等价的} 这里本质上就是被自动包装成了一个Integer类型的对象，只是语法上为了简单，就支持像这样编写。既然能装箱，也是支持拆箱的： 1234public static void main(String[] args) { Integer i = 10; int a = i;} 实际上上面的写法本质上就是： 1234public static void main(String[] args) { Integer i = 10; int a = i.intValue(); //通过此方法变成基本类型int值} 这里就是自动拆箱，得益于包装类型的自动装箱和拆箱机制，我们可以让包装类型轻松地参与到基本类型的运算中： 12345public static void main(String[] args) { Integer a = 10, b = 20; int c = a * b; //直接自动拆箱成基本类型参与到计算中 System.out.println(c);} 因为包装类是一个类，不是基本类型，所以说两个不同的对象，那么是不相等的： 123456public static void main(String[] args) { Integer a = new Integer(10); Integer b = new Integer(10); System.out.println(a == b); //虽然a和b的值相同，但是并不是同一个对象，所以说==判断为假} 那么自动装箱的呢？ 1234public static void main(String[] args) { Integer a = 10, b = 10; System.out.println(a == b);} 我们发现，通过自动装箱转换的Integer对象，如果值相同，得到的会是同一个对象，这是因为： 12345public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) //这里会有一个IntegerCache，如果在范围内，那么会直接返回已经提前创建好的对象 return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);} IntegerCache会默认缓存-128127之间的所有值，将这些值提前做成包装类放在数组中存放，虽然我们目前还没有学习数组，但是各位小伙伴只需要知道，我们如果直接让 -128127之间的值自动装箱为Integer类型的对象，那么始终都会得到同一个对象，这是为了提升效率，因为小的数使用频率非常高，有些时候并不需要创建那么多对象，创建对象越多，内存也会消耗更多。 但是如果超出这个缓存范围的话，就会得到不同的对象了： 1234public static void main(String[] args) { Integer a = 128, b = 128; System.out.println(a == b);} 这样就不会得到同一个对象了，因为超出了缓存的范围。同样的，Long、Short、Byte类型的包装类也有类似的机制，感兴趣的小伙伴可以自己点进去看看。 我们来看看包装类中提供了哪些其他的方法，包装类支持字符串直接转换： 1234public static void main(String[] args) { Integer i = new Integer(\"666\"); //直接将字符串的666，转换为数字666 System.out.println(i);} 当然，字符串转Integer有多个方法： 12345public static void main(String[] args) { Integer i = Integer.valueOf(\"5555\"); //Integer i = Integer.parseInt(\"5555\"); System.out.println(i);} 我们甚至可以对十六进制和八进制的字符串进行解码，得到对应的int值： 1234public static void main(String[] args) { Integer i = Integer.decode(\"0xA6\"); System.out.println(i);} 也可以将十进制的整数转换为其他进制的字符串： 123public static void main(String[] args) { System.out.println(Integer.toHexString(166));} 当然，Integer中提供的方法还有很多，这里就不一一列出了。 特殊包装类除了我们上面认识的这几种基本类型包装类之外，还有两个比较特殊的包装类型。 其中第一个是用于计算超大数字的BigInteger，我们知道，即使是最大的long类型，也只能表示64bit的数据，无法表示一个非常大的数，但是BigInteger没有这些限制，我们可以让他等于一个非常大的数字： 1234public static void main(String[] args) { BigInteger i = BigInteger.valueOf(Long.MAX_VALUE); //表示Long的最大值，轻轻松松 System.out.println(i);} 我们可以通过调用类中的方法，进行运算操作： 12345public static void main(String[] args) { BigInteger i = BigInteger.valueOf(Long.MAX_VALUE); i = i.multiply(BigInteger.valueOf(Long.MAX_VALUE)); //即使是long的最大值乘以long的最大值，也能给你算出来 System.out.println(i);} 我们来看看结果： 可以看到，此时数值已经非常大了，也可以轻松计算出来。咱们来点更刺激的： 12345public static void main(String[] args) { BigInteger i = BigInteger.valueOf(Long.MAX_VALUE); i = i.pow(100); //long的最大值来个100次方吧 System.out.println(i);} 可以看到，这个数字已经大到一排显示不下了： 一般情况，对于非常大的整数计算，我们就可以使用BigInteger来完成。 我们接着来看第二种，前面我们说了，浮点类型精度有限，对于需要精确计算的场景，就没办法了，而BigDecimal可以实现小数的精确计算。 1234567public static void main(String[] args) { BigDecimal i = BigDecimal.valueOf(10); i = i.divide(BigDecimal.valueOf(3), 100, RoundingMode.CEILING); //计算10/3的结果，精确到小数点后100位 //RoundingMode是舍入模式，就是精确到最后一位时，该怎么处理，这里CEILING表示向上取整 System.out.println(i);} 可以看到，确实可以精确到这种程度： 但是注意，对于这种结果没有终点的，无限循环的小数，我们必须要限制长度，否则会出现异常。 数组我们接着来看一个比较特殊的类型，数组。 假设出现一种情况，我们想记录100个数字，要是采用定义100个变量的方式可以吗？是不是有点太累了？这种情况我们就可以使用数组来存放一组相同类型的数据。 一维数组数组是相同类型数据的有序集合，数组可以代表任何相同类型的一组内容（包括引用类型和基本类型）其中存放的每一个数据称为数组的一个元素，我们来看看如何去定义一个数组变量： 123public static void main(String[] args) { int[] array; //类型[]就表示这个是一个数组类型} 注意，数组类型比较特殊，它本身也是类，但是编程不可见（底层C++写的，在运行时动态创建）即使是基本类型的数组，也是以对象的形式存在的，并不是基本数据类型。所以，我们要创建一个数组，同样需要使用new 关键字： 1234public static void main(String[] args) { int[] array = new int[10]; //在创建数组时，需要指定数组长度，也就是可以容纳多个int变量的值 Object obj = array; //因为同样是类，肯定是继承自Object的，所以说可以直接向上转型} 除了上面这种方式之外，我们也可以使用其他方式： 12345类型[] 变量名称 = new 类型[数组大小];类型 变量名称[] = new 类型[数组大小]; //支持C语言样式，但不推荐！类型[] 变量名称 = new 类型[]{...}; //静态初始化（直接指定值和大小）类型[] 变量名称 = {...}; //同上，但是只能在定义时赋值 创建出来的数组每个位置上都有默认值，如果是引用类型，就是null，如果是基本数据类型，就是0，或者是false，跟对象成员变量的默认值是一样的，要访问数组的某一个元素，我们可以： 1234public static void main(String[] args) { int[] array = new int[10]; System.out.println(\"数组的第一个元素为：\"+array[0]); //使用 变量名[下标] 的方式访问} 注意，数组的下标是从0开始的，不是从1开始的，所以说第一个元素的下标就是0，我们要访问第一个元素，那么直接输入0就行了，但是注意千万别写成负数或是超出范围了，否则会出现异常。 我们也可以使用这种方式为数组的元素赋值： 12345public static void main(String[] args) { int[] array = new int[10]; array[0] = 888; //就像使用变量一样，是可以放在赋值运算符左边的，我们可以直接给对应下标位置的元素赋值 System.out.println(\"数组的第一个元素为：\"+array[0]);} 因为数组本身也是一个对象，数组对象也是具有属性的，比如长度： 1234public static void main(String[] args) { int[] array = new int[10]; System.out.println(\"当前数组长度为：\"+array.length); //length属性是int类型的值，表示当前数组长度，长度是在一开始创建数组的时候就确定好的} 注意，这个length是在一开始就确定的，而且是final类型的，不允许进行修改，也就是说数组的长度一旦确定，不能随便进行修改，如果需要使用更大的数组，只能重新创建。 当然，既然是类型，那么肯定也是继承自Object类的： 12345public static void main(String[] args) { int[] array = new int[10]; System.out.println(array.toString()); System.out.println(array.equals(array));} 但是，很遗憾，除了clone()之外，这些方法并没有被重写，也就是说依然是采用的Object中的默认实现： 所以说通过toString()打印出来的结果，好丑，只不过我们可以发现，数组类型的类名很奇怪，是[开头的。 因此，如果我们要打印整个数组中所有的元素，得一个一个访问： 123456public static void main(String[] args) { int[] array = new int[10]; for (int i = 0; i &lt; array.length; i++) { System.out.print(array[i] + \" \"); }} 有时候为了方便，我们可以使用简化版的for语句foreach语法来遍历数组中的每一个元素： 123456public static void main(String[] args) { int[] array = new int[10]; for (int i : array) { //int i就是每一个数组中的元素，array就是我们要遍历的数组 System.out.print(i+\" \"); //每一轮循环，i都会更新成数组中下一个元素 }} 是不是感觉这种写法更加简洁？只不过这仅仅是语法糖而已，编译之后依然是跟上面一样老老实实在遍历的： 1234567891011public static void main(String[] args) { //反编译的结果 int[] array = new int[10]; int[] var2 = array; int var3 = array.length; for(int var4 = 0; var4 &lt; var3; ++var4) { int i = var2[var4]; System.out.print(i + \" \"); }} 对于这种普通的数组，其实使用还是挺简单的。这里需要特别说一下，对于基本类型的数组来说，是不支持自动装箱和拆箱的： 1234public static void main(String[] args) { int[] arr = new int[10]; Integer[] test = arr;} 还有，由于基本数据类型和引用类型不同，所以说int类型的数组时不能被Object类型的数组变量接收的： 但是如果是引用类型的话，是可以的： 1234public static void main(String[] args) { String[] arr = new String[10]; Object[] array = arr; //数组同样支持向上转型} 1234public static void main(String[] args) { Object[] arr = new Object[10]; String[] array = (String[]) arr; //也支持向下转型} 多维数组前面我们介绍了简单的数组（一维数组）既然数组可以是任何类型的，那么我们能否创建数组类型的数组呢？答案是可以的，套娃嘛，谁不会： 123public static void main(String[] args) { int[][] array = new int[2][10]; //数组类型数组那么就要写两个[]了} 存放数组的数组，相当于将维度进行了提升，比如上面的就是一个2x10的数组： 这个中数组一共有2个元素，每个元素都是一个存放10个元素的数组，所以说最后看起来就像一个矩阵一样。甚至可以继续套娃，将其变成一个三维数组，也就是存放数组的数组的数组。 123456public static void main(String[] args) { int[][] arr = { {1, 2}, {3, 4}, {5, 6}}; //一个三行两列的数组 System.out.println(arr[2][1]); //访问第三行第二列的元素} 在访问多维数组时，我们需要使用多次[]运算符来得到对应位置的元素。如果我们要遍历多维数组话，那么就需要多次嵌套循环： 12345678910public static void main(String[] args) { int[][] arr = new int[][]{{1, 2}, {3, 4}, {5, 6}}; for (int i = 0; i &lt; 3; i++) { //要遍历一个二维数组，那么我们得一列一列一行一行地来 for (int j = 0; j &lt; 2; j++) { System.out.println(arr[i][j]); } }} 可变长参数我们接着来看数组的延伸应用，实际上我们的方法是支持可变长参数的，什么是可变长参数？ 123456789public class Person { String name; int age; String sex; public void test(String... strings){ }} 我们在使用时，可以传入0 - N个对应类型的实参： 1234public static void main(String[] args) { Person person = new Person(); person.test(\"1！\", \"5！\", \"哥们在这跟你说唱\"); //这里我们可以自由传入任意数量的字符串} 那么我们在方法中怎么才能得到这些传入的参数呢，实际上可变长参数本质就是一个数组： 12345public void test(String... strings){ //strings这个变量就是一个String[]类型的 for (String string : strings) { System.out.println(string); //遍历打印数组中每一个元素 }} 注意，如果同时存在其他参数，那么可变长参数只能放在最后： 123public void test(int a, int b, String... strings){ } 这里最后我们再来说一个从开始到现在一直都没有说的东西： 123public static void main(String[] args) { //这个String[] args到底是个啥？？？ } 实际上这个是我们在执行Java程序时，输入的命令行参数，我们可以来打印一下： 12345public static void main(String[] args) { for (String arg : args) { System.out.println(arg); }} 可以看到，默认情况下直接运行什么都没有，但是如果我们在运行时，添加点内容的话： 1java com/test/Main lbwnb aaaa xxxxx #放在包中需要携带主类完整路径才能运行 可以看到，我们在后面随意添加的三个参数，都放到数组中了： 这个东西我们作为新手一般也不会用到，只做了解就行了。 字符串字符串类是一个比较特殊的类，它用于保存字符串。我们知道，基本类型char可以保存一个2字节的Unicode字符，而字符串则是一系列字符的序列（在C中就是一个字符数组）Java中没有字符串这种基本类型，因此只能使用类来进行定义。注意，字符串中的字符一旦确定，无法进行修改，只能重新创建。 String类String本身也是一个类，只不过它比较特殊，每个用双引号括起来的字符串，都是String类型的一个实例对象： 123public static void main(String[] args) { String str = \"Hello World!\";} 我们也可以象征性地使用一下new关键字： 123public static void main(String[] args) { String str = new String(\"Hello World!\"); //这种方式就是创建一个新的对象} 注意，如果是直接使用双引号创建的字符串，如果内容相同，为了优化效率，那么始终都是同一个对象： 12345public static void main(String[] args) { String str1 = \"Hello World\"; String str2 = \"Hello World\"; System.out.println(str1 == str2);} 但是如果我们使用构造方法主动创建两个新的对象，那么就是不同的对象了： 12345public static void main(String[] args) { String str1 = new String(\"Hello World\"); String str2 = new String(\"Hello World\"); System.out.println(str1 == str2);} 至于为什么会出现这种情况，我们在JVM篇视频教程中会进行详细的介绍，这里各位小伙伴只需要记住就行了。因此，如果我们仅仅是想要判断两个字符串的内容是否相同，不要使用==，String类重载了equals方法用于判断和比较内容是否相同： 12345public static void main(String[] args) { String str1 = new String(\"Hello World\"); String str2 = new String(\"Hello World\"); System.out.println(str1.equals(str2)); //字符串的内容比较，一定要用equals} 既然String也是一个类，那么肯定是具有一些方法的，我们可以来看看： 1234public static void main(String[] args) { String str = \"Hello World\"; System.out.println(str.length()); //length方法可以求字符串长度，这个长度是字符的数量} 因为双引号括起来的字符串本身就是一个实例对象，所以说我们也可以直接用： 123public static void main(String[] args) { System.out.println(\"Hello World\".length()); //虽然看起来挺奇怪的，但是确实支持这种写法} 字符串类中提供了很多方便我们操作的方法，比如字符串的裁剪、分割操作： 12345public static void main(String[] args) { String str = \"Hello World\"; String sub = str.substring(0, 3); //分割字符串，并返回一个新的子串对象 System.out.println(sub);} 1234567public static void main(String[] args) { String str = \"Hello World\"; String[] strings = str.split(\" \"); //使用split方法进行字符串分割，比如这里就是通过空格分隔，得到一个字符串数组 for (String string : strings) { System.out.println(string); }} 字符数组和字符串之间是可以快速进行相互转换的： 12345public static void main(String[] args) { String str = \"Hello World\"; char[] chars = str.toCharArray(); System.out.println(chars);} 12345public static void main(String[] args) { char[] chars = new char[]{'奥', '利', '给'}; String str = new String(chars); System.out.println(str);} 当然，String类还有很多其他的一些方法，这里就不一一介绍了。 StringBuilder类我们在之前的学习中已经了解，字符串支持使用+和+=进行拼接操作。 但是拼接字符串实际上底层需要进行很多操作，如果程序中大量进行字符串的拼接似乎不太好，编译器是很聪明的，String的拼接会在编译时进行各种优化： 1234public static void main(String[] args) { String str = \"杰哥\" + \"你干嘛\"; //我们在写代码时使用的是拼接的形式 System.out.println(str);} 编译之后就变成这样了： 1234public static void main(String[] args) { String str = \"杰哥你干嘛\"; System.out.println(str);} 对于变量来说，也有优化，比如下面这种情况： 123456789public static void main(String[] args) { String str1 = \"你看\"; String str2 = \"这\"; String str3 = \"汉堡\"; String str4 = \"做滴\"; String str5 = \"行不行\"; String result = str1 + str2 + str3 + str4 + str5; //5个变量连续加 System.out.println(result);} 如果直接使用加的话，每次运算都会生成一个新的对象，这里进行4次加法运算，那么中间就需要产生4个字符串对象出来，是不是有点太浪费了？这种情况实际上会被优化为下面的写法： 12345678910public static void main(String[] args) { String str1 = \"你看\"; String str2 = \"这\"; String str3 = \"汉堡\"; String str4 = \"做滴\"; String str5 = \"行不行\"; StringBuilder builder = new StringBuilder(); builder.append(str1).append(str2).append(str3).append(str4).append(str5); System.out.println(builder.toString());} 这里创建了一个StringBuilder的类型，这个类型是干嘛的呢？实际上它就是专门用于构造字符串的，我们可以使用它来对字符串进行拼接、裁剪等操作，它就像一个字符串编辑器，弥补了字符串不能修改的不足： 123456public static void main(String[] args) { StringBuilder builder = new StringBuilder(); //一开始创建时，内部什么都没有 builder.append(\"AAA\"); //我们可以使用append方法来讲字符串拼接到后面 builder.append(\"BBB\"); System.out.println(builder.toString()); //当我们字符串编辑完成之后，就可以使用toString转换为字符串了} 它还支持裁剪等操作： 12345public static void main(String[] args) { StringBuilder builder = new StringBuilder(\"AAABBB\"); //在构造时也可以指定初始字符串 builder.delete(2, 4); //删除2到4这个范围内的字符 System.out.println(builder.toString());} 当然，StringBuilder类的编辑操作也非常多，这里就不一一列出了。 正则表达式我们现在想要实现这样一个功能，对于给定的字符串进行判断，如果字符串符合我们的规则，那么就返回真，否则返回假，比如现在我们想要判断字符串是不是邮箱的格式： 1234public static void main(String[] args) { String str = \"aaaa731341@163.com\"; //假设邮箱格式为 数字/字母@数字/字母.com} 那么现在请你设计一个Java程序用于判断，你该怎么做？是不是感觉很麻烦，但是我们使用正则表达式就可以很轻松解决这种字符串格式匹配问题。 正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。 我们先来看看下面的这个例子： 12345public static void main(String[] args) { String str = \"oooo\"; //matches方法用于对给定正则表达式进行匹配，匹配成功返回true，否则返回false System.out.println(str.matches(\"o+\")); //+表示对前面这个字符匹配一次或多次，这里字符串是oooo，正好可以匹配} 用于规定给定组件必须要出现多少次才能满足匹配的，我们一般称为限定符，限定符表如下： 字符 描述 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 *“zoo”。** 等价于 **{0,}**。 + 匹配前面的子表达式一次或多次。例如，zo+ 能匹配 “zo” 以及 “zoo”**，但不能匹配 **”z”**。+** 等价于 **{1,}**。 ? 匹配前面的子表达式零次或一次。例如，do(es)? 可以匹配 “do” 、 “does”**、 **”doxy” 中的 “do” 。**?** 等价于 **{0,1}**。 {n} n 是一个非负整数。匹配确定的 n 次。例如，o{2} 不能匹配 “Bob” 中的 o，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，o{2,} 不能匹配 “Bob” 中的 o，但能匹配 “foooood” 中的所有 o。o{1,} 等价于 o+**。o{0,}** 则等价于 o*。 {n,m} m 和 n 均为非负整数，其中 n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，o{1,3} 将匹配 “fooooood” 中的前三个 o。o{0,1} 等价于 **o?**。请注意在逗号和两个数之间不能有空格。 如果我们想要表示一个范围内的字符，可以使用方括号： 1234public static void main(String[] args) { String str = \"abcabccaa\"; System.out.println(str.matches(\"[abc]*\")); //表示abc这几个字符可以出现 0 - N 次} 对于普通字符来说，我们可以下面的方式实现多种字符匹配： 字符 描述 [ABC] 匹配 […] 中的所有字符，例如 [aeiou] 匹配字符串 “google runoob taobao” 中所有的 e o u a 字母。 [^ABC] 匹配除了 […] 中字符的所有字符，例如 [^aeiou] 匹配字符串 “google runoob taobao” 中除了 e o u a 字母的所有字母。 [A-Z] [A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。 . 匹配除换行符（\\n、\\r）之外的任何单个字符，相等于 [^\\n\\r] [\\s\\S] 匹配所有。\\s 是匹配所有空白符，包括换行，\\S 非空白符，不包括换行。 \\w 匹配字母、数字、下划线。等价于 [A-Za-z0-9_] 当然，这里仅仅是对正则表达式的简单使用，实际上正则表达式内容非常多，如果需要完整学习正则表达式，可以到：https://www.runoob.com/regexp/regexp-syntax.html 正则表达式并不是只有Java才支持，其他很多语言比如JavaScript、Python等等都是支持正则表达式的。 内部类上一章我们详细介绍了类，我们现在已经知道该如何创建类、使用类了。当然，类的创建其实可以有多种多样的方式，并不仅仅局限于普通的创建。内部类顾名思义，就是创建在内部的类，那么具体是什么的内部呢，我们接着就来讨论一下。 注意：内部类很多地方都很绕，所以说一定要仔细思考。 成员内部类我们可以直接在类的内部定义成员内部类： 1234567public class Test { public class Inner { //内部类也是类，所以说里面也可以有成员变量、方法等，甚至还可以继续套娃一个成员内部类 public void test(){ System.out.println(\"我是成员内部类！\"); } }} 成员内部类和成员方法、成员变量一样，是对象所有的，而不是类所有的，如果我们要使用成员内部类，那么就需要： 1234public static void main(String[] args) { Test test = new Test(); //我们首先需要创建对象 Test.Inner inner = test.new Inner(); //成员内部类的类型名称就是 外层.内部类名称} 虽然看着很奇怪，但是确实是这样使用的。我们同样可以使用成员内部类中的方法： 12345public static void main(String[] args) { Test test = new Test(); Test.Inner inner = test.new Inner(); inner.test();} 注意，成员内部类也可以使用访问权限控制，如果我们我们将其权限改为private，那么就像我们把成员变量访问权限变成私有一样，外部是无法访问到这个内部类的： 可以看到这里直接不认识了。 这里我们需要特别注意一下，在成员内部类中，是可以访问到外层的变量的： 1234567891011121314public class Test { private final String name; public Test(String name){ this.name = name; } public class Inner { public void test(){ System.out.println(\"我是成员内部类：\"+name); //成员内部类可以访问到外部的成员变量 //因为成员内部类本身就是某个对象所有的，每个对象都有这样的一个类定义，这里的name是其所依附对象的 } }} 每个类可以创建一个对象，每个对象中都有一个单独的类定义，可以通过这个成员内部类又创建出更多对象，套娃了属于是。 所以说我们在使用时： 123456789public static void main(String[] args) { Test a = new Test(\"小明\"); Test.Inner inner1 = a.new Inner(); //依附于a创建的对象，那么就是a的 inner1.test(); Test b = new Test(\"小红\"); Test.Inner inner2 = b.new Inner(); //依附于b创建的对象，那么就是b的 inner2.test();} 那现在问大家一个问题，外部能访问内部类里面的成员变量吗？ 那么如果内部类中也定义了同名的变量，此时我们怎么去明确要使用的是哪一个呢？ 1234567891011121314151617public class Test { private final String name; public Test(String name){ this.name = name; } public class Inner { String name; public void test(String name){ System.out.println(\"方法参数的name = \"+name); //依然是就近原则，最近的是参数，那就是参数了 System.out.println(\"成员内部类的name = \"+this.name); //在内部类中使用this关键字，只能表示内部类对象 System.out.println(\"成员内部类的name = \"+Test.this.name); //如果需要指定为外部的对象，那么需要在前面添加外部类型名称 } }} 包括对方法的调用和super关键字的使用，也是一样的： 12345678910public class Inner { String name; public void test(String name){ this.toString(); //内部类自己的toString方法 super.toString(); //内部类父类的toString方法 Test.this.toString(); //外部类的toSrting方法 Test.super.toString(); //外部类父类的toString方法 }} 所以说成员内部类其实在某些情况下使用起来比较麻烦，对于这种成员内部类，我们一般只会在类的内部自己使用。 静态内部类前面我们介绍了成员内部类，它就像成员变量和成员方法一样，是属于对象的，同样的，静态内部类就像静态方法和静态变量一样，是属于类的，我们可以直接创建使用。 12345678910111213public class Test { private final String name; public Test(String name){ this.name = name; } public static class Inner { public void test(){ System.out.println(\"我是静态内部类！\"); } }} 不需要依附任何对象，我们可以直接创建静态内部类的对象： 1234public static void main(String[] args) { Test.Inner inner = new Test.Inner(); //静态内部类的类名同样是之前的格式，但是可以直接new了 inner.test();} 静态内部类由于是静态的，所以相对外部来说，整个内部类中都处于静态上下文（注意只是相当于外部来说）是无法访问到外部类的非静态内容的： 只不过受影响的只是外部内容的使用，内部倒是不受影响，还是跟普通的类一样： 1234567public static class Inner { String name; public void test(){ System.out.println(\"我是静态内部类：\"+name); }} 其实也很容易想通，因为静态内部类是属于外部类的，不依附任何对象，那么我要是直接访问外部类的非静态属性，那到底访问哪个对象的呢？这样肯定是说不通的。 局部内部类局部内部类就像局部变量一样，可以在方法中定义。 12345678910111213public class Test { private final String name; public Test(String name){ this.name = name; } public void hello(){ class Inner { //直接在方法中创建局部内部类 } }} 既然是在方法中声明的类，那作用范围也就只能在方法中了： 123456789101112public class Test { public void hello(){ class Inner{ //局部内部类跟局部变量一样，先声明后使用 public void test(){ System.out.println(\"我是局部内部类\"); } } Inner inner = new Inner(); //局部内部类直接使用类名就行 inner.test(); }} 只不过这种局部内部类的形式，使用频率很低，基本上不会用到，所以说了解就行了。 匿名内部类匿名内部类是我们使用频率非常高的一种内部类，它是局部内部类的简化版。 还记得我们在之前学习的抽象类和接口吗？在抽象类和接口中都会含有某些抽象方法需要子类去实现，我们当时已经很明确地说了不能直接通过new的方式去创建一个抽象类或是接口对象，但是我们可以使用匿名内部类。 123public abstract class Student { public abstract void test();} 正常情况下，要创建一个抽象类的实例对象，只能对其进行继承，先实现未实现的方法，然后创建子类对象。 而我们可以在方法中使用匿名内部类，将其中的抽象方法实现，并直接创建实例对象： 123456789public static void main(String[] args) { Student student = new Student() { //在new的时候，后面加上花括号，把未实现的方法实现了 @Override public void test() { System.out.println(\"我是匿名内部类的实现!\"); } }; student.test();} 此时这里创建出来的Student对象，就是一个已经实现了抽象方法的对象，这个抽象类直接就定义好了，甚至连名字都没有，就可以直接就创出对象。 匿名内部类中同样可以使用类中的属性（因为它本质上就相当于是对应类型的子类）所以说： 12345678Student student = new Student() { int a; //因为本质上就相当于是子类，所以说子类定义一些子类的属性完全没问题 @Override public void test() { System.out.println(name + \"我是匿名内部类的实现!\"); //直接使用父类中的name变量 }}; 同样的，接口也可以通过这种匿名内部类的形式，直接创建一个匿名的接口实现类： 123456789public static void main(String[] args) { Study study = new Study() { @Override public void study() { System.out.println(\"我是学习方法！\"); } }; study.study();} 当然，并不是说只有抽象类和接口才可以像这样创建匿名内部类，普通的类也可以，只不过意义不大，一般情况下只是为了进行一些额外的初始化工作而已。 Lambda表达式前面我们介绍了匿名内部类，我们可以通过这种方式创建一个临时的实现子类。 特别的，如果一个接口中有且只有一个待实现的抽象方法，那么我们可以将匿名内部类简写为Lambda表达式： 1234public static void main(String[] args) { Study study = () -&gt; System.out.println(\"我是学习方法！\"); //是不是感觉非常简洁！ study.study();} 在初学阶段，为了简化学习，各位小伙伴就认为Lambda表达式就是匿名内部类的简写就行了（Lambda表达式的底层其实并不只是简简单单的语法糖替换，感兴趣的可以在新特性篇视频教程中了解） 那么它是一个怎么样的简写规则呢？我们来看一下Lambda表达式的具体规范： 标准格式为：([参数类型 参数名称,]...) ‐&gt; { 代码语句，包括返回值 } 和匿名内部类不同，Lambda仅支持接口，不支持抽象类 接口内部必须有且仅有一个抽象方法（可以有多个方法，但是必须保证其他方法有默认实现，必须留一个抽象方法出来） 比如我们之前写的Study接口，只要求实现一个无参无返回值的方法，所以说直接就是最简单的形式： 1() -&gt; System.out.println(\"我是学习方法！\"); //跟之前流程控制一样，如果只有一行代码花括号可省略 当然，如果有一个参数和返回值的话： 1234567public static void main(String[] args) { Study study = (a) -&gt; { System.out.println(\"我是学习方法\"); return \"今天学会了\"+a; //实际上这里面就是方法体，该咋写咋写 }; System.out.println(study.study(10));} 注意，如果方法体中只有一个返回语句，可以直接省去花括号和return关键字： 123Study study = (a) -&gt; { return \"今天学会了\"+a; //这种情况是可以简化的}; 1Study study = (a) -&gt; \"今天学会了\"+a; 如果参数只有一个，那么可以省去小括号： 1Study study = a -&gt; \"今天学会了\"+a; 是不是感觉特别简洁，实际上我们程序员追求的就是写出简洁高效的代码，而Java也在朝这个方向一直努力，近年来从Java 9开始出现的一些新语法基本都是各种各样的简写版本。 如果一个方法的参数需要的是一个接口的实现： 1234567public static void main(String[] args) { test(a -&gt; \"今天学会了\"+a); //参数直接写成lambda表达式}private static void test(Study study){ study.study(10);} 当然，这还只是一部分，对于已经实现的方法，如果我们想直接作为接口抽象方法的实现，我们还可以使用方法引用。 方法引用方法引用就是将一个已实现的方法，直接作为接口中抽象方法的实现（当然前提是方法定义得一样才行） 123public interface Study { int sum(int a, int b); //待实现的求和方法} 那么使用时候，可以直接使用Lambda表达式： 123public static void main(String[] args) { Study study = (a, b) -&gt; a + b;} 只不过还能更简单，因为Integer类中默认提供了求两个int值之和的方法： 1234//Integer类中就已经有对应的实现了public static int sum(int a, int b) { return a + b;} 此时，我们可以直接将已有方法的实现作为接口的实现： 1234public static void main(String[] args) { Study study = (a, b) -&gt; Integer.sum(a, b); //直接使用Integer为我们通过好的求和方法 System.out.println(study.sum(10, 20));} 我们发现，Integer.sum的参数和返回值，跟我们在Study中定义的完全一样，所以说我们可以直接使用方法引用： 1234public static void main(String[] args) { Study study = Integer::sum; //使用双冒号来进行方法引用，静态方法使用 类名::方法名 的形式 System.out.println(study.sum(10, 20));} 方法引用其实本质上就相当于将其他方法的实现，直接作为接口中抽象方法的实现。任何方法都可以通过方法引用作为实现： 123public interface Study { String study();} 如果是普通从成员方法，我们同样需要使用对象来进行方法引用： 12345678public static void main(String[] args) { Main main = new Main(); Study study = main::lbwnb; //成员方法因为需要具体对象使用，所以说只能使用 对象::方法名 的形式}public String lbwnb(){ return \"卡布奇诺今犹在，不见当年倒茶人。\";} 因为现在只需要一个String类型的返回值，由于String的构造方法在创建对象时也会得到一个String类型的结果，所以说： 123public static void main(String[] args) { Study study = String::new; //没错，构造方法也可以被引用，使用new表示} 反正只要是符合接口中方法的定义的，都可以直接进行方法引用，对于Lambda表达式和方法引用，在Java新特性介绍篇视频教程中还有详细的讲解，这里就不多说了。 异常机制在理想的情况下，我们的程序会按照我们的思路去运行，按理说是不会出现问题的，但是，代码实际编写后并不一定是完美的，可能会有我们没有考虑到的情况，如果这些情况能够正常得到一个错误的结果还好，但是如果直接导致程序运行出现问题了呢？ 1234567public static void main(String[] args) { test(1, 0); //当b为0的时候，还能正常运行吗？}private static int test(int a, int b){ return a/b; //没有任何的判断而是直接做计算} 此时我们可以看到，出现了运算异常： 那么这个异常到底是什么样的一种存在呢？当程序运行出现我们没有考虑到的情况时，就有可能出现异常或是错误！ 异常的类型我们在之前其实已经接触过一些异常了，比如数组越界异常，空指针异常，算术异常等，他们其实都是异常类型，我们的每一个异常也是一个类，他们都继承自Exception类！异常类型本质依然类的对象，但是异常类型支持在程序运行出现问题时抛出（也就是上面出现的红色报错）也可以提前声明，告知使用者需要处理可能会出现的异常！ 异常的第一种类型是运行时异常，如上述的列子，在编译阶段无法感知代码是否会出现问题，只有在运行的时候才知道会不会出错（正常情况下是不会出错的），这样的异常称为运行时异常，异常也是由类定义的，所有的运行时异常都继承自RuntimeException。 1234public static void main(String[] args) { Object object = null; object.toString(); //这种情况就会出现运行时异常} 又比如下面的这种情况： 1234public static void main(String[] args) { Object object = new Object(); Main main = (Main) object;} 异常的另一种类型是编译时异常，编译时异常明确指出可能会出现的异常，在编译阶段就需要进行处理（捕获异常）必须要考虑到出现异常的情况，如果不进行处理，将无法通过编译！默认继承自Exception类的异常都是编译时异常。 1protected native Object clone() throws CloneNotSupportedException; 比如Object类中定义的clone方法，就明确指出了在运行的时候会出现的异常。 还有一种类型是错误，错误比异常更严重，异常就是不同寻常，但不一定会导致致命的问题，而错误是致命问题，一般出现错误可能JVM就无法继续正常运行了，比如OutOfMemoryError就是内存溢出错误（内存占用已经超出限制，无法继续申请内存了） 1234567public static void main(String[] args) { test();}private static void test(){ test();} 比如这样的一个无限递归的方法，会导致运行过程中无限制地向下调用方法，导致栈溢出： 这种情况就是错误了，已经严重到整个程序都无法正常运行了。又比如： 123public static void main(String[] args) { Object[] objects = new Object[Integer.MAX_VALUE]; //这里申请一个超级大数组} 实际上我们电脑的内存是有限的，不可能无限制地使用内存来存放变量，所以说如果内存不够用了，会直接： 此时没有更多的可用内存供我们的程序使用，那么程序也就没办法继续运行下去了，这同样是一个很严重的错误。 当然，我们这一块主要讨论的目录依然是异常。 自定义异常异常其实就两大类，一个是编译时异常，一个是运行时异常，我们先来看编译时异常。 12345public class TestException extends Exception{ public TestException(String message){ super(message); //这里我们选择使用父类的带参构造，这个参数就是异常的原因 }} 编译时异常只需要继承Exception就行了，编译时异常的子类有很多很多，仅仅是SE中就有700多个。 异常多种多样，不同的异常对应着不同的情况，比如在类型转换时出错那么就是类型转换异常，如果是使用一个值为null的变量调用方法，那么就会出现空指针异常。 运行时异常只需要继承RuntimeException就行了： 12345public class TestException extends RuntimeException{ public TestException(String message){ super(message); }} RuntimeException继承自Exception，Exception继承自Throwable： 运行时异常同同样也有很多，只不过运行时异常和编译型异常在使用时有一些不同，我们会在后面的学习中慢慢认识。 当然还有一种类型是Error，它是所有错误的父类，同样是继承自Throwable的。 抛出异常当别人调用我们的方法时，如果传入了错误的参数导致程序无法正常运行，这时我们就可以手动抛出一个异常来终止程序继续运行下去，同时告知上一级方法执行出现了问题： 12345public static int test(int a, int b) { if(b == 0) throw new RuntimeException(\"被除数不能为0\"); //使用throw关键字来抛出异常 return a / b;} 异常的抛出同样需要创建一个异常对象出来，我们抛出异常实际上就是将这个异常对象抛出，异常对象携带了我们抛出异常时的一些信息，比如是因为什么原因导致的异常，在RuntimeException的构造方法中我们可以写入原因。 当出现异常时： 程序会终止，并且会打印栈追踪信息，因为各位小伙伴才初学，还不知道什么是栈，我们这里就简单介绍一下，实际上方法之间的调用是有层级关系的，而当异常发生时，方法调用的每一层都会在栈追踪信息中打印出来，比如这里有两个at，实际上就是在告诉我们程序运行到哪个位置时出现的异常，位于最上面的就是发生异常的最核心位置，我们代码的第15行。 并且这里会打印出当前抛出的异常类型和我们刚刚自定义异常信息。 注意，如果我们在方法中抛出了一个非运行时异常，那么必须告知函数的调用方我们会抛出某个异常，函数调用方必须要对抛出的这个异常进行对应的处理才可以： 123private static void test() throws Exception { //使用throws关键字告知调用方此方法会抛出哪些异常，请调用方处理好 throw new Exception(\"我是编译时异常！\");} 注意，如果不同的分支条件会出现不同的异常，那么所有在方法中可能会抛出的异常都需要注明： 123456private static void test(int a) throws FileNotFoundException, ClassNotFoundException { //多个异常使用逗号隔开 if(a == 1) throw new FileNotFoundException(); else throw new ClassNotFoundException();} 当然，并不是只有非运行时异常可以像这样明确指出，运行时异常也可以，只不过不强制要求： 123private static void test(int a) throws RuntimeException { throw new RuntimeException();} 至于如何处理明确抛出的异常，我们会下一个部分中进行讲解。 最后再提一下，我们在重写方法时，如果父类中的方法表明了会抛出某个异常，只要重写的内容中不会抛出对应的异常我们可以直接省去： 1234@Overrideprotected Object clone() { return new Object();} 异常的处理当程序没有按照我们理想的样子运行而出现异常时（默认会交给JVM来处理，JVM发现任何异常都会立即终止程序运行，并在控制台打印栈追踪信息）现在我们希望能够自己处理出现的问题，让程序继续运行下去，就需要对异常进行捕获，比如： 123456789public static void main(String[] args) { try { //使用try-catch语句进行异常捕获 Object object = null; object.toString(); } catch (NullPointerException e){ //因为异常本身也是一个对象，catch中实际上就是用一个局部变量去接收异常 } System.out.println(\"程序继续正常运行！\");} 我们可以将代码编写到try语句块中，只要是在这个范围内发生的异常，都可以被捕获，使用catch关键字对指定的异常进行捕获，这里我们捕获的是NullPointerException空指针异常： 可以看到，当我们捕获异常之后，程序可以继续正常运行，并不会像之前一样直接结束掉。 注意，catch中捕获的类型只能是Throwable的子类，也就是说要么是抛出的异常，要么是错误，不能是其他的任何类型。 我们可以在catch语句块中对捕获到的异常进行处理： 12345678910public static void main(String[] args) { try { Object object = null; object.toString(); } catch (NullPointerException e){ e.printStackTrace(); //打印栈追踪信息 System.out.println(\"异常错误信息：\"+e.getMessage()); //获取异常的错误信息 } System.out.println(\"程序继续正常运行！\");} 如果某个方法明确指出会抛出哪些异常，除非抛出的异常是一个运行时异常，否则我们必须要使用try-catch语句块进行异常的捕获，不然就无法通过编译： 1234567public static void main(String[] args) { test(10); //必须要进行异常的捕获，否则报错}private static void test(int a) throws IOException { //明确会抛出IOException throw new IOException();} 当然，如果我们确实不想在当前这个方法中进行处理，那么我们可以继续踢皮球，抛给上一级： 1234567public static void main(String[] args) throws IOException { //继续编写throws往上一级抛 test(10);}private static void test(int a) throws IOException { throw new IOException();} 注意，如果已经是主方法了，那么就相当于到顶层了，此时发生异常再往上抛出的话，就会直接交给JVM进行处理，默认会让整个程序终止并打印栈追踪信息。 注意，如果我们要捕获的异常，是某个异常的父类，那么当发生这个异常时，同样可以捕获到： 12345678public static void main(String[] args) throws IOException { try { int[] arr = new int[1]; arr[1] = 100; //这里发生的是数组越界异常，它是运行时异常的子类 } catch (RuntimeException e){ //使用运行时异常同样可以捕获到 System.out.println(\"捕获到异常\"); }} 当代码可能出现多种类型的异常时，我们希望能够分不同情况处理不同类型的异常，就可以使用多重异常捕获： 123456789try { //....} catch (NullPointerException e) { } catch (IndexOutOfBoundsException e){} catch (RuntimeException e){ } 但是要注意一下顺序： 123456789try { //....} catch (RuntimeException e){ //父类型在前，会将子类的也捕获} catch (NullPointerException e) { //永远都不会被捕获} catch (IndexOutOfBoundsException e){ //永远都不会被捕获} 只不过这样写好像有点丑，我们也可以简写为： 12345try { //....} catch (NullPointerException | IndexOutOfBoundsException e) { //用|隔开每种类型即可 } 如果简写的话，那么发生这些异常的时候，都会采用统一的方式进行处理了。 最后，当我们希望，程序运行时，无论是否出现异常，都会在最后执行任务，可以交给finally语句块来处理： 1234567try { //....}catch (Exception e){ }finally { System.out.println(\"lbwnb\"); //无论是否出现异常，都会在最后执行} try语句块至少要配合catch或finally中的一个： 123456try { int a = 10; a /= 0;} finally { //不捕获异常，程序会终止，但在最后依然会执行下面的内容 System.out.println(\"lbwnb\"); } 思考：try、catch和finally执行顺序？ 断言表达式我们可以使用断言表达式来对某些东西进行判断，如果判断失败会抛出错误，只不过默认情况下没有开启断言，我们需要在虚拟机参数中手动开启一下： 开启断言之后，我们就可以开始使用了。 断言表达式需要使用到assert关键字，如果assert后面的表达式判断结果为false，将抛出AssertionError错误。 123public static void main(String[] args) { assert false;} 比如我们可以判断变量的值，如果大于10就抛出错误： 1234public static void main(String[] args) { int a = 10; assert a &gt; 10;} 我们可以在表达式的后面添加错误信息： 1234public static void main(String[] args) { int a = 10; assert a &gt; 10 : \"我是自定义的错误信息\";} 这样就会显示到错误后面了： 断言表达式一般只用于测试，我们正常的程序中一般不会使用，这里只做了解就行了。 常用工具类介绍前面我们学习了包装类、数组和字符串，我们接着来看看常用的一些工具类。工具类就是专门为一些特定场景编写的，便于我们去使用的类，工具类一般都会内置大量的静态方法，我们可以通过类名直接使用。 数学工具类Java提供的运算符实际上只能进行一些在小学数学中出现的运算，但是如果我们想要进行乘方、三角函数之类的高级运算，就没有对应的运算符能够做到，而此时我们就可以使用数学工具类来完成。 123456789public static void main(String[] args) { //Math也是java.lang包下的类，所以说默认就可以直接使用 System.out.println(Math.pow(5, 3)); //我们可以使用pow方法直接计算a的b次方 Math.abs(-1); //abs方法可以求绝对值 Math.max(19, 20); //快速取最大值 Math.min(2, 4); //快速取最小值 Math.sqrt(9); //求一个数的算术平方根} 当然，三角函数肯定也是安排上了的： 1234567Math.sin(Math.PI / 2); //求π/2的正弦值，这里我们可以使用预置的PI进行计算Math.cos(Math.PI); //求π的余弦值Math.tan(Math.PI / 4); //求π/4的正切值Math.asin(1); //三角函数的反函数也是有的，这里是求arcsin1的值Math.acos(1);Math.atan(0); 可能在某些情况下，计算出来的浮点数会得到一个很奇怪的结果： 123public static void main(String[] args) { System.out.println(Math.sin(Math.PI)); //计算 sinπ 的结果} 正常来说，sinπ的结果应该是0才对，为什么这里得到的是一个很奇怪的数？这个E是干嘛的，这其实是科学计数法的10，后面的数就是指数，上面的结果其实就是： $1.2246467991473532 \\times 10^{-16}$ 其实这个数是非常接近于0，这是因为精度问题导致的，所以说实际上结果就是0。 我们也可以快速计算对数函数： 1234567public static void main(String[] args) { Math.log(Math.E); //e为底的对数函数，其实就是ln，我们可以直接使用Math中定义好的e Math.log10(100); //10为底的对数函数 //利用换底公式，我们可以弄出来任何我们想求的对数函数 double a = Math.log(4) / Math.log(2); //这里是求以2为底4的对数，log(2)4 = ln4 / ln2 System.out.println(a);} 还有一些比较特殊的计算： 1234public static void main(String[] args) { Math.ceil(4.5); //通过使用ceil来向上取整 Math.floor(5.6); //通过使用floor来向下取整} 向上取整就是找一个大于当前数字的最小整数，向下取整就是砍掉小数部分。注意，如果是负数的话，向上取整就是去掉小数部分，向下取整就是找一个小于当前数字的最大整数。 这里我们再介绍一下随机数的生成，Java中想要生成一个随机数其实也很简单，我们需要使用Random类来生成（这个类时java.util包下的，需要手动导入才可以） 123456public static void main(String[] args) { Random random = new Random(); //创建Random对象 for (int i = 0; i &lt; 30; i++) { System.out.print(random.nextInt(100)+\" \"); //nextInt方法可以指定创建0 - x之内的随机数 }} 结果为，可以看到确实是一堆随机数： 只不过，程序中的随机并不是真随机，而是根据某些东西计算出来的，只不过计算过程非常复杂，能够在一定程度上保证随机性（根据爱因斯坦理论，宏观物质世界不存在真随机，看似随机的事物只是现目前无法计算而已，唯物主义的公理之一就是任何事物都有因果关系） 数组工具类前面我们介绍了数组，但是我们发现，想要操作数组实在是有点麻烦，比如我们要打印一个数组，还得一个一个元素遍历才可以，那么有没有一个比较方便的方式去使用数组呢？我们可以使用数组工具类Arrays。 这个类也是java.util包下类，它用于便捷操作数组，比如我们想要打印数组，可以直接通过toString方法转换字符串： 1234public static void main(String[] args) { int[] arr = new int[]{1, 4, 5, 8, 2, 0, 9, 7, 3, 6}; System.out.println(Arrays.toString(arr));} 是不是感觉非常方便？这样我们直接就可以打印数组了！ 除了这个方法，它还支持将数组进行排序： 12345public static void main(String[] args) { int[] arr = new int[]{1, 4, 5, 8, 2, 0, 9, 7, 3, 6}; Arrays.sort(arr); //可以对数组进行排序，将所有的元素按照从小到大的顺序排放 System.out.println(Arrays.toString(arr));} 感兴趣的小伙伴可以在数据结构与算法篇视频教程中了解多种多样的排序算法，这里的排序底层实现实际上用到了多种排序算法。 数组中的内容也可以快速进行填充： 12345public static void main(String[] args) { int[] arr = new int[10]; Arrays.fill(arr, 66); System.out.println(Arrays.toString(arr));} 我们可以快速地对一个数组进行拷贝： 123456public static void main(String[] args) { int[] arr = new int[]{1, 2, 3, 4, 5}; int[] target = Arrays.copyOf(arr, 5); System.out.println(Arrays.toString(target)); //拷贝数组的全部内容，并生成一个新的数组对象 System.out.println(arr == target);} 123456public static void main(String[] args) { int[] arr = new int[]{1, 2, 3, 4, 5}; int[] target = Arrays.copyOfRange(arr, 3, 5); //也可以只拷贝某个范围内的内容 System.out.println(Arrays.toString(target)); System.out.println(arr == target);} 我们也可以将一个数组中的内容拷贝到其他数组中： 123456public static void main(String[] args) { int[] arr = new int[]{1, 2, 3, 4, 5}; int[] target = new int[10]; System.arraycopy(arr, 0, target, 0, 5); //使用System.arraycopy进行搬运 System.out.println(Arrays.toString(target));} 对于一个有序的数组（从小到大排列）我们可以使用二分搜索快速找到对应的元素在哪个位置： 1234public static void main(String[] args) { int[] arr = new int[]{1, 2, 3, 4, 5}; System.out.println(Arrays.binarySearch(arr, 5)); //二分搜索仅适用于有序数组} 这里提到了二分搜索算法，我们会在后面的实战练习中进行讲解。 那要是现在我们使用的是多维数组呢？因为现在数组里面的每个元素就是一个数组，所以说toString会出现些问题： 1234public static void main(String[] args) { int[][] array = new int[][]{{2, 8, 4, 1}, {9, 2, 0, 3}}; System.out.println(Arrays.toString(array));} 只不过别担心，Arrays也支持对多维数组进行处理： 1234public static void main(String[] args) { int[][] array = new int[][]{{2, 8, 4, 1}, {9, 2, 0, 3}}; System.out.println(Arrays.deepToString(array)); //deepToString方法可以对多维数组进行打印} 同样的，因为数组本身没有重写equals方法，所以说无法判断两个不同的数组对象中的每一个元素是否相同，Arrays也为一维数组和多维数组提供了相等判断的方法： 123456public static void main(String[] args) { int[][] a = new int[][]{{2, 8, 4, 1}, {9, 2, 0, 3}}; int[][] b = new int[][]{{2, 8, 4, 1}, {9, 2, 0, 3}}; System.out.println(Arrays.equals(a, b)); //equals仅适用于一维数组 System.out.println(Arrays.deepEquals(a, b)); //对于多维数组，需要使用deepEquals来进行深层次判断} 这里肯定有小伙伴疑问了，不是说基本类型的数组不能转换为引用类型的数组吗？为什么这里的deepEquals接受的是Object[]也可以传入参数呢？这是因为现在是二维数组，二维数组每个元素都是一个数组，而数组本身的话就是一个引用类型了，所以说可以转换为Object类型，但是如果是一维数组的话，就报错： 总体来说，这个工具类对于我们数组的使用还是很方便的。 实战练习到目前为止，关于面向对象相关的内容我们已经学习了非常多了，接着依然是练习题。 冒泡排序算法有一个int数组，但是数组内的数据是打乱的，现在我们需要将数组中的数据按从小到大的顺序进行排列： 123public static void main(String[] args) { int[] arr = new int[]{3, 5, 7, 2, 9, 0, 6, 1, 8, 4};} 请你设计一个Java程序将这个数组中的元素按照顺序排列。 二分搜索算法现在有一个从小到大排序的数组，给你一个目标值target，现在我们想要找到这个值在数组中的对应下标，如果数组中没有这个数，请返回-1： 1234public static void main(String[] args) { int[] arr = {1, 3, 4, 6, 7, 8, 10, 11, 13, 15}; int target = 3;} 请你设计一个Java程序实现这个功能。 青蛙跳台阶问题现在一共有n个台阶，一只青蛙每次只能跳一阶或是两阶，那么一共有多少种跳到顶端的方案？ 例如n=2，那么一共有两种方案，一次性跳两阶或是每次跳一阶。 现在请你设计一个Java程序，计算当台阶数为n的情况下，能够有多少种方案到达顶端。 回文串判断“回文串”是一个正读和反读都一样的字符串，请你实现一个Java程序，判断用户输入的字符串（仅出现英文字符）是否为“回文”串。 ABCBA 就是一个回文串，因为正读反读都是一样的 ABCA 就不是一个回文串，因为反着读不一样 汉诺塔求解什么是汉诺塔？ 汉诺塔（Tower of Hanoi），又称河内塔，是一个源于印度古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始 按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。 这三根柱子我们就依次命名为A、B、C，现在请你设计一个Java程序，计算N阶（n片圆盘）汉诺塔移动操作的每一步。","categories":[],"tags":[]},{"title":"","slug":"白马Java/JavaSE笔记（一）重制版","date":"2025-09-07T23:26:13.327Z","updated":"2025-09-07T23:28:25.711Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/0.html","excerpt":"新手入门篇注意：开始学习JavaSE之前建议学习的前置课程《C语言程序设计》《数据结构》《操作系统》《计算机组成原理》 欢迎各位小伙伴来到JavaSE视频教程，期待与各位小伙伴共度这一旅程！视频中所有的文档、资料，都可以直接在视频下方简介中找到，视频非培训机构出品，纯个人录制，不需要加任何公众号、小程序，直接自取即可。 教程开始之前，提醒各位小伙伴： 如果你对某样东西不熟悉，请务必保证跟视频中使用一模一样的环境、一模一样的操作方式去使用，不要自作主张，否则出现某些奇怪的问题又不知道怎么办，就会浪费很多时间。 视频依然是基于Java 8进行讲解，不要自己去安装一个其他的版本，想要了解新版本特性可以在另一个视频里面观看。 在学习过程中，尽可能避免出现中文文件夹，包括后面的环境安装、项目创建，都尽量不要放在中文路径下（因为使用中文常常出现奇奇怪怪的问题）建议使用对应的英文单词代替，或者是用拼音都可以，最好只出现英文字母和数字。 本系列教程使用 IDEA社区版（免费）即可，不需要申请终极版。 如果觉得本视频对你有帮助，请一键三连支持一下UP主！ 计算机思维导论计算机自1946年问世以来，几乎改变了整个世界。","text":"新手入门篇注意：开始学习JavaSE之前建议学习的前置课程《C语言程序设计》《数据结构》《操作系统》《计算机组成原理》 欢迎各位小伙伴来到JavaSE视频教程，期待与各位小伙伴共度这一旅程！视频中所有的文档、资料，都可以直接在视频下方简介中找到，视频非培训机构出品，纯个人录制，不需要加任何公众号、小程序，直接自取即可。 教程开始之前，提醒各位小伙伴： 如果你对某样东西不熟悉，请务必保证跟视频中使用一模一样的环境、一模一样的操作方式去使用，不要自作主张，否则出现某些奇怪的问题又不知道怎么办，就会浪费很多时间。 视频依然是基于Java 8进行讲解，不要自己去安装一个其他的版本，想要了解新版本特性可以在另一个视频里面观看。 在学习过程中，尽可能避免出现中文文件夹，包括后面的环境安装、项目创建，都尽量不要放在中文路径下（因为使用中文常常出现奇奇怪怪的问题）建议使用对应的英文单词代替，或者是用拼音都可以，最好只出现英文字母和数字。 本系列教程使用 IDEA社区版（免费）即可，不需要申请终极版。 如果觉得本视频对你有帮助，请一键三连支持一下UP主！ 计算机思维导论计算机自1946年问世以来，几乎改变了整个世界。 现在我们可以通过电脑来做很多事情，比如我们常常听到的什么人工智能、电子竞技、大数据等等，都和计算机息息相关，包括我们现在的手机、平板等智能设备，也是计算机转变而来的。 也许你没有接触过计算机，也许你唯一接触计算机就是用来打游戏，也有可能你曾经捣鼓过计算机，在学习Java之前，先让我们来了解一下计算机的世界。 计算机的世界注意：如果你已经完成了《C语言程序设计》视频教程的学习，可以直接跳过此部分。 计算机虽然名字听着很高级，不过它也是由一个个简单电路组成的。 这是我们在初中就学习过的电路图，不过这种电路太过简单，只能完成一些很基础的的操作，比如点亮小灯泡等。 很明显想要实现计算机怎么高级的运算机器，肯定是做不到的，这时我们就需要引入更加强大的数字电路了。 用数字信号完成对数字量进行算术运算和逻辑运算的电路称为数字电路，或数字系统。由于它具有逻辑运算和逻辑处理功能，所以又称数字逻辑电路。现代的数字电路由半导体工艺制成的若干数字集成器件构造而成。逻辑门是数字逻辑电路的基本单元。 计算机专业一般会在大一开放《数字电路》这门课程，会对计算机底层的数字电路实现原理进行详细介绍。 数字电路引入了逻辑判断，我们来看看简单的数字电路： 数字电路中，用电压的高低来区分出两种信号，低电压表示0，高电压表示1，由于只能通过这种方式表示出两种类型的信号，所以计算机采用的是二进制。 二进制是计算技术中广泛采用的一种数制。二进制数据是用0和1两个数码来表示的数。它的基数为2，进位规则是“逢二进一”，借位规则是“借一当二”。 比如我们一般采用的都是十进制表示，比如9再继续加1的话，就需要进位了，变成10，在二进制中，因为只有0和1，所以当1继续加1时，就需要进位了，就变成10了（注意这不是十，读成一零就行了） 当然，仅仅有两种信号还不够，我们还需要逻辑门来辅助我们完成更多的计算，最基本的逻辑关系是与、或、非，而逻辑门就有相应的是与门、或门和非门，可以用电阻、电容、二极管、三极管等分立原件构成（具体咋构成的咱这里就不说了） 比如与操作，因为只有两种类型，我们一般将1表示为真，0表示为假，与操作（用&amp;表示）要求两个数参与进来，比如： 1 &amp; 1 = 1 必须两边都是真，结果才为真。 1 &amp; 0 = 0 两边任意一个或者都不是真，结果为假。 或运算（用 | 表示）： 1 | 0 = 1 两边只要有一个为真，结果就为真 0 | 0 = 0 两边同时为假，结果才是假 非运算实际上就是取反操作（可以是 ! 表示） !1 = 0 !0 = 1 非运算会将真变成假，假变成真 有了这些运算之后，我们的电路不仅仅可以实现计算，也可以实现各种各样的逻辑判断，最终才能发展成我们的计算机。 前面我们大概介绍一下计算机的底层操作原理，接着我们来看看计算机的基本组成。 相信各位熟知的计算机都是一个屏幕+一个主机的形式，然后配上我们的键盘鼠标，就可以开始使用了，但是实际上标准的计算机结构并没有这么简单，我们来看看： 我们电脑最核心的部件，当属CPU，因为几乎所有的运算都是依靠CPU进行（各种各样的计算电路已经在CPU中安排好了，我们只需要发送对应的指令就可以进行对应的运算），它就像我们人的大脑一样，有了大脑才能进行思考。不过光有大脑还不行，还要有一些其他的部分来辅助工作，比如我们想向电脑里面打字，那么就需要连接一个键盘才能输入，我们想要点击桌面上的图标，那么就需要一个鼠标来操作光标，这些都是输入设备。我们的电脑开机之后显示器上会显示出画面，实际上显示器就是输出设备。 当然除了这些内容之外，我们的电脑还需要内存来保存运行时的一些数据，以及外存来保存文件（比如硬盘）等。我们常说的iPhone14 512G，这个512G并不是指的内存，而是指的外存，准确的说是用于存放文件硬盘大小，而真正的内存是我们常说的4G/6G/8G运行内存，内存的速度远高于外存的速度，所以1G内存的价格远超1G硬盘的价格。 计算机包括五大部件：运算器、控制器、存储器、输入和输出设备。有了这一套完整的硬件环境，我们的电脑才算是有了一个完整的身体。 操作系统概述注意：如果你已经完成了《C语言程序设计》视频教程的学习，可以直接跳过此部分。 前面我们了解了一下计算机的大致原理和组成结构，但是光有这一套硬件可不行，如何让这一套硬件按照我们想要的方式运作起来，也是非常重要的，这时我们就需要介绍操作系统了。 操作系统（operating system，简称OS）是管理计算机硬件与软件资源的计算机程序。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入设备与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互操作的界面。 一般在计算机专业大二，会开放《操作系统》课程，会详细讲解操作系统的底层运作机制和调度。 一般我们电脑上都安装了Windows操作系统（苹果笔记本安装的是MacOS操作系统），现在主流的电脑都已经预装Windows11了： 有了操作系统，我们的电脑才能真正运行起来，我们就可以轻松地通过键盘和鼠标来操作电脑了。 不过操作系统最开始并不是图形化界面，它类似于Windows中的命令提示符： 没有什么图标这些概念，只有一个简简单单的黑框让我们进行操作，通过输入命令来进行一些简单的使用，程序的运行结果也会在黑框框（命令行）中打印出来，不过虽然仅仅是一个黑框，但是能运行的程序可是非常非常多的，只需要运行我们编写好的程序，就能完成各种各样复杂的计算任务，并且计算机的计算速度远超我们的人脑。 中国超级计算机系统天河二号，计算速度达到每秒5.49亿亿次。 当然，除了我们常见的Windows和MacOS系统之外，还有我们以后需要经常打交道的Linux操作系统，这种操作系统是开源的，意思是所有的人都可以拿到源代码进行修改，于是就出现了很多发行版： 这些发行版有带图形化界面的，也有不带图形化界面的，不带图形化界面的Linux将是我们以后学习的重点。 不同操作系统之间的软件并不是通用的，比如Windows下我们的软件一般是.exe后缀名称，而MacOS下则不是，并且也无法直接运行.exe文件，这是因为不同操作系统的具体实现会存在一些不同，程序编译（我们之后会介绍到）之后的格式也会不同，所以是无法做到软件通用的。 正是因为有了操作系统，才能够组织我们计算机的底层硬件（包括CPU、内存、输入输出设备等）进行有序工作，没有操作系统电脑就如同一堆废铁，只有躯壳没有灵魂。 计算机编程语言注意：如果你已经完成了《C语言程序设计》视频教程的学习，可以直接跳过此部分。 现在我们大致了解了我们的电脑的运作原理，实际上是一套完整的硬件+一个成形的操作系统共同存在的。接着我们就可以开始了解一下计算机的编程语言了。我们前面介绍的操作系统也是由编程语言写出来的，操作系统本身也算是一个软件。 那么操作系统是如何让底层硬件进行工作的呢？实际上就是通过向CPU发送指令来完成的。 计算机指令就是指挥机器工作的指示和命令，程序就是一系列按一定顺序排列的指令，执行程序的过程就是计算机的工作过程。指令集，就是CPU中用来计算和控制计算机系统的一套指令的集合，而每一种新型的CPU在设计时就规定了一系列与其他硬件电路相配合的指令系统。而指令集的先进与否，也关系到CPU的性能发挥，它也是CPU性能体现的一个重要标志。 我们电脑中的CPU有多种多样的，不同的CPU之间可能也会存在不同的架构，比如现在最常用的是x86架构，还有我们手机平板这样的移动设备使用的arm架构，不同的架构指令集也会有不同。 我们知道，计算机底层硬件都是采用的0和1这样的二进制表示，所以指令也是一样的，比如（这里随便写的）： 000001 - 代表开机 000010 - 代表关机 000011 - 代表进行加法运算 当我们通过电路发送给CPU这样的二进制指令，CPU就能够根据我们的指令执行对应的任务，而我们编写的程序保存在硬盘中也是这样的二进制形式，我们只需要将这些指令组织好，按照我们的思路一条一条执行对应的命令，就能够让计算机计算任何我们需要的内容了，这其实就是机器语言。 不过随着时代的进步，指令集越来越大，CPU支持的运算类型也越来越多，这样的纯二进制编写实在是太累了，并且越来越多的命令我们根本记不住，于是就有了汇编语言。汇编语言将这些二进制的操作码通过助记符来替换： MOV 传送字或字节。 MOVSX 先符号扩展,再传送。 MOVZX 先零扩展,再传送。 PUSH 把字压入堆栈。 把这些原有的二进制命令通过一个单词来代替，这样是不是就好记多了，在程序编写完成后，我们只需要最后将这些单词转换回二进制指令就可以了，这也是早期出现的低级编程语言。 不过虽然通过这些助记符就能够很轻松地记住命令，但是还是不够方便，因为可能我们的程序需要完成一个很庞大的任务，但是如果还是这样一条一条指令进行编写，是不是太慢了点，有时候可能做一个简单的计算，都需要好几条指令来完成。于是，高级编程语言——C语言，终于诞生了。 C语言诞生于美国的贝尔实验室，由丹尼斯·里奇（Dennis MacAlistair Ritchie）以肯尼斯·蓝·汤普森（Kenneth Lane Thompson）设计的B语言为基础发展而来，在它的主体设计完成后，汤普森和里奇用它完全重写了UNIX操作系统，且随着UNIX操作系统的发展，C语言也得到了不断的完善。 高级语言不同于低级语言，低级语言的主要操作对象是指令本身，而高级语言却更加符合我们人脑的认知，更像是通过我们人的思维，去告诉计算机你需要做什么，包括语法也会更加的简单易懂。下面是一段简单的C语言代码： 123456int main() { int a = 10; //定义一个a等于10 int b = 10; //定义一个b等于10 int c = a + b; //语义非常明确，c就是a加上b计算出来的结果。 return 0;} 不过现在看不懂没关系，我们后面慢慢学。 C语言虽然支持按照我们更容易理解的方式去进行编程，但是最后还是会编译成汇编指令最后变成计算机可以直接执行的指令，不过具体的编译过程，我们不需要再关心了，我们只需要去写就可以了，而对我们代码进行编译的东西，称为编译器。 当然，除了C语言之外，还有很多其他的高级语言，比如Java、Python、C#、PHP等等，相比其他编程语言，C算是比较古老的一种了，但是时隔多年直至今日，其他编程语言也依然无法撼动它的王者地位： 可以看到在2021年9月，依然排在编程语言排行榜的第一名（Python和Java紧随其后），可见这门语言是多么的不可撼动，很多操作系统、高级编程语言底层实现，几乎都是依靠C语言去编写的（包括Java的底层也是C/C++实现的）所以学习这一门语言，对于理工科尤其是计算机专业极为重要，学好C语言你甚至可以融汇贯通到其他语言，学起来也会轻松很多。 走进Java语言前面我们介绍了C语言，它实际上就是通过编译，将我们可以看懂的代码，翻译为计算机能够直接执行的指令，这样计算机就可以按照我们想要的方式去进行计算了。当然，除了C语言之外，也有其他的语言，比如近几年也很火的Python，它跟C语言不同，它并不会先进行编译，而是直接交给解释器解释执行： 1print(\"Hello World!\") 可见，这种方式也可以让计算机按照我们的想法去进行工作。 一般来说，编程语言就分为两大类： 编译型语言：需要先编译为计算机可以直接执行的命令才可以运行。优点是计算机直接运行，性能高；缺点是与平台密切相关，在一种操作系统上编译的程序，无法在其他非同类操作系统上运行，比如Windows下的exe程序在Mac上就无法运行。 解释型语言：只需要通过解释器代为执行即可，不需要进行编译。优点是可以跨平台，因为解释是解释器的事情，只需要在各个平台上安装对应的解释器，代码不需要任何修改就可以直接运行；缺点是需要依靠解释器解释执行，效率肯定没直接编译成机器指令运行的快，并且会产生额外的资源占用。 那么我们来看看我们今天要介绍的主角，Java语言（Java之父：James Gosling，詹姆斯·高斯林） Write Once, Run Anywhere. 这是Java语言的标语，它的目标很明确：一次编写，到处运行，它旨在打破平台的限制，让Java语言可以运行在任何平台上，并且不需要重新编译，实现跨平台运行。 Java自1995年正式推出以来，已经度过了快28个春秋，而基于Java语言，我们的生活中也有了各种各样的应用： 诺基亚手机上的很多游戏都是使用Java编写的。 安卓系统中的各种应用程序也是使用Java编写的。 著名沙盒游戏《Minecraft》也有对应的Java版本，得益于Java跨平台特性，无论在什么操作系统上都可以玩到这款游戏。 … （有关Java的详细发展历程，可以参考《Java核心技术·卷I》第一章） 可见，Java实际上早已在我们生活中的各个地方扎根。那么，Java语言是什么样的一个运行机制呢？ 实际上我们的Java程序也是需要进行编译才可以运行的，这一点与C语言是一样的，Java程序编译之后会变成.class结尾的二进制文件： 不过不同的是，这种二进制文件计算机并不能直接运行，而是需要交给JVM（Java虚拟机）执行。 JVM是个什么东西呢？简单来说，它就像我们前面介绍的解释器一样，我们可以将编译完成的.class文件直接交给JVM去运行，而程序中要做的事情，也都是由它来告诉计算机该如何去执行。 在不同的操作系统下，都有着对应的JVM实现，我们只需要安装好就可以了，而我们程序员只需要将Java程序编译为.class文件就可以直接交给JVM运行，无论是什么操作系统，JVM都采用的同一套标准读取和执行.class文件，所以说我们编译之后，在任何平台都可以运行，实现跨平台。 由于Java又需要编译同时还需要依靠JVM解释执行，所以说Java既是编译型语言，也是解释型语言。 Java分为很多个版本： JavaSE：是我们本教程的主要学习目标，它是标准版的Java，也是整个Java的最核心内容，在开始后续课程之前，这是我们不得不越过的一道坎，这个阶段一定要认真扎实地将Java学好，不然到了后面的高级部分，会很头疼。 JavaME：微缩版Java，已经基本没人用了。 JavaEE：企业级Java，比如网站开发，它是JavaSE阶段之后的主要学习方向。 从下节课开始，我们就正式地进行Java环境的安装和IDE的使用学习。 环境安装与IDE使用前面我们介绍了Java语言，以及其本身的一些性质，这一部分我们就开始进行学习环境安装（这一部分请务必跟着操作，不要自作主张地去操作，一开始就出问题其实是最劝退新手的） JDK下载与安装首先我们来介绍一下JDK和JRE，各位小伙伴一定要能够区分这两者才可以。 JRE（Java Runtime Environment）：Java的运行环境，安装了运行环境之后，Java程序才可以运行，一般不做开发，只是需要运行Java程序直接安装JRE即可。 JDK（Java Development Kit）：包含JRE，并且还附带了大量开发者工具，我们学习Java程序开发就使用JDK即可。 它们的关系如下： 那么现在我们就去下载JDK吧，这里推荐安装免费的ZuluJDK：https://www.azul.com/downloads/?version=java-8-lts&amp;package=jdk 在这里选择自己的操作系统对应的安装包： 比如Windows下，我们就选择.msi的安装包即可（MacOS、Linux下同样选择对应的即可） 下载完成后，我们直接双击安装： 注意，这里不建议各位小伙伴去修改安装的位置！新手只建议安装到默认位置（不要总担心C盘不够，该装的还是要装，尤其是这种环境，实在装不下就去将其他磁盘的空间分到C盘一部分）如果是因为没有安装到默认位置出现了任何问题，你要是找不到大佬问的话，又得重新来一遍，就很麻烦。 剩下的我们只需要一路点击Next即可，安装完成之后，我们打开CMD命令窗口（MacOS下直接打开“终端”）来验证一下（要打开CMD命令窗口，Windows11可以直接在下面的搜索框搜索cmd即可，或者直接在文件资源管理器路径栏输入cmd也可以） 我们直接输入java命令即可： 如果能够直接输出内容，说明环境已经安装成功了，正常情况下已经配置好了，我们不需要手动去配置什么环境变量，所以说安装好就别管了。 输入java -version可以查看当前安装的JDK版本： 只要是1.8.0就没问题了，后面的小版本号可能你们会比我的还要新。 这样我们就完成了Java环境的安装，我们可以来体验一下编写并且编译运行一个简单的Java程序，我们新建一个文本文档，命名为Main.txt（如果没有显示后缀名，需要在文件资源管理器中开启一下）然后用记事本打开，输入以下内容： 12345public class Main{ public static void main(String[] args){ System.out.println(\"Hello World!\"); }} 现在看不懂没关系，直接用就行，我们后面会一点一点讲解的。 编辑好之后，保存退出，接着我们将文件的后缀名称修改为.java这是Java源程序文件的后缀名称： 此时我们打开CMD，注意要先进入到对应的路径下，比如我们现在的路径： 我们使用cd命令先进入到这个目录下： 要编译一个Java程序，我们需要使用javac命令来进行： 执行后，可以看到目录下多出来了一个.class文件： 这样我们就成功编译了一个Java程序，然后我们就可以将其交给JVM运行了，我们直接使用java命令即可： 注意不要加上后缀名称，直接输入文件名字即可，可以看到打印了一个 Hello World! 字样，我们的第一个Java程序就可以运行了。 IDEA安装与使用前面我们介绍了JDK开发环境的安装以及成功编译运行了我们的第一个Java程序。 但是我们发现，如果我们以后都使用记事本来进行Java程序开发的话，是不是效率太低了点？我们还要先编辑，然后要改后缀，还要敲命令来编译，有没有更加方便一点的写代码的工具呢？这里我们要介绍的是：IntelliJ IDEA（这里不推荐各位小伙伴使用Eclipse，因为操作上没有IDEA这么友好） IDEA准确来说是一个集成开发环境（IDE），它集成了大量的开发工具，编写代码的错误检测、代码提示、一键完成编译运行等，非常方便。 下载地址：IntelliJ IDEA：JetBrains 功能强大、符合人体工程学的 Java IDE（如果你之前学习C语言程序设计篇使用过CLion，你会发现界面一模一样，这样就能方便你快速上手） 我们直接点击下载即可： 这个软件本身是付费的，比较贵，而且最近还涨价了，不过这里我们直接下载面的社区版本就行了（JavaSE学习阶段不需要终极版，但是建议有条件的还是申请一个，因为后面JavaWeb开始就需要终极版了，学生和教师可以直接免费申请一年的使用许可，并且每个学期都可以续一年） 下载好之后，直接按照即可，这个不强制要求安装到C盘，自己随意，但是注意路径中不要出现中文！ 这里勾选一下创建桌面快捷方式就行： 安装完成后，我们直接打开就可以了： 此时界面是全英文，如果各位小伙伴看得惯，可以直接使用全英文的界面（使用英文界面可以认识更多的专业术语词汇，但是可能看起来没中文那么直观，而且IDEA本身功能就比较多，英语不好的小伙伴就很头疼）这里还是建议英语不好的小伙伴使用中文界面，要使用中文只需要安装中文插件即可： 我们打开Plugins插件这一栏，然后直接在插件市场里面搜索Chinese，可以找到一个中文语言包的插件，我们直接Install安装即可，安装完成后点击重启，现在就是中文页面了： 如果各位小伙伴不喜欢黑色主题，也可以修改为白色主题，只需要在自定义中进行修改即可，一共四种主题。 如果你之前使用过其他IDE编写代码，这里还支持按键映射（采用其他IDE的快捷键方案）有需要的可以自己修改一下： 接下来，我们来看看如何使用IDEA编写Java程序，IDEA是以项目的形式对一个Java程序进行管理的，所以说我们直接创建一个新的项目，点击新建项目： 此时来到创建页面： 名称：你的Java项目的名称，随便起就行，尽量只带英文字母和数字，不要出现特殊字符和中文。 位置：项目的存放位置，可以自己根据情况修改，同样的，路径中不要出现中文。 语言：IDEA支持编写其他语言的项目，但是这里我们直接选择Java就行了。 构建系统：在JavaSE阶段一律选择IntelliJ就行了，Maven我们会在JavaWeb之后进行讲解，Gradle会在安卓开发教程中介绍。 JDK：就是我们之前安装好的JDK，如果是默认路径安装，这里会自动识别（所以说不要随便去改，不然这些地方就很麻烦） 当然，如果JDK这里没有自动识别到，那么就手动添加一下： 没问题之后，我们直接创建项目： 进入之后，可以看到已经自动帮助我们创建好了一个java源文件，跟我们之前的例子是一样的。要编译运行我们的Java程序，只需要直接点击左边的三角形（启动按钮）即可： 点击之后，会在下方自动开始构建： 完成之后，就可以在控制台看到输出的内容了： 我们可以看到新增加了一个out目录，这里面就是刚刚编译好的.class文件： IDEA非常强大，即使是编译之后的二进制文件，也可以反编译回原代码的样子： 如果我们想写一个新的Java项目，可以退出当前项目重新创建： 此时项目列表中就有我们刚刚创建的Java项目了： 如果你还想探索IDEA的其他功能，可以点击欢迎页最下方的学习： 会有一个专门的引导教程项目，来教你如何使用各项功能： IDEA新UI介绍和外观设置IDEA在2022年开启了界面新UI的测试，并将在年底前实装，所以说我们将老UI界面改为新的UI界面进行介绍（如果已经是新UI的样式，那么就不需要像下面一样开启了） 我们随便进入一个项目，然后双击Shift出现搜索框（这个搜索框很好用，什么都能搜）输入registry 找到ide.experimental.ui，将其勾选上，然后重启IDEA就变成新的UI样式了（你不说这是IDEA我还以为是VS呢） 这里介绍一下新UI的各个功能，首先是运行项目，依然是点击左侧三角形： 在第一次运行后，会自动生成一个运行配置，我们也可以直接点击右上角的运行： 效果是一样的，都可以编译运行Java项目。上面一排工具栏被丢到了一个菜单里面： 如果各位小伙伴觉得代码字体太小了，可以在设置中进行调整： IDEA的所有通知都可以在通知中查看： 我们来看右下角，第一个三角形图标是运行的结果： 第二栏是终端（其实就是内嵌的一个CMD命令窗口）可以自由敲命令，默认是位于项目根目录下： 至此，学习前准备就完成了，从下节课开始，我们将正式进入到Java语言的学习中。","categories":[],"tags":[]},{"title":"","slug":"白马Java Web/JavaWeb笔记（一）","date":"2025-08-31T15:29:05.027Z","updated":"2025-08-31T15:31:22.572Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/0.html","excerpt":"Java网络编程在JavaSE阶段，我们学习了I/O流，既然I/O流如此强大，那么能否跨越不同的主机进行I/O操作呢？这就要提到Java的网络编程了。 注意：本章会涉及到计算机网络相关内容（只会讲解大致内容，不会完整的讲解计算机网络知识） 计算机网络基础利用通信线路和通信设备，将地理位置不同的、功能独立的多台计算机互连起来，以功能完善的网络软件来实现资源共享和信息传递，就构成了计算机网络系统。 比如我们家里的路由器，通过将我们的设备（手机、平板、电脑、电视剧）连接到路由器，来实现对互联网的访问。实际上，我们的路由器连接在互联网上，而我们的设备又连接了路由器，这样我们的设备就可以通过路由器访问到互联网了。通过网络，我们可以直接访问互联网上的另一台主机，比如我们要把QQ的消息发送给我们的朋友，或是通过远程桌面管理来操作另一台电脑，也可以是连接本地网络上的打印机。 既然我们可以通过网络访问其他计算机，那么如何区别不同的计算机呢？通过IP地址，我们就可以区分不同的计算机了：","text":"Java网络编程在JavaSE阶段，我们学习了I/O流，既然I/O流如此强大，那么能否跨越不同的主机进行I/O操作呢？这就要提到Java的网络编程了。 注意：本章会涉及到计算机网络相关内容（只会讲解大致内容，不会完整的讲解计算机网络知识） 计算机网络基础利用通信线路和通信设备，将地理位置不同的、功能独立的多台计算机互连起来，以功能完善的网络软件来实现资源共享和信息传递，就构成了计算机网络系统。 比如我们家里的路由器，通过将我们的设备（手机、平板、电脑、电视剧）连接到路由器，来实现对互联网的访问。实际上，我们的路由器连接在互联网上，而我们的设备又连接了路由器，这样我们的设备就可以通过路由器访问到互联网了。通过网络，我们可以直接访问互联网上的另一台主机，比如我们要把QQ的消息发送给我们的朋友，或是通过远程桌面管理来操作另一台电脑，也可以是连接本地网络上的打印机。 既然我们可以通过网络访问其他计算机，那么如何区别不同的计算机呢？通过IP地址，我们就可以区分不同的计算机了： 每一台电脑在同一个网络上都有一个自己的IP地址，用于区别于其他的电脑，我们可以通过对方主机的IP地址对其进行访问。那么我手机连接的移动流量，能访问到连接家里路由器的电脑吗？（不能，因为他们不属于同一个网络） 而我们的电脑上可能运行着大量的程序，每一个程序可能都需要通过网络来访问其他计算机，那这时该如何区分呢？我们可以通过端口号来区分： 因此，我们一般看到的是这样的：192.168.0.11:8080，通过IP:端口的形式来访问目标主机上的一个应用程序服务。注意端口号只能是0-65535之间的值！ IP地址分为IPv4和IPv6，IPv4类似于192.168.0.11，我们上面提到的例子都是使用的IPv4，它一共有四组数字，每组数字占8个bit位，IPv4地址0.0.0.0表示为2进制就是：00000000.00000000.00000000.00000000，共32个bit，最大为255.255.255.255，实际上，IPv4能够表示的所有地址，早就已经被用完了。IPv6能够保存128个bit位，因此它也可以表示更多的IP地址，一个IPv6地址看起来像这样：1030::C9B4:FF12:48AA:1A2B，目前也正在向IPv6的阶段过度。 TCP和UDP是两种不同的传输层协议： TCP：当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠（会进行三次握手，断开也会进行四次挥手），这样才能保证正确收发数据，因此TCP更适合一些可靠的数据传输场景。 UDP：它是一种无连接协议，数据想发就发，而且不会建立可靠传输，也就是说传输过程中有可能会导致部分数据丢失，但是它比TCP传输更加简单高效，适合视频直播之类的。 了解Socket技术通过Socket技术（它是计算机之间进行通信的一种约定或一种方式），我们就可以实现两台计算机之间的通信，Socket也被翻译为套接字，是操作系统底层提供的一项通信技术，它支持TCP和UDP。而Java就对socket底层支持进行了一套完整的封装，我们可以通过Java来实现Socket通信。 要实现Socket通信，我们必须创建一个数据发送者和一个数据接收者，也就是客户端和服务端，我们需要提前启动服务端，来等待客户端的连接，而客户端只需要随时启动去连接服务端即可！ 12345678910//服务端public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\"正在等待客户端连接...\"); Socket socket = server.accept(); //当没有客户端连接时，线程会阻塞，直到有客户端连接为止 System.out.println(\"客户端已连接，IP地址为：\"+socket.getInetAddress().getHostAddress()); }catch (IOException e){ e.printStackTrace(); }} 123456789//客户端public static void main(String[] args) { try (Socket socket = new Socket(\"localhost\", 8080)){ System.out.println(\"已连接到服务端！\"); }catch (IOException e){ System.out.println(\"服务端连接失败！\"); e.printStackTrace(); }} 实际上它就是一个TCP连接的建立过程： 一旦TCP连接建立，服务端和客户端之间就可以相互发送数据，直到客户端主动关闭连接。当然，服务端不仅仅只可以让一个客户端进行连接，我们可以尝试让服务端一直运行来不断接受客户端的连接： 1234567891011public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\"正在等待客户端连接...\"); while (true){ //无限循环等待客户端连接 Socket socket = server.accept(); System.out.println(\"客户端已连接，IP地址为：\"+socket.getInetAddress().getHostAddress()); } }catch (IOException e){ e.printStackTrace(); }} 现在我们就可以多次去连接此服务端了。 使用Socket进行数据传输通过Socket对象，我们就可以获取到对应的I/O流进行网络数据传输： 12345678910111213141516171819public static void main(String[] args) { try (Socket socket = new Socket(\"localhost\", 8080); Scanner scanner = new Scanner(System.in)){ System.out.println(\"已连接到服务端！\"); OutputStream stream = socket.getOutputStream(); OutputStreamWriter writer = new OutputStreamWriter(stream); //通过转换流来帮助我们快速写入内容 System.out.println(\"请输入要发送给服务端的内容：\"); String text = scanner.nextLine(); writer.write(text+'\\n'); //因为对方是readLine()这里加个换行符 writer.flush(); System.out.println(\"数据已发送：\"+text); }catch (IOException e){ System.out.println(\"服务端连接失败！\"); e.printStackTrace(); }finally { System.out.println(\"客户端断开连接！\"); } }} 12345678910111213public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\"正在等待客户端连接...\"); Socket socket = server.accept(); System.out.println(\"客户端已连接，IP地址为：\"+socket.getInetAddress().getHostAddress()); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); //通过 System.out.print(\"接收到客户端数据：\"); System.out.println(reader.readLine()); socket.close(); //和服务端TCP连接完成之后，记得关闭socket }catch (IOException e){ e.printStackTrace(); }} 同理，既然服务端可以读取客户端的内容，客户端也可以在发送后等待服务端给予响应： 1234567891011121314151617181920public static void main(String[] args) { try (Socket socket = new Socket(\"localhost\", 8080); Scanner scanner = new Scanner(System.in)){ System.out.println(\"已连接到服务端！\"); OutputStream stream = socket.getOutputStream(); OutputStreamWriter writer = new OutputStreamWriter(stream); //通过转换流来帮助我们快速写入内容 System.out.println(\"请输入要发送给服务端的内容：\"); String text = scanner.nextLine(); writer.write(text+'\\n'); //因为对方是readLine()这里加个换行符 writer.flush(); System.out.println(\"数据已发送：\"+text); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); System.out.println(\"收到服务器返回：\"+reader.readLine()); }catch (IOException e){ System.out.println(\"服务端连接失败！\"); e.printStackTrace(); }finally { System.out.println(\"客户端断开连接！\"); }} 123456789101112131415public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\"正在等待客户端连接...\"); Socket socket = server.accept(); System.out.println(\"客户端已连接，IP地址为：\"+socket.getInetAddress().getHostAddress()); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); //通过 System.out.print(\"接收到客户端数据：\"); System.out.println(reader.readLine()); OutputStreamWriter writer = new OutputStreamWriter(socket.getOutputStream()); writer.write(\"已收到！\"); writer.flush(); }catch (IOException e){ e.printStackTrace(); }} 我们可以手动关闭单向的流： 12socket.shutdownOutput(); //关闭输出方向的流socket.shutdownInput(); //关闭输入方向的流 如果我们不希望服务端等待太长的时间，我们可以通过调用setSoTimeout()方法来设定IO超时时间： 1socket.setSoTimeout(3000); 当超过设定时间都依然没有收到客户端或是服务端的数据时，会抛出异常： 12345678910111213java.net.SocketTimeoutException: Read timed out at java.net.SocketInputStream.socketRead0(Native Method) at java.net.SocketInputStream.socketRead(SocketInputStream.java:116) at java.net.SocketInputStream.read(SocketInputStream.java:171) at java.net.SocketInputStream.read(SocketInputStream.java:141) at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284) at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326) at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178) at java.io.InputStreamReader.read(InputStreamReader.java:184) at java.io.BufferedReader.fill(BufferedReader.java:161) at java.io.BufferedReader.readLine(BufferedReader.java:324) at java.io.BufferedReader.readLine(BufferedReader.java:389) at com.test.Main.main(Main.java:41) 我们之前使用的都是通过构造方法直接连接服务端，那么是否可以等到我们想要的时候再去连接呢？ 123try (Socket socket = new Socket(); //调用无参构造不会自动连接 Scanner scanner = new Scanner(System.in)){ socket.connect(new InetSocketAddress(\"localhost\", 8080), 1000); //手动调用connect方法进行连接 如果连接的双方发生意外而通知不到对方，导致一方还持有连接，这样就会占用资源，因此我们可以使用setKeepAlive()方法来防止此类情况发生： 1socket.setKeepAlive(true); 当客户端连接后，如果设置了keeplive为 true，当对方没有发送任何数据过来，超过一个时间(看系统内核参数配置)，那么我们这边会发送一个ack探测包发到对方，探测双方的TCP/IP连接是否有效。 TCP在传输过程中，实际上会有一个缓冲区用于数据的发送和接收： 此缓冲区大小为：8192，我们可以手动调整其大小来优化传输效率： 12socket.setReceiveBufferSize(25565); //TCP接收缓冲区socket.setSendBufferSize(25565); //TCP发送缓冲区 使用Socket传输文件既然Socket为我们提供了IO流便于数据传输，那么我们就可以轻松地实现文件传输了。 使用浏览器访问Socket服务器在了解了如何使用Socket传输文件后，我们来看看，浏览器是如何向服务器发起请求的： 12345678910111213141516public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\"正在等待客户端连接...\"); Socket socket = server.accept(); System.out.println(\"客户端已连接，IP地址为：\"+socket.getInetAddress().getHostAddress()); InputStream in = socket.getInputStream(); //通过 System.out.println(\"接收到客户端数据：\"); while (true){ int i = in.read(); if(i == -1) break; System.out.print((char) i); } }catch (Exception e){ e.printStackTrace(); } } 我们现在打开浏览器，输入http://localhost:8080或是http://127.0.0.1:8080/，来连接我们本地开放的服务器。 我们发现浏览器是无法打开这个链接的，但是我们服务端却收到了不少的信息： 12345678910111213141516GET / HTTP/1.1Host: 127.0.0.1:8080Connection: keep-aliveCache-Control: max-age=0sec-ch-ua: \"Chromium\";v=\"94\", \"Google Chrome\";v=\"94\", \";Not A Brand\";v=\"99\"sec-ch-ua-mobile: ?0sec-ch-ua-platform: \"macOS\"Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Sec-Fetch-Site: noneSec-Fetch-Mode: navigateSec-Fetch-User: ?1Sec-Fetch-Dest: documentAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,und;q=0.8,en;q=0.7 实际上这些内容都是Http协议规定的请求头内容。HTTP是一种应用层协议，全称为超文本传输协议，它本质也是基于TCP协议进行数据传输，因此我们的服务端能够读取HTTP请求。但是Http协议并不会保持长连接，在得到我们响应的数据后会立即关闭TCP连接。 既然使用的是Http连接，如果我们的服务器要支持响应HTTP请求，那么就需要按照HTTP协议的规则，返回一个规范的响应文本，首先是响应头，它至少要包含一个响应码： 1HTTP/1.1 200 Accpeted 然后就是响应内容（注意一定要换行再写），我们尝试来编写一下支持HTTP协议的响应内容： 1234567891011121314151617public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\"正在等待客户端连接...\"); Socket socket = server.accept(); System.out.println(\"客户端已连接，IP地址为：\"+socket.getInetAddress().getHostAddress()); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); //通过 System.out.println(\"接收到客户端数据：\"); while (reader.ready()) System.out.println(reader.readLine()); //ready是判断当前流中是否还有可读内容 OutputStreamWriter writer = new OutputStreamWriter(socket.getOutputStream()); writer.write(\"HTTP/1.1 200 Accepted\\r\\n\"); //200是响应码，Http协议规定200为接受请求，400为错误的请求，404为找不到此资源（不止这些，还有很多） writer.write(\"\\r\\n\"); //在请求头写完之后还要进行一次换行，然后写入我们的响应实体（会在浏览器上展示的内容） writer.write(\"lbwnb!\"); writer.flush(); }catch (Exception e){ e.printStackTrace(); }} 我们可以打开浏览器的开发者模式（这里推荐使用Chrome/Edge浏览器，按下F12即可打开），我们来观察一下浏览器的实际请求过程。","categories":[],"tags":[]},{"title":"","slug":"白马Java Web/JavaWeb笔记（五）","date":"2025-08-31T15:29:05.025Z","updated":"2025-08-31T15:31:22.575Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/0.html","excerpt":"JavaWeb后端经过前面的学习，现在终于可以正式进入到后端的学习当中，不过，我们还是需要再系统地讲解一下HTTP通信基础知识，它是我们学习JavaWeb的基础知识，我们之前已经学习过TCP通信，而HTTP实际上是基于TCP协议之上的应用层协议，因此理解它并不难理解。 打好基础是关键！为什么要去花费时间来讲解计算机网络基础，我们学习一门技术，如果仅仅是知道如何使用却不知道其原理，那么就成了彻头彻尾的“码农”，只知道搬运代码实现功能，却不知道这行代码的执行流程，在遇到一些问题的时候就不知道如何解决，无论是知识层面还是应用层面都得不到提升。 无论怎么样，我们都要明确，我们学习JavaWeb的最终目的是为了搭建一个网站，并且让用户能访问我们的网站并在我们的网站上做一些事情。 计算机网络基础在计算机网络（谢希仁 第七版 第264页）中，是这样描述万维网的： 万维网（World Wide Web）并非是某种特殊的计算机网络，万维网是一个大规模的联机式信息储藏所，英文简称Web，万维网用**链接**的方法，能够非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需求获取丰富的信息。 这句话说的非常官方，但是也蕴藏着许多的信息，首先它指明，我们的互联网上存在许许多多的服务器，而我们通过访问这些服务器就能快速获取服务器为我们提供的信息（比如打开百度就能展示搜索、打开小破站能刷视频、打开微博能查看实时热点）而这些服务器就是由不同的公司在运营。 其次，我们通过浏览器，只需要输入对应的网址或是点击页面中的一个链接，就能够快速地跳转到另一个页面，从而按我们的意愿来访问服务器。","text":"JavaWeb后端经过前面的学习，现在终于可以正式进入到后端的学习当中，不过，我们还是需要再系统地讲解一下HTTP通信基础知识，它是我们学习JavaWeb的基础知识，我们之前已经学习过TCP通信，而HTTP实际上是基于TCP协议之上的应用层协议，因此理解它并不难理解。 打好基础是关键！为什么要去花费时间来讲解计算机网络基础，我们学习一门技术，如果仅仅是知道如何使用却不知道其原理，那么就成了彻头彻尾的“码农”，只知道搬运代码实现功能，却不知道这行代码的执行流程，在遇到一些问题的时候就不知道如何解决，无论是知识层面还是应用层面都得不到提升。 无论怎么样，我们都要明确，我们学习JavaWeb的最终目的是为了搭建一个网站，并且让用户能访问我们的网站并在我们的网站上做一些事情。 计算机网络基础在计算机网络（谢希仁 第七版 第264页）中，是这样描述万维网的： 万维网（World Wide Web）并非是某种特殊的计算机网络，万维网是一个大规模的联机式信息储藏所，英文简称Web，万维网用**链接**的方法，能够非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需求获取丰富的信息。 这句话说的非常官方，但是也蕴藏着许多的信息，首先它指明，我们的互联网上存在许许多多的服务器，而我们通过访问这些服务器就能快速获取服务器为我们提供的信息（比如打开百度就能展示搜索、打开小破站能刷视频、打开微博能查看实时热点）而这些服务器就是由不同的公司在运营。 其次，我们通过浏览器，只需要输入对应的网址或是点击页面中的一个链接，就能够快速地跳转到另一个页面，从而按我们的意愿来访问服务器。 而书中是这样描述万维网的工作方式： 万维网以客户服务器的方式工作，浏览器就是安装在用户主机上的万维网客户程序，万维网文档所驻留的主机则运行服务器程序，因此这台主机也称为万维网服务器。客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档，在一个客户程序主窗口上显示出的万维网文档称为页面。 上面提到的客户程序其实就是我们电脑上安装的浏览器，而服务端就是我们即将要去学习的Web服务器，也就是说，我们要明白如何搭建一个Web服务器并向用户发送我们提供的Web页面，在浏览器中显示的，一般就是HTML文档被解析后的样子。 那么，我们的服务器可能不止一个页面，可能会有很多个页面，那么客户端如何知道该去访问哪个服务器的哪个页面呢？这个时候就需要用到URL统一资源定位符。互联网上所有的资源，都有一个唯一确定的URL，比如http://www.baidu.com URL的格式为： &lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt; 协议是指采用什么协议来访问服务器，不同的协议决定了服务器返回信息的格式，我们一般使用HTTP协议。 主机可以是一个域名，也可以是一个IP地址（实际上域名最后会被解析为IP地址进行访问） 端口是当前服务器上Web应用程序开启的端口，我们前面学习TCP通信的时候已经介绍过了，HTTP协议默认使用80端口，因此有时候可以省略。 路径就是我们希望去访问此服务器上的某个文件，不同的路径代表访问不同的资源。 我们接着来了解一下什么是HTTP协议： HTTP是面向事务的应用层协议，它是万维网上能够可靠交换文件的重要基础。HTTP不仅传送完成超文本跳转所需的必须信息，而且也传送任何可从互联网上得到的信息，如文本、超文本、声音和图像。 实际上我们之前访问百度、访问自己的网站，所有的传输都是以HTTP作为协议进行的。 我们来看看HTTP的传输原理： HTTP使用了面向连接的TCP作为运输层协议，保证了数据的可靠传输。HTTP不必考虑数据在传输过程中被丢弃后又怎样被重传。但是HTTP协议本身是无连接的。也就是说，HTTP虽然使用了TCP连接，但是通信的双方在交换HTTP报文之前不需要先建立HTTP连接。1997年以前使用的是HTTP/1.0协议，之后就是HTTP/1.1协议了。 那么既然HTTP是基于TCP进行通信的，我们首先来回顾一下TCP的通信原理： TCP协议实际上是经历了三次握手再进行通信，也就是说保证整个通信是稳定的，才可以进行数据交换，并且在连接已经建立的过程中，双方随时可以互相发送数据，直到有一方主动关闭连接，这时在进行四次挥手，完成整个TCP通信。 而HTTP和TCP并不是一个层次的通信协议，TCP是传输层协议，而HTTP是应用层协议，因此，实际上HTTP的内容会作为TCP协议的报文被封装，并继续向下一层进行传递，而传输到客户端时，会依次进行解包，还原为最开始的HTTP数据。 HTTP使用TCP协议是为了使得数据传输更加可靠，既然它是依靠TCP协议进行数据传输，那么为什么说它本身是无连接的呢？我们来看一下HTTP的传输过程： 用户在点击鼠标链接某个万维网文档时，HTTP协议首先要和服务器建立TCP连接。这需要使用三报文握手。当建立TCP连接的三报文握手的前两部分完成后（即经过了一个RTT时间后），万维网客户就把HTTP请求报文作为建立TCP连接的三报文握手中的第三个报文的数据，发送给万维网服务器。服务器收到HTTP请求报文后，就把所请求的文档作为响应报文返回给客户。 因此，我们的浏览器请求一个页面，需要两倍的往返时间。 最后，我们再来了解一下HTTP的报文结构： 由客户端向服务端发送是报文称为请求报文，而服务端返回给客户端的称为响应报文，实际上，整个报文全部是以文本形式发送的，通过使用空格和换行来完成分段。 现在，我们已经了解了HTTP协议的全部基础知识，那么什么是Web服务器呢，实际上，它就是一个软件，但是它已经封装了所有的HTTP协议层面的操作，我们无需关心如何使用HTTP协议通信，而是直接基于服务器软件进行开发，我们只需要关心我们的页面数据如何展示、前后端如何交互即可。 认识Tomcat服务器 Tomcat（汤姆猫）就是一个典型的Web应用服务器软件，通过运行Tomcat服务器，我们就可以快速部署我们的Web项目，并交由Tomcat进行管理，我们只需要直接通过浏览器访问我们的项目即可。 那么首先，我们需要进行一个简单的环境搭建，我们需要在Tomcat官网下载最新的Tomcat服务端程序：https://tomcat.apache.org/download-10.cgi（下载速度可能有点慢） 下载：64-bit Windows zip 下载完成后，解压，并放入桌面，接下来需要配置一下环境变量，打开高级系统设置，打开环境变量，添加一个新的系统变量，变量名称为JRE_HOME，填写JDK的安装目录+/jre，比如Zulujdk默认就是：C:\\Program Files\\Zulu\\zulu-8\\jre 设置完成后，我们进入tomcat文件夹bin目录下，并在当前位置打开CMD窗口，将startup.sh拖入窗口按回车运行，如果环境变量配置有误，会提示，若没问题，服务器则正常启动。 如果出现乱码，说明编码格式配置有问题，我们修改一下服务器的配置文件，打开conf文件夹，找到logging.properties文件，这就是日志的配置文件（我们在前面已经给大家讲解过了）将ConsoleHandler的默认编码格式修改为GBK编码格式： 1java.util.logging.ConsoleHandler.encoding = GBK 现在重新启动服务器，就可以正常显示中文了。 服务器启动成功之后，不要关闭，我们打开浏览器，在浏览器中访问：http://localhost:8080/，Tomcat服务器默认是使用8080端口（可以在配置文件中修改），访问成功说明我们的Tomcat环境已经部署成功了。 整个Tomcat目录下，我们已经认识了bin目录（所有可执行文件，包括启动和关闭服务器的脚本）以及conf目录（服务器配置文件目录），那么我们接着来看其他的文件夹： lib目录：Tomcat服务端运行的一些依赖，不用关心。 logs目录：所有的日志信息都在这里。 temp目录：存放运行时产生的一些临时文件，不用关心。 work目录：工作目录，Tomcat会将jsp文件转换为java文件（我们后面会讲到，这里暂时不提及） webapp目录：所有的Web项目都在这里，每个文件夹都是一个Web应用程序： 我们发现，官方已经给我们预设了一些项目了，访问后默认使用的项目为ROOT项目，也就是我们默认打开的网站。 我们也可以访问example项目，只需要在后面填写路径即可：http://localhost:8080/examples/，或是docs项目（这个是Tomcat的一些文档）http://localhost:8080/docs/ Tomcat还自带管理页面，我们打开：http://localhost:8080/manager，提示需要用户名和密码，由于不知道是什么，我们先点击取消，页面中出现如下内容： You are not authorized to view this page. If you have not changed any configuration files, please examine the file conf/tomcat-users.xml in your installation. That file must contain the credentials to let you use this webapp. For example, to add the manager-gui role to a user named tomcat with a password of s3cret, add the following to the config file listed above. 12&lt;role rolename=\"manager-gui\"/&gt;&lt;user username=\"tomcat\" password=\"s3cret\" roles=\"manager-gui\"/&gt; Note that for Tomcat 7 onwards, the roles required to use the manager application were changed from the single manager role to the following four roles. You will need to assign the role(s) required for the functionality you wish to access. manager-gui - allows access to the HTML GUI and the status pages manager-script - allows access to the text interface and the status pages manager-jmx - allows access to the JMX proxy and the status pages manager-status - allows access to the status pages only The HTML interface is protected against CSRF but the text and JMX interfaces are not. To maintain the CSRF protection: Users with the manager-gui role should not be granted either the manager-script or manager-jmx roles. If the text or jmx interfaces are accessed through a browser (e.g. for testing since these interfaces are intended for tools not humans) then the browser must be closed afterwards to terminate the session. For more information - please see the Manager App How-To. 现在我们按照上面的提示，去配置文件中进行修改： 12&lt;role rolename=\"manager-gui\"/&gt;&lt;user username=\"admin\" password=\"admin\" roles=\"manager-gui\"/&gt; 现在再次打开管理页面，已经可以成功使用此用户进行登陆了。登录后，展示给我们的是一个图形化界面，我们可以快速预览当前服务器的一些信息，包括已经在运行的Web应用程序，甚至还可以查看当前的Web应用程序有没有出现内存泄露。 同样的，还有一个虚拟主机管理页面，用于一台主机搭建多个Web站点，一般情况下使用不到，这里就不做演示了。 我们可以将我们自己的项目也放到webapp文件夹中，这样就可以直接访问到了，我们在webapp目录下新建test文件夹，将我们之前编写的前端代码全部放入其中（包括html文件、js、css、icon等），重启服务器。 我们可以直接通过 http://localhost:8080/test/ 来进行访问。 使用Maven创建Web项目虽然我们已经可以在Tomcat上部署我们的前端页面了，但是依然只是一个静态页面（每次访问都是同样的样子），那么如何向服务器请求一个动态的页面呢（比如显示我们访问当前页面的时间）这时就需要我们编写一个Web应用程序来实现了，我们需要在用户向服务器发起页面请求时，进行一些处理，再将结果发送给用户的浏览器。 注意：这里需要使用终极版IDEA，如果你的还是社区版，就很难受了。 我们打开IDEA，新建一个项目，选择Java Enterprise（社区版没有此选项！）项目名称随便，项目模板选择Web应用程序，然后我们需要配置Web应用程序服务器，将我们的Tomcat服务器集成到IDEA中。配置很简单，首先点击新建，然后设置Tomcat主目录即可，配置完成后，点击下一步即可，依赖项使用默认即可，然后点击完成，之后IDEA会自动帮助我们创建Maven项目。 创建完成后，直接点击右上角即可运行此项目了，但是我们发现，有一个Servlet页面不生效。 需要注意的是，Tomcat10以上的版本比较新，Servlet API包名发生了一些变化，因此我们需要修改一下依赖： 123456&lt;dependency&gt; &lt;groupId&gt;jakarta.servlet&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet-api&lt;/artifactId&gt; &lt;version&gt;5.0.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 注意包名全部从javax改为jakarta，我们需要手动修改一下。 感兴趣的可以了解一下为什么名称被修改了： Eclipse基金会在2019年对 Java EE 标准的每个规范进行了重命名，阐明了每个规范在Jakarta EE平台未来的角色。 新的名称Jakarta EE是Java EE的第二次重命名。2006年5月，“J2EE”一词被弃用，并选择了Java EE这个名称。在YouTube还只是一家独立的公司的时候，数字2就就从名字中消失了，而且当时冥王星仍然被认为是一颗行星。同样，作为Java SE 5（2004）的一部分，数字2也从J2SE中删除了，那时谷歌还没有上市。 因为不能再使用javax名称空间，Jakarta EE提供了非常明显的分界线。 Jakarta 9（2019及以后）使用jakarta命名空间。 Java EE 5（2005）到Java EE 8（2017）使用javax命名空间。 Java EE 4使用javax命名空间。 我们可以将项目直接打包为war包（默认），打包好之后，放入webapp文件夹，就可以直接运行我们通过Java编写的Web应用程序了，访问路径为文件的名称。 Servlet前面我们已经完成了基本的环境搭建，那么现在我们就可以开始来了解我们的第一个重要类——Servlet。 它是Java EE的一个标准，大部分的Web服务器都支持此标准，包括Tomcat，就像之前的JDBC一样，由官方定义了一系列接口，而具体实现由我们来编写，最后交给Web服务器（如Tomcat）来运行我们编写的Servlet。 那么，它能做什么呢？我们可以通过实现Servlet来进行动态网页响应，使用Servlet，不再是直接由Tomcat服务器发送我们编写好的静态网页内容（HTML文件），而是由我们通过Java代码进行动态拼接的结果，它能够很好地实现动态网页的返回。 当然，Servlet并不是专用于HTTP协议通信，也可以用于其他的通信，但是一般都是用于HTTP。 创建Servlet那么如何创建一个Servlet呢，非常简单，我们只需要实现Servlet类即可，并添加注解@WebServlet来进行注册。 1234@WebServlet(\"/test\")public class TestServlet implements Servlet { ...实现接口方法} 我们现在就可以去访问一下我们的页面：http://localhost:8080/test/test 我们发现，直接访问此页面是没有任何内容的，这是因为我们还没有为该请求方法编写实现，这里先不做讲解，后面我们会对浏览器的请求处理做详细的介绍。 除了直接编写一个类，我们也可以在web.xml中进行注册，现将类上@WebServlet的注解去掉： 12345678&lt;servlet&gt; &lt;servlet-name&gt;test&lt;/servlet-name&gt; &lt;servlet-class&gt;com.example.webtest.TestServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;test&lt;/servlet-name&gt; &lt;url-pattern&gt;/test&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 这样的方式也能注册Servlet，但是显然直接使用注解更加方便，因此之后我们一律使用注解进行开发。只有比较新的版本才支持此注解，老的版本是不支持的哦。 实际上，Tomcat服务器会为我们提供一些默认的Servlet，也就是说在服务器启动后，即使我们什么都不编写，Tomcat也自带了几个默认的Servlet，他们编写在conf目录下的web.xml中： 12345678910111213&lt;!-- The mapping for the default servlet --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- The mappings for the JSP servlet --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;jsp&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 我们发现，默认的Servlet实际上可以帮助我们去访问一些静态资源，这也是为什么我们启动Tomcat服务器之后，能够直接访问webapp目录下的静态页面。 我们可以将之前编写的页面放入到webapp目录下，来测试一下是否能直接访问。 探究Servlet的生命周期我们已经了解了如何注册一个Servlet，那么我们接着来看看，一个Servlet是如何运行的。 首先我们需要了解，Servlet中的方法各自是在什么时候被调用的，我们先编写一个打印语句来看看： 123456789101112131415161718192021222324252627282930313233public class TestServlet implements Servlet { public TestServlet(){ System.out.println(\"我是构造方法！\"); } @Override public void init(ServletConfig servletConfig) throws ServletException { System.out.println(\"我是init\"); } @Override public ServletConfig getServletConfig() { System.out.println(\"我是getServletConfig\"); return null; } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(\"我是service\"); } @Override public String getServletInfo() { System.out.println(\"我是getServletInfo\"); return null; } @Override public void destroy() { System.out.println(\"我是destroy\"); }} 我们首先启动一次服务器，然后访问我们定义的页面，然后再关闭服务器，得到如下的顺序： 我是构造方法！我是init我是service我是service（出现两次是因为浏览器请求了2次，是因为有一次是请求favicon.ico，浏览器通病） 我是destroy 我们可以多次尝试去访问此页面，但是init和构造方法只会执行一次，而每次访问都会执行的是service方法，因此，一个Servlet的生命周期为： 首先执行构造方法完成 Servlet 初始化 Servlet 初始化后调用 init () 方法。 Servlet 调用 service() 方法来处理客户端的请求。 Servlet 销毁前调用 destroy() 方法。 最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。 现在我们发现，实际上在Web应用程序运行时，每当浏览器向服务器发起一个请求时，都会创建一个线程执行一次service方法，来让我们处理用户的请求，并将结果响应给用户。 我们发现service方法中，还有两个参数，ServletRequest和ServletResponse，实际上，用户发起的HTTP请求，就被Tomcat服务器封装为了一个ServletRequest对象，我们得到是其实是Tomcat服务器帮助我们创建的一个实现类，HTTP请求报文中的所有内容，都可以从ServletRequest对象中获取，同理，ServletResponse就是我们需要返回给浏览器的HTTP响应报文实体类封装。 那么我们来看看ServletRequest中有哪些内容，我们可以获取请求的一些信息： 123456789101112131415@Overridepublic void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { //首先将其转换为HttpServletRequest（继承自ServletRequest，一般是此接口实现） HttpServletRequest request = (HttpServletRequest) servletRequest; System.out.println(request.getProtocol()); //获取协议版本 System.out.println(request.getRemoteAddr()); //获取访问者的IP地址 System.out.println(request.getMethod()); //获取请求方法 //获取头部信息 Enumeration&lt;String&gt; enumeration = request.getHeaderNames(); while (enumeration.hasMoreElements()){ String name = enumeration.nextElement(); System.out.println(name + \": \" + request.getHeader(name)); }} 我们发现，整个HTTP请求报文中的所有内容，都可以通过HttpServletRequest对象来获取，当然，它的作用肯定不仅仅是获取头部信息，我们还可以使用它来完成更多操作，后面会一一讲解。 那么我们再来看看ServletResponse，这个是服务端的响应内容，我们可以在这里填写我们想要发送给浏览器显示的内容： 1234567//转换为HttpServletResponse（同上）HttpServletResponse response = (HttpServletResponse) servletResponse;//设定内容类型以及编码格式（普通HTML文本使用text/html，之后会讲解文件传输）response.setHeader(\"Content-type\", \"text/html;charset=UTF-8\");//获取Writer直接写入内容response.getWriter().write(\"我是响应内容！\");//所有内容写入完成之后，再发送给浏览器 现在我们在浏览器中打开此页面，就能够收到服务器发来的响应内容了。其中，响应头部分，是由Tomcat帮助我们生成的一个默认响应头。 因此，实际上整个流程就已经很清晰明了了。 解读和使用HttpServlet前面我们已经学习了如何创建、注册和使用Servlet，那么我们继续来深入学习Servlet接口的一些实现类。 首先Servlet有一个直接实现抽象类GenericServlet，那么我们来看看此类做了什么事情。 我们发现，这个类完善了配置文件读取和Servlet信息相关的的操作，但是依然没有去实现service方法，因此此类仅仅是用于完善一个Servlet的基本操作，那么我们接着来看HttpServlet，它是遵循HTTP协议的一种Servlet，继承自GenericServlet，它根据HTTP协议的规则，完善了service方法。 在阅读了HttpServlet源码之后，我们发现，其实我们只需要继承HttpServlet来编写我们的Servlet就可以了，并且它已经帮助我们提前实现了一些操作，这样就会给我们省去很多的时间。 12345678910@Log@WebServlet(\"/test\")public class TestServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.setContentType(\"text/html;charset=UTF-8\"); resp.getWriter().write(\"&lt;h1&gt;恭喜你解锁了全新玩法&lt;/h1&gt;\"); }} 现在，我们只需要重写对应的请求方式，就可以快速完成Servlet的编写。 @WebServlet注解详解我们接着来看WebServlet注解，我们前面已经得知，可以直接使用此注解来快速注册一个Servlet，那么我们来想细看看此注解还有什么其他的玩法。 首先name属性就是Servlet名称，而urlPatterns和value实际上是同样功能，就是代表当前Servlet的访问路径，它不仅仅可以是一个固定值，还可以进行通配符匹配： 1@WebServlet(\"/test/*\") 上面的路径表示，所有匹配/test/随便什么的路径名称，都可以访问此Servlet，我们可以在浏览器中尝试一下。 也可以进行某个扩展名称的匹配： 1@WebServlet(\"*.js\") 这样的话，获取任何以js结尾的文件，都会由我们自己定义的Servlet处理。 那么如果我们的路径为/呢？ 1@WebServlet(\"/\") 此路径和Tomcat默认为我们提供的Servlet冲突，会直接替换掉默认的，而使用我们的，此路径的意思为，如果没有找到匹配当前访问路径的Servlet，那么久会使用此Servlet进行处理。 我们还可以为一个Servlet配置多个访问路径： 1@WebServlet({\"/test1\", \"/test2\"}) 我们接着来看loadOnStartup属性，此属性决定了是否在Tomcat启动时就加载此Servlet，默认情况下，Servlet只有在被访问时才会加载，它的默认值为-1，表示不在启动时加载，我们可以将其修改为大于等于0的数，来开启启动时加载。并且数字的大小决定了此Servlet的启动优先级。 12345678910111213141516@Log@WebServlet(value = \"/test\", loadOnStartup = 1)public class TestServlet extends HttpServlet { @Override public void init() throws ServletException { super.init(); log.info(\"我被初始化了！\"); } @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.setContentType(\"text/html;charset=UTF-8\"); resp.getWriter().write(\"&lt;h1&gt;恭喜你解锁了全新玩法&lt;/h1&gt;\"); }} 其他内容都是Servlet的一些基本配置，这里就不详细讲解了。 使用POST请求完成登陆我们前面已经了解了如何使用Servlet来处理HTTP请求，那么现在，我们就结合前端，来实现一下登陆操作。 我们需要修改一下我们的Servlet，现在我们要让其能够接收一个POST请求： 12345678910@Log@WebServlet(\"/login\")public class LoginServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.getParameterMap().forEach((k, v) -&gt; { System.out.println(k + \": \" + Arrays.toString(v)); }); }} ParameterMap存储了我们发送的POST请求所携带的表单数据，我们可以直接将其遍历查看，浏览器发送了什么数据。 现在我们再来修改一下前端： 12345678910111213141516171819&lt;body&gt; &lt;h1&gt;登录到系统&lt;/h1&gt; &lt;form method=\"post\" action=\"login\"&gt; &lt;hr&gt; &lt;div&gt; &lt;label&gt; &lt;input type=\"text\" placeholder=\"用户名\" name=\"username\"&gt; &lt;/label&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt; &lt;input type=\"password\" placeholder=\"密码\" name=\"password\"&gt; &lt;/label&gt; &lt;/div&gt; &lt;div&gt; &lt;button&gt;登录&lt;/button&gt; &lt;/div&gt; &lt;/form&gt;&lt;/body&gt; 通过修改form标签的属性，现在我们点击登录按钮，会自动向后台发送一个POST请求，请求地址为当前地址+/login（注意不同路径的写法），也就是我们上面编写的Servlet路径。 运行服务器，测试后发现，在点击按钮后，确实向服务器发起了一个POST请求，并且携带了表单中文本框的数据。 现在，我们根据已有的基础，将其与数据库打通，我们进行一个真正的用户登录操作，首先修改一下Servlet的逻辑： 12345678910111213141516@Overrideprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //首先设置一下响应类型 resp.setContentType(\"text/html;charset=UTF-8\"); //获取POST请求携带的表单数据 Map&lt;String, String[]&gt; map = req.getParameterMap(); //判断表单是否完整 if(map.containsKey(\"username\") &amp;&amp; map.containsKey(\"password\")) { String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); //权限校验（待完善） }else { resp.getWriter().write(\"错误，您的表单数据不完整！\"); }} 接下来我们再去编写Mybatis的依赖和配置文件，创建一个表，用于存放我们用户的账号和密码。 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"${驱动类（含包名）}\"/&gt; &lt;property name=\"url\" value=\"${数据库连接URL}\"/&gt; &lt;property name=\"username\" value=\"${用户名}\"/&gt; &lt;property name=\"password\" value=\"${密码}\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.27&lt;/version&gt;&lt;/dependency&gt; 配置完成后，在我们的Servlet的init方法中编写Mybatis初始化代码，因为它只需要初始化一次。 123456SqlSessionFactory factory;@SneakyThrows@Overridepublic void init() throws ServletException { factory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsReader(\"mybatis-config.xml\"));} 现在我们创建一个实体类以及Mapper来进行用户信息查询： 12345@Datapublic class User { String username; String password;} 12345public interface UserMapper { @Select(\"select * from users where username = #{username} and password = #{password}\") User getUser(@Param(\"username\") String username, @Param(\"password\") String password);} 123&lt;mappers&gt; &lt;mapper class=\"com.example.dao.UserMapper\"/&gt;&lt;/mappers&gt; 好了，现在完事具备，只欠东风了，我们来完善一下登陆验证逻辑： 1234567891011//登陆校验（待完善）try (SqlSession sqlSession = factory.openSession(true)){ UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUser(username, password); //判断用户是否登陆成功，若查询到信息则表示存在此用户 if(user != null){ resp.getWriter().write(\"登陆成功！\"); }else { resp.getWriter().write(\"登陆失败，请验证您的用户名或密码！\"); }} 现在再去浏览器上进行测试吧！ 注册界面其实是同理的，这里就不多做讲解了。 上传和下载文件首先我们来看看比较简单的下载文件，首先将我们的icon.png放入到resource文件夹中，接着我们编写一个Servlet用于处理文件下载： 1234567891011@WebServlet(\"/file\")public class FileServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.setContentType(\"image/png\"); OutputStream outputStream = resp.getOutputStream(); InputStream inputStream = Resources.getResourceAsStream(\"icon.png\"); }} 为了更加快速地编写IO代码，我们可以引入一个工具库： 12345&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt; 使用此类库可以快速完成IO操作： 12345resp.setContentType(\"image/png\");OutputStream outputStream = resp.getOutputStream();InputStream inputStream = Resources.getResourceAsStream(\"icon.png\");//直接使用copy方法完成转换IOUtils.copy(inputStream, outputStream); 现在我们在前端页面添加一个链接，用于下载此文件： 12&lt;hr&gt;&lt;a href=\"file\" download=\"icon.png\"&gt;点我下载高清资源&lt;/a&gt; 下载文件搞定，那么如何上传一个文件呢？ 首先我们编写前端部分： 12345678&lt;form method=\"post\" action=\"file\" enctype=\"multipart/form-data\"&gt; &lt;div&gt; &lt;input type=\"file\" name=\"test-file\"&gt; &lt;/div&gt; &lt;div&gt; &lt;button&gt;上传文件&lt;/button&gt; &lt;/div&gt;&lt;/form&gt; 注意必须添加enctype=\"multipart/form-data\"，来表示此表单用于文件传输。 现在我们来修改一下Servlet代码： 1234567891011121314@MultipartConfig@WebServlet(\"/file\")public class FileServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { try(FileOutputStream stream = new FileOutputStream(\"/Users/nagocoler/Documents/IdeaProjects/WebTest/test.png\")){ Part part = req.getPart(\"test-file\"); IOUtils.copy(part.getInputStream(), stream); resp.setContentType(\"text/html;charset=UTF-8\"); resp.getWriter().write(\"文件上传成功！\"); } }} 注意，必须添加@MultipartConfig注解来表示此Servlet用于处理文件上传请求。 现在我们再运行服务器，并将我们刚才下载的文件又上传给服务端。 使用XHR请求数据现在我们希望，网页中的部分内容，可以动态显示，比如网页上有一个时间，旁边有一个按钮，点击按钮就可以刷新当前时间。 这个时候就需要我们在网页展示时向后端发起请求了，并根据后端响应的结果，动态地更新页面中的内容，要实现此功能，就需要用到JavaScript来帮助我们，首先在js中编写我们的XHR请求，并在请求中完成动态更新： 12345678910function updateTime() { let xhr = new XMLHttpRequest(); xhr.onreadystatechange = function() { if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) { document.getElementById(\"time\").innerText = xhr.responseText } }; xhr.open('GET', 'time', true); xhr.send();} 接着修改一下前端页面，添加一个时间显示区域： 1234567&lt;hr&gt;&lt;div id=\"time\"&gt;&lt;/div&gt;&lt;br&gt;&lt;button onclick=\"updateTime()\"&gt;更新数据&lt;/button&gt;&lt;script&gt; updateTime()&lt;/script&gt; 最后创建一个Servlet用于处理时间更新请求： 1234567891011@WebServlet(\"/time\")public class TimeServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); String date = dateFormat.format(new Date()); resp.setContentType(\"text/html;charset=UTF-8\"); resp.getWriter().write(date); }} 现在点击按钮就可以更新了。 GET请求也能传递参数，这里做一下演示。 重定向与请求转发当我们希望用户登录完成之后，直接跳转到网站的首页，那么这个时候，我们就可以使用重定向来完成。当浏览器收到一个重定向的响应时，会按照重定向响应给出的地址，再次向此地址发出请求。 实现重定向很简单，只需要调用一个方法即可，我们修改一下登陆成功后执行的代码： 1resp.sendRedirect(\"time\"); 调用后，响应的状态码会被设置为302，并且响应头中添加了一个Location属性，此属性表示，需要重定向到哪一个网址。 现在，如果我们成功登陆，那么服务器会发送给我们一个重定向响应，这时，我们的浏览器会去重新请求另一个网址。这样，我们在登陆成功之后，就可以直接帮助用户跳转到用户首页了。 那么我们接着来看请求转发，请求转发其实是一种服务器内部的跳转机制，我们知道，重定向会使得浏览器去重新请求一个页面，而请求转发则是服务器内部进行跳转，它的目的是，直接将本次请求转发给其他Servlet进行处理，并由其他Servlet来返回结果，因此它是在进行内部的转发。 1req.getRequestDispatcher(\"/time\").forward(req, resp); 现在，在登陆成功的时候，我们将请求转发给处理时间的Servlet，注意这里的路径规则和之前的不同，我们需要填写Servlet上指明的路径，并且请求转发只能转发到此应用程序内部的Servlet，不能转发给其他站点或是其他Web应用程序。 现在再次进行登陆操作，我们发现，返回结果为一个405页面，证明了，我们的请求现在是被另一个Servlet进行处理，并且请求的信息全部被转交给另一个Servlet，由于此Servlet不支持POST请求，因此返回405状态码。 那么也就是说，该请求包括请求参数也一起被传递了，那么我们可以尝试获取以下POST请求的参数。 现在我们给此Servlet添加POST请求处理，直接转交给Get请求处理： 1234@Overrideprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req, resp);} 再次访问，成功得到结果，但是我们发现，浏览器只发起了一次请求，并没有再次请求新的URL，也就是说，这一次请求直接返回了请求转发后的处理结果。 那么，请求转发有什么好处呢？它可以携带数据！ 12req.setAttribute(\"test\", \"我是请求转发前的数据\");req.getRequestDispatcher(\"/time\").forward(req, resp); 1System.out.println(req.getAttribute(\"test\")); 通过setAttribute方法来给当前请求添加一个附加数据，在请求转发后，我们可以直接获取到该数据。 重定向属于2次请求，因此无法使用这种方式来传递数据，那么，如何在重定向之间传递数据呢？我们可以使用即将要介绍的ServletContext对象。 最后总结，两者的区别为： 请求转发是一次请求，重定向是两次请求 请求转发地址栏不会发生改变， 重定向地址栏会发生改变 请求转发可以共享请求参数 ，重定向之后，就获取不了共享参数了 请求转发只能转发给内部的Servlet 了解ServletContext对象ServletContext全局唯一，它是属于整个Web应用程序的，我们可以通过getServletContext()来获取到此对象。 此对象也能设置附加值： 123ServletContext context = getServletContext();context.setAttribute(\"test\", \"我是重定向之前的数据\");resp.sendRedirect(\"time\"); 1System.out.println(getServletContext().getAttribute(\"test\")); 因为无论在哪里，无论什么时间，获取到的ServletContext始终是同一个对象，因此我们可以随时随地获取我们添加的属性。 它不仅仅可以用来进行数据传递，还可以做一些其他的事情，比如请求转发： 1context.getRequestDispatcher(\"/time\").forward(req, resp); 它还可以获取根目录下的资源文件（注意是webapp根目录下的，不是resource中的资源） 初始化参数初始化参数类似于初始化配置需要的一些值，比如我们的数据库连接相关信息，就可以通过初始化参数来给予Servlet，或是一些其他的配置项，也可以使用初始化参数来实现。 我们可以给一个Servlet添加一些初始化参数： 123@WebServlet(value = \"/login\", initParams = { @WebInitParam(name = \"test\", value = \"我是一个默认的初始化参数\")}) 它也是以键值对形式保存的，我们可以直接通过Servlet的getInitParameter方法获取： 1System.out.println(getInitParameter(\"test\")); 但是，这里的初始化参数仅仅是针对于此Servlet，我们也可以定义全局初始化参数，只需要在web.xml编写即可： 1234&lt;context-param&gt; &lt;param-name&gt;lbwnb&lt;/param-name&gt; &lt;param-value&gt;我是全局初始化参数&lt;/param-value&gt;&lt;/context-param&gt; 我们需要使用ServletContext来读取全局初始化参数： 12ServletContext context = getServletContext();System.out.println(context.getInitParameter(\"lbwnb\")); 有关ServletContext其他的内容，我们需要完成后面内容的学习，才能理解。 Cookie什么是Cookie？不是曲奇，它可以在浏览器中保存一些信息，并且在下次请求时，请求头中会携带这些信息。 我们可以编写一个测试用例来看看： 123Cookie cookie = new Cookie(\"test\", \"yyds\");resp.addCookie(cookie);resp.sendRedirect(\"time\"); 123for (Cookie cookie : req.getCookies()) { System.out.println(cookie.getName() + \": \" + cookie.getValue());} 我们可以观察一下，在HttpServletResponse中添加Cookie之后，浏览器的响应头中会包含一个Set-Cookie属性，同时，在重定向之后，我们的请求头中，会携带此Cookie作为一个属性，同时，我们可以直接通过HttpServletRequest来快速获取有哪些Cookie信息。 还有这么神奇的事情吗？那么我们来看看，一个Cookie包含哪些信息： name - Cookie的名称，Cookie一旦创建，名称便不可更改 value - Cookie的值，如果值为Unicode字符，需要为字符编码。如果为二进制数据，则需要使用BASE64编码 maxAge - Cookie失效的时间，单位秒。如果为正数，则该Cookie在maxAge秒后失效。如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。如果为0，表示删除该Cookie。默认为-1。 secure - 该Cookie是否仅被使用安全协议传输。安全协议。安全协议有HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false。 path - Cookie的使用路径。如果设置为“/sessionWeb/”，则只有contextPath为“/sessionWeb”的程序可以访问该Cookie。如果设置为“/”，则本域名下contextPath都可以访问该Cookie。注意最后一个字符必须为“/”。 domain - 可以访问该Cookie的域名。如果设置为“.google.com”，则所有以“google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”。 comment - 该Cookie的用处说明，浏览器显示Cookie信息的时候显示该说明。 version - Cookie使用的版本号。0表示遵循Netscape的Cookie规范，1表示遵循W3C的RFC 2109规范 我们发现，最关键的其实是name、value、maxAge、domain属性。 那么我们来尝试修改一下maxAge来看看失效时间： 1cookie.setMaxAge(20); 设定为20秒，我们可以直接看到，响应头为我们设定了20秒的过期时间。20秒内访问都会携带此Cookie，而超过20秒，Cookie消失。 既然了解了Cookie的作用，我们就可以通过使用Cookie来实现记住我功能，我们可以将用户名和密码全部保存在Cookie中，如果访问我们的首页时携带了这些Cookie，那么我们就可以直接为用户进行登陆，如果登陆成功则直接跳转到首页，如果登陆失败，则清理浏览器中的Cookie。 那么首先，我们先在前端页面的表单中添加一个勾选框： 123456&lt;div&gt; &lt;label&gt; &lt;input type=\"checkbox\" placeholder=\"记住我\" name=\"remember-me\"&gt; 记住我 &lt;/label&gt;&lt;/div&gt; 接着，我们在登陆成功时进行判断，如果用户勾选了记住我，那么就讲Cookie存储到本地： 12345678if(map.containsKey(\"remember-me\")){ //若勾选了勾选框，那么会此表单信息 Cookie cookie_username = new Cookie(\"username\", username); cookie_username.setMaxAge(30); Cookie cookie_password = new Cookie(\"password\", password); cookie_password.setMaxAge(30); resp.addCookie(cookie_username); resp.addCookie(cookie_password);} 然后，我们修改一下默认的请求地址，现在一律通过http://localhost:8080/yyds/login进行登陆，那么我们需要添加GET请求的相关处理： 123456789101112131415161718192021222324@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { Cookie[] cookies = req.getCookies(); if(cookies != null){ String username = null; String password = null; for (Cookie cookie : cookies) { if(cookie.getName().equals(\"username\")) username = cookie.getValue(); if(cookie.getName().equals(\"password\")) password = cookie.getValue(); } if(username != null &amp;&amp; password != null){ //登陆校验 try (SqlSession sqlSession = factory.openSession(true)){ UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUser(username, password); if(user != null){ resp.sendRedirect(\"time\"); return; //直接返回 } } } } req.getRequestDispatcher(\"/\").forward(req, resp); //正常情况还是转发给默认的Servlet帮我们返回静态页面} 现在，30秒内都不需要登陆，访问登陆页面后，会直接跳转到time页面。 现在已经离我们理想的页面越来越接近了，但是仍然有一个问题，就是我们的首页，无论是否登陆，所有人都可以访问，那么，如何才可以实现只有登陆之后才能访问呢？这就需要用到Session了。 Session由于HTTP是无连接的，那么如何能够辨别当前的请求是来自哪个用户发起的呢？Session就是用来处理这种问题的，每个用户的会话都会有一个自己的Session对象，来自同一个浏览器的所有请求，就属于同一个会话。 但是HTTP协议是无连接的呀，那Session是如何做到辨别是否来自同一个浏览器呢？Session实际上是基于Cookie实现的，前面我们了解了Cookie，我们知道，服务端可以将Cookie保存到浏览器，当浏览器下次访问时，就会附带这些Cookie信息。 Session也利用了这一点，它会给浏览器设定一个叫做JSESSIONID的Cookie，值是一个随机的排列组合，而此Cookie就对应了你属于哪一个对话，只要我们的浏览器携带此Cookie访问服务器，服务器就会通过Cookie的值进行辨别，得到对应的Session对象，因此，这样就可以追踪到底是哪一个浏览器在访问服务器。 那么现在，我们在用户登录成功之后，将用户对象添加到Session中，只要是此用户发起的请求，我们都可以从HttpSession中读取到存储在会话中的数据： 12HttpSession session = req.getSession();session.setAttribute(\"user\", user); 同时，如果用户没有登录就去访问首页，那么我们将发送一个重定向请求，告诉用户，需要先进行登录才可以访问： 123456HttpSession session = req.getSession();User user = (User) session.getAttribute(\"user\");if(user == null) { resp.sendRedirect(\"login\"); return;} 在访问的过程中，注意观察Cookie变化。 Session并不是永远都存在的，它有着自己的过期时间，默认时间为30分钟，若超过此时间，Session将丢失，我们可以在配置文件中修改过期时间： 123&lt;session-config&gt; &lt;session-timeout&gt;1&lt;/session-timeout&gt;&lt;/session-config&gt; 我们也可以在代码中使用invalidate方法来使Session立即失效： 1session.invalidate(); 现在，通过Session，我们就可以更好地控制用户对于资源的访问，只有完成登陆的用户才有资格访问首页。 Filter有了Session之后，我们就可以很好地控制用户的登陆验证了，只有授权的用户，才可以访问一些页面，但是我们需要一个一个去进行配置，还是太过复杂，能否一次性地过滤掉没有登录验证的用户呢？ 过滤器相当于在所有访问前加了一堵墙，来自浏览器的所有访问请求都会首先经过过滤器，只有过滤器允许通过的请求，才可以顺利地到达对应的Servlet，而过滤器不允许的通过的请求，我们可以自由地进行控制是否进行重定向或是请求转发。并且过滤器可以添加很多个，就相当于添加了很多堵墙，我们的请求只有穿过层层阻碍，才能与Servlet相拥，像极了爱情。 添加一个过滤器非常简单，只需要实现Filter接口，并添加@WebFilter注解即可： 1234567@WebFilter(\"/*\") //路径的匹配规则和Servlet一致，这里表示匹配所有请求public class TestFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { }} 这样我们就成功地添加了一个过滤器，那么添加一句打印语句看看，是否所有的请求都会经过此过滤器： 12HttpServletRequest request = (HttpServletRequest) servletRequest;System.out.println(request.getRequestURL()); 我们发现，现在我们发起的所有请求，一律需要经过此过滤器，并且所有的请求都没有任何的响应内容。 那么如何让请求可以顺利地到达对应的Servlet，也就是说怎么让这个请求顺利通过呢？我们只需要在最后添加一句： 1filterChain.doFilter(servletRequest, servletResponse); 那么这行代码是什么意思呢？ 由于我们整个应用程序可能存在多个过滤器，那么这行代码的意思实际上是将此请求继续传递给下一个过滤器，当没有下一个过滤器时，才会到达对应的Servlet进行处理，我们可以再来创建一个过滤器看看效果： 12345678@WebFilter(\"/*\")public class TestFilter2 implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\"我是2号过滤器\"); filterChain.doFilter(servletRequest, servletResponse); }} 由于过滤器的过滤顺序是按照类名的自然排序进行的，因此我们将第一个过滤器命名进行调整。 我们发现，在经过第一个过滤器之后，会继续前往第二个过滤器，只有两个过滤器全部经过之后，才会到达我们的Servlet中。 实际上，当doFilter方法调用时，就会一直向下直到Servlet，在Servlet处理完成之后，又依次返回到最前面的Filter，类似于递归的结构，我们添加几个输出语句来判断一下： 123456@Overridepublic void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\"我是2号过滤器\"); filterChain.doFilter(servletRequest, servletResponse); System.out.println(\"我是2号过滤器，处理后\");} 123456@Overridepublic void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\"我是1号过滤器\"); filterChain.doFilter(servletRequest, servletResponse); System.out.println(\"我是1号过滤器，处理后\");} 最后验证我们的结论。 同Servlet一样，Filter也有对应的HttpFilter专用类，它针对HTTP请求进行了专门处理，因此我们可以直接使用HttpFilter来编写： 123456789101112131415161718public abstract class HttpFilter extends GenericFilter { private static final long serialVersionUID = 7478463438252262094L; public HttpFilter() { } public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { if (req instanceof HttpServletRequest &amp;&amp; res instanceof HttpServletResponse) { this.doFilter((HttpServletRequest)req, (HttpServletResponse)res, chain); } else { throw new ServletException(\"non-HTTP request or response\"); } } protected void doFilter(HttpServletRequest req, HttpServletResponse res, FilterChain chain) throws IOException, ServletException { chain.doFilter(req, res); }} 那么现在，我们就可以给我们的应用程序添加一个过滤器，用户在未登录情况下，只允许静态资源和登陆页面请求通过，登陆之后畅行无阻： 12345678910111213141516171819@WebFilter(\"/*\")public class MainFilter extends HttpFilter { @Override protected void doFilter(HttpServletRequest req, HttpServletResponse res, FilterChain chain) throws IOException, ServletException { String url = req.getRequestURL().toString(); //判断是否为静态资源 if(!url.endsWith(\".js\") &amp;&amp; !url.endsWith(\".css\") &amp;&amp; !url.endsWith(\".png\")){ HttpSession session = req.getSession(); User user = (User) session.getAttribute(\"user\"); //判断是否未登陆 if(user == null &amp;&amp; !url.endsWith(\"login\")){ res.sendRedirect(\"login\"); return; } } //交给过滤链处理 chain.doFilter(req, res); }} 现在，我们的页面已经基本完善为我们想要的样子了。 当然，可能跟着教程编写的项目比较乱，大家可以自己花费一点时间来重新编写一个Web应用程序，加深对之前讲解知识的理解。我们也会在之后安排一个编程实战进行深化练习。 Listener监听器并不是我们学习的重点内容，那么什么是监听器呢？ 如果我们希望，在应用程序加载的时候，或是Session创建的时候，亦或是在Request对象创建的时候进行一些操作，那么这个时候，我们就可以使用监听器来实现。 默认为我们提供了很多类型的监听器，我们这里就演示一下监听Session的创建即可： 1234567@WebListenerpublic class TestListener implements HttpSessionListener { @Override public void sessionCreated(HttpSessionEvent se) { System.out.println(\"有一个Session被创建了\"); }} 有关监听器相关内容，了解即可。 了解JSP页面与加载规则前面我们已经完成了整个Web应用程序生命周期中所有内容的学习，我们已经完全了解，如何编写一个Web应用程序，并放在Tomcat上部署运行，以及如何控制浏览器发来的请求，通过Session+Filter实现用户登陆验证，通过Cookie实现自动登陆等操作。到目前为止，我们已经具备编写一个完整Web网站的能力。 在之前的教程中，我们的前端静态页面并没有与后端相结合，我们前端页面所需的数据全部需要单独向后端发起请求获取，并动态进行内容填充，这是一种典型的前后端分离写法，前端只负责要数据和显示数据，后端只负责处理数据和提供数据，这也是现在更流行的一种写法，让前端开发者和后端开发者各尽其责，更加专一，这才是我们所希望的开发模式。 JSP并不是我们需要重点学习的内容，因为它已经过时了，使用JSP会导致前后端严重耦合，因此这里只做了解即可。 JSP其实就是一种模板引擎，那么何谓模板引擎呢？顾名思义，它就是一个模板，而模板需要我们填入数据，才可以变成一个页面，也就是说，我们可以直接在前端页面中直接填写数据，填写后生成一个最终的HTML页面返回给前端。 首先我们来创建一个新的项目，项目创建成功后，删除Java目录下的内容，只留下默认创建的jsp文件，我们发现，在webapp目录中，存在一个index.jsp文件，现在我们直接运行项目，会直接访问这个JSP页面。 12345678910111213&lt;%@ page contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;JSP - Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;&lt;%= \"Hello World!\" %&gt;&lt;/h1&gt;&lt;br/&gt;&lt;a href=\"hello-servlet\"&gt;Hello Servlet&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 但是我们并没有编写对应的Servlet来解析啊，那么为什么这个JSP页面会被加载呢？ 实际上，我们一开始提到的两个Tomcat默认的Servlet中，一个是用于请求静态资源，还有一个就是用于处理jsp的： 123456&lt;!-- The mappings for the JSP servlet --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;jsp&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 那么，JSP和普通HTML页面有什么区别呢，我们发现它的语法和普通HTML页面几乎一致，我们可以直接在JSP中编写Java代码，并在页面加载的时候执行，我们随便找个地方插入： 123&lt;% System.out.println(\"JSP页面被加载\");%&gt; 我们发现，请求一次页面，页面就会加载一次，并执行我们填写的Java代码。也就是说，我们可以直接在此页面中执行Java代码来填充我们的数据，这样我们的页面就变成了一个动态页面，使用&lt;%= %&gt;来填写一个值： 1&lt;h1&gt;&lt;%= new Date() %&gt;&lt;/h1&gt; 现在访问我们的网站，每次都会创建一个新的Date对象，因此每次访问获取的时间都不一样，我们的网站已经算是一个动态的网站的了。 虽然这样在一定程度上上为我们提供了便利，但是这样的写法相当于整个页面既要编写前端代码，也要编写后端代码，随着项目的扩大，整个页面会显得难以阅读，并且现在都是前后端开发人员职责非常明确的，如果要编写JSP页面，那就必须要招一个既会前端也会后端的程序员，这样显然会导致不必要的开销。 那么我们来研究一下，为什么JSP页面能够在加载的时候执行Java代码呢？ 首先我们将此项目打包，并在Tomcat服务端中运行，生成了一个文件夹并且可以正常访问。 我们现在看到work目录，我们发现这个里面多了一个index_jsp.java和index_jsp.class，那么这些东西是干嘛的呢，我们来反编译一下就啥都知道了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase //继承自HttpServlet implements org.apache.jasper.runtime.JspSourceDependent, org.apache.jasper.runtime.JspSourceImports { ... public void _jspService(final jakarta.servlet.http.HttpServletRequest request, final jakarta.servlet.http.HttpServletResponse response) throws java.io.IOException, jakarta.servlet.ServletException { if (!jakarta.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) { final java.lang.String _jspx_method = request.getMethod(); if (\"OPTIONS\".equals(_jspx_method)) { response.setHeader(\"Allow\",\"GET, HEAD, POST, OPTIONS\"); return; } if (!\"GET\".equals(_jspx_method) &amp;&amp; !\"POST\".equals(_jspx_method) &amp;&amp; !\"HEAD\".equals(_jspx_method)) { response.setHeader(\"Allow\",\"GET, HEAD, POST, OPTIONS\"); response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, \"JSP 只允许 GET、POST 或 HEAD。Jasper 还允许 OPTIONS\"); return; } } final jakarta.servlet.jsp.PageContext pageContext; jakarta.servlet.http.HttpSession session = null; final jakarta.servlet.ServletContext application; final jakarta.servlet.ServletConfig config; jakarta.servlet.jsp.JspWriter out = null; final java.lang.Object page = this; jakarta.servlet.jsp.JspWriter _jspx_out = null; jakarta.servlet.jsp.PageContext _jspx_page_context = null; try { response.setContentType(\"text/html; charset=UTF-8\"); pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true); _jspx_page_context = pageContext; application = pageContext.getServletContext(); config = pageContext.getServletConfig(); session = pageContext.getSession(); out = pageContext.getOut(); _jspx_out = out; out.write(\"\\n\"); out.write(\"\\n\"); out.write(\"&lt;!DOCTYPE html&gt;\\n\"); out.write(\"&lt;html&gt;\\n\"); out.write(\"&lt;head&gt;\\n\"); out.write(\" &lt;title&gt;JSP - Hello World&lt;/title&gt;\\n\"); out.write(\"&lt;/head&gt;\\n\"); out.write(\"&lt;body&gt;\\n\"); out.write(\"&lt;h1&gt;\"); out.print( new Date() ); out.write(\"&lt;/h1&gt;\\n\"); System.out.println(\"JSP页面被加载\"); out.write(\"\\n\"); out.write(\"&lt;br/&gt;\\n\"); out.write(\"&lt;a href=\\\"hello-servlet\\\"&gt;Hello Servlet&lt;/a&gt;\\n\"); out.write(\"&lt;/body&gt;\\n\"); out.write(\"&lt;/html&gt;\"); } catch (java.lang.Throwable t) { if (!(t instanceof jakarta.servlet.jsp.SkipPageException)){ out = _jspx_out; if (out != null &amp;&amp; out.getBufferSize() != 0) try { if (response.isCommitted()) { out.flush(); } else { out.clearBuffer(); } } catch (java.io.IOException e) {} if (_jspx_page_context != null) _jspx_page_context.handlePageException(t); else throw new ServletException(t); } } finally { _jspxFactory.releasePageContext(_jspx_page_context); } }} 我们发现，它是继承自HttpJspBase类，我们可以反编译一下jasper.jar（它在tomcat的lib目录中）来看看: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package org.apache.jasper.runtime;import jakarta.servlet.ServletConfig;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import jakarta.servlet.jsp.HttpJspPage;import java.io.IOException;import org.apache.jasper.compiler.Localizer;public abstract class HttpJspBase extends HttpServlet implements HttpJspPage { private static final long serialVersionUID = 1L; protected HttpJspBase() { } public final void init(ServletConfig config) throws ServletException { super.init(config); this.jspInit(); this._jspInit(); } public String getServletInfo() { return Localizer.getMessage(\"jsp.engine.info\", new Object[]{\"3.0\"}); } public final void destroy() { this.jspDestroy(); this._jspDestroy(); } public final void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this._jspService(request, response); } public void jspInit() { } public void _jspInit() { } public void jspDestroy() { } protected void _jspDestroy() { } public abstract void _jspService(HttpServletRequest var1, HttpServletResponse var2) throws ServletException, IOException;} 实际上，Tomcat在加载JSP页面时，会将其动态转换为一个java类并编译为class进行加载，而生成的Java类，正是一个Servlet的子类，而页面的内容全部被编译为输出字符串，这便是JSP的加载原理，因此，JSP本质上依然是一个Servlet！ 如果同学们感兴趣的话，可以查阅一下其他相关的教程，本教程不再讲解此技术。 使用Thymeleaf模板引擎虽然JSP为我们带来了便捷，但是其缺点也是显而易见的，那么有没有一种既能实现模板，又能兼顾前后端分离的模板引擎呢？ Thymeleaf（百里香叶）是一个适用于Web和独立环境的现代化服务器端Java模板引擎，官方文档：https://www.thymeleaf.org/documentation.html。 那么它和JSP相比，好在哪里呢，我们来看官网给出的例子： 1234567891011121314&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th th:text=\"#{msgs.headers.name}\"&gt;Name&lt;/th&gt; &lt;th th:text=\"#{msgs.headers.price}\"&gt;Price&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr th:each=\"prod: ${allProducts}\"&gt; &lt;td th:text=\"${prod.name}\"&gt;Oranges&lt;/td&gt; &lt;td th:text=\"${#numbers.formatDecimal(prod.price, 1, 2)}\"&gt;0.99&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 我们可以在前端页面中填写占位符，而这些占位符的实际值则由后端进行提供，这样，我们就不用再像JSP那样前后端都写在一起了。 那么我们来创建一个例子感受一下，首先还是新建一个项目，注意，在创建时，勾选Thymeleaf依赖。 首先编写一个前端页面，名称为test.html，注意，是放在resource目录下，在html标签内部添加xmlns:th=\"http://www.thymeleaf.org\"引入Thymeleaf定义的标签属性： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div th:text=\"${title}\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 接着我们编写一个Servlet作为默认页面： 123456789101112131415161718@WebServlet(\"/index\")public class HelloServlet extends HttpServlet { TemplateEngine engine; @Override public void init() throws ServletException { engine = new TemplateEngine(); ClassLoaderTemplateResolver r = new ClassLoaderTemplateResolver(); engine.setTemplateResolver(r); } @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { Context context = new Context(); context.setVariable(\"title\", \"我是标题\"); engine.process(\"test.html\", context, resp.getWriter()); }} 我们发现，浏览器得到的页面，就是已经经过模板引擎解析好的页面，而我们的代码依然是后端处理数据，前端展示数据，因此使用Thymeleaf就能够使得当前Web应用程序的前后端划分更加清晰。 虽然Thymeleaf在一定程度上分离了前后端，但是其依然是在后台渲染HTML页面并发送给前端，并不是真正意义上的前后端分离。 Thymeleaf语法基础那么，如何使用Thymeleaf呢？ 首先我们看看后端部分，我们需要通过TemplateEngine对象来将模板文件渲染为最终的HTML页面： 12345678TemplateEngine engine;@Overridepublic void init() throws ServletException { engine = new TemplateEngine(); //设定模板解析器决定了从哪里获取模板文件，这里直接使用ClassLoaderTemplateResolver表示加载内部资源文件 ClassLoaderTemplateResolver r = new ClassLoaderTemplateResolver(); engine.setTemplateResolver(r);} 由于此对象只需要创建一次，之后就可以一直使用了。接着我们来看如何使用模板引擎进行解析： 12345678@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //创建上下文，上下文中包含了所有需要替换到模板中的内容 Context context = new Context(); context.setVariable(\"title\", \"&lt;h1&gt;我是标题&lt;/h1&gt;\"); //通过此方法就可以直接解析模板并返回响应 engine.process(\"test.html\", context, resp.getWriter());} 操作非常简单，只需要简单几步配置就可以实现模板的解析。接下来我们就可以在前端页面中通过上下文提供的内容，来将Java代码中的数据解析到前端页面。 接着我们来了解Thymeleaf如何为普通的标签添加内容，比如我们示例中编写的： 1&lt;div th:text=\"${title}\"&gt;&lt;/div&gt; 我们使用了th:text来为当前标签指定内部文本，注意任何内容都会变成普通文本，即使传入了一个HTML代码，如果我希望向内部添加一个HTML文本呢？我们可以使用th:utext属性： 1&lt;div th:utext=\"${title}\"&gt;&lt;/div&gt; 并且，传入的title属性，不仅仅只是一个字符串的值，而是一个字符串的引用，我们可以直接通过此引用调用相关的方法： 1&lt;div th:text=\"${title.toLowerCase()}\"&gt;&lt;/div&gt; 这样看来，Thymeleaf既能保持JSP为我们带来的便捷，也能兼顾前后端代码的界限划分。 除了替换文本，它还支持替换一个元素的任意属性，我们发现，th:能够拼接几乎所有的属性，一旦使用th:属性名称，那么属性的值就可以通过后端提供了，比如我们现在想替换一个图片的链接： 1234567@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { Context context = new Context(); context.setVariable(\"url\", \"http://n.sinaimg.cn/sinakd20121/600/w1920h1080/20210727/a700-adf8480ff24057e04527bdfea789e788.jpg\"); context.setVariable(\"alt\", \"图片就是加载不出来啊\"); engine.process(\"test.html\", context, resp.getWriter());} 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img width=\"700\" th:src=\"${url}\" th:alt=\"${alt}\"&gt;&lt;/body&gt;&lt;/html&gt; 现在访问我们的页面，就可以看到替换后的结果了。 Thymeleaf还可以进行一些算术运算，几乎Java中的运算它都可以支持： 1&lt;div th:text=\"${value % 2}\"&gt;&lt;/div&gt; 同样的，它还支持三元运算： 1&lt;div th:text=\"${value % 2 == 0 ? 'yyds' : 'lbwnb'}\"&gt;&lt;/div&gt; 多个属性也可以通过+进行拼接，就像Java中的字符串拼接一样，这里要注意一下，字符串不能直接写，要添加单引号： 1&lt;div th:text=\"${name}+' 我是文本 '+${value}\"&gt;&lt;/div&gt; Thymeleaf流程控制语法除了一些基本的操作，我们还可以使用Thymeleaf来处理流程控制语句，当然，不是直接编写Java代码的形式，而是添加一个属性即可。 首先我们来看if判断语句，如果if条件满足，则此标签留下，若if条件不满足，则此标签自动被移除： 123456@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { Context context = new Context(); context.setVariable(\"eval\", true); engine.process(\"test.html\", context, resp.getWriter());} 1&lt;div th:if=\"${eval}\"&gt;我是判断条件标签&lt;/div&gt; th:if会根据其中传入的值或是条件表达式的结果进行判断，只有满足的情况下，才会显示此标签，具体的判断规则如下： 如果值不是空的： 如果值是布尔值并且为true。 如果值是一个数字，并且是非零 如果值是一个字符，并且是非零 如果值是一个字符串，而不是“错误”、“关闭”或“否” 如果值不是布尔值、数字、字符或字符串。 如果值为空，th:if将计算为false th:if还有一个相反的属性th:unless，效果完全相反，这里就不演示了。 我们接着来看多分支条件判断，我们可以使用th:switch属性来实现： 12345&lt;div th:switch=\"${eval}\"&gt; &lt;div th:case=\"1\"&gt;我是1&lt;/div&gt; &lt;div th:case=\"2\"&gt;我是2&lt;/div&gt; &lt;div th:case=\"3\"&gt;我是3&lt;/div&gt;&lt;/div&gt; 只不过没有default属性，但是我们可以使用th:case=\"*\"来代替： 1&lt;div th:case=\"*\"&gt;我是Default&lt;/div&gt; 最后我们再来看看，它如何实现遍历，假如我们有一个存放书籍信息的List需要显示，那么如何快速生成一个列表呢？我们可以使用th:each来进行遍历操作： 123456@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { Context context = new Context(); context.setVariable(\"list\", Arrays.asList(\"伞兵一号的故事\", \"倒一杯卡布奇诺\", \"玩游戏要啸着玩\", \"十七张牌前的电脑屏幕\")); engine.process(\"test.html\", context, resp.getWriter());} 123&lt;ul&gt; &lt;li th:each=\"title : ${list}\" th:text=\"'《'+${title}+'》'\"&gt;&lt;/li&gt;&lt;/ul&gt; th:each中需要填写 “单个元素名称 : ${列表}”，这样，所有的列表项都可以使用遍历的单个元素，只要使用了th:each，都会被循环添加。因此最后生成的结果为： 123456&lt;ul&gt; &lt;li&gt;《伞兵一号的故事》&lt;/li&gt; &lt;li&gt;《倒一杯卡布奇诺》&lt;/li&gt; &lt;li&gt;《玩游戏要啸着玩》&lt;/li&gt; &lt;li&gt;《十七张牌前的电脑屏幕》&lt;/li&gt; &lt;/ul&gt; 我们还可以获取当前循环的迭代状态，只需要在最后添加iterStat即可，从中可以获取很多信息，比如当前的顺序： 123&lt;ul&gt; &lt;li th:each=\"title, iterStat : ${list}\" th:text=\"${iterStat.index}+'.《'+${title}+'》'\"&gt;&lt;/li&gt;&lt;/ul&gt; 状态变量在th:each属性中定义，并包含以下数据： 当前迭代索引，以0开头。这是index属性。 当前迭代索引，以1开头。这是count属性。 迭代变量中的元素总量。这是size属性。 每个迭代的迭代变量。这是current属性。 当前迭代是偶数还是奇数。这些是even/odd布尔属性。 当前迭代是否是第一个迭代。这是first布尔属性。 当前迭代是否是最后一个迭代。这是last布尔属性。 通过了解了流程控制语法，现在我们就可以很轻松地使用Thymeleaf来快速替换页面中的内容了。 Thymeleaf模板布局在某些网页中，我们会发现，整个网站的页面，除了中间部分的内容会随着我们的页面跳转而变化外，有些部分是一直保持一个状态的，比如打开小破站，我们翻动评论或是切换视频分P的时候，变化的仅仅是对应区域的内容，实际上，其他地方的内容会无论内部页面如何跳转，都不会改变。 Thymeleaf就可以轻松实现这样的操作，我们只需要将不会改变的地方设定为模板布局，并在不同的页面中插入这些模板布局，就无需每个页面都去编写同样的内容了。现在我们来创建两个页面： 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"head\"&gt; &lt;div&gt; &lt;h1&gt;我是标题内容，每个页面都有&lt;/h1&gt; &lt;/div&gt; &lt;hr&gt; &lt;/div&gt; &lt;div class=\"body\"&gt; &lt;ul&gt; &lt;li th:each=\"title, iterStat : ${list}\" th:text=\"${iterStat.index}+'.《'+${title}+'》'\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"head\"&gt; &lt;div&gt; &lt;h1&gt;我是标题内容，每个页面都有&lt;/h1&gt; &lt;/div&gt; &lt;hr&gt; &lt;/div&gt; &lt;div class=\"body\"&gt; &lt;div&gt;这个页面的样子是这样的&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 接着将模板引擎写成工具类的形式： 12345678910111213public class ThymeleafUtil { private static final TemplateEngine engine; static { engine = new TemplateEngine(); ClassLoaderTemplateResolver r = new ClassLoaderTemplateResolver(); engine.setTemplateResolver(r); } public static TemplateEngine getEngine() { return engine; }} 123456789@WebServlet(\"/index2\")public class HelloServlet2 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { Context context = new Context(); ThymeleafUtil.getEngine().process(\"test2.html\", context, resp.getWriter()); }} 现在就有两个Servlet分别对应两个页面了，但是这两个页面实际上是存在重复内容的，我们要做的就是将这些重复内容提取出来。 我们单独编写一个head.html来存放重复部分： 1234567891011&lt;!DOCTYPE html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\" lang=\"en\"&gt;&lt;body&gt; &lt;div class=\"head\" th:fragment=\"head-title\"&gt; &lt;div&gt; &lt;h1&gt;我是标题内容，每个页面都有&lt;/h1&gt; &lt;/div&gt; &lt;hr&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 现在，我们就可以直接将页面中的内容快速替换： 123456&lt;div th:include=\"head.html::head-title\"&gt;&lt;/div&gt;&lt;div class=\"body\"&gt; &lt;ul&gt; &lt;li th:each=\"title, iterStat : ${list}\" th:text=\"${iterStat.index}+'.《'+${title}+'》'\"&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 我们可以使用th:insert和th:replace和th:include这三种方法来进行页面内容替换，那么th:insert和th:replace（和th:include，自3.0年以来不推荐）有什么区别？ th:insert最简单：它只会插入指定的片段作为标签的主体。 th:replace实际上将标签直接替换为指定的片段。 th:include和th:insert相似，但它没有插入片段，而是只插入此片段的内容。 你以为这样就完了吗？它还支持参数传递，比如我们现在希望插入二级标题，并且由我们的子页面决定： 1234567&lt;div class=\"head\" th:fragment=\"head-title\"&gt; &lt;div&gt; &lt;h1&gt;我是标题内容，每个页面都有&lt;/h1&gt; &lt;h2&gt;我是二级标题&lt;/h2&gt; &lt;/div&gt; &lt;hr&gt;&lt;/div&gt; 稍加修改，就像JS那样添加一个参数名称： 1234567&lt;div class=\"head\" th:fragment=\"head-title(sub)\"&gt; &lt;div&gt; &lt;h1&gt;我是标题内容，每个页面都有&lt;/h1&gt; &lt;h2 th:text=\"${sub}\"&gt;&lt;/h2&gt; &lt;/div&gt; &lt;hr&gt;&lt;/div&gt; 现在直接在替换位置添加一个参数即可： 123456&lt;div th:include=\"head.html::head-title('这个是第1个页面的二级标题')\"&gt;&lt;/div&gt;&lt;div class=\"body\"&gt; &lt;ul&gt; &lt;li th:each=\"title, iterStat : ${list}\" th:text=\"${iterStat.index}+'.《'+${title}+'》'\"&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 这样，不同的页面还有着各自的二级标题。 探讨Tomcat类加载机制有关JavaWeb的内容，我们就聊到这里，在最后，我们还是来看一下Tomcat到底是如何加载和运行我们的Web应用程序的。 Tomcat服务器既然要同时运行多个Web应用程序，那么就必须要实现不同应用程序之间的隔离，也就是说，Tomcat需要分别去加载不同应用程序的类以及依赖，还必须保证应用程序之间的类无法相互访问，而传统的类加载机制无法做到这一点，同时每个应用程序都有自己的依赖，如果两个应用程序使用了同一个版本的同一个依赖，那么还有必要去重新加载吗，带着诸多问题，Tomcat服务器编写了一套自己的类加载机制。 首先我们要知道，Tomcat本身也是一个Java程序，它要做的是去动态加载我们编写的Web应用程序中的类，而要解决以上提到的一些问题，就出现了几个新的类加载器，我们来看看各个加载器的不同之处： Common ClassLoader：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Web应用程序访问。 Catalina ClassLoader：Tomcat容器私有的类加载器，加载路径中的class对于Web应用程序不可见。 Shared ClassLoader：各个Web应用程序共享的类加载器，加载路径中的class对于所有Web应用程序可见，但是对于Tomcat容器不可见。 Webapp ClassLoader：各个Web应用程序私有的类加载器，加载路径中的class只对当前Web应用程序可见，每个Web应用程序都有一个自己的类加载器，此加载器可能存在多个实例。 JasperLoader：JSP类加载器，每个JSP文件都有一个自己的类加载器，也就是说，此加载器可能会存在多个实例。 通过这样进行划分，就很好地解决了我们上面所提到的问题，但是我们发现，这样的类加载机制，破坏了JDK的双亲委派机制（在JavaSE阶段讲解过），比如Webapp ClassLoader，它只加载自己的class文件，它没有将类交给父类加载器进行加载，也就是说，我们可以随意创建和JDK同包同名的类，岂不是就出问题了？ 难道Tomcat的开发团队没有考虑到这个问题吗？ 实际上，WebAppClassLoader的加载机制是这样的：WebAppClassLoader 加载类的时候，绕开了 AppClassLoader，直接先使用 ExtClassLoader 来加载类。这样的话，如果定义了同包同名的类，就不会被加载，而如果是自己定义 的类，由于该类并不是JDK内部或是扩展类，所有不会被加载，而是再次回到WebAppClassLoader进行加载，如果还失败，再使用AppClassloader进行加载。 实战：编写图书管理系统图书管理系统需要再次迎来升级，现在，我们可以直接访问网站来操作图书，这里我们给大家提供一个前端模板直接编写，省去编写前端的时间。 本次实战使用到的框架：Servlet+Mybatis+Thymeleaf 注意在编写的时候，为了使得整体的代码简洁高效，我们严格遵守三层架构模式： 就是说，表示层只做UI，包括接受请求和相应，给模板添加上下文，以及进行页面的解析，最后响应给浏览器；业务逻辑层才是用于进行数据处理的地方，表示层需要向逻辑层索要数据，才能将数据添加到模板的上下文中；数据访问层一般就是连接数据库，包括增删改查等基本的数据库操作，业务逻辑层如果需要从数据库取数据，就需要向数据访问层请求数据。 当然，贯穿三大层次的当属实体类了，我们还需要创建对应的实体类进行数据的封装，以便于在三层架构中进行数据传递。 接下来，明确我们要实现的功能，也就是项目需求： 图书管理员的登陆和退出（只有登陆之后才能进入管理页面） 图书的列表浏览（包括书籍是否被借出的状态也要进行显示）以及图书的添加和删除 学生的列表浏览 查看所有的借阅列表，添加借阅信息 结束语首先祝贺各位顺利完成了JavaWeb相关知识的学习。 本教程创作的动力离不开各位观众姥爷们的支持，我们也会在后面为大家录制更多的Java技术栈教程，如果您喜欢本系列视频的话，直接用三连狠狠的砸向UP主吧！ 虽然我们现在已经学会了如何去编写一个网站，但是实际上，这样的开发模式已经过时（不过拿去当毕设当期末设计直接无敌好吧），我们还需要继续深入了解更加现代化的开发模式，这样我们才有机会参与到企业的项目开发当中。 希望在后续的视频中，还能看到各位的身影，完结撒花！","categories":[],"tags":[]},{"title":"","slug":"白马Java Web/JavaWeb笔记（四）","date":"2025-08-31T15:29:05.024Z","updated":"2025-08-31T15:31:22.573Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/0.html","excerpt":"前端基础提醒：还没有申请到IDEA专业版本授权的同学要抓紧了，很快就需要用到。 经过前面基础内容的学习，现在我们就可以正式地进入Web开发的学习当中啦~ 本章节会讲解前端基础内容（如果已经学习过，可以直接跳到下一个大章节了）那么什么是前端，什么又是后端呢？ 前端：我们网站的页面，包括网站的样式、图片、视频等一切用户可见的内容都是前端的内容。 后端：处理网站的所有数据来源，比如我们之前从数据库中查询数据，而我们查询的数据经过处理最终会被展示到前端，而用于处理前端数据的工作就是由后端来完成的。 相当于，前端仅仅是一层皮，它直接决定了整个网站的美观程度，我们可以自由地编排页面的布局，甚至可以编写好看的特效；而灵魂则是后端，如何处理用户的交互、如何处理数据查询是后端的职责所在，我们前面学习的都是后端内容，而Java也是一门专注于后端开发的语言。 对于前端开发我们需要学习一些新的内容，只有了解了它们，我们才能编写出美观的页面。 本教程并不会过多地去讲解前端知识，我们只会提及一些必要的内容，我们主要学习的是JavaWeb，更倾向于后端开发，学习前端的目的只是为了让同学们了解前后端的交互方式，在进行后端开发时思路能够更加清晰，有关前端的完整内容学习，可以浏览其他前端知识教程。 我们在最开始讲解网络编程时，提到了浏览器访问服务器，实际上浏览器访问服务器就是一种B/S结构，而我们使用Java代码编写的客户端连接服务器就是一种C/S结构。","text":"前端基础提醒：还没有申请到IDEA专业版本授权的同学要抓紧了，很快就需要用到。 经过前面基础内容的学习，现在我们就可以正式地进入Web开发的学习当中啦~ 本章节会讲解前端基础内容（如果已经学习过，可以直接跳到下一个大章节了）那么什么是前端，什么又是后端呢？ 前端：我们网站的页面，包括网站的样式、图片、视频等一切用户可见的内容都是前端的内容。 后端：处理网站的所有数据来源，比如我们之前从数据库中查询数据，而我们查询的数据经过处理最终会被展示到前端，而用于处理前端数据的工作就是由后端来完成的。 相当于，前端仅仅是一层皮，它直接决定了整个网站的美观程度，我们可以自由地编排页面的布局，甚至可以编写好看的特效；而灵魂则是后端，如何处理用户的交互、如何处理数据查询是后端的职责所在，我们前面学习的都是后端内容，而Java也是一门专注于后端开发的语言。 对于前端开发我们需要学习一些新的内容，只有了解了它们，我们才能编写出美观的页面。 本教程并不会过多地去讲解前端知识，我们只会提及一些必要的内容，我们主要学习的是JavaWeb，更倾向于后端开发，学习前端的目的只是为了让同学们了解前后端的交互方式，在进行后端开发时思路能够更加清晰，有关前端的完整内容学习，可以浏览其他前端知识教程。 我们在最开始讲解网络编程时，提到了浏览器访问服务器，实际上浏览器访问服务器就是一种B/S结构，而我们使用Java代码编写的客户端连接服务器就是一种C/S结构。 Web开发还要从HTML开始讲起，这个语言非常简单，很好学习，看完视频如果你觉得前端简单自己更喜欢一些，建议马上转前端吧，还来得及，工资还比后端高，不像后端那么枯燥乏味。 HTML页面我们前面学习了XML语言，它是一种标记语言，我们需要以成对标签的格式进行填写，但是它是专用于保存数据，而不是展示数据，而HTML恰恰相反，它专用于展示数据，由于我们前面已经学习过XML语言了，HTML语言和XML很相似，所以我们学习起来会很快。 第一个HTML页面我们前面知道，通过浏览器可以直接浏览XML文件，而浏览器一般是用于浏览HTML文件的，以HTML语言编写的内容，会被浏览器识别为一个页面，并根据我们编写的内容，将对应的组件添加到浏览器窗口中。 我们一般使用Chrome、Safari、Microsoft Edge等浏览器进行测试，IE浏览器已经彻底淘汰了！ 比如我们可以创建一个Html文件来看看浏览器会如何识别，使用IDEA也能编写HTML页面，我们在IDEA中新建一个Web模块，进入之后我们发现，项目中没有任何内容，我们右键新建一个HTML文件，选择HTML5文件，并命名为index，创建后出现： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 我们发现，它和XML基本长得一样，并且还自带了一些标签，那么现在我们通过浏览器来浏览这个HTML文件（这里推荐使用内置预览，不然还得来回切换窗口） 我们发现现在什么东西都没有，但是在浏览器的标签位置显示了网页的名称为Title，并且显示了一个IDEA的图标作为网页图标。 现在我们稍微进行一些修改： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;lbw的直播间&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 现在全体起立&lt;/body&gt;&lt;/html&gt; 再次打开浏览器，我们发现页面中出现了我们输入的文本内容，并且标题也改为了我们自定义的标题。 我们可以在设置-&gt;工具-&gt;Web浏览器和预览中将重新加载页面规则改为变更时，这样我们使用内置浏览器或是外部浏览器，可以自动更新我们编写的内容。 我们还可以在页面中添加一个图片，随便将一张图片放到html文件的同级目录下，命名为image.xxx，其中xxx是后缀名称，不要修改，我们在body节点中添加以下内容： 12&lt;img width=\"300\" src=\"image.xxx\" alt=\"剑光如我，斩尽牛杂\"&gt;&lt;!-- 注意xxx替换成对应的后缀名称 --&gt; 我们发现，我们的页面中居然能够显示我们添加的图片内容。因此，我们只需要编写对应的标签，浏览器就能够自动识别为对应的组件，并将其展示到我们的浏览器窗口中。 我们再来看看插入一个B站的视频，很简单，只需要到对应的视频下方，找到分享，我们看到有一个嵌入代码： 1&lt;iframe src=\"//player.bilibili.com/player.html?aid=333231998&amp;bvid=BV1rA411g7q8&amp;cid=346917516&amp;page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"800\" height=\"500\"&gt; &lt;/iframe&gt; 每一个页面都是通过这些标签来编写的，几乎所有的网站都是使用HTML编写页面。 HTML语法规范一个HTML文件中一般分为两个部分： 头部：一般包含页面的标题、页面的图标、还有页面的一些设置，也可以在这里导入css、js等内容。 主体：整个页面所有需要显示的内容全部在主体编写。 我们首先来看头部，我们之前使用的HTML文件中头部包含了这些内容： 12&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;lbw的直播间&lt;/title&gt; 首先meta标签用于定义页面的一些元信息，这里使用它来定义了一个字符集（编码格式），一般是UTF-8，下面的title标签就是页面的标题，会显示在浏览器的上方。我们现在来给页面设置一个图标，图标一般可以在字节跳动的IconPark网站找到：https://iconpark.oceanengine.com/home，选择一个自己喜欢的图标下载即可。 将图标放入到项目目录中，并命名为icon.png，在HTML头部添加以下内容： 1&lt;link rel=\"icon\" href=\"icon.png\" type=\"image/x-icon\" /&gt; link标签用于关联当前HTML页面与其他资源的关系，关系通过rel属性指定，这里使用的是icon表示这个文件是当前页面图标。 现在访问此页面，我们发现页面的图标已经变成我们指定的图标样式了。 现在我们再来看主体，我们可以在主体内部编写该页面要展示的所有内容，比如我们之前就用到了img标签来展示一个图片，其中每一个标签都称为一个元素： 1&lt;img width=\"300\" src=\"image.xxx\" alt=\"当图片加载失败时，显示的文本\"&gt; 我们发现，这个标签只存在一个，并没有成对出现，HTML中有些标签是单标签，也就是说只有这一个，还有一些标签是双标签，必须成对出现，HTML中，也不允许交叉嵌套，但是出现交叉嵌套时，浏览器并不会提示错误，而是仍旧尝试去解析这些内容，甚至会帮助我们进行一定程度的修复，比如： 123456&lt;body&gt; &lt;iframe src=\"//player.bilibili.com/player.html?aid=333231998&amp;bvid=BV1rA411g7q8&amp;cid=346917516&amp;page=1\" width=\"800\" height=\"500\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"&gt;&lt;/body&gt;&lt;/iframe&gt; 很明显上面的代码已经出现交叉嵌套的情况了，但是依然能够在浏览器中正确地显示。 在主体中，我们一般使用div标签来分割页面： 1234&lt;body&gt; &lt;div&gt;我是第一块&lt;/div&gt; &lt;div&gt;我是第二块&lt;/div&gt;&lt;/body&gt; 通过使用div标签，我们将整个页面按行划分，而高度就是内部元素的高度，那么如果只希望按元素划分，也就是说元素占多大就划分多大的空间，那么我们就可以使用span标签来划分： 1234567&lt;body&gt; &lt;div&gt; &lt;span&gt;我是第一块第一个部分&lt;/span&gt; &lt;span&gt;我是第一块第二个部分&lt;/span&gt; &lt;/div&gt; &lt;div&gt;我是第二块&lt;/div&gt;&lt;/body&gt; 我们也可以使用p段落标签，它一般用于文章分段： 1234567891011121314151617&lt;body&gt; &lt;p&gt; 你看这个彬彬啊，才喝几罐就醉了，真的太逊了。 这个彬彬就是逊呀！ 听你这么说，你很勇哦？ 开玩笑，我超勇的，超会喝的啦。 超会喝，很勇嘛。身材不错哦，蛮结实的嘛。 &lt;/p&gt; &lt;p&gt; 哎，杰哥，你干嘛啊。都几岁了，还那么害羞！我看你，完全是不懂哦！ 懂，懂什么啊？ 你想懂？我房里有一些好康的。 好康，是新游戏哦！ 什么新游戏，比游戏还刺激！ &lt;/p&gt; &lt;p&gt; 杰哥，这是什么啊？ 哎呦，你脸红啦！来，让我看看。 不要啦！！ 让我看看嘛。 不要啦，杰哥，你干嘛啊！ 让我看看你法语正不正常啊！ &lt;/p&gt;&lt;/body&gt; 那么如果遇到特殊字符该怎么办呢？和XML一样，我们可以使用转义字符： 注意：多个连续的空格字符只能被识别为一个，如果需要连续多个必须使用转义字符，同时也不会识别换行，换行只会变成一个空格，需要换行必须使用br标签。 通过了解了HTML的一些基础语法，我们现在就知道一个页面大致是如何编写了。 HTML常用标签前面我们已经了解了HTML的基本语法规范，那么现在我们就来看看，有哪些常用的标签吧，首先是换行和分割线： br 换行 hr 分割线 1234567&lt;body&gt; &lt;div&gt; 我是一段文字&lt;br&gt;我是第二段文字 &lt;/div&gt; &lt;hr&gt; &lt;div&gt;我是底部文字&lt;/div&gt;&lt;/body&gt; 标题一般用h1到h6表示，我们来看看效果： 123456789&lt;body&gt;&lt;h1&gt;一级标题&lt;/h1&gt;&lt;h2&gt;二级标题&lt;/h2&gt;&lt;h3&gt;三级标题&lt;/h3&gt;&lt;h4&gt;四级标题&lt;/h4&gt;&lt;h5&gt;五级标题&lt;/h5&gt;&lt;h6&gt;六级标题&lt;/h6&gt;&lt;p&gt;我是正文内容，真不错。&lt;/p&gt;&lt;/body&gt; 现在我们来看看超链接，我们可以添加一个链接用于指向其他网站： 1&lt;a href=\"https://www.bilibili.com\"&gt;点击访问小破站&lt;/a&gt; 我们也可以指定页面上的一个锚点进行滚动： 1234567891011&lt;body&gt;&lt;a href=\"#test\"&gt;跳转锚点&lt;/a&gt;&lt;img src=\"image.jpeg\" width=\"500\"&gt;&lt;img src=\"image.jpeg\" width=\"500\"&gt;&lt;img src=\"image.jpeg\" width=\"500\"&gt;&lt;img src=\"image.jpeg\" width=\"500\"&gt;&lt;div id=\"test\"&gt;我是锚点&lt;/div&gt;&lt;img src=\"image.jpeg\" width=\"500\"&gt;&lt;img src=\"image.jpeg\" width=\"500\"&gt;&lt;img src=\"image.jpeg\" width=\"500\"&gt;&lt;/body&gt; 每个元素都可以有一个id属性，我们只需要给元素添加一个id属性，就使用a标签可以跳转到一个指定锚点。 我们接着来看看列表元素，这是一个无需列表，其中每一个li表示一个列表项： 1234567&lt;ul&gt; &lt;li&gt;一号选项&lt;/li&gt; &lt;li&gt;二号选项&lt;/li&gt; &lt;li&gt;三号选项&lt;/li&gt; &lt;li&gt;四号选项&lt;/li&gt; &lt;li&gt;五号选项&lt;/li&gt;&lt;/ul&gt; 我们也可以使用ol来显示一个有序列表： 1234567&lt;ol&gt; &lt;li&gt;一号选项&lt;/li&gt; &lt;li&gt;二号选项&lt;/li&gt; &lt;li&gt;三号选项&lt;/li&gt; &lt;li&gt;四号选项&lt;/li&gt; &lt;li&gt;五号选项&lt;/li&gt;&lt;/ol&gt; 表格也是很重要的一种元素，但是它编写起来相对有一点麻烦： 123456789101112131415161718192021222324&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年级&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;0001&lt;/td&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;2019&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;0002&lt;/td&gt; &lt;td&gt;小红&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;td&gt;2020&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 虽然这样生成了一个表格，但是这个表格并没有分割线，并且格式也不符合我们想要的样式，那么如何才能修改这些基础属性的样式呢，我们就需要聊聊CSS了。 HTML表单表单就像其名字一样，用户在页面中填写了对应的内容，点击按钮就可以提交到后台，比如登陆界面，就可以使用表单来实现： 一个网页中最重要的当属输入框和按钮了，那么我们来看看如何创建一个输入框和按钮： 1234&lt;label&gt; 我是输入框 &lt;input type=\"text\"&gt;&lt;/label&gt; 对于一个输入框，我们一般会将其包括在一个lable标签中，它和span效果一样，但是我们点击前面文字也能快速获取输入框焦点。 12345678910111213141516&lt;body&gt;&lt;div&gt;登陆我们的网站&lt;/div&gt;&lt;hr&gt;&lt;div&gt; &lt;label&gt; 账号： &lt;input type=\"text\"&gt; &lt;/label&gt;&lt;/div&gt;&lt;div&gt; &lt;label&gt; 密码： &lt;input type=\"password\"&gt; &lt;/label&gt;&lt;/div&gt;&lt;/body&gt; 输入框可以有很多类型，我们来试试看password，现在输入内容就不会直接展示原文了。 创建一个按钮有以下几种方式，在学习JavaWeb时，我们更推荐第二种方式，我们后面进行登陆操作需要配合表单使用： 123&lt;button&gt;登陆&lt;/button&gt;&lt;input type=\"submit\" value=\"登陆\"&gt;&lt;input type=\"button\" value=\"登陆\"&gt; 现在我们就可以写一个大致的登陆页面了： 123456789101112131415161718192021222324&lt;body&gt; &lt;h1&gt;登陆我们的网站&lt;/h1&gt; &lt;form&gt; &lt;div&gt; &lt;label&gt; 账号： &lt;input type=\"text\" placeholder=\"Username...\"&gt; &lt;/label&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt; 密码： &lt;input type=\"password\" placeholder=\"Password...\"&gt; &lt;/label&gt; &lt;/div&gt; &lt;br&gt; &lt;a href=\"https://www.baidu.com\"&gt;忘记密码&lt;/a&gt; &lt;br&gt; &lt;br&gt; &lt;div&gt; &lt;input type=\"submit\" value=\"登陆\"&gt; &lt;/div&gt; &lt;/form&gt;&lt;/body&gt; 表单一般使用form标签将其囊括，但是现在我们还用不到表单提交，因此之后我们再来讲解表单的提交。 input只能实现单行文本，那么如何实现多行文本呢？ 1234&lt;label&gt; 这是我们的文本框&lt;br&gt; &lt;textarea placeholder=\"文本内容...\" cols=\"10\" rows=\"10\"&gt;&lt;/textarea&gt;&lt;/label&gt; 我们还可以指定默认的行数和列数，拖动左下角可以自定义文本框的大小。 我们还可以在页面中添加勾选框： 1234&lt;label&gt; &lt;input type=\"checkbox\"&gt; 我同意本网站的隐私政策&lt;/label&gt; 上面演示的是一个多选框，那么我们来看看单选框： 12345678&lt;label&gt; &lt;input type=\"radio\" name=\"role\"&gt; 学生&lt;/label&gt;&lt;label&gt; &lt;input type=\"radio\" name=\"role\"&gt; 教师&lt;/label&gt; 这里需要使用name属性进行分组，同一个组内的选项只能选择一个。 我们也可以添加列表让用户进行选择，创建一个下拉列表： 1234567&lt;label&gt; 登陆身份： &lt;select&gt; &lt;option&gt;学生&lt;/option&gt; &lt;option&gt;教师&lt;/option&gt; &lt;/select&gt;&lt;/label&gt; 默认选取的是第一个选项，我们可以通过selected属性来决定默认使用的是哪个选项。 当然，HTML的元素远不止我们所提到的这些，有关更多HTML元素的内容，可以自行了解。 CSS样式之前我们编写的页面非常基础，我们只能通过一些很基本的属性来排列我们的页面元素，那么如何实现更高度的自定义呢，我们就需要用到CSS来自定义样式，首先我们创建一个名为style.css的文件。 首先在我们HTML文件的头部添加： 1&lt;link href=\"style.css\" rel=\"stylesheet\"&gt; 我们在CSS文件中添加以下内容： 123body { text-align: center;} 我们发现，网页的内容全部变为居中显示了，这正是css在生效，相当于我们现在给页面添加了自定义的样式规则。 当然，我们也可以选择不使用CSS，而是直接对某个元素添加样式： 12&lt;body style=\"text-align: center;\"&gt; ... 这样的效果其实是等同于上面的css文件的，相当于我们直接把样式定义在指定元素上。 也可以在头部直接定义样式，而不是使用外部文件： 12345&lt;style&gt; body { text-align: center; }&lt;/style&gt; 使用以上三种方式都可以自定义页面的样式，我们推荐使用还是第一种，不然我们的代码会很繁杂。 样式的属性是非常多的，我们不可能一个一个全部讲完，视频中用到什么再来讲解什么，如果同学们感兴趣，可以自行下去了解。 CSS选择器我们首先来了解一下选择器，那么什么是选择器呢？我们想要自定义一个元素的样式，那么我们肯定要去选择某个元素，只有先找到要自定义的元素，我们才能开始编写样式。 我们上面的例子中使用的就是标签名选择器，它可以快速选择页面中所有指定的的标签，比如我们之前使用的就是body标签，那么就相当于页面中所有的body元素全都使用此样式，那么我们现在来试试看选择页面中所有的input标签： 123input { width: 200px;} 我们发现，页面中所有的input元素宽度全部被设定为了200个像素（px是单位大小，代表像素，除了px还有em和rem，他们是根据当前元素字体大小决定的相对大小，一般用于适配各种大小的浏览器窗口，这里暂时不用） 样式编写完成后，如果只有一个属性，可以不带;若多个属性则每个属性后面都需要添加一个; 因此，一个标签选择器的格式为： 123标签名称 { 属性名称: 属性值} 我们还可以设定输入框的字体大小、行高等： 12345input { width: 200px; font-size: 20px; line-height: 40px;} 我们现在可以通过选择器快速地去设置某个元素样式了，那么如何实现只设置某个元素的样式呢，现在我们来看看，id选择器，我们之前已经讲解过了，每个元素都可以有一个id属性，我们可以将其当做一个跳转的锚点使用，而现在，我们可以使用css来进行定位： 我们先为元素添加id属性： 1&lt;h1 id=\"title\"&gt;登陆我们的网站&lt;/h1&gt; 现在使用CSS选择我们的元素，并设定一个属性，选择某个id需要在前面加上一个#： 123#title { color: red;} 虽然id选择器已经可以很方便的指定某个元素，但是如果我们希望n个但不是元素都被选择，id选择器就无法实现了，因为每个元素的id是唯一的，不允许出现重复id的元素，因此接着我们来讲解一下类选择器。 每个元素都可以有一个class属性，表示当前元素属于某个类（注意这里的类和我们Java中的类概念完全不同）一个元素可以属于很多个类，一个类也可以被很多个元素使用： 1234567891011121314&lt;form&gt; &lt;div &gt; &lt;label class=\"test\"&gt; 账号： &lt;input type=\"text\" placeholder=\"Username...\"&gt; &lt;/label&gt; &lt;/div&gt; &lt;div&gt; &lt;label class=\"test\"&gt; 密码： &lt;input type=\"password\" placeholder=\"Password...\"&gt; &lt;/label&gt; &lt;/div&gt;&lt;/form&gt; 上面的例子中，两个label元素都使用了test类（类名称是我们自定义的），现在我们在css文件中编写以下内容来以类进行选择： 123.test{ color: blue;} 我们发现，两个标签的文本内容都变为了蓝色，因此使用类选择器，能够对所有为此类的元素添加样式。注意在进行类选择时，我们需要在类名前面加上.来表示。 组合选择器和优先级问题我们也可以让多个选择器，共用一个css样式： 123.test, #title { color: red;} 只需要并排写即可，注意中间需要添加一个英文的逗号用于分割，我们也可以使用*来一次性选择所有的元素： 123* { color: red;} 我们还可以选择位于某个元素内的某个元素： 123div label { color: red;} 这样的话，就会选择所有位于div元素中的label元素。 当然，我们这里只介绍了一些常用的选择器，有关详细的CSS选择器可以查阅：https://www.runoob.com/cssref/css-selectors.html 我们接着来看一下选择器的优先级： 我们根据上面的信息，来测试一下，首先编写一下HTML文件： 123&lt;body&gt; &lt;div class=\"test\" id=\"simple\" style=\"color: blue\"&gt;我是测试文本内容&lt;/div&gt;&lt;/body&gt; 现在我们来编写一下css文件： 1234567891011.test { color: yellow;}#simple { color: red;}* { color: palegreen;} 那么现在我们可以看到，实际上生效的是我们直接编写在标签内部的内联属性，那么现在我们依次进行移除，来看看它们的优先级。 那么如果我们希望某个属性无视任何的优先级，我们可以在属性后面添加!important标记，表示此属性是一个重要属性，它的优先级会被置为最高。 思考：那要是我每个选择器的这个属性后面都加一个!important会怎么样？ 自定义边距我们来看看，如何使用css控制一个div板块的样式，首先编写以下代码，相当于一个div嵌套了一个div元素： 12345&lt;div id=\"outer\"&gt; &lt;div id=\"inner\"&gt; &lt;/div&gt;&lt;/div&gt; 现在编写一下自定义的css样式，我们将div设定为固定大小，并且背景颜色添加为绿色： 12345#outer { background: palegreen; width: 300px; height: 300px;} 我们发现左侧快速预览页面存在空隙，这是因为浏览器给我们添加了一个边距属性，我们只需要覆盖此属性并将其设定为0即可： 123body { margin: 0;} 现在我们给内部嵌套的div也设定一个大小，并将颜色设定为橙色： 12345#inner { background: darkorange; width: 100px; height: 100px;} 现在我们发现内部的div元素位于右上角，我们还可以以百分比的形式来指定大小： 12345#inner { background: darkorange; width: 100%; height: 100%;} 百分比会依照当前可用大小来进行分配，比如当前位于一个div内部，并且外部div元素是固定大小300px，因此100%就相当于使用了外部的全部大小，也是300px，现在内部元素完全将外部元素覆盖了，整个元素现在呈现为橙色。 我们可以为一个元素设定边距，边距分为外边距和内边距，外部元素内边距决定了内部元素与外部元素之间的间隔，我们来修改一下css样式： 123456#outer { background: palegreen; width: 300px; height: 300px; padding: 10px;} 我们发现，内部的div元素小了一圈，这是因为外部div元素设定了内边距，上下左右都被设定为10px大小。 而我们发现，实际上我们在一开始也是将body的外边距设定为了0，整个页面跟浏览器窗口直接间隔0px的宽度。 编写一个漂亮的登陆界面现在我们就来尝试编写一个漂亮的登陆界面吧！ JavaScript语言也称为js，是我们整个前端基础的重点内容，只有了解了JavaScript语言，我们才能了解前端如何与后端交互。 JavaScript与Java没有毛关系，仅仅只是名字中包含了Java而已，跟Java比起来，它更像Python，它是一门解释型语言，不需要进行编译，它甚至可以直接在浏览器的命令窗口中运行。 它相当于是前端静态页面的一个补充，它可以让一个普通的页面在后台执行一些程序，比如我们点击一个按钮，我们可能希望执行某些操作，比如下载文件、页面跳转、页面弹窗、进行登陆等，都可以使用JavaScript来帮助我们实现。 我们来看看一个简单的JavaScript程序： 12345678910111213const arr = [0, 2, 1, 5, 9, 3, 4, 6, 7, 8]for (let i = 0; i &lt; arr.length; i++) { for (let j = 0; j &lt; arr.length - 1; j++) { if(arr[j] &gt; arr[j+1]){ const tmp = arr[j] arr[j] = arr[j+1] arr[j+1] = tmp } }}window.alert(arr) 这段代码实际上就是实现了一个冒泡排序算法，我们可以直接在页面的头部中引用此js文件，浏览器会在加载时自动执行js文件中编写的内容： 1&lt;script src=\"test.js\"&gt;&lt;/script&gt; 我们发现JS的语法和Java非常相似，但是它还是和Java存在一些不同之处，而且存在很多阴间语法，那么我们来看看JS的语法。 JavaScript基本语法在js中，定义变量和Java中有一些不同，定义一个变量可以使用let关键字或是var关键字，IDEA推荐我们使用let关键字，因为var存在一定的设计缺陷（这里就不做讲解了，之后一律使用let关键字进行变量声明）： 123let a = 10;a++;window.alert(a) 上面的结果中，我们得到了a的结果是11，也就是说自增和自减运算在JS中也是支持的，并且JS每一句结尾可以不用加分号。 js并不是Java那样的强类型语言（任意变量的类型一定是明确的），它是一门弱类型语言，变量的类型并不会在一开始确定，因此我们在定义变量时无需指定变量的确切类型，而是在运行时动态解析类型： 123let a = 10;a = \"HelloWorld！\"console.info(a) 我们发现，变量a已经被赋值为数字类型，但是我们依然在后续能将其赋值一个字符串，它的类型是随时可变的。 很多人说，这种变态的类型机制是JS的一大缺陷。 世界上只有两种语言：一种是很多人骂的，一种是没人用的。 我们接着来看看，JS中存在的基本数据类型： Number：数字类型（包括小数和整数） String：字符串类型（可以使用单引号或是双引号） Boolean：布尔类型（与Java一致） 还包括一些特殊值： undefined：未定义 - 变量声明但不赋值默认为undefined null：空值 - 等同于Java中的null NaN：非数字 - 值不是合法数字，比如： 1window.alert(100/'xx') 我们可以使用typeof关键字来查看当前变量值的类型： 1234let a = 10;console.info(typeof a)a = 'Hello World'console.info(typeof a) JavaScript逻辑运算和流程控制我们接着来看看js中的关系运算符，包括如下8个关系运算符：大于（&gt;）,小于（&lt;）,小于等于（&lt;=）,大于等于（&gt;=）,相等（==），不等（!=），全等（===），不全等（!==） 其实关系运算符大致和Java中的使用方法一致，不过它还可以进行字符串比较，有点像C++的语法： 12console.info(666 &gt; 777)console.info('aa' &gt; 'ab') 那么，相等和全等有什么区别呢？ 12console.info('10' == 10)console.info('10' === 10) 我们发现，在Java中，若运算符两边是不同的基本数据类型，会直接得到false，而JS中却不像这样，我们发现字符串的10居然等于数字10，而使用全等判断才是我们希望的结果。 ==的比较规则是：当操作数类型一样时，比较的规则和恒等运算符一样，都相等才相等，如果两个操作数是字符串，则进行字符串的比较，如果里面有一个操作数不是字符串，那两个操作数通过Number()方法进行转换，转成数字进行比较。 因此，我们上面进行的判断实际上是运算符两边都进行了数字转换的结果进行比较，自然也就得到了true，而全等判断才是我们在Java中认识的相等判断。 我们接着来看逻辑运算，JS中包括&amp;&amp;、||、&amp;、|、?:等，我们先来看看位运算符： 12console.info(4 &amp; 7)console.info(4 | 7) 实际上和Java中是一样的，那么我再来看看逻辑运算： 1console.info(true || false) 对于boolean变量的判断，是与Java一致的，但是JS也可以使用非Boolen类型变量进行判断： 12console.info(!0)console.info(!1) 和C/C++语言一样，0代表false，非0代表true，那么字符串呢？ 12console.info(!\"a\")console.info(!\"\") 我们发现，空串为false，非空串为true，我们再来看看： 12console.info(true || 7)console.info(7 || true) 我们发现，前者得到的结果为true，而后者得到的结果却是是7，真是滑天下之大稽，什么鬼玩意，实际上是因为，默认非0都是true，而后者又是先判断的7，因此会直接得到7而不是被转换为true 那么我们再来看看几个特殊值默认代表什么： 123console.info(!undefined)console.info(!null)console.info(!NaN) 最后来使用一下三元运算符，实际上和Java中是一样的： 12let a = true ? \"xx\" : 20console.info(a) 得益于JS的动态类型，emmm，三元运算符不一定需要固定的返回值类型。 JS的分支结构，实际上和Java是一样的，也是使用if-else语句来进行： 12345if(\"lbwnb\"){ //非空串为true console.info(\"!!!\")} else { console.info(\"???\")} 同理，多分支语句也能实现： 1234567if(\"\"){ console.info(\"!!!\")} else if(-666){ console.info(\"???\")} else { console.info(\"O.O\")} 当然，多分支语句也可以使用switch来完成： 1234567891011121314let a = \"a\"switch (a){ case \"a\": console.info(\"1\") break case \"b\": console.info(\"2\") break case \"c\": console.info(\"3\") break default: console.info(\"4\")} 接着我们来看看循环结构，其实循环结构也和Java相差不大： 1234let i = 10while(i--){ console.info(\"100\")} 123for (let i = 0; i &lt; 10; i++) { console.info(\"??\")} JavaScript函数定义JS中的方法和Java中的方法定义不太一样，JS中一般称其为函数，我们来看看定义一个函数的格式是什么： 123function f() { console.info(\"有一个人前来买瓜\")} 定义一个函数，需要在前面加上function关键字表示这是一个函数，后面跟上函数名称和()，其中可以包含参数，在{}中编写函数代码。我们只需要直接使用函数名+()就能调用函数： 1f(); 我们接着来看一下，如何给函数添加形式参数以及返回值： 123456function f(a) { console.info(\"得到的实参为：\"+a) return 666}f(\"aa\"); 由于JS是动态类型，因此我们不必指明参数a的类型，同时也不必指明返回值的类型，一个函数可能返回不同类型的结果，因此直接编写return语句即可。同理，我们可以在调用函数时，不传参，那么默认会使用undefined： 123456function f(a) { console.info(\"得到的实参为：\"+a) return 666}f(); 那么如果我们希望不传参的时候使用我们自定义的默认值呢？ 123456function f(a = \"6666\") { console.info(\"得到的实参为：\"+a) return 666}f(); 我们可以直接在形参后面指定默认值。 函数本身也是一种类型，他可以被变量接收，所有函数类型的变量，也可以直接被调用： 1234567function f(a = \"6666\") { console.info(\"得到的实参为：\"+a) return 666}let k = f;k(); 我们也可以直接将匿名函数赋值给变量： 123let f = function (str) { console.info(\"实参为：\"+str)} 既然函数是一种类型，那么函数也能作为一个参数进行传递： 1234567function f(test) { test();}f(function () { console.info(\"这是一个匿名函数\")}) 对于所有的匿名函数，可以像Java的匿名接口实现一样编写lambda表达式： 1234567function f(test) { test();}f(() =&gt; { console.info(\"可以，不跟你多bb\")}) 1234567function f(test) { test(\"这个是回调参数\");}f(param =&gt; { console.info(\"接受到回调参数：\"+param)}) JavaScript数组和对象JS中的数组定义与Java不同，它更像是Python中的列表，数组中的每个元素并不需要时同样的类型： 1let arr = [1, \"lbwnb\", false, undefined, NaN] 我们可以直接使用下标来访问： 12let arr = [1, \"lbwnb\", false, undefined, NaN]console.info(arr[1]) 我们一开始编写的排序算法，也是使用了数组。 数组还可以动态扩容，如果我们尝试访问超出数组长度的元素，并不会出现错误，而是得到undefined，同样的，我们也可以直接往超出数组长度的地方设置元素： 123let arr = [1, \"lbwnb\", false, undefined, NaN]arr[5] = \"???\"console.info(arr) 也可以使用push和pop来实现栈操作： 1234let arr = [1, \"lbwnb\", false, undefined, NaN]arr.push(\"bbb\")console.info(arr.pop())console.info(arr) 数组还包括一些其他的方法，这里就不一一列出了： 12345let arr = [1, \"lbwnb\", false, undefined, NaN]arr.fill(1)console.info(arr.map(o =&gt; { return 'xxx'+o})) 我们接着来看对象，JS中也能定义对象，但是这里的对象有点颠覆我们的认知： 12let obj = new Object()let obj = {} 以上两种写法都能够创建一个对象，但是更推荐使用下面的一种。 JS中的对象也是非常随意的，我们可以动态为其添加属性： 123let obj = {}obj.name = \"伞兵一号\"console.info(obj) 同理，我们也可以给对象动态添加一个函数： 123456let obj = {}obj.f = function (){ console.info(\"我是对象内部的函数\")}obj.f() 我们可以在函数内使用this关键字来指定对象内的属性： 12345678let name = \"我是外部变量\"let obj = {}obj.name = \"我是内部变量\"obj.f = function (){ console.info(\"name属性为：\"+this.name)}obj.f() 注意：如果使用lambda表达式，那么this并不会指向对象。 除了动态添加属性，我们也可以在一开始的时候指定对象内部的成员： 12345678let obj = { name: \"我是内部的变量\", f: function (){ console.info(\"name属性为：\"+this.name) }}obj.f() 注意如果有多行属性，需要在属性定义后添加一个,进行分割！ JavaScript事件当我们点击一个页面中的按钮之后，我们希望之后能够进行登陆操作，或是执行一些JS代码来实现某些功能，那么这个时候，就需要用到事件。 事件相当于一个通知，我们可以提前设定好事件发生时需要执行的内容，当事件发生时，就会执行我们预先设定好的JS代码。 事件有很多种类型，其中常用的有： onclick：点击事件 oninput：内容输入事件 onsubmit：内容提交事件 那么如何为事件添加一个动作呢？ 1&lt;input type=\"password\" oninput=\"console.info('正在输入文本')\"&gt; 我们可以直接为一个元素添加对应事件的属性，比如oninput事件，我们可以直接在事件的值中编写js代码，但是注意，只能使用单引号，因为双引号用于囊括整个值。 我们也可以单独编写一个函数，当事件发生时直接调用我们的函数： 123function f() { window.alert(\"你输入了一个字符\")} 1&lt;input type=\"password\" oninput=\"oninput()\"&gt; 仅仅了解了事件，还不足以实现高度自定义，我们接着来看DOM。 Document对象当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model），它将整个页面的所有元素全部映射为JS对象，这样我们就可以在JS中操纵页面中的元素。 比如我现在想要读取页面中某个输入框中的内容，那么我们就需要从DOM中获取此输入框元素的对象： 1document.getElementById(\"pwd\").value 通过document对象就能够快速获取当前页面中对应的元素，并且我们也可以快速获取元素中的一些属性。 比如现在我们可以结合事件，来进行密码长度的校验，密码长度小于6则不合法，不合法的密码，会让密码框边框变红，那么首先我们先来编写一个css样式： 1234.illegal-pwd{ border: red 1px solid !important; box-shadow: 0 0 5px red;} 接着我们来编写一下js代码，定义一个函数，此函数接受一个参数（元素本身的对象）检测输入的长度是否大于6，否则就将当前元素的class属性设定为css指定的class： 1234567function checkIllegal(e) { if(e.value.length &lt; 6) { e.setAttribute(\"class\", \"illegal-pwd\") }else { e.removeAttribute(\"class\") }} 最后我们将此函数绑定到oninput事件即可，注意传入了一个this，这里的this代表的是输入框元素本身： 1&lt;input id=\"pwd\" oninput=\"checkIllegal(this)\" type=\"password\"&gt; 现在我们在输入的时候，会自动检查密码是否合法。 既然oninput本身也是一个属性，那么实际上我们可以动态进行修改： 1document.getElementById(\"pwd\").oninput = () =&gt; console.info(\"???\") 那么，我们前面提及的window对象又是什么东西呢？ 实际上Window对象范围更加广阔，它甚至直接代表了整个窗口，当然也包含我们的Document对象，我们一般通过Window对象来弹出提示框之类的东西。 发送XHR请求JS的大致内容我们已经全部学习完成了，那么如何使用JS与后端进行交互呢？ 我们知道，如果我们需要提交表单，那么我们就需要将表单的信息全部发送给我们的服务器，那么，如何发送给服务器呢？ 通过使用XMLHttpRequest对象，来向服务器发送一个HTTP请求，下面是一个最简单的请求格式： 123let xhr = new XMLHttpRequest();xhr.open('GET', 'https://www.baidu.com');xhr.send(); 上面的例子中，我们向服务器发起了一次网络请求，但是我们请求的是百度的服务器，并且此请求的方法为GET请求。 我们现在将其绑定到一个按钮上作为事件触发： 12345function http() { let xhr = new XMLHttpRequest(); xhr.open('GET', 'https://www.baidu.com'); xhr.send(); } 1&lt;input id=\"button\" type=\"button\" onclick=\"http()\"&gt; 我们可以在网络中查看我们发起的HTTP请求并且查看请求的响应结果，比如上面的请求，会返回百度这个页面的全部HTML代码。 实际上，我们的浏览器在我们输入网址后，也会向对应网站的服务器发起一次HTTP的GET请求。 在浏览器得到页面响应后，会加载当前页面，如果当前页面还引用了其他资源文件，那么会继续向服务器发起请求，直到页面中所有的资源文件全部加载完成后，才会停止。","categories":[],"tags":[]},{"title":"","slug":"白马Java Web/JavaWeb笔记（三）","date":"2025-08-31T15:29:05.022Z","updated":"2025-08-31T15:31:22.574Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/0.html","excerpt":"Java与数据库通过Java如何去使用数据库来帮助我们存储数据呢，这将是本章节讨论的重点。 初识JDBCJDBC是什么？JDBC英文名为：Java Data Base Connectivity(Java数据库连接)，官方解释它是Java编程语言和广泛的数据库之间独立于数据库的连接标准的Java API，根本上说JDBC是一种规范，它提供的接口，一套完整的，允许便捷式访问底层数据库。可以用JAVA来写不同类型的可执行文件：JAVA应用程序、JAVA Applets、Java Servlet、JSP等，不同的可执行文件都能通过JDBC访问数据库，又兼备存储的优势。简单说它就是Java与数据库的连接的桥梁或者插件，用Java代码就能操作数据库的增删改查、存储过程、事务等。 我们可以发现，JDK自带了一个java.sql包，而这里面就定义了大量的接口，不同类型的数据库，都可以通过实现此接口，编写适用于自己数据库的实现类。而不同的数据库厂商实现的这套标准，我们称为数据库驱动。 准备工作那么我们首先来进行一些准备工作，以便开始JDBC的学习： 将idea连接到我们的数据库，以便以后调试。 将mysql驱动jar依赖导入到项目中（推荐6.0版本以上，这里用到是8.0） 向Jetbrians申请一个学生/教师授权，用于激活idea终极版（进行JavaWeb开发需要用到，一般申请需要3-7天时间审核）不是大学生的话…emmm…懂的都懂。 教育授权申请地址：https://www.jetbrains.com/shop/eform/students 一个Java程序并不是一个人的战斗，我们可以在别人开发的基础上继续向上开发，其他的开发者可以将自己编写的Java代码打包为jar，我们只需要导入这个jar作为依赖，即可直接使用别人的代码，就像我们直接去使用JDK提供的类一样。","text":"Java与数据库通过Java如何去使用数据库来帮助我们存储数据呢，这将是本章节讨论的重点。 初识JDBCJDBC是什么？JDBC英文名为：Java Data Base Connectivity(Java数据库连接)，官方解释它是Java编程语言和广泛的数据库之间独立于数据库的连接标准的Java API，根本上说JDBC是一种规范，它提供的接口，一套完整的，允许便捷式访问底层数据库。可以用JAVA来写不同类型的可执行文件：JAVA应用程序、JAVA Applets、Java Servlet、JSP等，不同的可执行文件都能通过JDBC访问数据库，又兼备存储的优势。简单说它就是Java与数据库的连接的桥梁或者插件，用Java代码就能操作数据库的增删改查、存储过程、事务等。 我们可以发现，JDK自带了一个java.sql包，而这里面就定义了大量的接口，不同类型的数据库，都可以通过实现此接口，编写适用于自己数据库的实现类。而不同的数据库厂商实现的这套标准，我们称为数据库驱动。 准备工作那么我们首先来进行一些准备工作，以便开始JDBC的学习： 将idea连接到我们的数据库，以便以后调试。 将mysql驱动jar依赖导入到项目中（推荐6.0版本以上，这里用到是8.0） 向Jetbrians申请一个学生/教师授权，用于激活idea终极版（进行JavaWeb开发需要用到，一般申请需要3-7天时间审核）不是大学生的话…emmm…懂的都懂。 教育授权申请地址：https://www.jetbrains.com/shop/eform/students 一个Java程序并不是一个人的战斗，我们可以在别人开发的基础上继续向上开发，其他的开发者可以将自己编写的Java代码打包为jar，我们只需要导入这个jar作为依赖，即可直接使用别人的代码，就像我们直接去使用JDK提供的类一样。 使用JDBC连接数据库注意：6.0版本以上，不用手动加载驱动，我们直接使用即可！ 1234567891011121314//1. 通过DriverManager来获得数据库连接try (Connection connection = DriverManager.getConnection(\"连接URL\",\"用户名\",\"密码\"); //2. 创建一个用于执行SQL的Statement对象 Statement statement = connection.createStatement()){ //注意前两步都放在try()中，因为在最后需要释放资源！ //3. 执行SQL语句，并得到结果集 ResultSet set = statement.executeQuery(\"select * from 表名\"); //4. 查看结果 while (set.next()){ ... }}catch (SQLException e){ e.printStackTrace();}//5. 释放资源，try-with-resource语法会自动帮助我们close 其中，连接的URL如果记不住格式，我们可以打开idea的数据库连接配置，复制一份即可。（其实idea本质也是使用的JDBC，整个idea程序都是由Java编写的，实际上idea就是一个Java程序） 了解DriverManager我们首先来了解一下DriverManager是什么东西，它其实就是管理我们的数据库驱动的： 123456789101112131415public static synchronized void registerDriver(java.sql.Driver driver, DriverAction da) throws SQLException { /* Register the driver if it has not already been added to our list */ if(driver != null) { registeredDrivers.addIfAbsent(new DriverInfo(driver, da)); //在刚启动时，mysql实现的驱动会被加载，我们可以断点调试一下。 } else { // This is for compatibility with the original DriverManager throw new NullPointerException(); } println(\"registerDriver: \" + driver);} 我们可以通过调用getConnection()来进行数据库的链接： 1234567891011121314@CallerSensitivepublic static Connection getConnection(String url, String user, String password) throws SQLException { java.util.Properties info = new java.util.Properties(); if (user != null) { info.put(\"user\", user); } if (password != null) { info.put(\"password\", password); } return (getConnection(url, info, Reflection.getCallerClass())); //内部有实现} 我们可以手动为驱动管理器添加一个日志打印： 123static { DriverManager.setLogWriter(new PrintWriter(System.out)); //这里直接设定为控制台输出} 现在我们执行的数据库操作日志会在控制台实时打印。 了解ConnectionConnection是数据库的连接对象，可以通过连接对象来创建一个Statement用于执行SQL语句： 1Statement createStatement() throws SQLException; 我们发现除了普通的Statement，还存在PreparedStatement： 12PreparedStatement prepareStatement(String sql) throws SQLException; 在后面我们会详细介绍PreparedStatement的使用，它能够有效地预防SQL注入式攻击。 它还支持事务的处理，也放到后面来详细进行讲解。 了解Statement我们发现，我们之前使用了executeQuery()方法来执行select语句，此方法返回给我们一个ResultSet对象，查询得到的数据，就存放在ResultSet中！ Statement除了执行这样的DQL语句外，我们还可以使用executeUpdate()方法来执行一个DML或是DDL语句，它会返回一个int类型，表示执行后受影响的行数，可以通过它来判断DML语句是否执行成功。 也可以通过excute()来执行任意的SQL语句，它会返回一个boolean来表示执行结果是一个ResultSet还是一个int，我们可以通过使用getResultSet()或是getUpdateCount()来获取。 执行DML操作我们通过几个例子来向数据库中插入数据。 执行DQL操作执行DQL操作会返回一个ResultSet对象，我们来看看如何从ResultSet中去获取数据： 1234//首先要明确，select返回的数据类似于一个excel表格while (set.next()){ //每调用一次next()就会向下移动一行，首次调用会移动到第一行} 我们在移动行数后，就可以通过set中提供的方法，来获取每一列的数据。 执行批处理操作当我们要执行很多条语句时，可以不用一次一次地提交，而是一口气全部交给数据库处理，这样会节省很多的时间。 123456789101112public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(); Statement statement = connection.createStatement()){ statement.addBatch(\"insert into user values ('f', 1234)\"); statement.addBatch(\"insert into user values ('e', 1234)\"); //添加每一条批处理语句 statement.executeBatch(); //一起执行 }catch (SQLException e){ e.printStackTrace(); }} 将查询结果映射为对象既然我们现在可以从数据库中获取数据了，那么现在就可以将这些数据转换为一个类来进行操作，首先定义我们的实体类： 123456789101112131415public class Student { Integer sid; String name; String sex; public Student(Integer sid, String name, String sex) { this.sid = sid; this.name = name; this.sex = sex; } public void say(){ System.out.println(\"我叫：\"+name+\"，学号为：\"+sid+\"，我的性别是：\"+sex); }} 现在我们来进行一个转换： 1234while (set.next()){ Student student = new Student(set.getInt(1), set.getString(2), set.getString(3)); student.say();} 注意：列的下标是从1开始的。 我们也可以利用反射机制来将查询结果映射为对象，使用反射的好处是，无论什么类型都可以通过我们的方法来进行实体类型映射： 12345678910111213141516private static &lt;T&gt; T convert(ResultSet set, Class&lt;T&gt; clazz){ try { Constructor&lt;T&gt; constructor = clazz.getConstructor(clazz.getConstructors()[0].getParameterTypes()); //默认获取第一个构造方法 Class&lt;?&gt;[] param = constructor.getParameterTypes(); //获取参数列表 Object[] object = new Object[param.length]; //存放参数 for (int i = 0; i &lt; param.length; i++) { //是从1开始的 object[i] = set.getObject(i+1); if(object[i].getClass() != param[i]) throw new SQLException(\"错误的类型转换：\"+object[i].getClass()+\" -&gt; \"+param[i]); } return constructor.newInstance(object); } catch (ReflectiveOperationException | SQLException e) { e.printStackTrace(); return null; }} 现在我们就可以通过我们的方法来将查询结果转换为一个对象了： 1234while (set.next()){ Student student = convert(set, Student.class); if(student != null) student.say();} 实际上，在后面我们会学习Mybatis框架，它对JDBC进行了深层次的封装，而它就进行类似上面反射的操作来便于我们对数据库数据与实体类的转换。 实现登陆与SQL注入攻击在使用之前，我们先来看看如果我们想模拟登陆一个用户，我们该怎么去写： 1234567891011try (Connection connection = DriverManager.getConnection(\"URL\",\"用户名\",\"密码\"); Statement statement = connection.createStatement(); Scanner scanner = new Scanner(System.in)){ ResultSet res = statement.executeQuery(\"select * from user where username='\"+scanner.nextLine()+\"'and pwd='\"+scanner.nextLine()+\"';\"); while (res.next()){ String username = res.getString(1); System.out.println(username+\" 登陆成功！\"); }}catch (SQLException e){ e.printStackTrace();} 用户可以通过自己输入用户名和密码来登陆，乍一看好像没啥问题，那如果我输入的是以下内容呢： 123Test1111' or 1=1; -- # Test 登陆成功！ 1=1一定是true，那么我们原本的SQL语句会变为： 1select * from user where username='Test' and pwd='1111' or 1=1; -- ' 我们发现，如果允许这样的数据插入，那么我们原有的SQL语句结构就遭到了破坏，使得用户能够随意登陆别人的账号。因此我们可能需要限制用户的输入来防止用户输入一些SQL语句关键字，但是关键字非常多，这并不是解决问题的最好办法。 使用PreparedStatement我们发现，如果单纯地使用Statement来执行SQL命令，会存在严重的SQL注入攻击漏洞！而这种问题，我们可以使用PreparedStatement来解决： 1234567891011121314151617public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(\"URL\",\"用户名\",\"密码\"); PreparedStatement statement = connection.prepareStatement(\"select * from user where username= ? and pwd=?;\"); Scanner scanner = new Scanner(System.in)){ statement.setString(1, scanner.nextLine()); statement.setString(2, scanner.nextLine()); System.out.println(statement); //打印查看一下最终执行的 ResultSet res = statement.executeQuery(); while (res.next()){ String username = res.getString(1); System.out.println(username+\" 登陆成功！\"); } }catch (SQLException e){ e.printStackTrace(); }} 我们发现，我们需要提前给到PreparedStatement一个SQL语句，并且使用?作为占位符，它会预编译一个SQL语句，通过直接将我们的内容进行替换的方式来填写数据。使用这种方式，我们之前的例子就失效了！我们来看看实际执行的SQL语句是什么： 1com.mysql.cj.jdbc.ClientPreparedStatement: select * from user where username= 'Test' and pwd='123456'' or 1=1; -- '; 我们发现，我们输入的参数一旦出现'时，会被变为转义形式\\'，而最外层有一个真正的'来将我们输入的内容进行包裹，因此它能够有效地防止SQL注入攻击！ 管理事务JDBC默认的事务处理行为是自动提交，所以前面我们执行一个SQL语句就会被直接提交（相当于没有启动事务），所以JDBC需要进行事务管理时，首先要通过Connection对象调用setAutoCommit(false) 方法, 将SQL语句的提交（commit）由驱动程序转交给应用程序负责。 12345con.setAutoCommit(); //关闭自动提交后相当于开启事务。// SQL语句// SQL语句// SQL语句con.commit();或 con.rollback(); 一旦关闭自动提交，那么现在执行所有的操作如果在最后不进行commit()来提交事务的话，那么所有的操作都会丢失，只有提交之后，所有的操作才会被保存！也可以使用rollback()来手动回滚之前的全部操作！ 1234567891011121314public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(\"URL\",\"用户名\",\"密码\"); Statement statement = connection.createStatement()){ connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(\"insert into user values ('a', 1234)\"); statement.executeUpdate(\"insert into user values ('b', 1234)\"); statement.executeUpdate(\"insert into user values ('c', 1234)\"); connection.commit(); //如果前面任何操作出现异常，将不会执行commit()，之前的操作也就不会生效 }catch (SQLException e){ e.printStackTrace(); }} 我们来接着尝试一下使用回滚操作： 123456789101112131415161718public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(\"URL\",\"用户名\",\"密码\"); Statement statement = connection.createStatement()){ connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(\"insert into user values ('a', 1234)\"); statement.executeUpdate(\"insert into user values ('b', 1234)\"); connection.rollback(); //回滚，撤销前面全部操作 statement.executeUpdate(\"insert into user values ('c', 1234)\"); connection.commit(); //提交事务（注意，回滚之前的内容都没了） }catch (SQLException e){ e.printStackTrace(); }} 同样的，我们也可以去创建一个回滚点来实现定点回滚： 1234567891011121314151617181920public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(\"URL\",\"用户名\",\"密码\"); Statement statement = connection.createStatement()){ connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(\"insert into user values ('a', 1234)\"); Savepoint savepoint = connection.setSavepoint(); //创建回滚点 statement.executeUpdate(\"insert into user values ('b', 1234)\"); connection.rollback(savepoint); //回滚到回滚点，撤销前面全部操作 statement.executeUpdate(\"insert into user values ('c', 1234)\"); connection.commit(); //提交事务（注意，回滚之前的内容都没了） }catch (SQLException e){ e.printStackTrace(); }} 通过开启事务，我们就可以更加谨慎地进行一些操作了，如果我们想从事务模式切换为原有的自动提交模式，我们可以直接将其设置回去： 12345678910111213public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(\"URL\",\"用户名\",\"密码\"); Statement statement = connection.createStatement()){ connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(\"insert into user values ('a', 1234)\"); connection.setAutoCommit(true); //重新开启自动提交，开启时把之前的事务模式下的内容给提交了 statement.executeUpdate(\"insert into user values ('d', 1234)\"); //没有commit也成功了！ }catch (SQLException e){ e.printStackTrace(); } 通过学习JDBC，我们现在就可以通过Java来访问和操作我们的数据库了！为了更好地衔接，我们还会接着讲解主流持久层框架——Mybatis，加深JDBC的记忆。 使用Lombok我们发现，在以往编写项目时，尤其是在类进行类内部成员字段封装时，需要编写大量的get/set方法，这不仅使得我们类定义中充满了get和set方法，同时如果字段名称发生改变，又要挨个进行修改，甚至当字段变得很多时，构造方法的编写会非常麻烦！ 通过使用Lombok（小辣椒）就可以解决这样的问题！ 我们来看看，使用原生方式和小辣椒方式编写类的区别，首先是传统方式： 1234567891011121314151617181920212223242526272829303132333435public class Student { private Integer sid; private String name; private String sex; public Student(Integer sid, String name, String sex) { this.sid = sid; this.name = name; this.sex = sex; } public Integer getSid() { //长！ return sid; } public void setSid(Integer sid) { //到！ this.sid = sid; } public String getName() { //爆！ return name; } public void setName(String name) { //炸！ this.name = name; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; }} 而使用Lombok之后： 12345678@Getter@Setter@AllArgsConstructorpublic class Student { private Integer sid; private String name; private String sex;} 我们发现，使用Lombok之后，只需要添加几个注解，就能够解决掉我们之前长长的一串代码！ 配置Lombok 首先我们需要导入Lombok的jar依赖，和jdbc依赖是一样的，放在项目目录下直接导入就行了。可以在这里进行下载：https://projectlombok.org/download 然后我们要安装一下Lombok插件，由于IDEA默认都安装了Lombok的插件，因此直接导入依赖后就可以使用了。 重启IDEA Lombok是一种插件化注解API，是通过添加注解来实现的，然后在javac进行编译的时候，进行处理。 Java的编译过程可以分成三个阶段： 所有源文件会被解析成语法树。 调用注解处理器。如果注解处理器产生了新的源文件，新文件也要进行编译。 最后，语法树会被分析并转化成类文件。 实际上在上述的第二阶段，会执行*lombok.core.AnnotationProcessor*，它所做的工作就是我们上面所说的，修改语法树。 使用Lombok我们通过实战来演示一下Lombok的实用注解： 我们通过添加@Getter和@Setter来为当前类的所有字段生成get/set方法，他们可以添加到类或是字段上，注意静态字段不会生成，final字段无法生成set方法。 我们还可以使用@Accessors来控制生成Getter和Setter的样式。 我们通过添加@ToString来为当前类生成预设的toString方法。 我们可以通过添加@EqualsAndHashCode来快速生成比较和哈希值方法。 我们可以通过添加@AllArgsConstructor和@NoArgsConstructor来快速生成全参构造和无参构造。 我们可以添加@RequiredArgsConstructor来快速生成参数只包含final或被标记为@NonNull的成员字段。 使用@Data能代表@Setter、@Getter、@RequiredArgsConstructor、@ToString、@EqualsAndHashCode全部注解。 一旦使用@Data就不建议此类有继承关系，因为equal方法可能不符合预期结果（尤其是仅比较子类属性）。 使用@Value与@Data类似，但是并不会生成setter并且成员属性都是final的。 使用@SneakyThrows来自动生成try-catch代码块。 使用@Cleanup作用与局部变量，在最后自动调用其close()方法（可以自由更换） 使用@Builder来快速生成建造者模式。 通过使用@Builder.Default来指定默认值。 通过使用@Builder.ObtainVia来指定默认值的获取方式。 认识Mybatis在前面JDBC的学习中，虽然我们能够通过JDBC来连接和操作数据库，但是哪怕只是完成一个SQL语句的执行，都需要编写大量的代码，更不用说如果我还需要进行实体类映射，将数据转换为我们可以直接操作的实体类型，JDBC很方便，但是还不够方便，我们需要一种更加简洁高效的方式来和数据库进行交互。 再次强调：学习厉害的框架或是厉害的技术，并不是为了一定要去使用它，而是它们能够使得我们在不同的开发场景下，合理地使用这些技术，以灵活地应对需要解决的问题。 MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。 我们依然使用传统的jar依赖方式，从最原始开始讲起，不使用Maven，有关Maven内容我们会在后面统一讲解！全程围绕官方文档讲解！ 这一块内容很多很杂，再次强调要多实践！ XML语言概述在开始介绍Mybatis之前，XML语言发明最初是用于数据的存储和传输，它可以长这样： 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;outer&gt; &lt;name&gt;阿伟&lt;/name&gt; &lt;desc&gt;怎么又在玩电动啊&lt;/desc&gt; &lt;inner type=\"1\"&gt; &lt;age&gt;10&lt;/age&gt; &lt;sex&gt;男&lt;/sex&gt; &lt;/inner&gt;&lt;/outer&gt; 如果你学习过前端知识，你会发现它和HTML几乎长得一模一样！但是请注意，虽然它们长得差不多，但是他们的意义却不同，HTML主要用于通过编排来展示数据，而XML主要是存放数据，它更像是一个配置文件！当然，浏览器也是可以直接打开XML文件的。 一个XML文件存在以下的格式规范： 必须存在一个根节点，将所有的子标签全部包含。 可以但不必须包含一个头部声明（主要是可以设定编码格式） 所有的标签必须成对出现，可以嵌套但不能交叉嵌套 区分大小写。 标签中可以存在属性，比如上面的type=\"1\"就是inner标签的一个属性，属性的值由单引号或双引号包括。 XML文件也可以使用注释： 12&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!-- 注释内容 --&gt; 通过IDEA我们可以使用Ctrl+/来快速添加注释文本（不仅仅适用于XML，还支持很多种类型的文件） 那如果我们的内容中出现了&lt;或是&gt;字符，那该怎么办呢？我们就可以使用XML的转义字符来代替： 如果嫌一个一个改太麻烦，也可以使用CD来快速创建不解析区域： 123&lt;test&gt; &lt;name&gt;&lt;![CDATA[我看你&lt;&gt;&lt;&gt;&lt;&gt;是一点都不懂哦&gt;&gt;&gt;]]&gt;&lt;/name&gt;&lt;/test&gt; 那么，我们现在了解了XML文件的定义，现在该如何去解析一个XML文件呢？比如我们希望将定义好的XML文件读取到Java程序中，这时该怎么做呢？ JDK为我们内置了一个叫做org.w3c的XML解析库，我们来看看如何使用它来进行XML文件内容解析： 12345678910111213141516171819202122// 创建DocumentBuilderFactory对象DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();// 创建DocumentBuilder对象try { DocumentBuilder builder = factory.newDocumentBuilder(); Document d = builder.parse(\"file:mappers/test.xml\"); // 每一个标签都作为一个节点 NodeList nodeList = d.getElementsByTagName(\"test\"); // 可能有很多个名字为test的标签 Node rootNode = nodeList.item(0); // 获取首个 NodeList childNodes = rootNode.getChildNodes(); // 一个节点下可能会有很多个节点，比如根节点下就囊括了所有的节点 //节点可以是一个带有内容的标签（它内部就还有子节点），也可以是一段文本内容 for (int i = 0; i &lt; childNodes.getLength(); i++) { Node child = childNodes.item(i); if(child.getNodeType() == Node.ELEMENT_NODE) //过滤换行符之类的内容，因为它们都被认为是一个文本节点 System.out.println(child.getNodeName() + \"：\" +child.getFirstChild().getNodeValue()); // 输出节点名称，也就是标签名称，以及标签内部的文本（内部的内容都是子节点，所以要获取内部的节点） }} catch (Exception e) { e.printStackTrace();} 当然，学习和使用XML只是为了更好地去认识Mybatis的工作原理，以及如何使用XML来作为Mybatis的配置文件，这是在开始之前必须要掌握的内容（使用Java读取XML内容不要求掌握，但是需要知道Mybatis就是通过这种方式来读取配置文件的） 不仅仅是Mybatis，包括后面的Spring等众多框架都会用到XML来作为框架的配置文件！ 初次使用Mybatis那么我们首先来感受一下Mybatis给我们带来的便捷，就从搭建环境开始，中文文档网站：https://mybatis.org/mybatis-3/zh/configuration.html 我们需要导入Mybatis的依赖，Jar包需要在github上下载，如果卡得一匹，连不上可以在视频简介处从分享的文件中获取。同样地放入到项目的根目录下，右键作为依赖即可！（依赖变多之后，我们可以将其放到一个单独的文件夹，不然会很繁杂） 依赖导入完成后，我们就可以编写Mybatis的配置文件了（现在不是在Java代码中配置了，而是通过一个XML文件去配置，这样就使得硬编码的部分大大减少，项目后期打包成Jar运行不方便修复，但是通过配置文件，我们随时都可以去修改，就变得很方便了，同时代码量也大幅度减少，配置文件填写完成后，我们只需要关心项目的业务逻辑而不是如何去读取配置文件）我们按照官方文档给定的提示，在项目根目录下新建名为mybatis-config.xml的文件，并填写以下内容： 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"${驱动类（含包名）}\"/&gt; &lt;property name=\"url\" value=\"${数据库连接URL}\"/&gt; &lt;property name=\"username\" value=\"${用户名}\"/&gt; &lt;property name=\"password\" value=\"${密码}\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 我们发现，在最上方还引入了一个叫做DTD（文档类型定义）的东西，它提前帮助我们规定了一些标签，我们就需要使用Mybatis提前帮助我们规定好的标签来进行配置（因为只有这样Mybatis才能正确识别我们配置的内容） 通过进行配置，我们就告诉了Mybatis我们链接数据库的一些信息，包括URL、用户名、密码等，这样Mybatis就知道该链接哪个数据库、使用哪个账号进行登陆了（也可以不使用配置文件，这里不做讲解，还请各位小伙伴自行阅读官方文档） 配置文件完成后，我们需要在Java程序启动时，让Mybatis对配置文件进行读取并得到一个SqlSessionFactory对象： 123456public static void main(String[] args) throws FileNotFoundException { SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(new FileInputStream(\"mybatis-config.xml\")); try (SqlSession sqlSession = sqlSessionFactory.openSession(true)){ //暂时还没有业务 }} 直接运行即可，虽然没有干什么事情，但是不会出现错误，如果之前的配置文件编写错误，直接运行会产生报错！那么现在我们来看看，SqlSessionFactory对象是什么东西： 每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的，我们可以通过SqlSessionFactory来创建多个新的会话，SqlSession对象，每个会话就相当于我不同的地方登陆一个账号去访问数据库，你也可以认为这就是之前JDBC中的Statement对象，会话之间相互隔离，没有任何关联。 而通过SqlSession就可以完成几乎所有的数据库操作，我们发现这个接口中定义了大量数据库操作的方法，因此，现在我们只需要通过一个对象就能完成数据库交互了，极大简化了之前的流程。 我们来尝试一下直接读取实体类，读取实体类肯定需要一个映射规则，比如类中的哪个字段对应数据库中的哪个字段，在查询语句返回结果后，Mybatis就会自动将对应的结果填入到对象的对应字段上。首先编写实体类，，直接使用Lombok是不是就很方便了： 12345678import lombok.Data;@Datapublic class Student { int sid; //名称最好和数据库字段名称保持一致，不然可能会映射失败导致查询结果丢失 String name; String sex;} 在根目录下重新创建一个mapper文件夹，新建名为TestMapper.xml的文件作为我们的映射器，并填写以下内容： 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"TestMapper\"&gt; &lt;select id=\"selectStudent\" resultType=\"com.test.entity.Student\"&gt; select * from student &lt;/select&gt;&lt;/mapper&gt; 其中namespace就是命名空间，每个Mapper都是唯一的，因此需要用一个命名空间来区分，它还可以用来绑定一个接口。我们在里面写入了一个select标签，表示添加一个select操作，同时id作为操作的名称，resultType指定为我们刚刚定义的实体类，表示将数据库结果映射为Student类，然后就在标签中写入我们的查询语句即可。 编写好后，我们在配置文件中添加这个Mapper映射器： 1234&lt;mappers&gt; &lt;mapper url=\"file:mappers/TestMapper.xml\"/&gt; &lt;!-- 这里用的是url，也可以使用其他类型，我们会在后面讲解 --&gt;&lt;/mappers&gt; 最后在程序中使用我们定义好的Mapper即可： 1234567public static void main(String[] args) throws FileNotFoundException { SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(new FileInputStream(\"mybatis-config.xml\")); try (SqlSession sqlSession = sqlSessionFactory.openSession(true)){ List&lt;Student&gt; student = sqlSession.selectList(\"selectStudent\"); student.forEach(System.out::println); }} 我们会发现，Mybatis非常智能，我们只需要告诉一个映射关系，就能够直接将查询结果转化为一个实体类！ 配置Mybatis在了解了Mybatis为我们带来的便捷之后，现在我们就可以正式地去学习使用Mybatis了！ 由于SqlSessionFactory一般只需要创建一次，因此我们可以创建一个工具类来集中创建SqlSession，这样会更加方便一些： 123456789101112131415161718192021public class MybatisUtil { //在类加载时就进行创建 private static SqlSessionFactory sqlSessionFactory; static { try { sqlSessionFactory = new SqlSessionFactoryBuilder().build(new FileInputStream(\"mybatis-config.xml\")); } catch (FileNotFoundException e) { e.printStackTrace(); } } /** * 获取一个新的会话 * @param autoCommit 是否开启自动提交（跟JDBC是一样的，如果不自动提交，则会变成事务操作） * @return SqlSession对象 */ public static SqlSession getSession(boolean autoCommit){ return sqlSessionFactory.openSession(autoCommit); }} 现在我们只需要在main方法中这样写即可查询结果了： 123456public static void main(String[] args) { try (SqlSession sqlSession = MybatisUtil.getSession(true)){ List&lt;Student&gt; student = sqlSession.selectList(\"selectStudent\"); student.forEach(System.out::println); }} 之前我们演示了，如何创建一个映射器来将结果快速转换为实体类，但是这样可能还是不够方便，我们每次都需要去找映射器对应操作的名称，而且还要知道对应的返回类型，再通过SqlSession来执行对应的方法，能不能再方便一点呢？ 现在，我们可以通过namespace来绑定到一个接口上，利用接口的特性，我们可以直接指明方法的行为，而实际实现则是由Mybatis来完成。 123public interface TestMapper { List&lt;Student&gt; selectStudent();} 将Mapper文件的命名空间修改为我们的接口，建议同时将其放到同名包中，作为内部资源： 12345&lt;mapper namespace=\"com.test.mapper.TestMapper\"&gt; &lt;select id=\"selectStudent\" resultType=\"com.test.entity.Student\"&gt; select * from student &lt;/select&gt;&lt;/mapper&gt; 作为内部资源后，我们需要修改一下配置文件中的mapper定义，不使用url而是resource表示是Jar内部的文件： 123&lt;mappers&gt; &lt;mapper resource=\"com/test/mapper/TestMapper.xml\"/&gt;&lt;/mappers&gt; 现在我们就可以直接通过SqlSession获取对应的实现类，通过接口中定义的行为来直接获取结果： 1234567public static void main(String[] args) { try (SqlSession sqlSession = MybatisUtil.getSession(true)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); List&lt;Student&gt; student = testMapper.selectStudent(); student.forEach(System.out::println); }} 那么肯定有人好奇，TestMapper明明是一个我们自己定义接口啊，Mybatis也不可能提前帮我们写了实现类啊，那这接口怎么就出现了一个实现类呢？我们可以通过调用getClass()方法来看看实现类是个什么： 12TestMapper testMapper = sqlSession.getMapper(TestMapper.class);System.out.println(testMapper.getClass()); 我们发现，实现类名称很奇怪，名称为com.sun.proxy.$Proxy4，它是通过动态代理生成的，相当于动态生成了一个实现类，而不是预先定义好的，有关Mybatis这一部分的原理，我们放在最后一节进行讲解。 接下来，我们再来看配置文件，之前我们并没有对配置文件进行一个详细的介绍： 12345678910111213141516&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/study\"/&gt; &lt;property name=\"username\" value=\"test\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"com/test/mapper/TestMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 首先就从environments标签说起，一般情况下，我们在开发中，都需要指定一个数据库的配置信息，包含连接URL、用户、密码等信息，而environment就是用于进行这些配置的！实际情况下可能会不止有一个数据库连接信息，比如开发过程中我们一般会使用本地的数据库，而如果需要将项目上传到服务器或是防止其他人的电脑上运行时，我们可能就需要配置另一个数据库的信息，因此，我们可以提前定义好所有的数据库信息，该什么时候用什么即可！ 在environments标签上有一个default属性，来指定默认的环境，当然如果我们希望使用其他环境，可以修改这个默认环境，也可以在创建工厂时选择环境： 12sqlSessionFactory = new SqlSessionFactoryBuilder() .build(new FileInputStream(\"mybatis-config.xml\"), \"环境ID\"); 我们还可以给类型起一个别名，以简化Mapper的编写： 1234&lt;!-- 需要在environments的上方 --&gt;&lt;typeAliases&gt; &lt;typeAlias type=\"com.test.entity.Student\" alias=\"Student\"/&gt;&lt;/typeAliases&gt; 现在Mapper就可以直接使用别名了： 12345&lt;mapper namespace=\"com.test.mapper.TestMapper\"&gt; &lt;select id=\"selectStudent\" resultType=\"Student\"&gt; select * from student &lt;/select&gt;&lt;/mapper&gt; 如果这样还是很麻烦，我们也可以直接让Mybatis去扫描一个包，并将包下的所有类自动起别名（别名为首字母小写的类名） 123&lt;typeAliases&gt; &lt;package name=\"com.test.entity\"/&gt;&lt;/typeAliases&gt; 也可以为指定实体类添加一个注解，来指定别名： 1234567@Data@Alias(\"lbwnb\")public class Student { private int sid; private String name; private String sex;} 当然，Mybatis也包含许多的基础配置，通过使用： 123&lt;settings&gt; &lt;setting name=\"\" value=\"\"/&gt;&lt;/settings&gt; 所有的配置项可以在中文文档处查询，本文不会进行详细介绍，在后面我们会提出一些比较重要的配置项。 有关配置文件的介绍就暂时到这里为止，我们讨论的重心应该是Mybatis的应用，而不是配置文件，所以省略了一部分内容的讲解。 增删改查在了解了Mybatis的一些基本配置之后，我们就可以正式来使用Mybatis来进行数据库操作了！ 在前面我们演示了如何快速进行查询，我们只需要编写一个对应的映射器既可以了： 12345&lt;mapper namespace=\"com.test.mapper.TestMapper\"&gt; &lt;select id=\"studentList\" resultType=\"Student\"&gt; select * from student &lt;/select&gt;&lt;/mapper&gt; 当然，如果你不喜欢使用实体类，那么这些属性还可以被映射到一个Map上： 123&lt;select id=\"selectStudent\" resultType=\"Map\"&gt; select * from student&lt;/select&gt; 123public interface TestMapper { List&lt;Map&gt; selectStudent();} Map中就会以键值对的形式来存放这些结果了。 通过设定一个resultType属性，让Mybatis知道查询结果需要映射为哪个实体类，要求字段名称保持一致。那么如果我们不希望按照这样的规则来映射呢？我们可以自定义resultMap来设定映射规则： 12345&lt;resultMap id=\"Test\" type=\"Student\"&gt; &lt;result column=\"sid\" property=\"sid\"/&gt; &lt;result column=\"sex\" property=\"name\"/&gt; &lt;result column=\"name\" property=\"sex\"/&gt;&lt;/resultMap&gt; 通过指定映射规则，我们现在名称和性别一栏就发生了交换，因为我们将其映射字段进行了交换。 如果一个类中存在多个构造方法，那么很有可能会出现这样的错误： 123456789### Exception in thread \"main\" org.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: org.apache.ibatis.executor.ExecutorException: No constructor found in com.test.entity.Student matching [java.lang.Integer, java.lang.String, java.lang.String]### The error may exist in com/test/mapper/TestMapper.xml### The error may involve com.test.mapper.TestMapper.getStudentBySid### The error occurred while handling results### SQL: select * from student where sid = ?### Cause: org.apache.ibatis.executor.ExecutorException: No constructor found in com.test.entity.Student matching [java.lang.Integer, java.lang.String, java.lang.String] at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:30) ... 这时就需要使用constructor标签来指定构造方法： 123456&lt;resultMap id=\"test\" type=\"Student\"&gt; &lt;constructor&gt; &lt;arg column=\"sid\" javaType=\"Integer\"/&gt; &lt;arg column=\"name\" javaType=\"String\"/&gt; &lt;/constructor&gt;&lt;/resultMap&gt; 值得注意的是，指定构造方法后，若此字段被填入了构造方法作为参数，将不会通过反射给字段单独赋值，而构造方法中没有传入的字段，依然会被反射赋值，有关resultMap的内容，后面还会继续讲解。 如果数据库中存在一个带下划线的字段，我们可以通过设置让其映射为以驼峰命名的字段，比如my_test映射为myTest 123&lt;settings&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt;&lt;/settings&gt; 如果不设置，默认为不开启，也就是默认需要名称保持一致。 我们接着来看看条件查询，既然是条件查询，那么肯定需要我们传入查询条件，比如现在我们想通过sid字段来通过学号查找信息： 1Student getStudentBySid(int sid); 123&lt;select id=\"getStudentBySid\" parameterType=\"int\" resultType=\"Student\"&gt; select * from student where sid = #{sid}&lt;/select&gt; 我们通过使用#{xxx}或是${xxx}来填入我们给定的属性，实际上Mybatis本质也是通过PreparedStatement首先进行一次预编译，有效地防止SQL注入问题，但是如果使用${xxx}就不再是通过预编译，而是直接传值，因此我们一般都使用#{xxx}来进行操作。 使用parameterType属性来指定参数类型（非必须，可以不用，推荐不用） 接着我们来看插入、更新和删除操作，其实与查询操作差不多，不过需要使用对应的标签，比如插入操作： 123&lt;insert id=\"addStudent\" parameterType=\"Student\"&gt; insert into student(name, sex) values(#{name}, #{sex})&lt;/insert&gt; 1int addStudent(Student student); 我们这里使用的是一个实体类，我们可以直接使用实体类里面对应属性替换到SQL语句中，只需要填写属性名称即可，和条件查询是一样的。 复杂查询一个老师可以教授多个学生，那么能否一次性将老师的学生全部映射给此老师的对象呢，比如： 123456@Datapublic class Teacher { int tid; String name; List&lt;Student&gt; studentList;} 映射为Teacher对象时，同时将其教授的所有学生一并映射为List列表，显然这是一种一对多的查询，那么这时就需要进行复杂查询了。而我们之前编写的都非常简单，直接就能完成映射，因此我们现在需要使用resultMap来自定义映射规则： 1234567891011121314&lt;select id=\"getTeacherByTid\" resultMap=\"asTeacher\"&gt; select *, teacher.name as tname from student inner join teach on student.sid = teach.sid inner join teacher on teach.tid = teacher.tid where teach.tid = #{tid}&lt;/select&gt;&lt;resultMap id=\"asTeacher\" type=\"Teacher\"&gt; &lt;id column=\"tid\" property=\"tid\"/&gt; &lt;result column=\"tname\" property=\"name\"/&gt; &lt;collection property=\"studentList\" ofType=\"Student\"&gt; &lt;id property=\"sid\" column=\"sid\"/&gt; &lt;result column=\"name\" property=\"name\"/&gt; &lt;result column=\"sex\" property=\"sex\"/&gt; &lt;/collection&gt;&lt;/resultMap&gt; 可以看到，我们的查询结果是一个多表联查的结果，而联查的数据就是我们需要映射的数据（比如这里是一个老师有N个学生，联查的结果也是这一个老师对应N个学生的N条记录），其中id标签用于在多条记录中辨别是否为同一个对象的数据，比如上面的查询语句得到的结果中，tid这一行始终为1，因此所有的记录都应该是tid=1的教师的数据，而不应该变为多个教师的数据，如果不加id进行约束，那么会被识别成多个教师的数据！ 通过使用collection来表示将得到的所有结果合并为一个集合，比如上面的数据中每个学生都有单独的一条记录，因此tid相同的全部学生的记录就可以最后合并为一个List，得到最终的映射结果，当然，为了区分，最好也设置一个id，只不过这个例子中可以当做普通的result使用。 了解了一对多，那么多对一又该如何查询呢，比如每个学生都有一个对应的老师，现在Student新增了一个Teacher对象，那么现在又该如何去处理呢？ 1234567891011121314@Data@Accessors(chain = true)public class Student { private int sid; private String name; private String sex; private Teacher teacher;}@Datapublic class Teacher { int tid; String name;} 现在我们希望的是，每次查询到一个Student对象时都带上它的老师，同样的，我们也可以使用resultMap来实现（先修改一下老师的类定义，不然会很麻烦）： 12345678910111213&lt;resultMap id=\"test2\" type=\"Student\"&gt; &lt;id column=\"sid\" property=\"sid\"/&gt; &lt;result column=\"name\" property=\"name\"/&gt; &lt;result column=\"sex\" property=\"sex\"/&gt; &lt;association property=\"teacher\" javaType=\"Teacher\"&gt; &lt;id column=\"tid\" property=\"tid\"/&gt; &lt;result column=\"tname\" property=\"name\"/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=\"selectStudent\" resultMap=\"test2\"&gt; select *, teacher.name as tname from student left join teach on student.sid = teach.sid left join teacher on teach.tid = teacher.tid&lt;/select&gt; 通过使用association进行关联，形成多对一的关系，实际上和一对多是同理的，都是对查询结果的一种处理方式罢了。 事务操作我们可以在获取SqlSession关闭自动提交来开启事务模式，和JDBC其实都差不多： 123456789public static void main(String[] args) { try (SqlSession sqlSession = MybatisUtil.getSession(false)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); testMapper.addStudent(new Student().setSex(\"男\").setName(\"小王\")); testMapper.selectStudent().forEach(System.out::println); }} 我们发现，在关闭自动提交后，我们的内容是没有进入到数据库的，现在我们来试一下在最后提交事务： 1sqlSession.commit(); 在事务提交后，我们的内容才会被写入到数据库中。现在我们来试试看回滚操作： 123456789try (SqlSession sqlSession = MybatisUtil.getSession(false)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); testMapper.addStudent(new Student().setSex(\"男\").setName(\"小王\")); testMapper.selectStudent().forEach(System.out::println); sqlSession.rollback(); sqlSession.commit();} 回滚操作也印证成功。 动态SQL动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。 我们直接使用官网的例子进行讲解。 缓存机制MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。 其实缓存机制我们在之前学习IO流的时候已经提及过了，我们可以提前将一部分内容放入缓存，下次需要获取数据时，我们就可以直接从缓存中读取，这样的话相当于直接从内存中获取而不是再去向数据库索要数据，效率会更高。 因此Mybatis内置了一个缓存机制，我们查询时，如果缓存中存在数据，那么我们就可以直接从缓存中获取，而不是再去向数据库进行请求。 Mybatis存在一级缓存和二级缓存，我们首先来看一下一级缓存，默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存（一级缓存无法关闭，只能调整），我们来看看下面这段代码： 12345678public static void main(String[] args) throws InterruptedException { try (SqlSession sqlSession = MybatisUtil.getSession(true)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); Student student1 = testMapper.getStudentBySid(1); Student student2 = testMapper.getStudentBySid(1); System.out.println(student1 == student2); }} 我们发现，两次得到的是同一个Student对象，也就是说我们第二次查询并没有重新去构造对象，而是直接得到之前创建好的对象。如果还不是很明显，我们可以修改一下实体类： 123456789101112@Data@Accessors(chain = true)public class Student { public Student(){ System.out.println(\"我被构造了\"); } private int sid; private String name; private String sex;} 我们通过前面的学习得知Mybatis在映射为对象时，在只有一个构造方法的情况下，无论你构造方法写成什么样子，都会去调用一次构造方法，如果存在多个构造方法，那么就会去找匹配的构造方法。我们可以通过查看构造方法来验证对象被创建了几次。 结果显而易见，只创建了一次，也就是说当第二次进行同样的查询时，会直接使用第一次的结果，因为第一次的结果已经被缓存了。 那么如果我修改了数据库中的内容，缓存还会生效吗： 123456789public static void main(String[] args) throws InterruptedException { try (SqlSession sqlSession = MybatisUtil.getSession(true)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); Student student1 = testMapper.getStudentBySid(1); testMapper.addStudent(new Student().setName(\"小李\").setSex(\"男\")); Student student2 = testMapper.getStudentBySid(1); System.out.println(student1 == student2); }} 我们发现，当我们进行了插入操作后，缓存就没有生效了，我们再次进行查询得到的是一个新创建的对象。 也就是说，一级缓存，在进行DML操作后，会使得缓存失效，也就是说Mybatis知道我们对数据库里面的数据进行了修改，所以之前缓存的内容可能就不是当前数据库里面最新的内容了。还有一种情况就是，当前会话结束后，也会清理全部的缓存，因为已经不会再用到了。但是一定注意，一级缓存只针对于单个会话，多个会话之间不相通。 1234567891011121314public static void main(String[] args) { try (SqlSession sqlSession = MybatisUtil.getSession(true)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); Student student2; try(SqlSession sqlSession2 = MybatisUtil.getSession(true)){ TestMapper testMapper2 = sqlSession2.getMapper(TestMapper.class); student2 = testMapper2.getStudentBySid(1); } Student student1 = testMapper.getStudentBySid(1); System.out.println(student1 == student2); }} 注意：一个会话DML操作只会重置当前会话的缓存，不会重置其他会话的缓存，也就是说，其他会话缓存是不会更新的！ 一级缓存给我们提供了很高速的访问效率，但是它的作用范围实在是有限，如果一个会话结束，那么之前的缓存就全部失效了，但是我们希望缓存能够扩展到所有会话都能使用，因此我们可以通过二级缓存来实现，二级缓存默认是关闭状态，要开启二级缓存，我们需要在映射器XML文件中添加： 1&lt;cache/&gt; 可见二级缓存是Mapper级别的，也就是说，当一个会话失效时，它的缓存依然会存在于二级缓存中，因此如果我们再次创建一个新的会话会直接使用之前的缓存，我们首先根据官方文档进行一些配置： 12345&lt;cache eviction=\"FIFO\" flushInterval=\"60000\" size=\"512\" readOnly=\"true\"/&gt; 我们来编写一个代码： 12345678910111213public static void main(String[] args) { Student student; try (SqlSession sqlSession = MybatisUtil.getSession(true)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); student = testMapper.getStudentBySid(1); } try (SqlSession sqlSession2 = MybatisUtil.getSession(true)){ TestMapper testMapper2 = sqlSession2.getMapper(TestMapper.class); Student student2 = testMapper2.getStudentBySid(1); System.out.println(student2 == student); }} 我们可以看到，上面的代码中首先是第一个会话在进行读操作，完成后会结束会话，而第二个操作重新创建了一个新的会话，再次执行了同样的查询，我们发现得到的依然是缓存的结果。 那么如果我不希望某个方法开启缓存呢？我们可以添加useCache属性来关闭缓存： 123&lt;select id=\"getStudentBySid\" resultType=\"Student\" useCache=\"false\"&gt; select * from student where sid = #{sid}&lt;/select&gt; 我们也可以使用flushCache=”false”在每次执行后都清空缓存，通过这这个我们还可以控制DML操作完成之后不清空缓存。 123&lt;select id=\"getStudentBySid\" resultType=\"Student\" flushCache=\"true\"&gt; select * from student where sid = #{sid}&lt;/select&gt; 添加了二级缓存之后，会先从二级缓存中查找数据，当二级缓存中没有时，才会从一级缓存中获取，当一级缓存中都还没有数据时，才会请求数据库，因此我们再来执行上面的代码： 1234567891011121314public static void main(String[] args) { try (SqlSession sqlSession = MybatisUtil.getSession(true)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); Student student2; try(SqlSession sqlSession2 = MybatisUtil.getSession(true)){ TestMapper testMapper2 = sqlSession2.getMapper(TestMapper.class); student2 = testMapper2.getStudentBySid(1); } Student student1 = testMapper.getStudentBySid(1); System.out.println(student1 == student2); }} 得到的结果就会是同一个对象了，因为现在是优先从二级缓存中获取。 读取顺序：二级缓存 =&gt; 一级缓存 =&gt; 数据库 虽然缓存机制给我们提供了很大的性能提升，但是缓存存在一个问题，我们之前在计算机组成原理中可能学习过缓存一致性问题，也就是说当多个CPU在操作自己的缓存时，可能会出现各自的缓存内容不同步的问题，而Mybatis也会这样，我们来看看这个例子： 123456789public static void main(String[] args) throws InterruptedException { try (SqlSession sqlSession = MybatisUtil.getSession(true)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); while (true){ Thread.sleep(3000); System.out.println(testMapper.getStudentBySid(1)); } }} 我们现在循环地每三秒读取一次，而在这个过程中，我们使用IDEA手动修改数据库中的数据，将1号同学的学号改成100，那么理想情况下，下一次读取将无法获取到小明，因为小明的学号已经发生变化了。 但是结果却是依然能够读取，并且sid并没有发生改变，这也证明了Mybatis的缓存在生效，因为我们是从外部进行修改，Mybatis不知道我们修改了数据，所以依然在使用缓存中的数据，但是这样很明显是不正确的，因此，如果存在多台服务器或者是多个程序都在使用Mybatis操作同一个数据库，并且都开启了缓存，需要解决这个问题，要么就得关闭Mybatis的缓存来保证一致性： 123&lt;settings&gt; &lt;setting name=\"cacheEnabled\" value=\"false\"/&gt;&lt;/settings&gt; 123&lt;select id=\"getStudentBySid\" resultType=\"Student\" useCache=\"false\" flushCache=\"true\"&gt; select * from student where sid = #{sid}&lt;/select&gt; 要么就需要实现缓存共用，也就是让所有的Mybatis都使用同一个缓存进行数据存取，在后面，我们会继续学习Redis、Ehcache、Memcache等缓存框架，通过使用这些工具，就能够很好地解决缓存一致性问题。 使用注解开发在之前的开发中，我们已经体验到Mybatis为我们带来的便捷了，我们只需要编写对应的映射器，并将其绑定到一个接口上，即可直接通过该接口执行我们的SQL语句，极大的简化了我们之前JDBC那样的代码编写模式。那么，能否实现无需xml映射器配置，而是直接使用注解在接口上进行配置呢？答案是可以的，也是现在推荐的一种方式（也不是说XML就不要去用了，由于Java 注解的表达能力和灵活性十分有限，可能相对于XML配置某些功能实现起来会不太好办，但是在大部分场景下，直接使用注解开发已经绰绰有余了） 首先我们来看一下，使用XML进行映射器编写时，我们需要现在XML中定义映射规则和SQL语句，然后再将其绑定到一个接口的方法定义上，然后再使用接口来执行： 123&lt;insert id=\"addStudent\"&gt; insert into student(name, sex) values(#{name}, #{sex})&lt;/insert&gt; 1int addStudent(Student student); 而现在，我们可以直接使用注解来实现，每个操作都有一个对应的注解： 12@Insert(\"insert into student(name, sex) values(#{name}, #{sex})\")int addStudent(Student student); 当然，我们还需要修改一下配置文件中的映射器注册： 1234&lt;mappers&gt; &lt;mapper class=\"com.test.mapper.MyMapper\"/&gt; &lt;!-- 也可以直接注册整个包下的 &lt;package name=\"com.test.mapper\"/&gt; --&gt;&lt;/mappers&gt; 通过直接指定Class，来让Mybatis知道我们这里有一个通过注解实现的映射器。 我们接着来看一下，如何使用注解进行自定义映射规则： 1234567@Results({ @Result(id = true, column = \"sid\", property = \"sid\"), @Result(column = \"sex\", property = \"name\"), @Result(column = \"name\", property = \"sex\")})@Select(\"select * from student\")List&lt;Student&gt; getAllStudent(); 直接通过@Results注解，就可以直接进行配置了，此注解的value是一个@Result注解数组，每个@Result注解都都一个单独的字段配置，其实就是我们之前在XML映射器中写的： 12345&lt;resultMap id=\"test\" type=\"Student\"&gt; &lt;id property=\"sid\" column=\"sid\"/&gt; &lt;result column=\"name\" property=\"sex\"/&gt; &lt;result column=\"sex\" property=\"name\"/&gt;&lt;/resultMap&gt; 现在我们就可以通过注解来自定义映射规则了。那么如何使用注解来完成复杂查询呢？我们还是使用一个老师多个学生的例子： 123456789101112@Results({ @Result(id = true, column = \"tid\", property = \"tid\"), @Result(column = \"name\", property = \"name\"), @Result(column = \"tid\", property = \"studentList\", many = @Many(select = \"getStudentByTid\") )})@Select(\"select * from teacher where tid = #{tid}\")Teacher getTeacherBySid(int tid);@Select(\"select * from student inner join teach on student.sid = teach.sid where tid = #{tid}\")List&lt;Student&gt; getStudentByTid(int tid); 我们发现，多出了一个子查询，而这个子查询是单独查询该老师所属学生的信息，而子查询结果作为@Result注解的一个many结果，代表子查询的所有结果都归入此集合中（也就是之前的collection标签） 123456789&lt;resultMap id=\"asTeacher\" type=\"Teacher\"&gt; &lt;id column=\"tid\" property=\"tid\"/&gt; &lt;result column=\"tname\" property=\"name\"/&gt; &lt;collection property=\"studentList\" ofType=\"Student\"&gt; &lt;id property=\"sid\" column=\"sid\"/&gt; &lt;result column=\"name\" property=\"name\"/&gt; &lt;result column=\"sex\" property=\"sex\"/&gt; &lt;/collection&gt;&lt;/resultMap&gt; 同理，@Result也提供了@One子注解来实现一对一的关系表示，类似于之前的assocation标签： 12345678910@Results({ @Result(id = true, column = \"sid\", property = \"sid\"), @Result(column = \"sex\", property = \"name\"), @Result(column = \"name\", property = \"sex\"), @Result(column = \"sid\", property = \"teacher\", one = @One(select = \"getTeacherBySid\") )})@Select(\"select * from student\")List&lt;Student&gt; getAllStudent(); 如果现在我希望直接使用注解编写SQL语句但是我希望映射规则依然使用XML来实现，这时该怎么办呢？ 123@ResultMap(\"test\")@Select(\"select * from student\")List&lt;Student&gt; getAllStudent(); 提供了@ResultMap注解，直接指定ID即可，这样我们就可以使用XML中编写的映射规则了，这里就不再演示了。 那么如果出现之前的两个构造方法的情况，且没有任何一个构造方法匹配的话，该怎么处理呢？ 12345678910111213141516@Data@Accessors(chain = true)public class Student { public Student(int sid){ System.out.println(\"我是一号构造方法\"+sid); } public Student(int sid, String name){ System.out.println(\"我是二号构造方法\"+sid+name); } private int sid; private String name; private String sex;} 我们可以通过@ConstructorArgs注解来指定构造方法： 123456@ConstructorArgs({ @Arg(column = \"sid\", javaType = int.class), @Arg(column = \"name\", javaType = String.class)})@Select(\"select * from student where sid = #{sid} and sex = #{sex}\")Student getStudentBySidAndSex(@Param(\"sid\") int sid, @Param(\"sex\") String sex); 得到的结果和使用constructor标签效果一致，这里就不多做讲解了。 我们发现，当参数列表中出现两个以上的参数时，会出现错误： 12@Select(\"select * from student where sid = #{sid} and sex = #{sex}\")Student getStudentBySidAndSex(int sid, String sex); 12345678910111213Exception in thread \"main\" org.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: org.apache.ibatis.binding.BindingException: Parameter 'sid' not found. Available parameters are [arg1, arg0, param1, param2]### Cause: org.apache.ibatis.binding.BindingException: Parameter 'sid' not found. Available parameters are [arg1, arg0, param1, param2] at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:30) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:153) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:145) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:140) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectOne(DefaultSqlSession.java:76) at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:87) at org.apache.ibatis.binding.MapperProxy$PlainMethodInvoker.invoke(MapperProxy.java:145) at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:86) at com.sun.proxy.$Proxy6.getStudentBySidAndSex(Unknown Source) at com.test.Main.main(Main.java:16) 原因是Mybatis不明确到底哪个参数是什么，因此我们可以添加@Param来指定参数名称： 12@Select(\"select * from student where sid = #{sid} and sex = #{sex}\")Student getStudentBySidAndSex(@Param(\"sid\") int sid, @Param(\"sex\") String sex); 探究：要是我两个参数一个是基本类型一个是对象类型呢？ 1System.out.println(testMapper.addStudent(100, new Student().setName(\"小陆\").setSex(\"男\"))); 12@Insert(\"insert into student(sid, name, sex) values(#{sid}, #{name}, #{sex})\")int addStudent(@Param(\"sid\") int sid, @Param(\"student\") Student student); 那么这个时候，就出现问题了，Mybatis就不能明确这些属性是从哪里来的： 12345678910### SQL: insert into student(sid, name, sex) values(?, ?, ?)### Cause: org.apache.ibatis.binding.BindingException: Parameter 'name' not found. Available parameters are [student, param1, sid, param2] at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:30) at org.apache.ibatis.session.defaults.DefaultSqlSession.update(DefaultSqlSession.java:196) at org.apache.ibatis.session.defaults.DefaultSqlSession.insert(DefaultSqlSession.java:181) at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:62) at org.apache.ibatis.binding.MapperProxy$PlainMethodInvoker.invoke(MapperProxy.java:145) at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:86) at com.sun.proxy.$Proxy6.addStudent(Unknown Source) at com.test.Main.main(Main.java:16) 那么我们就通过参数名称.属性的方式去让Mybatis知道我们要用的是哪个属性： 12@Insert(\"insert into student(sid, name, sex) values(#{sid}, #{student.name}, #{student.sex})\")int addStudent(@Param(\"sid\") int sid, @Param(\"student\") Student student); 那么如何通过注解控制缓存机制呢？ 123456@CacheNamespace(readWrite = false)public interface MyMapper { @Select(\"select * from student\") @Options(useCache = false) List&lt;Student&gt; getAllStudent(); 使用@CacheNamespace注解直接定义在接口上即可，然后我们可以通过使用@Options来控制单个操作的缓存启用。 探究Mybatis的动态代理机制在探究动态代理机制之前，我们要先聊聊什么是代理：其实顾名思义，就好比我开了个大棚，里面栽种的西瓜，那么西瓜成熟了是不是得去卖掉赚钱，而我们的西瓜非常多，一个人肯定卖不过来，肯定就要去多找几个开水果摊的帮我们卖，这就是一种代理。实际上是由水果摊老板在帮我们卖瓜，我们只告诉老板卖多少钱，而至于怎么卖的是由水果摊老板决定的。 那么现在我们来尝试实现一下这样的类结构，首先定义一个接口用于规范行为： 12345public interface Shopper { //卖瓜行为 void saleWatermelon(String customer);} 然后需要实现一下卖瓜行为，也就是我们要告诉老板卖多少钱，这里就直接写成成功出售： 12345678public class ShopperImpl implements Shopper{ //卖瓜行为的实现 @Override public void saleWatermelon(String customer) { System.out.println(\"成功出售西瓜给 ===&gt; \"+customer); }} 最后老板代理后肯定要用自己的方式去出售这些西瓜，成交之后再按照我们告诉老板的价格进行出售： 123456789101112131415161718192021public class ShopperProxy implements Shopper{ private final Shopper impl; public ShopperProxy(Shopper impl){ this.impl = impl; } //代理卖瓜行为 @Override public void saleWatermelon(String customer) { //首先进行 代理商讨价还价行为 System.out.println(customer + \"：哥们，这瓜多少钱一斤啊？\"); System.out.println(\"老板：两块钱一斤。\"); System.out.println(customer + \"：你这瓜皮子是金子做的，还是瓜粒子是金子做的？\"); System.out.println(\"老板：你瞅瞅现在哪有瓜啊，这都是大棚的瓜，你嫌贵我还嫌贵呢。\"); System.out.println(customer + \"：给我挑一个。\"); impl.saleWatermelon(customer); //讨价还价成功，进行我们告诉代理商的卖瓜行为 }} 现在我们来试试看： 123456public class Main { public static void main(String[] args) { Shopper shopper = new ShopperProxy(new ShopperImpl()); shopper.saleWatermelon(\"小强\"); }} 这样的操作称为静态代理，也就是说我们需要提前知道接口的定义并进行实现才可以完成代理，而Mybatis这样的是无法预知代理接口的，我们就需要用到动态代理。 JDK提供的反射框架就为我们很好地解决了动态代理的问题，在这里相当于对JavaSE阶段反射的内容进行一个补充。 123456789101112131415161718public class ShopperProxy implements InvocationHandler { Object target; public ShopperProxy(Object target){ this.target = target; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { String customer = (String) args[0]; System.out.println(customer + \"：哥们，这瓜多少钱一斤啊？\"); System.out.println(\"老板：两块钱一斤。\"); System.out.println(customer + \"：你这瓜皮子是金子做的，还是瓜粒子是金子做的？\"); System.out.println(\"老板：你瞅瞅现在哪有瓜啊，这都是大棚的瓜，你嫌贵我还嫌贵呢。\"); System.out.println(customer + \"：行，给我挑一个。\"); return method.invoke(target, args); }} 通过实现InvocationHandler来成为一个动态代理，我们发现它提供了一个invoke方法，用于调用被代理对象的方法并完成我们的代理工作。现在就可以通过 Proxy.newProxyInstance来生成一个动态代理类： 1234567public static void main(String[] args) { Shopper impl = new ShopperImpl(); Shopper shopper = (Shopper) Proxy.newProxyInstance(impl.getClass().getClassLoader(), impl.getClass().getInterfaces(), new ShopperProxy(impl)); shopper.saleWatermelon(\"小强\"); System.out.println(shopper.getClass());} 通过打印类型我们发现，就是我们之前看到的那种奇怪的类：class com.sun.proxy.$Proxy0，因此Mybatis其实也是这样的来实现的（肯定有人问了：Mybatis是直接代理接口啊，你这个不还是要把接口实现了吗？）那我们来改改，现在我们不代理任何类了，直接做接口实现： 12345678910111213public class ShopperProxy implements InvocationHandler { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { String customer = (String) args[0]; System.out.println(customer + \"：哥们，这瓜多少钱一斤啊？\"); System.out.println(\"老板：两块钱一斤。\"); System.out.println(customer + \"：你这瓜皮子是金子做的，还是瓜粒子是金子做的？\"); System.out.println(\"老板：你瞅瞅现在哪有瓜啊，这都是大棚的瓜，你嫌贵我还嫌贵呢。\"); System.out.println(customer + \"：行，给我挑一个。\"); return null; }} 1234567public static void main(String[] args) { Shopper shopper = (Shopper) Proxy.newProxyInstance(Shopper.class.getClassLoader(), new Class[]{ Shopper.class }, //因为本身就是接口，所以直接用就行 new ShopperProxy()); shopper.saleWatermelon(\"小强\"); System.out.println(shopper.getClass());} 我们可以去看看Mybatis的源码。 Mybatis的学习差不多就到这里为止了，不过，同样类型的框架还有很多，Mybatis属于半自动框架，SQL语句依然需要我们自己编写，虽然存在一定的麻烦，但是会更加灵活，而后面我们还会学习JPA，它是全自动的框架，你几乎见不到SQL的影子！ 使用JUnit进行单元测试首先一问：我们为什么需要单元测试？ 随着我们的项目逐渐变大，比如我们之前编写的图书管理系统，我们都是边在写边在测试，而我们当时使用的测试方法，就是直接在主方法中运行测试，但是，在很多情况下，我们的项目可能会很庞大，不可能每次都去完整地启动一个项目来测试某一个功能，这样显然会降低我们的开发效率，因此，我们需要使用单元测试来帮助我们针对于某个功能或是某个模块单独运行代码进行测试，而不是启动整个项目。 同时，在我们项目的维护过程中，难免会涉及到一些原有代码的修改，很有可能出现改了代码导致之前的功能出现问题（牵一发而动全身），而我们又不一定能立即察觉到，因此，我们可以提前保存一些测试用例，每次完成代码后都可以跑一遍测试用例，来确保之前的功能没有因为后续的修改而出现问题。 我们还可以利用单元测试来评估某个模块或是功能的耗时和性能，快速排查导致程序运行缓慢的问题，这些都可以通过单元测试来完成，可见单元测试对于开发的重要性。 尝试JUnit首先需要导入JUnit依赖，我们在这里使用Junit4进行介绍，最新的Junit5放到Maven板块一起讲解，Jar包已经放在视频下方简介中，直接去下载即可。同时IDEA需要安装JUnit插件（默认是已经捆绑安装的，因此无需多余配置） 现在我们创建一个新的类，来编写我们的单元测试用例： 1234567891011public class TestMain { @Test public void method(){ System.out.println(\"我是测试用例1\"); } @Test public void method2(){ System.out.println(\"我是测试用例2\"); }} 我们可以点击类前面的测试按钮，或是单个方法前的测试按钮，如果点击类前面的测试按钮，会执行所有的测试用例。 运行测试后，我们发现控制台得到了一个测试结果，显示为绿色表示测试通过。 只需要通过打上@Test注解，即可将一个方法标记为测试案例，我们可以直接运行此测试案例，但是我们编写的测试方法有以下要求： 方法必须是public的 不能是静态方法 返回值必须是void 必须是没有任何参数的方法 对于一个测试案例来说，我们肯定希望测试的结果是我们所期望的一个值，因此，如果测试的结果并不是我们所期望的结果，那么这个测试就应该没有成功通过！ 我们可以通过断言工具类来进行判定： 1234567public class TestMain { @Test public void method(){ System.out.println(\"我是测试案例！\"); Assert.assertEquals(1, 2); //参数1是期盼值，参数2是实际测试结果值 }} 通过运行代码后，我们发现测试过程中抛出了一个错误，并且IDEA给我们显示了期盼结果和测试结果，那么现在我们来测试一个案例，比如我们想查看冒泡排序的编写是否正确： 1234567891011121314151617@Testpublic void method(){ int[] arr = {0, 4, 5, 2, 6, 9, 3, 1, 7, 8}; //错误的冒泡排序 for (int i = 0; i &lt; arr.length - 1; i++) { for (int j = 0; j &lt; arr.length - 1 - i; j++) { if(arr[j] &gt; arr[j + 1]){ int tmp = arr[j]; arr[j] = arr[j+1]; // arr[j+1] = tmp; } } } Assert.assertArrayEquals(new int[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, arr);} 通过测试，我们发现得到的结果并不是我们想要的结果，因此现在我们需要去修改为正确的冒泡排序，修改后，测试就能正确通过了。我们还可以再通过一个案例来更加深入地了解测试，现在我们想测试从数据库中取数据是否为我们预期的数据： 123456789@Testpublic void method(){ try (SqlSession sqlSession = MybatisUtil.getSession(true)){ TestMapper mapper = sqlSession.getMapper(TestMapper.class); Student student = mapper.getStudentBySidAndSex(1, \"男\"); Assert.assertEquals(new Student().setName(\"小明\").setSex(\"男\").setSid(1), student); }} 那么如果我们在进行所有的测试之前需要做一些前置操作该怎么办呢，一种办法是在所有的测试用例前面都加上前置操作，但是这样显然是很冗余的，因为一旦发生修改就需要挨个进行修改，因此我们需要更加智能的方法，我们可以通过@Before注解来添加测试用例开始之前的前置操作： 12345678910111213141516171819202122232425262728293031323334353637public class TestMain { private SqlSessionFactory sqlSessionFactory; @Before public void before(){ System.out.println(\"测试前置正在初始化...\"); try { sqlSessionFactory = new SqlSessionFactoryBuilder() .build(new FileInputStream(\"mybatis-config.xml\")); } catch (FileNotFoundException e) { e.printStackTrace(); } System.out.println(\"测试初始化完成，正在开始测试案例...\"); } @Test public void method1(){ try (SqlSession sqlSession = sqlSessionFactory.openSession(true)){ TestMapper mapper = sqlSession.getMapper(TestMapper.class); Student student = mapper.getStudentBySidAndSex(1, \"男\"); Assert.assertEquals(new Student().setName(\"小明\").setSex(\"男\").setSid(1), student); System.out.println(\"测试用例1通过！\"); } } @Test public void method2(){ try (SqlSession sqlSession = sqlSessionFactory.openSession(true)){ TestMapper mapper = sqlSession.getMapper(TestMapper.class); Student student = mapper.getStudentBySidAndSex(2, \"女\"); Assert.assertEquals(new Student().setName(\"小红\").setSex(\"女\").setSid(2), student); System.out.println(\"测试用例2通过！\"); } }} 同理，在所有的测试完成之后，我们还想添加一个收尾的动作，那么只需要使用@After注解即可添加结束动作： 1234@Afterpublic void after(){ System.out.println(\"测试结束，收尾工作正在进行...\");} 有关JUnit的使用我们就暂时只介绍这么多。 JUL日志系统首先一问：我们为什么需要日志系统？ 我们之前一直都在使用System.out.println来打印信息，但是，如果项目中存在大量的控制台输出语句，会显得很凌乱，而且日志的粒度是不够细的，假如我们现在希望，项目只在debug的情况下打印某些日志，而在实际运行时不打印日志，采用直接输出的方式就很难实现了，因此我们需要使用日志框架来规范化日志输出。 而JDK为我们提供了一个自带的日志框架，位于java.util.logging包下，我们可以使用此框架来实现日志的规范化打印，使用起来非常简单： 12345678public class Main { public static void main(String[] args) { // 首先获取日志打印器 Logger logger = Logger.getLogger(Main.class.getName()); // 调用info来输出一个普通的信息，直接填写字符串即可 logger.info(\"我是普通的日志\"); }} 我们可以在主类中使用日志打印，得到日志的打印结果： 12十一月 15, 2021 12:55:37 下午 com.test.Main main信息: 我是普通的日志 我们发现，通过日志输出的结果会更加规范。 JUL日志讲解日志分为7个级别，详细信息我们可以在Level类中查看： SEVERE（最高值）- 一般用于代表严重错误 WARNING - 一般用于表示某些警告，但是不足以判断为错误 INFO （默认级别） - 常规消息 CONFIG FINE FINER FINEST（最低值） 我们之前通过info方法直接输出的结果就是使用的默认级别的日志，我们可以通过log方法来设定该条日志的输出级别： 1234567public static void main(String[] args) { Logger logger = Logger.getLogger(Main.class.getName()); logger.log(Level.SEVERE, \"严重的错误\", new IOException(\"我就是错误\")); logger.log(Level.WARNING, \"警告的内容\"); logger.log(Level.INFO, \"普通的信息\"); logger.log(Level.CONFIG, \"级别低于普通信息\");} 我们发现，级别低于默认级别的日志信息，无法输出到控制台，我们可以通过设置来修改日志的打印级别： 1234567891011121314151617public static void main(String[] args) { Logger logger = Logger.getLogger(Main.class.getName()); //修改日志级别 logger.setLevel(Level.CONFIG); //不使用父日志处理器 logger.setUseParentHandlers(false); //使用自定义日志处理器 ConsoleHandler handler = new ConsoleHandler(); handler.setLevel(Level.CONFIG); logger.addHandler(handler); logger.log(Level.SEVERE, \"严重的错误\", new IOException(\"我就是错误\")); logger.log(Level.WARNING, \"警告的内容\"); logger.log(Level.INFO, \"普通的信息\"); logger.log(Level.CONFIG, \"级别低于普通信息\");} 每个Logger都有一个父日志打印器，我们可以通过getParent()来获取： 1234public static void main(String[] args) throws IOException { Logger logger = Logger.getLogger(Main.class.getName()); System.out.println(logger.getParent().getClass());} 我们发现，得到的是java.util.logging.LogManager$RootLogger这个类，它默认使用的是ConsoleHandler，且日志级别为INFO，由于每一个日志打印器都会直接使用父类的处理器，因此我们之前需要关闭父类然后使用我们自己的处理器。 我们通过使用自己日志处理器来自定义级别的信息打印到控制台，当然，日志处理器不仅仅只有控制台打印，我们也可以使用文件处理器来处理日志信息，我们继续添加一个处理器： 1234//添加输出到本地文件FileHandler fileHandler = new FileHandler(\"test.log\");fileHandler.setLevel(Level.WARNING);logger.addHandler(fileHandler); 注意，这个时候就有两个日志处理器了，因此控制台和文件的都会生效。如果日志的打印格式我们不喜欢，我们还可以自定义打印格式，比如我们控制台处理器就默认使用的是SimpleFormatter，而文件处理器则是使用的XMLFormatter，我们可以自定义： 12345//使用自定义日志处理器(控制台)ConsoleHandler handler = new ConsoleHandler();handler.setLevel(Level.CONFIG);handler.setFormatter(new XMLFormatter());logger.addHandler(handler); 我们可以直接配置为想要的打印格式，如果这些格式还不能满足你，那么我们也可以自行实现： 1234567891011121314151617181920212223242526272829303132public static void main(String[] args) throws IOException { Logger logger = Logger.getLogger(Main.class.getName()); logger.setUseParentHandlers(false); //为了让颜色变回普通的颜色，通过代码块在初始化时将输出流设定为System.out ConsoleHandler handler = new ConsoleHandler(){{ setOutputStream(System.out); }}; //创建匿名内部类实现自定义的格式 handler.setFormatter(new Formatter() { @Override public String format(LogRecord record) { SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\"); String time = format.format(new Date(record.getMillis())); //格式化日志时间 String level = record.getLevel().getName(); // 获取日志级别名称 // String level = record.getLevel().getLocalizedName(); // 获取本地化名称（语言跟随系统） String thread = String.format(\"%10s\", Thread.currentThread().getName()); //线程名称（做了格式化处理，留出10格空间） long threadID = record.getThreadID(); //线程ID String className = String.format(\"%-20s\", record.getSourceClassName()); //发送日志的类名 String msg = record.getMessage(); //日志消息 //\\033[33m作为颜色代码，30~37都有对应的颜色，38是没有颜色，IDEA能显示，但是某些地方可能不支持 return \"\\033[38m\" + time + \" \\033[33m\" + level + \" \\033[35m\" + threadID + \"\\033[38m --- [\" + thread + \"] \\033[36m\" + className + \"\\033[38m : \" + msg + \"\\n\"; } }); logger.addHandler(handler); logger.info(\"我是测试消息1...\"); logger.log(Level.INFO, \"我是测试消息2...\"); logger.log(Level.WARNING, \"我是测试消息3...\");} 日志可以设置过滤器，如果我们不希望某些日志信息被输出，我们可以配置过滤规则： 12345678910public static void main(String[] args) throws IOException { Logger logger = Logger.getLogger(Main.class.getName()); //自定义过滤规则 logger.setFilter(record -&gt; !record.getMessage().contains(\"普通\")); logger.log(Level.SEVERE, \"严重的错误\", new IOException(\"我就是错误\")); logger.log(Level.WARNING, \"警告的内容\"); logger.log(Level.INFO, \"普通的信息\");} 实际上，整个日志的输出流程如下： Properties配置文件Properties文件是Java的一种配置文件，我们之前学习了XML，但是我们发现XML配置文件读取实在是太麻烦，那么能否有一种简单一点的配置文件呢？我们可以使用Properties文件： 12name=Testdesc=Description 该文件配置很简单，格式为配置项=配置值，我们可以直接通过Properties类来将其读取为一个类似于Map一样的对象： 12345public static void main(String[] args) throws IOException { Properties properties = new Properties(); properties.load(new FileInputStream(\"test.properties\")); System.out.println(properties);} 我们发现，Properties类是继承自Hashtable，而Hashtable是实现的Map接口，也就是说，Properties本质上就是一个Map一样的结构，它会把所有的配置项映射为一个Map，这样我们就可以快速地读取对应配置的值了。 我们也可以将已经存在的Properties对象放入输出流进行保存，我们这里就不保存文件了，而是直接打印到控制台，我们只需要提供输出流即可： 1234567public static void main(String[] args) throws IOException { Properties properties = new Properties(); // properties.setProperty(\"test\", \"lbwnb\"); //和put效果一样 properties.put(\"test\", \"lbwnb\"); properties.store(System.out, \"????\"); //properties.storeToXML(System.out, \"????\"); 保存为XML格式} 我们可以通过System.getProperties()获取系统的参数，我们来看看： 123public static void main(String[] args) throws IOException { System.getProperties().store(System.out, \"系统信息：\");} 编写日志配置文件我们可以通过进行配置文件来规定日志打印器的一些默认值： 1234# RootLogger 的默认处理器为handlers= java.util.logging.ConsoleHandler# RootLogger 的默认的日志级别.level= CONFIG 我们来尝试使用配置文件来进行配置： 123456789public static void main(String[] args) throws IOException { //获取日志管理器 LogManager manager = LogManager.getLogManager(); //读取我们自己的配置文件 manager.readConfiguration(new FileInputStream(\"logging.properties\")); //再获取日志打印器 Logger logger = Logger.getLogger(Main.class.getName()); logger.log(Level.CONFIG, \"我是一条日志信息\"); //通过自定义配置文件，我们发现默认级别不再是INFO了} 我们也可以去修改ConsoleHandler的默认配置： 123456# 指定默认日志级别java.util.logging.ConsoleHandler.level = ALL# 指定默认日志消息格式java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter# 指定默认的字符集java.util.logging.ConsoleHandler.encoding = UTF-8 其实，我们阅读ConsoleHandler的源码就会发现，它就是通过读取配置文件来进行某些参数设置： 123456789101112131415161718192021// Private method to configure a ConsoleHandler from LogManager// properties and/or default values as specified in the class// javadoc.private void configure() { LogManager manager = LogManager.getLogManager(); String cname = getClass().getName(); setLevel(manager.getLevelProperty(cname +\".level\", Level.INFO)); setFilter(manager.getFilterProperty(cname +\".filter\", null)); setFormatter(manager.getFormatterProperty(cname +\".formatter\", new SimpleFormatter())); try { setEncoding(manager.getStringProperty(cname +\".encoding\", null)); } catch (Exception ex) { try { setEncoding(null); } catch (Exception ex2) { // doing a setEncoding with null should always work. // assert false; } }} 使用Lombok快速开启日志我们发现，如果我们现在需要全面使用日志系统，而不是传统的直接打印，那么就需要在每个类都去编写获取Logger的代码，这样显然是很冗余的，能否简化一下这个流程呢？ 前面我们学习了Lombok，我们也体会到Lombok给我们带来的便捷，我们可以通过一个注解快速生成构造方法、Getter和Setter，同样的，Logger也是可以使用Lombok快速生成的。 1234567@Logpublic class Main { public static void main(String[] args) { System.out.println(\"自动生成的Logger名称：\"+log.getName()); log.info(\"我是日志信息\"); }} 只需要添加一个@Log注解即可，添加后，我们可以直接使用一个静态变量log，而它就是自动生成的Logger。我们也可以手动指定名称： 1234567@Log(topic = \"打工是不可能打工的\")public class Main { public static void main(String[] args) { System.out.println(\"自动生成的Logger名称：\"+log.getName()); log.info(\"我是日志信息\"); }} Mybatis日志系统Mybatis也有日志系统，它详细记录了所有的数据库操作等，但是我们在前面的学习中没有开启它，现在我们学习了日志之后，我们就可以尝试开启Mybatis的日志系统，来监控所有的数据库操作，要开启日志系统，我们需要进行配置： 1&lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\" /&gt; logImpl包括很多种配置项，包括 SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING，而默认情况下是未配置，也就是说不打印。我们这里将其设定为STDOUT_LOGGING表示直接使用标准输出将日志信息打印到控制台，我们编写一个测试案例来看看效果： 12345678910111213141516171819202122public class TestMain { private SqlSessionFactory sqlSessionFactory; @Before public void before(){ try { sqlSessionFactory = new SqlSessionFactoryBuilder() .build(new FileInputStream(\"mybatis-config.xml\")); } catch (FileNotFoundException e) { e.printStackTrace(); } } @Test public void test(){ try(SqlSession sqlSession = sqlSessionFactory.openSession(true)){ TestMapper mapper = sqlSession.getMapper(TestMapper.class); System.out.println(mapper.getStudentBySidAndSex(1, \"男\")); System.out.println(mapper.getStudentBySidAndSex(1, \"男\")); } }} 我们发现，两次获取学生信息，只有第一次打开了数据库连接，而第二次并没有。 现在我们学习了日志系统，那么我们来尝试使用日志系统输出Mybatis的日志信息： 1&lt;setting name=\"logImpl\" value=\"JDK_LOGGING\" /&gt; 将其配置为JDK_LOGGING表示使用JUL进行日志打印，因为Mybatis的日志级别都比较低，因此我们需要设置一下logging.properties默认的日志级别： 123handlers= java.util.logging.ConsoleHandler.level= ALLjava.util.logging.ConsoleHandler.level = ALL 代码编写如下： 12345678910111213141516171819202122232425@Logpublic class TestMain { private SqlSessionFactory sqlSessionFactory; @Before public void before(){ try { sqlSessionFactory = new SqlSessionFactoryBuilder() .build(new FileInputStream(\"mybatis-config.xml\")); LogManager manager = LogManager.getLogManager(); manager.readConfiguration(new FileInputStream(\"logging.properties\")); } catch (IOException e) { e.printStackTrace(); } } @Test public void test(){ try(SqlSession sqlSession = sqlSessionFactory.openSession(true)){ TestMapper mapper = sqlSession.getMapper(TestMapper.class); log.info(mapper.getStudentBySidAndSex(1, \"男\").toString()); log.info(mapper.getStudentBySidAndSex(1, \"男\").toString()); } }} 但是我们发现，这样的日志信息根本没法看，因此我们需要修改一下日志的打印格式，我们自己创建一个格式化类： 12345678public class TestFormatter extends Formatter { @Override public String format(LogRecord record) { SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\"); String time = format.format(new Date(record.getMillis())); //格式化日志时间 return time + \" : \" + record.getMessage() + \"\\n\"; }} 现在再来修改一下默认的格式化实现： 1234handlers= java.util.logging.ConsoleHandler.level= ALLjava.util.logging.ConsoleHandler.level = ALLjava.util.logging.ConsoleHandler.formatter = com.test.TestFormatter 现在就好看多了，当然，我们还可以继续为Mybatis添加文件日志，这里就不做演示了。 使用Maven管理项目注意：开始之前，看看你C盘空间够不够，最好预留2GB空间以上！ 吐槽：很多电脑预装系统C盘都给得巨少，就算不装软件，一些软件的缓存文件也能给你塞满，建议有时间重装一下系统重新分配一下磁盘空间。 Maven 翻译为”专家”、”内行”，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。Maven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。 通过Maven，可以帮助我们做： 项目的自动构建，包括代码的编译、测试、打包、安装、部署等操作。 依赖管理，项目使用到哪些依赖，可以快速完成导入。 我们之前并没有讲解如何将我们的项目打包为Jar文件运行，同时，我们导入依赖的时候，每次都要去下载对应的Jar包，这样其实是很麻烦的，并且还有可能一个Jar包依赖于另一个Jar包，就像之前使用JUnit一样，因此我们需要一个更加方便的包管理机制。 Maven也需要安装环境，但是IDEA已经自带了Maven环境，因此我们不需要再去进行额外的环境安装（无IDEA也能使用Maven，但是配置过程很麻烦，并且我们现在使用的都是IDEA的集成开发环境，所以这里就不讲解Maven命令行操作了）我们直接创建一个新的Maven项目即可。 Maven项目结构我们可以来看一下，一个Maven项目和我们普通的项目有什么区别： 那么首先，我们需要了解一下POM文件，它相当于是我们整个Maven项目的配置文件，它也是使用XML编写的： 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;MavenTest&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt;&lt;/project&gt; 我们可以看到，Maven的配置文件是以project为根节点，而modelVersion定义了当前模型的版本，一般是4.0.0，我们不用去修改。 groupId、artifactId、version这三个元素合在一起，用于唯一区别每个项目，别人如果需要将我们编写的代码作为依赖，那么就必须通过这三个元素来定位我们的项目，我们称为一个项目的基本坐标，所有的项目一般都有自己的Maven坐标，因此我们通过Maven导入其他的依赖只需要填写这三个基本元素就可以了，无需再下载Jar文件，而是Maven自动帮助我们下载依赖并导入。 groupId 一般用于指定组名称，命名规则一般和包名一致，比如我们这里使用的是org.example，一个组下面可以有很多个项目。 artifactId 一般用于指定项目在当前组中的唯一名称，也就是说在组中用于区分于其他项目的标记。 version 代表项目版本，随着我们项目的开发和改进，版本号也会不断更新，就像LOL一样，每次赛季更新都会有一个大版本更新，我们的Maven项目也是这样，我们可以手动指定当前项目的版本号，其他人使用我们的项目作为依赖时，也可以根本版本号进行选择（这里的SNAPSHOT代表快照，一般表示这是一个处于开发中的项目，正式发布项目一般只带版本号） properties中一般都是一些变量和选项的配置，我们这里指定了JDK的源代码和编译版本为1.8，无需进行修改。 Maven依赖导入现在我们尝试使用Maven来帮助我们快速导入依赖，我们需要导入之前的JDBC驱动依赖、JUnit依赖、Mybatis依赖、Lombok依赖，那么如何使用Maven来管理依赖呢？ 我们可以创建一个dependencies节点： 123&lt;dependencies&gt; //里面填写的就是所有的依赖&lt;/dependencies&gt; 那么现在就可以向节点中填写依赖了，那么我们如何知道每个依赖的坐标呢？我们可以在：https://mvnrepository.com/ 进行查询（可能打不开，建议用流量，或是直接百度某个项目的Maven依赖），我们直接搜索lombok即可，打开后可以看到已经给我们写出了依赖的坐标： 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.22&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 我们直接将其添加到dependencies节点中即可，现在我们来编写一个测试用例看看依赖导入成功了没有： 123456public class Main { public static void main(String[] args) { Student student = new Student(\"小明\", 18); System.out.println(student); }} 123456@Data@AllArgsConstructorpublic class Student { String name; int age;} 项目运行成功，表示成功导入了依赖。那么，Maven是如何进行依赖管理呢，以致于如此便捷的导入依赖，我们来看看Maven项目的依赖管理流程： 通过流程图我们得知，一个项目依赖一般是存储在中央仓库中，也有可能存储在一些其他的远程仓库（私服），几乎所有的依赖都被放到了中央仓库中，因此，Maven可以直接从中央仓库中下载大部分的依赖（Maven第一次导入依赖是需要联网的），远程仓库中下载之后 ，会暂时存储在本地仓库，我们会发现我们本地存在一个.m2文件夹，这就是Maven本地仓库文件夹，默认建立在C盘，如果你C盘空间不足，会出现问题！ 在下次导入依赖时，如果Maven发现本地仓库中就已经存在某个依赖，那么就不会再去远程仓库下载了。 可能在导入依赖时，小小伙伴们会出现卡顿的问题，我们建议配置一下IDEA自带的Maven插件远程仓库地址，我们打开IDEA的安装目录，找到安装根目录/plugins/maven/lib/maven3/conf文件夹，找到settings.xml文件，打开编辑： 找到mirros标签，添加以下内容： 123456&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt; 这样，我们就将默认的远程仓库地址（国外），配置为国内的阿里云仓库地址了（依赖的下载速度就会快起来了） Maven依赖作用域除了三个基本的属性用于定位坐标外，依赖还可以添加以下属性： type：依赖的类型，对于项目坐标定义的packaging。大部分情况下，该元素不必声明，其默认值为jar scope：依赖的范围（作用域，着重讲解） optional：标记依赖是否可选 exclusions：用来排除传递性依赖（一个项目有可能依赖于其他项目，就像我们的项目，如果别人要用我们的项目作为依赖，那么就需要一起下载我们项目的依赖，如Lombok） 我们着重来讲解一下scope属性，它决定了依赖的作用域范围： compile ：为默认的依赖有效范围。如果在定义依赖关系的时候，没有明确指定依赖有效范围的话，则默认采用该依赖有效范围。此种依赖，在编译、运行、测试时均有效。 provided ：在编译、测试时有效，但是在运行时无效，也就是说，项目在运行时，不需要此依赖，比如我们上面的Lombok，我们只需要在编译阶段使用它，编译完成后，实际上已经转换为对应的代码了，因此Lombok不需要在项目运行时也存在。 runtime ：在运行、测试时有效，但是在编译代码时无效。比如我们如果需要自己写一个JDBC实现，那么肯定要用到JDK为我们指定的接口，但是实际上在运行时是不用自带JDK的依赖，因此只保留我们自己写的内容即可。 test ：只在测试时有效，例如：JUnit，我们一般只会在测试阶段使用JUnit，而实际项目运行时，我们就用不到测试了，那么我们来看看，导入JUnit的依赖： 同样的，我们可以在网站上搜索Junit的依赖，我们这里导入最新的JUnit5作为依赖： 123456&lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;5.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 我们所有的测试用例全部编写到Maven项目给我们划分的test目录下，位于此目录下的内容不会在最后被打包到项目中，只用作开发阶段测试使用： 123456789public class MainTest { @Test public void test(){ System.out.println(\"测试\"); //Assert在JUnit5时名称发生了变化Assertions Assertions.assertArrayEquals(new int[]{1, 2, 3}, new int[]{1, 2}); }} 因此，一般仅用作测试的依赖如JUnit只保留在测试中即可，那么现在我们再来添加JDBC和Mybatis的依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.27&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt;&lt;/dependency&gt; 我们发现，Maven还给我们提供了一个resource文件夹，我们可以将一些静态资源，比如配置文件，放入到这个文件夹中，项目在打包时会将资源文件夹中文件一起打包的Jar中，比如我们在这里编写一个Mybatis的配置文件： 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;setting name=\"logImpl\" value=\"JDK_LOGGING\" /&gt; &lt;/settings&gt; &lt;!-- 需要在environments的上方 --&gt; &lt;typeAliases&gt; &lt;package name=\"com.test.entity\"/&gt; &lt;/typeAliases&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/study\"/&gt; &lt;property name=\"username\" value=\"test\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper class=\"com.test.mapper.TestMapper\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 现在我们创建一下测试用例，顺便带大家了解一下Junit5的一些比较方便的地方： 123456789101112131415161718192021222324public class MainTest { //因为配置文件位于内部，我们需要使用Resources类的getResourceAsStream来获取内部的资源文件 private static SqlSessionFactory factory; //在JUnit5中@Before被废弃，它被细分了： @BeforeAll // 一次性开启所有测试案例只会执行一次 (方法必须是static) // @BeforeEach 一次性开启所有测试案例每个案例开始之前都会执行一次 @SneakyThrows public static void before(){ factory = new SqlSessionFactoryBuilder() .build(Resources.getResourceAsStream(\"mybatis.xml\")); } @DisplayName(\"Mybatis数据库测试\") //自定义测试名称 @RepeatedTest(3) //自动执行多次测试 public void test(){ try (SqlSession sqlSession = factory.openSession(true)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); System.out.println(testMapper.getStudentBySid(1)); } }} 那么就有人提问了，如果我需要的依赖没有上传的远程仓库，而是只有一个Jar怎么办呢？我们可以使用第四种作用域： system：作用域和provided是一样的，但是它不是从远程仓库获取，而是直接导入本地Jar包： 1234567&lt;dependency&gt; &lt;groupId&gt;javax.jntm&lt;/groupId&gt; &lt;artifactId&gt;lbwnb&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;C://学习资料/4K高清无码/test.jar&lt;/systemPath&gt;&lt;/dependency&gt; 比如上面的例子，如果scope为system，那么我们需要添加一个systemPath来指定jar文件的位置，这里就不再演示了。 Maven可选依赖当项目中的某些依赖不希望被使用此项目作为依赖的项目使用时，我们可以给依赖添加optional标签表示此依赖是可选的，默认在导入依赖时，不会导入可选的依赖： 1&lt;optional&gt;true&lt;/optional&gt; 比如Mybatis的POM文件中，就存在大量的可选依赖： 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.30&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.30&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; ... 由于Mybatis要支持多种类型的日志，需要用到很多种不同的日志框架，因此需要导入这些依赖来做兼容，但是我们项目中并不一定会使用这些日志框架作为Mybatis的日志打印器，因此这些日志框架仅Mybatis内部做兼容需要导入使用，而我们可以选择不使用这些框架或是选择其中一个即可，也就是说我们导入Mybatis之后想用什么日志框架再自己加就可以了。 Maven排除依赖我们了解了可选依赖，现在我们可以让使用此项目作为依赖的项目默认不使用可选依赖，但是如果存在那种不是可选依赖，但是我们导入此项目有不希望使用此依赖该怎么办呢，这个时候我们就可以通过排除依赖来防止添加不必要的依赖： 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;5.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 我们这里演示了排除JUnit的一些依赖，我们可以在外部库中观察排除依赖之后和之前的效果。 Maven继承关系一个Maven项目可以继承自另一个Maven项目，比如多个子项目都需要父项目的依赖，我们就可以使用继承关系来快速配置。 我们右键左侧栏，新建一个模块，来创建一个子项目： 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;MavenTest&lt;/artifactId&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;ChildModel&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt;&lt;/project&gt; 我们可以看到，IDEA默认给我们添加了一个parent节点，表示此Maven项目是父Maven项目的子项目，子项目直接继承父项目的groupId，子项目会直接继承父项目的所有依赖，除非依赖添加了optional标签，我们来编写一个测试用例尝试一下: 12345678import lombok.extern.java.Log;@Logpublic class Main { public static void main(String[] args) { log.info(\"我是日志信息\"); }} 可以看到，子项目也成功继承了Lombok依赖。 我们还可以让父Maven项目统一管理所有的依赖，包括版本号等，子项目可以选取需要的作为依赖，而版本全由父项目管理，我们可以将dependencies全部放入dependencyManagement节点，这样父项目就完全作为依赖统一管理。 1234567891011121314151617181920212223242526&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.22&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;5.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.27&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 我们发现，子项目的依赖失效了，因为现在父项目没有依赖，而是将所有的依赖进行集中管理，子项目需要什么再拿什么即可，同时子项目无需指定版本，所有的版本全部由父项目决定，子项目只需要使用即可： 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 当然，父项目如果还存在dependencies节点的话，里面的内依赖依然是直接继承： 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;5.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; ... Maven常用命令我们可以看到在IDEA右上角Maven板块中，每个Maven项目都有一个生命周期，实际上这些是Maven的一些插件，每个插件都有各自的功能，比如： clean命令，执行后会清理整个target文件夹，在之后编写Springboot项目时可以解决一些缓存没更新的问题。 validate命令可以验证项目的可用性。 compile命令可以将项目编译为.class文件。 install命令可以将当前项目安装到本地仓库，以供其他项目导入作为依赖使用 verify命令可以按顺序执行每个默认生命周期阶段（validate，compile，package等） Maven测试项目通过使用test命令，可以一键测试所有位于test目录下的测试案例，请注意有以下要求： 测试类的名称必须是以Test结尾，比如MainTest 测试方法上必须标注@Test注解，实测@RepeatedTest无效 这是由于JUnit5比较新，我们需要重新配置插件升级到高版本，才能完美的兼容Junit5： 12345678910&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;!-- JUnit 5 requires Surefire version 2.22.0 or higher --&gt; &lt;version&gt;2.22.0&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 现在@RepeatedTest、@BeforeAll也能使用了。 Maven打包项目我们的项目在编写完成之后，要么作为Jar依赖，供其他模型使用，要么就作为一个可以执行的程序，在控制台运行，我们只需要直接执行package命令就可以直接对项目的代码进行打包，生成jar文件。 当然，以上方式仅适用于作为Jar依赖的情况，如果我们需要打包一个可执行文件，那么我不仅需要将自己编写的类打包到Jar中，同时还需要将依赖也一并打包到Jar中，因为我们使用了别人为我们通过的框架，自然也需要运行别人的代码，我们需要使用另一个插件来实现一起打包： 123456789101112131415161718192021222324&lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;configuration&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;archive&gt; &lt;manifest&gt; &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;mainClass&gt;com.test.Main&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assembly&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 在打包之前也会执行一次test命令，来保证项目能够正常运行，当测试出现问题时，打包将无法完成，我们也可以手动跳过，选择执行Maven目标来手动执行Maven命令，输入mvn package -Dmaven.test.skip=true 来以跳过测试的方式进行打包。 最后得到我们的Jar文件，在同级目录下输入java -jar xxxx.jar来运行我们打包好的Jar可执行程序（xxx代表文件名称） deploy命令用于发布项目到本地仓库和远程仓库，一般情况下用不到，这里就不做讲解了。 site命令用于生成当前项目的发布站点，暂时不需要了解。 我们之前还讲解了多模块项目，那么多模块下父项目存在一个packing打包类型标签，所有的父级项目的packing都为pom，packing默认是jar类型，如果不作配置，maven会将该项目打成jar包。作为父级项目，还有一个重要的属性，那就是modules，通过modules标签将项目的所有子项目引用进来，在build父级项目时，会根据子模块的相互依赖关系整理一个build顺序，然后依次build。 实战：基于Mybatis+JUL+Lombok+Maven的图书管理系统（带单元测试）项目需求： 在线录入学生信息和书籍信息 查询书籍信息列表 查询学生信息列表 查询借阅信息列表 完整的日志系统","categories":[],"tags":[]},{"title":"","slug":"白马Java Web/JavaWeb笔记（二）","date":"2025-08-31T15:29:05.020Z","updated":"2025-08-31T15:31:22.573Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/0.html","excerpt":"数据库基础数据库是学习JavaWeb的一个前置，只有了解了数据库的操作和使用，我们才能更好地组织和管理网站应用产生的数据。 什么是数据库数据库是数据管理的有效技术，是由一批数据构成的有序集合，这些数据被存放在结构化的数据表里。数据表之间相互关联，反映客观事物间的本质联系。数据库能有效地帮助一个组织或企业科学地管理各类信息资源。简而言之，我们的数据可以交给数据库来帮助我们进行管理，同时数据库能够为我们提供高效的访问性能。 在JavaSE学习阶段中，我们学习了如何使用文件I/O来将数据保存到本地，这样就可以将一个数据持久地存储在本地，即使程序重新打开，我们也能加载回上一次的数据，但是当我们的数据变得非常多的时候，这样的方式就显得不太方便了。同时我们如果需要查找众多数据的中的某一个，就只能加载到内存再进行查找，这样显然是很难受的！ 而数据库就是专门做这事的，我们可以快速查找想要的数据，便捷地插入、修改和删除数据，并且数据库不仅能做这些事，还能提供更多便于管理数据和操作数据的功能！ 常见的数据库常见的数据库有很多种，包括但不限于：","text":"数据库基础数据库是学习JavaWeb的一个前置，只有了解了数据库的操作和使用，我们才能更好地组织和管理网站应用产生的数据。 什么是数据库数据库是数据管理的有效技术，是由一批数据构成的有序集合，这些数据被存放在结构化的数据表里。数据表之间相互关联，反映客观事物间的本质联系。数据库能有效地帮助一个组织或企业科学地管理各类信息资源。简而言之，我们的数据可以交给数据库来帮助我们进行管理，同时数据库能够为我们提供高效的访问性能。 在JavaSE学习阶段中，我们学习了如何使用文件I/O来将数据保存到本地，这样就可以将一个数据持久地存储在本地，即使程序重新打开，我们也能加载回上一次的数据，但是当我们的数据变得非常多的时候，这样的方式就显得不太方便了。同时我们如果需要查找众多数据的中的某一个，就只能加载到内存再进行查找，这样显然是很难受的！ 而数据库就是专门做这事的，我们可以快速查找想要的数据，便捷地插入、修改和删除数据，并且数据库不仅能做这些事，还能提供更多便于管理数据和操作数据的功能！ 常见的数据库常见的数据库有很多种，包括但不限于： MySQL - 免费，用的最多的，开源数据库，适用于中小型 Microsoft SQL Server - 收钱的，但是提供技术支持，适用于Windows Server Oracle - 收钱的，大型数据库系统 而我们要学习的是MySQL数据，其实无论学习哪种数据库，SQL语句大部分都是通用的，只有少许语法是不通用的，因此我们只需要学习一种数据库其他的也就差不多都会了。 数据模型数据模型与现实世界中的模型一样，是对现实世界数据特征的一种抽象。实际上，我们之前学习的类就是对现实世界数据的一种抽象，比如一个学生的特征包括姓名，年龄，年级，学号，专业等，这些特征也称为实体的一种属性，属性具有以下特点： 属性不可再分 一个实体的属性可以有很多个 用于唯一区分不同实体的的属性，称为Key，比如每个同学的学号都是不一样的 属性取值可以有一定的约束，比如性别只能是男或是女 实体或是属性之间可以具有一定的联系，比如一个老师可以教很多个学生，而学生相对于老师就是被教授的关系；又比如每个同学都有一个学号与其唯一对应，因此学号和学生之间也有一种联系。而像一个老师教多个学生的联系就是一种一对多的联系（1:n），而学号唯一对应，就是一种一对一的联系（1:1）；每一个老师不仅可以教多个学生，每一个学生也可以有多个教师，这就是一种多对多的联系（n:m） MySQL就是一种关系型数据库，通过使用关系型数据库，我们就可以很好地存储这样带有一定联系的数据。 通过构建一个ER图，我们就能很好地理清不同数据模型之间的关系和特点。 数据库的创建既然了解了属性和联系，那么我们就来尝试创建一个数据库，并在数据库中添加用于存放数据的表，每一张表都代表一种实体的数据。首先我们要明确，我们需要创建什么样子的表： 学生表：用于存放所有学生的数据，学生（学号，姓名，性别） 教师表：用于存放所有教师的数据，教师（教师号，姓名） 授课表：用于存放教师与学生的授课信息，授课（学号，教师号） 其中，标注下划线的属性，作为Key，用于区别于其他实体数据的唯一标记。 为了理解起来更加轻松，我们从图形界面操作再讲到SQL语句，请不要着急。我们现在通过Navicat或idea自带的数据库客户端来创建一个数据库和上述三个表。 数据库的规范化要去设计存放一个实体的表，我们就需要了解数据库的关系规范化，尽可能减少“不好”的关系存在，如何设计一个优良的关系模型是最关键的内容！简而言之，我们要学习一下每一个表该如何去设计。 第一范式（1NF）第一范式是指数据库的每一列都是不可分割的基本数据项，而下面这样的就存在可分割的情况： 学生（姓名，电话号码） 电话号码实际上包括了家用座机电话和移动电话，因此它可以被拆分为： 学生（姓名，座机号码，手机号码） 满足第一范式是关系型数据库最基本的要求！ 第二范式（2NF）第二范式要求表中必须存在主键，且其他的属性必须完全依赖于主键，比如： 学生（学号，姓名，性别） 学号是每个学生的唯一标识，每个学生都有着不同的学号，因此此表中存在一个主键，并且每个学生的所有属性都依赖于学号，学号发生改变就代表学生发生改变，姓名和性别都会因此发生改变，所有此表满足第二范式。 第三范式（3NF）在满足第二范式的情况下，所有的属性都不传递依赖于主键，满足第三范式。 学生借书情况（借阅编号，学生学号，书籍编号，书籍名称，书籍作者） 实际上书籍编号依赖于借阅编号，而书籍名称和书籍作者依赖于书籍编号，因此存在传递依赖的情况，我们可以将书籍信息进行单独拆分为另一张表： 学生借书情况（借阅编号，学生学号，书籍编号） 书籍（书籍编号，书籍名称，书籍作者） 这样就消除了传递依赖，从而满足第三范式。 BCNFBCNF作为第三范式的补充，假设仓库管理关系表为StorehouseManage(仓库ID, 存储物品ID, 管理员ID, 数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。这个数据库表中存在如下决定关系： (仓库ID, 存储物品ID) →(管理员ID, 数量) (管理员ID, 存储物品ID) → (仓库ID, 数量) 所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系： (仓库ID) → (管理员ID) (管理员ID) → (仓库ID) 即存在关键字段决定关键字段的情况，如果修改管理员ID，那么就必须逐一进行修改，所以其不符合BCNF范式。 认识SQL语句结构化查询语言（Structured Query Language）简称SQL，这是一种特殊的语言，它专门用于数据库的操作。每一种数据库都支持SQL，但是他们之间会存在一些细微的差异，因此不同的数据库都存在自己的“方言”。 SQL语句不区分大小写（关键字推荐使用大写），它支持多行，并且需要使用;进行结尾！ SQL也支持注释，通过使用--或是#来编写注释内容，也可以使用/*来进行多行注释。 我们要学习的就是以下四种类型的SQL语言： 数据查询语言（Data Query Language, DQL）基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块。 数据操纵语言（Data Manipulation Language, DML）是SQL语言中，负责对数据库对象运行数据访问工作的指令集，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入、更新与删除，是开发以数据为中心的应用程序必定会使用到的指令。 数据库定义语言DDL(Data Definition Language)，是用于描述数据库中要存储的现实世界实体的语言。 DCL（Data Control Language）是数据库控制语言。是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL。 我们平时所说的CRUD其实就是增删改查（Create/Retrieve/Update/Delete） 数据库定义语言（DDL）数据库操作我们可以通过create database来创建一个数据库： 1create database 数据库名 为了能够支持中文，我们在创建时可以设定编码格式： 1CREATE DATABASE IF NOT EXISTS 数据库名 DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 如果我们创建错误了，我们可以将此数据库删除，通过使用drop database来删除一个数据库： 1drop database 数据库名 创建表数据库创建完成后，我们一般通过create table语句来创建一张表： 1234create table 表名(列名 数据类型[列级约束条件], 列名 数据类型[列级约束条件], ... [,表级约束条件]) SQL数据类型以下的数据类型用于字符串存储： char(n)可以存储任意字符串，但是是固定长度为n，如果插入的长度小于定义长度时，则用空格填充。 varchar(n)也可以存储任意数量字符串，长度不固定，但不能超过n，不会用空格填充。 以下数据类型用于存储数字： smallint用于存储小的整数，范围在 (-32768，32767) int用于存储一般的整数，范围在 (-2147483648，2147483647) bigint用于存储大型整数，范围在 (-9,223,372,036,854,775,808，9,223,372,036,854,775,807) float用于存储单精度小数 double用于存储双精度的小数 以下数据类型用于存储时间： date存储日期 time存储时间 year存储年份 datetime用于混合存储日期+时间 列级约束条件列级约束有六种：主键Primary key、外键foreign key 、唯一 unique、检查 check （MySQL不支持）、默认default 、非空/空值 not null/ null 表级约束条件表级约束有四种：主键、外键、唯一、检查 现在我们通过SQL语句来创建我们之前提到的三张表。 1[CONSTRAINT &lt;外键名&gt;] FOREIGN KEY 字段名 [，字段名2，…] REFERENCES &lt;主表名&gt; 主键列1 [，主键列2，…] 修改表如果我们想修改表结构，我们可以通过alter table来进行修改： 123ALTER TABLE 表名[ADD 新列名 数据类型[列级约束条件]] [DROP COLUMN 列名[restrict|cascade]] [ALTER COLUMN 列名 新数据类型] 我们可以通过ADD来添加一个新的列，通过DROP来删除一个列，不过我们可以添加restrict或cascade，默认是restrict，表示如果此列作为其他表的约束或视图引用到此列时，将无法删除，而cascade会强制连带引用此列的约束、视图一起删除。还可以通过ALTER来修改此列的属性。 删除表我们可以通过drop table来删除一个表： 1DROP TABLE 表名[restrict|cascade] 其中restrict和cascade上面的效果一致。 数据库操纵语言（DML）前面我们已经学习了如何使用SQL语句来创建、修改、删除数据库以及表，而如何向数据库中插入、删除、更新数据，将是本版块讨论的重点。 插入数据通过使用insert into语句来向数据库中插入一条数据（一条记录）： 1INSERT INTO 表名 VALUES(值1, 值2, 值3) 如果插入的数据与列一一对应，那么可以省略列名，但是如果希望向指定列上插入数据，就需要给出列名： 1INSERT INTO 表名(列名1, 列名2) VALUES(值1, 值2) 我们也可以一次性向数据库中插入多条数据： 1INSERT INTO 表名(列名1, 列名2) VALUES(值1, 值2), (值1, 值2), (值1, 值2) 我们来试试看向我们刚刚创建的表中添加三条数据。 修改数据我们可以通过update语句来更新表中的数据： 1UPDATE 表名 SET 列名=值,... WHERE 条件 注意，SQL语句中的等于判断是= 警告：如果忘记添加WHERE字句来限定条件，将使得整个表中此列的所有数据都被修改！ 删除数据我们可以通过使用delete来删除表中的数据： 1DELETE FROM 表名 通过这种方式，将删除表中全部数据，我们也可以使用where来添加条件，只删除指定的数据： 1DELETE FROM 表名 WHERE 条件 数据库查询语言（DQL）数据库的查询是我们整个数据库学习中的重点内容，面对数据库中庞大的数据，该如何去寻找我们想要的数据，就是我们主要讨论的问题。 单表查询单表查询是最简单的一种查询，我们只需要在一张表中去查找数据即可，通过使用select语句来进行单表查询： 12345678-- 指定查询某一列数据SELECT 列名[,列名] FROM 表名-- 会以别名显示此列SELECT 列名 别名 FROM 表名-- 查询所有的列数据SELECT * FROM 表名-- 只查询不重复的值SELECT DISTINCT 列名 FROM 表名 我们也可以添加where字句来限定查询目标： 1SELECT * FROM 表名 WHERE 条件 常用查询条件 一般的比较运算符，包括=、&gt;、&lt;、&gt;=、&lt;=、!=等。 是否在集合中：in、not in 字符模糊匹配：like，not like 多重条件连接查询：and、or、not 我们来尝试使用一下上面这几种条件。 排序查询我们可以通过order by来将查询结果进行排序： 1SELECT * FROM 表名 WHERE 条件 ORDER BY 列名 ASC|DESC 使用ASC表示升序排序，使用DESC表示降序排序，默认为升序。 我们也可以可以同时添加多个排序： 1SELECT * FROM 表名 WHERE 条件 ORDER BY 列名1 ASC|DESC, 列名2 ASC|DESC 这样会先按照列名1进行排序，每组列名1相同的数据再按照列名2排序。 聚集函数聚集函数一般用作统计，包括： count([distinct]*)统计所有的行数（distinct表示去重再统计，下同） count([distinct]列名)统计某列的值总和 sum([distinct]列名)求一列的和（注意必须是数字类型的） avg([distinct]列名)求一列的平均值（注意必须是数字类型） max([distinct]列名)求一列的最大值 min([distinct]列名)求一列的最小值 一般聚集函数是这样使用的： 1SELECT count(distinct 列名) FROM 表名 WHERE 条件 分组和分页查询通过使用group by来对查询结果进行分组，它需要结合聚合函数一起使用： 1SELECT sum(*) FROM 表名 WHERE 条件 GROUP BY 列名 我们还可以添加having来限制分组条件： 1SELECT sum(*) FROM 表名 WHERE 条件 GROUP BY 列名 HAVING 约束条件 我们可以通过limit来限制查询的数量，只取前n个结果： 1SELECT * FROM 表名 LIMIT 数量 我们也可以进行分页： 1SELECT * FROM 表名 LIMIT 起始位置,数量 多表查询多表查询是同时查询的两个或两个以上的表，多表查询会提通过连接转换为单表查询。 1SELECT * FROM 表1, 表2 直接这样查询会得到两张表的笛卡尔积，也就是每一项数据和另一张表的每一项数据都结合一次，会产生庞大的数据。 1SELECT * FROM 表1, 表2 WHERE 条件 这样，只会从笛卡尔积的结果中得到满足条件的数据。 注意：如果两个表中都带有此属性吗，需要添加表名前缀来指明是哪一个表的数据。 自身连接查询自身连接，就是将表本身和表进行笛卡尔积计算，得到结果，但是由于表名相同，因此要先起一个别名： 1SELECT * FROM 表名 别名1, 表名 别名2 其实自身连接查询和前面的是一样的，只是连接对象变成自己和自己了。 外连接查询外连接就是专门用于联合查询情景的，比如现在有一个存储所有用户的表，还有一张用户详细信息的表，我希望将这两张表结合到一起来查看完整的数据，我们就可以通过使用外连接来进行查询，外连接有三种方式： 通过使用inner join进行内连接，只会返回两个表满足条件的交集部分： 通过使用left join进行左连接，不仅会返回两个表满足条件的交集部分，也会返回左边表中的全部数据，而在右表中缺失的数据会使用null来代替（右连接right join同理，只是反过来而已，这里就不再介绍了）： 嵌套查询我们可以将查询的结果作为另一个查询的条件，比如： 1SELECT * FROM 表名 WHERE 列名 = (SELECT 列名 FROM 表名 WHERE 条件) 我们来再次尝试编写一下在最开始我们查找某教师所有学生的SQL语句。 数据库控制语言（DCL）庞大的数据库不可能由一个人来管理，我们需要更多的用户来一起管理整个数据库。 创建用户我们可以通过create user来创建用户： 1CREATE USER 用户名 identified by 密码; 也可以不带密码： 1CREATE USER 用户名; 我们可以通过@来限制用户登录的登录IP地址，%表示匹配所有的IP地址，默认使用的就是任意IP地址。 登陆用户首先需要添加一个环境变量，然后我们通过cmd去登陆mysql： 1login -u 用户名 -p 输入密码后即可登陆此用户，我们输入以下命令来看看能否访问所有数据库： 1show databases; 我们发现，虽然此用户能够成功登录，但是并不能查看完整的数据库列表，这是因为此用户还没有权限！ 用户授权我们可以通过使用grant来为一个数据库用户进行授权： 1grant all|权限1,权限2...(列1,...) on 数据库.表 to 用户 [with grant option] 其中all代表授予所有权限，当数据库和表为*，代表为所有的数据库和表都授权。如果在最后添加了with grant option，那么被授权的用户还能将已获得的授权继续授权给其他用户。 我们可以使用revoke来收回一个权限： 1revoke all|权限1,权限2...(列1,...) on 数据库.表 from 用户 视图视图本质就是一个查询的结果，不过我们每次都可以通过打开视图来按照我们想要的样子查看数据。既然视图本质就是一个查询的结果，那么它本身就是一个虚表，并不是真实存在的，数据实际上还是存放在原来的表中。 我们可以通过create view来创建视图; 1CREATE VIEW 视图名称(列名) as 子查询语句 [WITH CHECK OPTION]; WITH CHECK OPTION是指当创建后，如果更新视图中的数据，是否要满足子查询中的条件表达式，不满足将无法插入，创建后，我们就可以使用select语句来直接查询视图上的数据了，因此，还能在视图的基础上，导出其他的视图。 若视图是由两个以上基本表导出的，则此视图不允许更新。 若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT和UPDATE操作，但允许执行DELETE操作。 若视图的字段来自集函数，则此视图不允许更新。 若视图定义中含有GROUP BY子句，则此视图不允许更新。 若视图定义中含有DISTINCT短语，则此视图不允许更新。 若视图定义中有嵌套查询，并且内层查询的FROM子句中涉及的表也是导出该视图的基本表，则此视图不允许更新。例如将成绩在平均成绩之上的元组定义成一个视图GOOD_SC： CREATE VIEW GOOD_SC AS SELECT Sno, Cno, Grade FROM SC WHERE Grade &gt; (SELECT AVG(Grade) FROM SC); 导出视图GOOD_SC的基本表是SC，内层查询中涉及的表也是SC，所以视图GOOD_SC是不允许更新的。 一个不允许更新的视图上定义的视图也不允许更新 通过drop来删除一个视图： 1drop view apptest 索引在数据量变得非常庞大时，通过创建索引，能够大大提高我们的查询效率，就像Hash表一样，它能够快速地定位元素存放的位置，我们可以通过下面的命令创建索引： 1234-- 创建索引CREATE INDEX 索引名称 ON 表名 (列名)-- 查看表中的索引show INDEX FROM student 我们也可以通过下面的命令删除一个索引： 1drop index 索引名称 on 表名 虽然添加索引后会使得查询效率更高，但是我们不能过度使用索引，索引为我们带来高速查询效率的同时，也会在数据更新时产生额外建立索引的开销，同时也会占用磁盘资源。 触发器触发器就像其名字一样，在某种条件下会自动触发，在select/update/delete时，会自动执行我们预先设定的内容，触发器通常用于检查内容的安全性，相比直接添加约束，触发器显得更加灵活。 触发器所依附的表称为基本表，当触发器表上发生select/update/delete等操作时，会自动生成两个临时的表（new表和old表，只能由触发器使用） 比如在insert操作时，新的内容会被插入到new表中；在delete操作时，旧的内容会被移到old表中，我们仍可在old表中拿到被删除的数据；在update操作时，旧的内容会被移到old表中，新的内容会出现在new表中。 1CREATE TRIGGER 触发器名称 [BEFORE|AFTER] [INSERT|UPDATE|DELETE] ON 表名/视图名 FOR EACH ROW DELETE FROM student WHERE student.sno = new.sno FOR EACH ROW表示针对每一行都会生效，无论哪行进行指定操作都会执行触发器！ 通过下面的命令来查看触发器： 1SHOW TRIGGERS 如果不需要，我们就可以删除此触发器： 1DROP TRIGGER 触发器名称 事务当我们要进行的操作非常多时，比如要依次删除很多个表的数据，我们就需要执行大量的SQL语句来完成，这些数据库操作语句就可以构成一个事务！只有Innodb引擎支持事务，我们可以这样来查看支持的引擎： 1SHOW ENGINES; MySQL默认采用的是Innodb引擎，我们也可以去修改为其他的引擎。 事务具有以下特性： 原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 我们通过以下例子来探究以下事务： 12345678begin; #开始事务...rollback; #回滚事务savepoint 回滚点; #添加回滚点rollback to 回滚点; #回滚到指定回滚点...commit; #提交事务-- 一旦提交，就无法再进行回滚了！ 选学内容函数和存储过程并没有包含在我们的教程当中，但是这并不代表它们就不重要，通过学习它们能够让你的数据库管理能力更上一层楼，它们能够捆绑一组SQL语句运行，并且可以反复使用，大大提高工作效率。","categories":[],"tags":[]},{"title":"Oracle","slug":"黑马Oracle/oracle learning","date":"2025-07-07T09:36:01.015Z","updated":"2025-07-27T03:34:30.703Z","comments":true,"path":"posts/f145fed6.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/f145fed6.html","excerpt":"Oracle简介Oracle特点Oracle数据库具有以下特点： 支持多用户，大事务量的事务处理 数据安全性和完整性控制 支持分布式数据处理 可移植性 Oracle体系结构数据库Oracle数据库是数据的物理存储。Oracle的数据库是指一个操作系统只有一个库，可以看做Oracle只有一个大数据库。 实例一个Oracle实例（Oracle Instance）有一系列的后台进程（Background Processes）和内存结构（Memory Structures）组成。一个数据库可以有多个(n个)实例。","text":"Oracle简介Oracle特点Oracle数据库具有以下特点： 支持多用户，大事务量的事务处理 数据安全性和完整性控制 支持分布式数据处理 可移植性 Oracle体系结构数据库Oracle数据库是数据的物理存储。Oracle的数据库是指一个操作系统只有一个库，可以看做Oracle只有一个大数据库。 实例一个Oracle实例（Oracle Instance）有一系列的后台进程（Background Processes）和内存结构（Memory Structures）组成。一个数据库可以有多个(n个)实例。 数据文件(dbf) 数据文件是数据库的物理存储单位。数据库的数据是存储在表空间中的。 一个表空间可以由一个或多个数据文件组成，一个数据文件只能属于一个表空间。 一旦数据文件被加入到某个表空间，就不能删除这个文件，如果要删除该数据文件，必须删除其所属的表空间才可以。 表空间 表空间是Oracle对物理数据库上相关数据文件（ORA或者DBF文件）的逻辑映射。 一个数据库在逻辑上被划分成一到若干个表空间，每个表空间包含了在逻辑上相关联的一组结构。 每个数据库至少有一个表空间称之为 system 表空间 。 每个表空间由同一磁盘上的一个或多个文件组成，这些文件叫数据文件(datafile) 。一个数据文件只能属于一个表空间。 注： (1)表的数据，是有用户放入某一个表空间的，而这个表空间会随机把这些表数据放到一个或者多个数据文件中。 (2)逻辑结构最小单位是数据块，不是磁盘块。 由于 oracle 的数据库不是普通的概念， oracle 是由用户和表空间对数据进行管理和存放的。但是表不是由表空间去查询的，而是由用户去查的。因为不同用户可以在同一个表空间建立同一个名字的表！这里区分就是用户了！ 图片理解： 这个符号是指一个数据文件由多个磁盘块组成 用户表空间—&gt;用户—&gt;表 用户是在表空间下建立的。用户登陆后只能看到和操作自己的表 , Oracle的用户与MySQL的数据库类似，每建立一个应用需要创建一个用户。 超级管理员账户 数据库操作创建表空间12345CREATE tablespace waterbossdatafile 'D:\\2_dan\\learningVideo\\oracle\\waterboss.dbf'size 100mautoextend ONnext 10m; 名字可以一样，也可以不一样 创建用户123create user wateruserIDENTIFIED BY 123456default tablespace waterboss; wateruser：用户名 123456：密码 waterboss：默认表空间名称 用户赋权1grant dba to wateruser;--给用户赋dba权限 表的创建、修改与删除创建表语法： 12345CREATE TABLE 表名称(字段名 类型 长度 primary key字段名 类型 长度......); 12345678910create table t_owners(id number primary key,name varchar2(30),addressid number,housenumber varchar2(30),watermeter varchar2(30),adddate date,ownertypeid number); 数据类型字符型 CHAR : 固定长度的字符类型，最多存储 2000 个字节 VARCHAR2 : 可变长度的字符类型，最多存储 4000 个字节 LONG : 大文本类型。 最大可以存储 2G 数值型 NUMBER : 数值类型 例如：NUMBER (5) 最大可以存的数为 99999NUMBER(5,2) 最大可以存的数为 999.99 日期型 DATE ：日期时间型，精确到秒 TIMESTAMP ：精确到秒的小数点后 9 位 二进制型 CLOB : 存储字符 最大可以存 4G BLOB ：存储图像、声音、 视频等二进制数据 最多可以存 4G 修改表增加字段语法 12345ALTER TABLE 表名称 ADD( 列名1 类型 [DEFAULT 默认值]， 列名2 类型 [DEFAULT 默认值]); 1ALTER TABLE T_OWNERS ADD ( REMARK VARCHAR2 ( 20 ), OUTDATE DATE ) ; 修改字段语法 12345ALTER TABLE 表名称 MODIFY(列名1 类型 [DEFAULT 默认值]，列名2 类型 [DEFAULT 默认值]) 1234ALTER TABLE T_OWNERS MODIFY( NAME CHAR(20) DEFAULT 'hello') 修改字段名语法 1ALTER TABLE 表名称 RNAME COLUMN 原列名 TO 新列名 1ALTER TABLE T_OWNERS RENAME COLUMN OUTDATE TO EXITDATE 删除字段名 12345--删除一个字段ALTER TABLE 表名称 DROP COLUMN 列名--删除多个字段ALTER TABLE 表名称 DROP( 列名1, 列名2...) 12--删除字段ALTER TABLE T_OWNERS DROP COLUMN REMARK 删除表1DROP TABLE 表名称 数据增删改插入数据语法： 1INSERT INTO 表名( 列名1，列名2，...) VALUES ( 值1，值2...) 1insert into T_OWNERS_COPY VALUES(11, '张三丰', 1, '123', '321', sysdate, 1); 修改数据方式1 1update 表名 set 列名1=值1, 列名2=值2,... where 修改条件; 1update T_OWNERS_COPY set NAME = '小红', ADDRESSID = '888' where id = 1; 方式2 1truncate table 表名 两种方式的区别： truncate删除的数据不可以rollback，delete删除的数据可以rollback 删除数据语法： 1delete fromm 表名 where 删除条件; 1delete from T_OWNERS_COPY where id = 11; JDBC连接Oracle导入驱动包ojdbc8.jaroracle 19c安装之后的ojdbc.jar包在下面这个地方可以找到，D:\\6_application\\oracle\\jdbc\\lib 将上面的jar添加到工程的library，否则会报下面这个错误。 12345678910111213141516171819java.lang.ClassNotFoundException: oracle.jdbc.driver.OracleDriver at java.net.URLClassLoader.findClass(URLClassLoader.java:382) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) at java.lang.Class.forName0(Native Method) at java.lang.Class.forName(Class.java:264) at dao.BaseDao.&lt;clinit&gt;(BaseDao.java:11) at dao.OwnerDao.add(OwnerDao.java:15) at test.Test01.main(Test01.java:17)Exception in thread \"main\" java.lang.RuntimeException: java.sql.SQLException: No suitable driver found for jdbc:oracle:thin:@localhost:1521:orcl at dao.OwnerDao.add(OwnerDao.java:26) at test.Test01.main(Test01.java:17)Caused by: java.sql.SQLException: No suitable driver found for jdbc:oracle:thin:@localhost:1521:orcl at java.sql.DriverManager.getConnection(DriverManager.java:689) at java.sql.DriverManager.getConnection(DriverManager.java:247) at dao.BaseDao.getConnection(BaseDao.java:23) at dao.OwnerDao.add(OwnerDao.java:15) ... 1 more BaseDao123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package dao;import java.sql.*;/** * 基础数据访问类 */public class BaseDao { static { try { Class.forName(\"oracle.jdbc.driver.OracleDriver\"); // 加载Oracle JDBC驱动 } catch (Exception e) { e.printStackTrace(); } } /** * 获取数据库连接 * * @return 数据库连接对象 */ public static Connection getConnection() throws SQLException { //痩连接: jdbc:oracle:thin return DriverManager.getConnection(\"jdbc:oracle:thin:@localhost:1521:orcl\", \"wateruser\", \"123456\"); } /** * 关闭数据库连接 * * @param conn 数据库连接对象 */ public static void close(ResultSet rs, Statement stmt, Connection conn) { if (rs != null) { try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if (stmt != null) { try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn != null) { try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } }} OwnerDao1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package dao;import entity.Owners;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;public class OwnerDao { public static void add(Owners owner) { Connection conn = null; //预处理，防止注入攻击 PreparedStatement stmt = null; try { conn = BaseDao.getConnection(); stmt = conn.prepareStatement(\"INSERT INTO T_OWNERS_COPY (id, name, addressid, housenumber, watermeter, adddate, ownertypeid) VALUES (?, ?, ?, ?, ?, ?, ?)\"); stmt.setLong(1, owner.getId()); stmt.setString(2, owner.getName()); stmt.setLong(3, owner.getAddressid()); stmt.setString(4, owner.getHousenumber()); stmt.setString(5, owner.getWatermeter()); //日期转为长整型Long, 然后再构造为java.sql.Date类型 stmt.setDate(6, new java.sql.Date(owner.getAdddate().getTime())); stmt.setLong(7, owner.getOwnertypeid()); stmt.executeUpdate(); } catch (SQLException e) { throw new RuntimeException(e); } finally { BaseDao.close(null, stmt, conn); } } public static void modify(Owners owner) { Connection conn = null; PreparedStatement stmt = null; try { conn = BaseDao.getConnection(); stmt = conn.prepareStatement(\"update T_OWNERS_COPY set name =?, addressid=?, housenumber=?, watermeter=?, adddate=?, ownertypeid=? where id=?\"); stmt.setString(1, owner.getName()); stmt.setLong(2, owner.getAddressid()); stmt.setString(3, owner.getHousenumber()); stmt.setString(4, owner.getWatermeter()); stmt.setDate(5, new java.sql.Date(owner.getAdddate().getTime())); stmt.setLong(6, owner.getOwnertypeid()); stmt.setLong(7, owner.getId()); stmt.executeUpdate(); } catch (SQLException e) { throw new RuntimeException(e); } finally { BaseDao.close(null, stmt, conn); } } public static void delete(Owners owner) { Connection conn = null; PreparedStatement stmt = null; try { conn = BaseDao.getConnection(); stmt = conn.prepareStatement(\"delete from T_OWNERS_COPY where id=?\"); stmt.setLong(1, owner.getId()); stmt.executeUpdate(); } catch (SQLException e) { throw new RuntimeException(e); } finally { BaseDao.close(null, stmt, conn); } }} 实体类Owners123456789101112131415161718192021public class Owners { private Long id;//业主编号 private String name;// 业主名称 private Long addressid;// 地址编号 private String housenumber;// 门牌号 private String watermeter;// 水表编号 private Date adddate;// 登记日期 private Long ownertypeid;// 业主类型 ID public Long getId() { return id; } public void setId(Long id) { this.id = id; } /* 其他getter，setter方法，省略 */} 测试代码1234567891011121314public class Test02 { public static void main(String[] args) { Owners owner = new Owners(); owner.setId(1L); owner.setName(\"张三\"); owner.setAddressid(111L); owner.setHousenumber(\"111号\"); owner.setWatermeter(\"6666\"); owner.setAdddate(new java.util.Date()); owner.setOwnertypeid(888L); OwnerDao.modify(owner); }} 执行modify方法之前 执行modify方法之后 数据导入与导出数据库导入与导出整库导出1exp system/超级管理员用户system的密码 full=y --full=y表示整库导出 执行命令后会在当前目录下生成一个叫EXPDAT.DMP，此文件为备份文件。 添加file参数即可指定备份文件的名称 1exp system/超级管理员用户system的密码 file=文件名 full=y 整库导入1imp system/超级管理员用户system的密码 full=y 如果指定file 参数，则按照file指定的备份文件进行导入 1imp system/超级管理员用户system的密码 full=y file=water.dmp 按用户导入与导出导出1exp system/itcast owner=wateruser file=wateruser.dmp 导入1imp system/itcast file=wateruser.dmp fromuser=wateruser 导入前特意删掉T_OWNERS_COPY表 导入后刷新，表成功导入 按表导入与导出导出1exp wateruser/123456 file=a.dmp tables=t_account,a_area 导入1imp wateruser/123456 file=a.dmp tables=t_account,a_area 单表查询简单条件查询精确查询需求：查询水表编号为30408 的业主记录 查询语句： 123456SELECT * FROM T_OWNERS WHERE watermeter = '30408' 查询结果： 模糊查询需求：查询业主名称包含“刘”的业主记录 查询语句： 123456SELECT * FROM t_owners WHERE name LIKE '%刘%' 查询结果： and运算符需求：查询业主名称包含“刘”的并且门牌号包含5 的业主记录 查询语句： 1234567SELECT * FROM t_owners WHERE name LIKE '%刘%' AND housenumber LIKE '%5%' 查询结果： or运算符需求：查询业主名称包含“刘”的或者门牌号包含5 的业主记录 查询语句： 1234567SELECT * FROM t_owners WHERE name LIKE '%刘%' OR housenumber LIKE '%5%' 查询结果： and和or运算符混合使用需求：查询业主名称包含“刘”的或者门牌号包含5 的业主记录，并且地址编号为3 的记录。 查询语句： 12345678--and 的优先级比or大，需要用()来改变优先级。SELECT * FROM t_owners WHERE ( name LIKE '%刘%' OR housenumber LIKE '%5%' ) AND addressid =3 查询结果： 范围查询需求：查询台账记录中用水量大于等于10000，并且小于等于20000 的记录 用&gt;= 和&lt;=来实现 查询语句： 1234567SELECT * FROM T_ACCOUNT WHERE usenum &gt;= 10000 AND usenum &lt;= 20000 查询结果： 用between .. and ..来实现 查询语句： 1234567SELECT * FROM T_ACCOUNT WHERE usenum BETWEEN 10000 AND 20000 查询结果： 空值查询需求1：查询T_PRICETABLE 表中MAXNUM 为空的记录 查询语句： 123456SELECT * FROM T_PRICETABLE t WHERE maxnum IS NULL 查询结果： 需求2：查询T_PRICETABLE 表中MAXNUM 不为空的记录 查询语句： 123456SELECT * FROM T_PRICETABLE t WHERE maxnum IS NOT NULL 查询结果： 去重需求：查询业主表中的地址ID,不重复显示 查询语句： 1234SELECT DISTINCT addressid FROM T_OWNERS 查询结果： 排序查询需求1：对T_ACCOUNT 表按使用量进行升序排序 查询语句： 1234567--默认是升序SELECT * FROM T_ACCOUNT ORDER BY usenum 查询结果： 需求2：对T_ACCOUNT 表按使用量进行降序排序 查询语句： 123456SELECT * FROM T_ACCOUNT ORDER BY usenum DESC 查询结果： 基于伪列的查询在Oracle 的表的使用过程中，实际表中还有一些附加的列，称为伪列。伪列就像表中的列一样，但是在表中并不存储。伪列只能查询，不能进行增删改操作。 ROWID表中的每一行在数据文件中都有一个物理地址，ROWID 伪列返回的就是该行的物理地址。 使用ROWID 可以快速的定位表中的某一行。 ROWID 值可以唯一的标识表中的一行。 由于ROWID 返回的是该行的物理地址，因此使用ROWID 可以显示行是如何存储的。 查询语句： 12345SELECT ROWID , t.* FROM T_AREA t 查询结果： ROWNUM在查询 的结果集中，ROWNUMM为结果集中每一行标识一个行号。第一行返回1，第二行返回2…。通过它可以限制查询结果集中返回的行数。 查询语句： 12345SELECT ROWNUM , t.* FROM T_OWNERTYPE t 查询结果： 聚合统计Oralce中的聚合统计是通过分组函数来实现的。 聚合函数 求和sum 需求：统计2012 年所有用户的用水量总和 查询语句： 123456SELECT sum( usenum ) FROM t_account WHERE year = '2012' 查询结果： 求平均avg 需求：统计2012 年所有用水量（字数）的平均值 查询语句： 123456SELECT avg(usenum) FROM T_ACCOUNT WHERE year = '2012' 查询结果： 求最大值max 需求：统计2012 年最高用水量（字数） 查询语句： 123456SELECT max( usenum ) FROM T_ACCOUNT WHERE year = '2012' 查询结果： 求最小值min 需求：统计2012 年最低用水量（字数） 查询语句： 123456SELECT min( usenum ) FROM T_ACCOUNT WHERE year = '2012' 查询结果： 统计记录个数count 需求：统计业主类型ID 为1 的业主数量 查询语句： 123456SELECT count( * ) FROM T_OWNERS t WHERE ownertypeid =1 查询结果： 分组聚合group by需求：按区域分组统计水费合计数 查询语句： 1234567SELECT areaid, sum( money ) FROM t_account GROUP BY areaid 查询结果： 分组后条件查询having需求：查询水费合计大于16900 的区域及水费合计 查询语句： 123456789SELECT areaid, sum( money ) FROM t_account GROUP BY areaid HAVING sum( money ) &gt; 169000 查询结果： 连接查询多表内连接查询需求1：查询显示业主编号，业主名称，业主类型名称，如下图： 查询语句： 123456789SELECT o.id 业主编号, o.name 业主名称, ot.name 业主类型 FROM T_OWNERS o, T_OWNERTYPE ot WHERE o.ownertypeid = ot.id 查询结果： 需求2：查询显示业主编号，业主名称、地址和业主类型，如下图 查询语句： 123456789101112SELECT o.id 业主编号, o.name 业主名称, ad.name 地址, ot.name 业主类型 FROM T_OWNERS o, T_OWNERTYPE ot, T_ADDRESS ad WHERE o.ownertypeid = ot.id AND o.addressid = ad.id 查询结果： 需求3：查询显示业主编号、业主名称、地址、所属区域、业主分类，如下图： 查询语句： 123456789101112131415SELECT o.id 业主编号, o.name 业主名称, ar.name 区域, ad.name 地址, ot.name 业主类型 FROM T_OWNERS o, T_OWNERTYPE ot, T_ADDRESS ad, T_AREA ar WHERE o.ownertypeid = ot.id AND o.addressid = ad.id AND ad.areaid = ar.id 查询结果： 需求：查询显示业主编号、业主名称、地址、所属区域、收费员、业主分类，如下图： 查询语句： 123456789101112131415161718SELECT ow.id 业主编号, ow.name 业主名称, ad.name 地址, ar.name 所属区域, op.name 收费员, ot.name 业主类型 FROM T_OWNERS ow, T_OWNERTYPE ot, T_ADDRESS ad, T_AREA ar, T_OPERATOR op WHERE ow.ownertypeid = ot.id AND ow.addressid = ad.id AND ad.areaid = ar.id AND ad.operatorid = op.id 查询结果： 左外连接查询需求1：查询业主的账务记录，显示业主编号、名称、年、月、金额。如果此业主没有账务记录也要列出姓名。 分析：业主表为左表、账务表为右表。 按照SQL1999标准的语法，查询语句： 123456789SELECT ow.id, ow.name, ac.year, ac.month, ac.money FROM T_OWNERS ow LEFT JOIN T_ACCOUNT ac ON ow.id = ac.owneruuid 查询结果： 按照Oracle提供的语法，查询语句： 如果是左外连接，就在右表所在的条件后面加上(+) 1234567891011SELECT ow.id, ow.name, ac.year, ac.month, ac.money FROM T_OWNERS ow, T_ACCOUNT ac WHERE ow.id = ac.owneruuid ( + ) 查询结果： 和上面的结果一样 右外连接查询需求：查询业主的账务记录，显示业主编号、名称、年、月、金额。如果账务记录没有对应的业主信息，也要列出记录。如下图： 按照SQL1999标准的语法，查询语句： 123456789SELECT ow.id, ow.name, ac.year, ac.month, ac.money FROM T_OWNERS ow RIGHT JOIN T_ACCOUNT ac ON ow.id = ac.owneruuid 查询结果： 按照Oracle提供的语法，查询语句： 1234567891011SELECT ow.id, ow.name, ac.year, ac.month, ac.money FROM T_OWNERS ow, T_ACCOUNT ac WHERE ow.id ( + ) = ac.owneruuid 查询结果： 和上面的结果一样 子查询where子句中的子查询单行子查询 只返回一条记录 单行操作符 需求：查询2012 年1 月用水量大于平均值的台账记录 查询语句： 12345678SELECT * FROM T_ACCOUNT WHERE year = '2012' AND month = '01' AND usenum &gt; ( SELECT avg( usenum ) FROM T_ACCOUNT WHERE year = '2012' AND month = '01' ) 查询结果： 多行子查询 可能会返回多条记录 多行操作符 in运算符需求1：查询地址编号为1 、3、4 的业主记录 查询语句： 123456SELECT * FROM T_OWNERS WHERE addressid IN ( 1, 3, 4 ) 查询结果： 需求2：查询地址含有“花园”的业主的信息 查询语句： 123456SELECT * FROM T_OWNERS WHERE addressid IN ( SELECT id FROM t_address WHERE name LIKE '%花园%' ) 查询结果： 需求3：查询地址不含有“花园”的业主的信息 查询语句： 123456SELECT * FROM T_OWNERS WHERE addressid NOT IN ( SELECT id FROM t_address WHERE name LIKE '%花园%' ) 查询结果： from子句中的子查询from 子句的子查询为多行子查询需求：查询显示业主编号，业主名称，业主类型名称，条件为业主类型为”居民”，使用子查询实现。 查询语句： 12345678910111213141516SELECT * FROM ( SELECT o.id 业主编号, o.name 业主名称, ot.name 业主类型 FROM T_OWNERS o, T_OWNERTYPE ot WHERE o.ownertypeid = ot.id ) WHERE 业主类型= '居民' 查询结果： select子句中的子查询select 子句的子查询必须为单行子查询 需求1：列出业主信息，包括ID，名称，所属地址。 查询语句： 123456SELECT id, name, ( SELECT name FROM t_address WHERE id = addressid ) addressname FROM t_owners 查询结果： 需求2：列出业主信息，包括ID，名称，所属地址，所属区域。 老师写的查询语句： 1234567SELECT id, name, ( SELECT name FROM t_address WHERE id = addressid ) addressname, ( SELECT ( SELECT name FROM t_area WHERE id = areaid ) FROM t_address WHERE id = addressid ) adrename FROM t_owners; 查询结果： 自己写的查询语句： 1234567SELECT id, name, ( SELECT name FROM T_ADDRESS WHERE id = ADDRESSID ) AS addressName, ( SELECT name FROM T_AREA WHERE id = ( SELECT id FROM T_ADDRESS WHERE id = ADDRESSID ) ) AS areaName FROM T_OWNERS; 犯过的错误 1234567SELECT id, name, ( SELECT name FROM T_ADDRESS WHERE id = ADDRESSID ) AS 'addressName', -- 会报错，因为子查询的结果列名使用了单引号 '，而在SQL中，单引号通常用于字符串值，而不是列别名。列别名应该使用双引号 \" 或者直接省略引号。 ( SELECT name FROM T_AREA WHERE id = ( SELECT id FROM T_ADDRESS WHERE id = ADDRESSID ) ) AS 'areaName' -- 会报错，原因同上FROM T_OWNERS; 分页查询简单分页rowNum只能是小于或者小于等于 需求：分页查询台账表T_ACCOUNT，每页10 条记录 查询前10条数据： 1234567SELECT ROWNUM , t.* FROM T_ACCOUNT t WHERE ROWNUM &lt;= 10; 查询第11条到第20条数据： 12SELECT ROWNUM, t.* FROM T_ACCOUNT t WHERE ROWNUM &gt; 10 AND ROWNUM &lt;= 20; 查询不到数据，原因是rownum是在查询语句扫描每条记录的时候产生的，不能使用大于符号，只能使用小于或者小于等于符号。只用等于符号也不行。 将语句改正确 123456SELECT * FROM ( SELECT ROWNUM r, t.* FROM t_account t WHERE ROWNUM &lt;= 20 ) WHERE r &gt; 10; 基于排序的分页需求：分页查询台账表T_ACCOUNT，每页10 条记录，按使用使用量降序排序。 先将数据按照使用量降序排序 123456SELECT * FROM t_account ORDER BY usenum DESC; 123456SELECT * FROM ( SELECT ROWNUM r, t.* FROM ( SELECT * FROM T_ACCOUNT ORDER BY usenum DESC ) t WHERE ROWNUM &lt;= 20 ) WHERE r &gt; 10 ; 单行函数一、字符函数 函数 说明 ASCII 返回对应字符的十进制值 CHR 给出十进制返回字符 CONCAT 拼接两个字符串，与 INITCAT 将字符串的第一个字母变为大写 INSTR 找出某个字符串的位置 INSTRB 找出某个字符串的位置和字节数 LENGTH 以字符给出字符串的长度 LENGTHB 以字节给出字符串的长度 LOWER 将字符串转换成小写 LPAD 使用指定的字符在字符的左边填充 LTRIM 在左边裁剪掉指定的字符 RPAD 使用指定的字符在字符的右边填充 RTRIM 在右边裁剪掉指定的字符 REPLACE 执行字符串搜索和替换 SUBSTR 取字符串的子串 SUBSTRB 取字符串的子串（以字节） SOUNDEX 返回一个同音字符串 TRANSLATE 执行字符串搜索和替换 TRIM 裁剪掉前面或后面的字符串 UPPER 将字符串变为大写 二、数值函数 函数 说明 ABS(value) 绝对值 CEIL(value) 大于或等于value的最小整数 COS(value) 余弦 COSH(value) 反余弦 EXP(value) e 的value次幂 FLOOR(value) 小于或等于value的最大整数 LN(value) value的自然对数 LOG(value) value的以10为底的对数 MOD(value,divisor) 求模 POWER(value,exponent) value的exponent次幂 ROUND(value,precision) 按precision 精度4舍5入 SIGN(value) value 为正返回1;为负返回-1;为0 返回0. SIN(value) 余弦 SINH(value) 反余弦 SQRT(value) value的平方根 TAN(value) 正切 TANH(value) 反正切 TRUNC(value,按precision) 按照precision截取value VSIZE(value) 返回value 在ORACLE的存储空间大小 三、日期函数 函数 描述 ADD_MONTHS 在日期date 上增加count 个月 GREATEST(date1,date2,. . .) 从日期列表中选出最晚的日期 LAST_DAY( date ) 返回日期date 所在月的最后一天 LEAST( date1, date2, . . .) 从日期列表中选出最早的日期 MONTHS_BETWEEN(date2,date1) 给出Date2 - date1 的月数(可以是小数) NEXT_DAY( date,’day’) 给出日期date 之后下一天的日期，这里的day 为星期，如： MONDAY,Tuesday 等。 NEW_TIME(date,’this’,’other’) 给出在this 时区=Other 时区的日期和时间 ROUND(date,’format’) 未指定format 时，如果日期中的时间在中午之前，则将日期中的时间截断为12 A.M.(午夜，一天的开始),否则进到第二天。时间截断为12 A.M.(午夜，一天的开始),否则进到第二天。 TRUNC(date,’format’) 未指定format 时，将日期截为12 A.M.( 午夜，一天的开始). 四、转换函数 函数 说明 CHARTOROWID 将字符转换到rowid类型 CONVERT 转换一个字符节到另外一个字符节 HEXTORAW 转换十六进制到raw 类型 RAWTOHEX 转换raw 到十六进制 ROWIDTOCHAR 转换ROWID 到字符 TO_CHAR 转换日期格式到字符串 TO_DATE 按照指定的格式将字符串转换到日期型 TO_MULTIBYTE 把单字节字符转换到多字节 TO_NUMBER 将数字字串转换到数字 TO_SINGLE_BYTE 转换多字节到单字节 五、其他函数空值处理函数NVL语法： NVL（检测的值，如果为null 的值）； 需求：显示价格表中业主类型ID 为1 的价格记录，如果上限值为NULL,则显示9999999 12345678SELECT PRICE, MINNUM, NVL( MAXNUM, 9999999 ) FROM T_PRICETABLE WHERE OWNERTYPEID =1 空值处理函数NVL2语法： NVL2（检测的值，如果不为null 的值，如果为null 的值）； 需求：显示价格表中业主类型ID 为1 的价格记录，如果上限值为NULL,显示“不限”. 12345678SELECT PRICE, MINNUM, NVL2( MAXNUM, to_char( MAXNUM ), '不限' ) FROM T_PRICETABLE WHERE OWNERTYPEID =1 条件取值decode语法： decode(条件,值1,翻译值1,值2,翻译值2,…值n,翻译值n,缺省值)【功能】根据条件返回相应值 需求：显示下列信息（不要关联查询业主类型表，直接判断1 2 3 的值） 写法1（Oracle特有的方法）： 123456SELECT name, decode( ownertypeid, 1, ' 居民', 2, ' 行政事业单位 ', 3, '商业' ) AS 类型 FROM T_OWNERS 写法2： 12345SELECT name, ( CASE ownertypeid WHEN 1 THEN '居民' WHEN 2 THEN '行政事业单位' WHEN 3 THEN '商业' ELSE '其它' END ) FROM T_OWNERS 写法3： 12345SELECT name, ( CASE WHEN ownertypeid = 1 THEN '居民' WHEN ownertypeid = 2 THEN '行政事业' WHEN ownertypeid = 3 THEN '商业' END ) FROM T_OWNERS 行列转换需求1：按月份统计2012 年各个地区的水费，如下图 1234567891011121314151617181920SELECT ( SELECT name FROM T_AREA WHERE id = areaid ) 区域, sum( CASE WHEN month = '01' THEN money ELSE 0 END ) 一月, sum( CASE WHEN month = '02' THEN money ELSE 0 END ) 二月, sum( CASE WHEN month = '03' THEN money ELSE 0 END ) 三月, sum( CASE WHEN month = '04' THEN money ELSE 0 END ) 四月, sum( CASE WHEN month = '05' THEN money ELSE 0 END ) 五月, sum( CASE WHEN month = '06' THEN money ELSE 0 END ) 六月, sum( CASE WHEN month = '07' THEN money ELSE 0 END ) 七月, sum( CASE WHEN month = '08' THEN money ELSE 0 END ) 八月, sum( CASE WHEN month = '09' THEN money ELSE 0 END ) 九月, sum( CASE WHEN month = '10' THEN money ELSE 0 END ) 十月, sum( CASE WHEN month = '11' THEN money ELSE 0 END ) 十一月, sum( CASE WHEN month = '12' THEN money ELSE 0 END ) 十二月 FROM T_ACCOUNT WHERE year = '2012' GROUP BY areaid 需求2：按季度统计2012 年各个地区的水费，如下图 123456789101112SELECT ( SELECT name FROM T_AREA WHERE id = areaid ) 区域, sum( CASE WHEN month &gt;= '01' AND month &lt;= '03' THEN money ELSE 0 END ) 第一季度, sum( CASE WHEN month &gt;= '04' AND month &lt;= '06' THEN money ELSE 0 END ) 第二季度, sum( CASE WHEN month &gt;= '07' AND month &lt;= '09' THEN money ELSE 0 END ) 第三季度, sum( CASE WHEN month &gt;= '10' AND month &lt;= '12' THEN money ELSE 0 END ) 第四季度 FROM T_ACCOUNT WHERE year = '2012' GROUP BY areaid 分析函数以下三个分析函数可以用于排名使用。下图为三种排名方式的举例 RANK 相同的值排名相同，排名跳跃需求：对T_ACCOUNT 表的usenum字段进行排序，相同的值排名相同，排名跳跃 12345SELECT rank ( ) over ( ORDER BY usenum DESC ), usenum FROM T_ACCOUNT DENSE_RANK 相同的值排名相同，排名连续需求：对T_ACCOUNT 表的usenum 字段进行排序，相同的值排名相同，排名连续 12345SELECT dense_rank ( ) over ( ORDER BY usenum DESC ), usenum FROM T_ACCOUNT ROW_NUMBER 返回连续的排名，无论值是否相等需求：对T_ACCOUNT表的usenum字段进行排序，返回连续的排名，无论值是否相等 12345SELECT row_number ( ) over ( ORDER BY usenum DESC ), usenum FROM T_ACCOUNT 用row_number实现分页查询 1234567SELECT * FROM ( SELECT row_number ( ) over ( ORDER BY usenum DESC ) rownumber, usenum FROM T_ACCOUNT ) WHERE rownumber &gt; 10 AND rownumber &lt;= 20 集合运算集合运算，集合运算就是将两个或者多个结果集组合成为一个结果集。 Key Info UNION ALL(并集) 返回各个查询的所有记录，包括重复记录。 UNION(并集) 返回各个查询的所有记录，不包括重复记录。 INTERSECT(交集) 返回两个查询共有的记录。 MINUS(差集 返回第一个查询检索出的记录减去第二个查询检索出的记录之后剩余的记录。 并集运算 1234--union all:不会去掉重复记录select * from t_owners where id&lt;=7union allselect * from t_owners where id&gt;=5 1234--union: 会去掉重复记录select * from t_owners where id&lt;=7unionselect * from t_owners where id&gt;=5 交集运算 123select * from t_owners where id&lt;=7intersectselect * from t_owners where id&gt;=5 差集运算 123select * from t_owners where id&lt;=7minusselect * from t_owners where id&gt;=5 差集实现分页123456789101112131415SELECT ROWNUM , t.* FROM T_ACCOUNT t WHERE ROWNUM &lt;= 20 MINUSSELECT ROWNUM , t.* FROM T_ACCOUNT t WHERE ROWNUM &lt;= 10 视图概念视图是一种数据库对象，是从一个或者多个数据库表或视图中导出的虚表，视图所对应的数据不是真正的存在视图中，而是存储在所引用的数据表中，视图的结构和数据是对数据表进行查询的结果。 根据创建视图时给的条件，视图可以是一个数据表的一部分，也可以是多个基表的联合。 创建或修改视图12CREATE [ OR REPLACE ] [ force ] VIEW view_name AS subquery [ WITH CHECK OPTION ][ WITH read ONLY] 解释： OR REPLACE：如果该视图已经存在，Oracle会自动重建该视图 FORCE: 不管基表是否存在，都会创建该视图 WITH CHECK OPTION：插入或修改的数据必须满足视图定义的约束 WITH read ONLY：该视图上不能进行任何DML操作 删除视图1DROP VIEW view_name; 案例简单视图的创建和使用需求：创建视图：业务类型为1的业主信息 123456CREATE VIEW view_t_owners AS SELECT* FROM t_owners WHERE OWNERTYPEID = 1; 查询视图数据 1234SELECT * FROM view_t_owners; 修改视图数据，基表的数据页会被修改 1234UPDATE view_t_owners SET name = '林玲玲' WHERE id = 4; 带约束检查的视图需求：根据地址表（T_ADDRESS）创建视图 VIEW_T_ADDRESS, 内容为区域 ID为 2 的记录。 1234567CREATE OR REPLACE VIEW view_T_ADDRESS AS SELECT * FROM T_ADDRESS WHERE AREAID = 2 WITH CHECK OPTION; 因为areaid是创建视图时使用的条件，所以不能修改它的值，执行下面的update会报错。 1234UPDATE view_t_address SET areaid = 1 WHERE id = 3; 只读视图1234567CREATE OR REPLACE VIEW view_t_owners1 AS SELECT * FROM T_OWNERS WHERE ownertypeid = 1 WITH read ONLY 执行update的时候会报错 1234UPDATE view_t_owners1 SET name = 'summer' WHERE id = 1; 创建带错误的视图基表不存在，根据这个不存在的基表创建视图 我这个sql报错了，为什么？？？ 12345CREATE OR raplace force VIEW view_t_temp AS SELECT * FROM t_temp 复杂视图多表关联查询需求：创建视图，查询显示业主编号 业主名称，业主类型名称 12345678910CREATE OR REPLACE VIEW view_owners AS SELECT o.id 业主编号 , o.name 业主名称 , ot.name 业主类型 FROM T_OWNERS o, T_OWNERTYPE ot WHERE o.ownertypeid = ot.id 1select * from view_owners","categories":[{"name":"Oracle","slug":"Oracle","permalink":"https://xiaofanshutu.github.io/categories/Oracle/"}],"tags":[]},{"title":"事务","slug":"动力节点MySQL/第08章 事务","date":"2025-07-02T22:59:12.930Z","updated":"2025-07-02T23:06:43.133Z","comments":true,"path":"posts/93ac284c.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/93ac284c.html","excerpt":"事务概述 事务是一个最小的工作单元。在数据库当中，事务表示一件完整的事儿。 一个业务的完成可能需要多条DML语句共同配合才能完成，例如转账业务，需要执行两条DML语句，先更新张三账户的余额，再更新李四账户的余额，为了保证转账业务不出现问题，就必须保证要么同时成功，要么同时失败，怎么保证同时成功或者同时失败呢？就需要使用事务机制。 也就是说用了事务机制之后，在同一个事务当中，多条DML语句会同时成功，或者同时失败，不会出现一部分成功，一部分失败的现象。 事务只针对DML语句有效：因为只有这三个语句是改变表中数据的。 insert delete update事务四大特性：ACID 原子性（Atomicity）：是指事务包含的所有操作要么全部成功，要么同时失败。 一致性（Consistency）：是指事务开始前，和事务完成后，数据应该是一致的。例如张三和李四的钱加起来是5000，中间不管进行过多少次的转账操作(update)，总量5000是不会变的。这就是事务的一致性。 隔离性（Isolation）：隔离性是当多个⽤户并发访问数据库时，⽐如操作同⼀张表时，数据库为每⼀个⽤户开启的事务，不能被其他事务的操作所⼲扰，多个并发事务之间要相互隔离。 持久性（Durability）：持久性是指⼀个事务⼀旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。 演示MySQL事务在dos命令窗口中开启MySQL事务：start transaction; 或者：begin;回滚事务：rollback;提交事务：commit;只要执行以上的rollback或者commit，事务都会结束。MySQL默认情况下采用的事务机制是：自动提交。所谓自动提交就是只要执行一条DML语句则提交一次。 事务隔离级别 隔离级别从低到高排序：读未提交 &lt; 读提交 &lt; 可重复读 &lt; 串行化****不同隔离级别会存在不同的现象，现象按照严重性从高到低排序：脏读 &gt; 不可重复读 &gt; 幻读 查看与设置隔离级别mysql默认的隔离级别：可重复读（REPEATABLE READ）。 查看当前会话的隔离级别：select @@transaction_isolation; 查看全局的隔离级别：select @@gobal.transaction_isolation; 设置事务隔离级别： 会话级：set session transaction isolation level read committed; 全局级：set global transaction isolation level read committed;不同现象脏读指的是一个事务读取了另一个事务尚未提交的数据，即读取了另一个事务中的脏数据（Dirty Data）。在此情况下，如果另一个事务回滚了或者修改了这些数据，那么读取这些脏数据的事务所处理的数据就是不准确的。不可重复读指在一个事务内，多次读取同一个数据行，得到的结果可能是不一样的。这是由于其他事务对数据行做出了修改操作，导致数据的不一致性。幻读指在事务执行过程中，前后两次相同的查询条件得到的结果集不一致，可能会变多或变少。隔离级别读未提交（READ UNCOMMITTED）A事务与B事务，A事务可以读取到B事务未提交的数据。这是最低的隔离级别。几乎两个事务之间没有隔离。这种隔离级别是一种理论层面的，在实际的数据库产品中，没有从这个级别起步的。当事务隔离级别是读未提交时，三种现象都存在：脏读，不可重复读，幻读。我们可以开启两个DOS命令窗口，模拟两个事务，演示一下这种隔离级别。三种现象中最严重的是脏读，我们只需要演示脏读问题即可，因为存在脏读的话，就一定存在不可重复读和幻读问题。 将全局事务隔离级别设置为：READ UNCOMMITTED","text":"事务概述 事务是一个最小的工作单元。在数据库当中，事务表示一件完整的事儿。 一个业务的完成可能需要多条DML语句共同配合才能完成，例如转账业务，需要执行两条DML语句，先更新张三账户的余额，再更新李四账户的余额，为了保证转账业务不出现问题，就必须保证要么同时成功，要么同时失败，怎么保证同时成功或者同时失败呢？就需要使用事务机制。 也就是说用了事务机制之后，在同一个事务当中，多条DML语句会同时成功，或者同时失败，不会出现一部分成功，一部分失败的现象。 事务只针对DML语句有效：因为只有这三个语句是改变表中数据的。 insert delete update事务四大特性：ACID 原子性（Atomicity）：是指事务包含的所有操作要么全部成功，要么同时失败。 一致性（Consistency）：是指事务开始前，和事务完成后，数据应该是一致的。例如张三和李四的钱加起来是5000，中间不管进行过多少次的转账操作(update)，总量5000是不会变的。这就是事务的一致性。 隔离性（Isolation）：隔离性是当多个⽤户并发访问数据库时，⽐如操作同⼀张表时，数据库为每⼀个⽤户开启的事务，不能被其他事务的操作所⼲扰，多个并发事务之间要相互隔离。 持久性（Durability）：持久性是指⼀个事务⼀旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。 演示MySQL事务在dos命令窗口中开启MySQL事务：start transaction; 或者：begin;回滚事务：rollback;提交事务：commit;只要执行以上的rollback或者commit，事务都会结束。MySQL默认情况下采用的事务机制是：自动提交。所谓自动提交就是只要执行一条DML语句则提交一次。 事务隔离级别 隔离级别从低到高排序：读未提交 &lt; 读提交 &lt; 可重复读 &lt; 串行化****不同隔离级别会存在不同的现象，现象按照严重性从高到低排序：脏读 &gt; 不可重复读 &gt; 幻读 查看与设置隔离级别mysql默认的隔离级别：可重复读（REPEATABLE READ）。 查看当前会话的隔离级别：select @@transaction_isolation; 查看全局的隔离级别：select @@gobal.transaction_isolation; 设置事务隔离级别： 会话级：set session transaction isolation level read committed; 全局级：set global transaction isolation level read committed;不同现象脏读指的是一个事务读取了另一个事务尚未提交的数据，即读取了另一个事务中的脏数据（Dirty Data）。在此情况下，如果另一个事务回滚了或者修改了这些数据，那么读取这些脏数据的事务所处理的数据就是不准确的。不可重复读指在一个事务内，多次读取同一个数据行，得到的结果可能是不一样的。这是由于其他事务对数据行做出了修改操作，导致数据的不一致性。幻读指在事务执行过程中，前后两次相同的查询条件得到的结果集不一致，可能会变多或变少。隔离级别读未提交（READ UNCOMMITTED）A事务与B事务，A事务可以读取到B事务未提交的数据。这是最低的隔离级别。几乎两个事务之间没有隔离。这种隔离级别是一种理论层面的，在实际的数据库产品中，没有从这个级别起步的。当事务隔离级别是读未提交时，三种现象都存在：脏读，不可重复读，幻读。我们可以开启两个DOS命令窗口，模拟两个事务，演示一下这种隔离级别。三种现象中最严重的是脏读，我们只需要演示脏读问题即可，因为存在脏读的话，就一定存在不可重复读和幻读问题。 将全局事务隔离级别设置为：READ UNCOMMITTED 1set global transaction isolation level read uncommitted; 开启两个DOS命令窗口来模拟两个事务：A事务与B事务。 A事务 B事务 mysql&gt; use powernode mysql&gt; use powernode mysql&gt; start transaction; mysql&gt; start transaction; mysql&gt; select * from a; mysql&gt; insert into a values(4); mysql&gt; select * from a; 通过以上测试，可以看到，A事务读取到了B事务还没有提交的数据。这种现象就是脏读。 读提交（READ COMMITTED）A事务与B事务，A事务可以读取到B事务提交之后的数据。Oracle数据库默认的就是这种隔离级别。 将数据库的全局事务隔离级别设置为读提交：READ COMMITTED 1set global transaction isolation level read committed; 演示： A事务 B事务 mysql&gt; use powernode mysql&gt; use powernode mysql&gt; start transaction; mysql&gt; start transaction; mysql&gt; select * from a; mysql&gt; insert into a values(4); mysql&gt; select * from a; mysql&gt; commit; mysql&gt; select * from a; 通过以上测试看出，A事务只能读取到B事务提交之后的数据。这种隔离级别解决了脏读问题，但肯定是存在不可重复读和幻读问题。因为只要事务B进行了增删改操作之后并提交了，事务A读取到的数据肯定是不同的。即：不可重复读和幻读都存在。 可重复读（REPEATABLE READ）这个隔离级别是MySQL数据库默认的。A事务和B事务，A事务开启后，读取了某一条记录，然后B事务对这条记录进行修改并提交，A事务读取到的还是修改前的数据。这种隔离级别称为可重复读。 将数据库全局隔离级别修改为可重复读： 1set global transaction isolation level repeatable read; 演示： A事务 B事务 mysql&gt; use powernode mysql&gt; use powernode mysql&gt; start transaction; mysql&gt; start transaction; mysql&gt; select empno,ename,sal from emp where empno=7369; mysql&gt; update emp set ename=’SMITH’,sal=8000 where empno=7369; mysql&gt; commit; mysql&gt; select empno,ename,sal from emp where empno=7369; 通过以上测试得知：当事务隔离级别设置为可重复读时，避免了不可重复读问题。 那么在MySQL当中，当事务隔离级别设置为可重复读时，能够避免幻读问题吗？测试一下： 事务A 事务B mysql&gt; use powernode mysql&gt; use powernode mysql&gt; start transaction; mysql&gt; start transaction; mysql&gt; select * from a; mysql&gt; insert into a values(5); mysql&gt; commit; mysql&gt; select * from a; 通过以上测试得知：当事务隔离级别设置为可重复读时，也避免了幻读问题。是完全避免了幻读问题吗？并不是。请看以下测试： 事务A 事务B mysql&gt; use powernode mysql&gt; use powernode mysql&gt; start transaction; mysql&gt; start transaction; mysql&gt; select * from a; mysql&gt; insert into a values(6); mysql&gt; commit; mysql&gt; select * from a for update; 通过以上测试得知：当事务隔离级别设置为可重复读，MySQL会尽最大努力避免幻读问题，但这种隔离级别无法完全避免幻读问题。 串行化（SERIALIZABLE）这种隔离级别最高，避免了所有的问题，缺点是效率低，因为这种隔离级别会导致事务排队处理，不支持并发。 设置数据库全局隔离级别为串行化： 1set global transaction isolation level serializable; 演示： 事务A 事务B mysql&gt; use powernode mysql&gt; use powernode mysql&gt; start transaction; mysql&gt; start transaction; mysql&gt; select * from a; mysql&gt; insert into a values(7); mysql&gt; select * from a; mysql&gt; commit; 通过以上测试得知：当事务隔离级别设置为串行化时，事务只能排队执行，不支持并发。 可重复读的幻读问题在上面讲解过程中我提到，MySQL默认的隔离级别可重复读，在很大程度上避免了幻读问题（并不能完全解决），那么它是如何解决幻读问题的呢，解决方案包括两种： 针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好的避免了幻读问题。 针对当前读（select … for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好的避免了幻读问题。 快照读是如何解决幻读的什么是快照读？普通的select语句都是采用的快照读。顾名思义：在整个事务的处理过程中，执行相同的一个select语句时，每次都是读取的快照。（快照指的是固定的某个时刻的数据，就像现实世界中的拍照一样，把那个美好的时刻留下来）。也就是说，当事务隔离级别是可重复读，并且执行的select语句是一个普通的select语句时，都会采用快照读的方式读取数据，底层实现原理是： 底层由 MVCC（多版本并发控制）实现，实现的方式是开始事务后，在执行第一个查询语句后，会创建一个 Read View，后续的查询语句利用这个 Read View，通过这个 Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的，即使中途有其他事务插入了新纪录，是查询不出来这条数据的，所以就很好的避免了幻读问题。 演示： 事务A 事务B mysql&gt; use powernode mysql&gt; use powernode mysql&gt; start transaction; mysql&gt; start transaction; mysql&gt; select * from a; //快照读 mysql&gt; insert into a values(5); mysql&gt; commit; mysql&gt; select * from a; //快照读 当前读是如何解决幻读的当前读，顾名思义：每一次都读取最新的数据。当前读包括：update、delete、insert、select…for update。这个很好理解，因为增删改的时候都要基于最新的数据进行增删改。而select…for update原理是：对查询范围内的数据进行加锁，不允许其它事务对这个范围内的数据进行增删改。也就是说这个select语句范围内的数据是不允许并发的，只能排队执行，从而避免幻读问题。select…for update加的锁叫做：next-key lock。我们可以称其为：间隙锁 + 记录锁。间隙锁用来保证在锁定的范围内不允许insert操作。记录锁用来保证在锁定的范围内不允许delete和update操作。 假如有这样的数据：SQL语句是这样写的： 1select * from a where id between 2 and 4 for update; 那么id在[2-4]区间的所有记录行被锁定，不能插入3是通过间隙锁来搞定的。不能修改或删除2和4是通过记录锁来搞定的。 演示： 事务A 事务B mysql&gt; use powernode mysql&gt; use powernode mysql&gt; start transaction; mysql&gt; start transaction; mysql&gt; select * from a where id between 2 and 4 for update; // 当前读 出现幻读的两种情况在同一个事务处理过程中，如果前后两次都采用快照读，或者都采用当前读，则不会出现幻读问题。如果第一次使用快照读，后面使用了当前读，则会出现幻读问题。 第一种产生幻读的场景A事务与B事务。在A事务中第一次查询使用快照读，B事务插入数据。然后在A事务中第二次查询使用当前读。则会产生幻读现象。演示： 事务A 事务B mysql&gt; use powernode mysql&gt; use powernode mysql&gt; start transaction; mysql&gt; start transaction; mysql&gt; select * from a; mysql&gt; insert into a values(5); mysql&gt; commit; mysql&gt; select * from a for update; // 产生了幻读 第二种产生幻读的场景事务A与事务B，在事务A中第一次查询使用快照读，在事务B中插入一条数据，然后在事务A中更新事务B插入的那条记录，最后在事务A中再次使用快照读。则会发生幻读现象。 事务A 事务B mysql&gt; use powernode mysql&gt; use powernode mysql&gt; start transaction; mysql&gt; start transaction; mysql&gt; select * from a; mysql&gt; insert into a values(6); mysql&gt; commit; mysql&gt; update a set id=100 where id=6; //主要是因为这个SQL语句的执行触发了当前读 mysql&gt; select * from a; // 产生了幻读 总结可重复读的幻读问题MySQL的可重复读隔离级别（默认隔离级），根据不同的查询方式，分别提出了避免幻读的方案： 针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读。 针对当前读（select … for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读。 我举例了两个发生幻读场景的例子。 第一个例子：对于快照读， MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。 第二个例子：对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。 所以，MySQL 可重复读隔离级别并没有彻底解决幻读，只是很大程度上避免了幻读现象的发生。要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://xiaofanshutu.github.io/categories/MySQL/"}],"tags":[]},{"title":"视图","slug":"动力节点MySQL/第07章 视图","date":"2025-07-02T22:46:02.851Z","updated":"2025-07-02T22:53:57.145Z","comments":true,"path":"posts/50a54d3c.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/50a54d3c.html","excerpt":"只能将select语句创建为视图。 创建视图 1create or replace view v_emp as select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno; 视图作用 如果开发中有一条非常复杂的SQL，而这个SQL在多处使用，会给开发和维护带来成本。使用视图可以降低开发和维护的成本。 视图可以隐藏表的字段名。 修改视图 1alter view v_emp as select e.ename,d.dname,d.deptno from emp e join dept d on e.deptno = d.deptno; 删除视图 drop view if exists v_emp; 对视图增删改（DML：insert delete update）可以影响到原表数据。","text":"只能将select语句创建为视图。 创建视图 1create or replace view v_emp as select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno; 视图作用 如果开发中有一条非常复杂的SQL，而这个SQL在多处使用，会给开发和维护带来成本。使用视图可以降低开发和维护的成本。 视图可以隐藏表的字段名。 修改视图 1alter view v_emp as select e.ename,d.dname,d.deptno from emp e join dept d on e.deptno = d.deptno; 删除视图 drop view if exists v_emp; 对视图增删改（DML：insert delete update）可以影响到原表数据。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://xiaofanshutu.github.io/categories/MySQL/"}],"tags":[]},{"title":"数据库设计三范式","slug":"动力节点MySQL/第06章 三范式","date":"2025-07-02T13:41:22.456Z","updated":"2025-07-02T13:45:23.490Z","comments":true,"path":"posts/80436e1d.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/80436e1d.html","excerpt":"什么是数据库设计三范式数据库表设计的原则。教你怎么设计数据库表有效，并且节省空间。 三范式 第一范式：任何一张表都应该有主键，每个字段是原子性的不能再分 以下表的设计不符合第一范式：无主键，并且联系方式可拆分。 应该这样设计： 第二范式：建立在第一范式基础上的，另外要求所有非主键字段完全依赖主键，不能产生部分依赖 以下表存储了学生和老师的信息 虽然符合第一范式，但是违背了第二范式，学生姓名、老师姓名都产生了部分依赖。导致数据冗余。","text":"什么是数据库设计三范式数据库表设计的原则。教你怎么设计数据库表有效，并且节省空间。 三范式 第一范式：任何一张表都应该有主键，每个字段是原子性的不能再分 以下表的设计不符合第一范式：无主键，并且联系方式可拆分。 应该这样设计： 第二范式：建立在第一范式基础上的，另外要求所有非主键字段完全依赖主键，不能产生部分依赖 以下表存储了学生和老师的信息 虽然符合第一范式，但是违背了第二范式，学生姓名、老师姓名都产生了部分依赖。导致数据冗余。 以下这种设计方式就是符合第二范式的： 第三范式：建立在第二范式基础上的，非主键字段不能传递依赖于主键字段 以下设计方式就是违背第三范式的 以上因为产生了传递依赖，导致班级名称冗余。 以下这种方式就是符合第三范式的： 一对多怎么设计口诀：一对多两张表，多的表加外键。 多对多怎么设计多对多三张表，关系表添加外键。 一对一怎么设计两种方案： 第一种：主键共享 第二种：外键唯一 最终的设计最终以满足客户需求为原则，有的时候会拿空间换速度。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://xiaofanshutu.github.io/categories/MySQL/"}],"tags":[]},{"title":"MySQL表相关","slug":"动力节点MySQL/第05章 表相关","date":"2025-06-30T23:16:56.277Z","updated":"2025-07-01T00:07:26.004Z","comments":true,"path":"posts/31637be2.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/31637be2.html","excerpt":"创建表语法格式： 123456create table 表名( 字段名1 数据类型, 字段名2 数据类型, 字段名3 数据类型, ......); 例如：创建学生表 12345create table t_student( no int, name varchar, gender char(1) default '男'); 插入数据语法格式： 1insert into 表名(字段名1, 字段名2, 字段名3,......) values (值1,值2,值3,......); 字段名和值要一一对应。类型要一一对应，数量要一一对应。字段名也可以省略，如果字段名省略就表示把所有字段名都写上去了，并且顺序和建表时的顺序相同。","text":"创建表语法格式： 123456create table 表名( 字段名1 数据类型, 字段名2 数据类型, 字段名3 数据类型, ......); 例如：创建学生表 12345create table t_student( no int, name varchar, gender char(1) default '男'); 插入数据语法格式： 1insert into 表名(字段名1, 字段名2, 字段名3,......) values (值1,值2,值3,......); 字段名和值要一一对应。类型要一一对应，数量要一一对应。字段名也可以省略，如果字段名省略就表示把所有字段名都写上去了，并且顺序和建表时的顺序相同。 删除表语法格式： 1drop table 表名; 或者 1drop table if exists 表名; 判断是否存在这个表，如果存在则删除。避免不存在时的报错。 MySQL数据类型数据类型（data_type）是指系统中所允许的数据的类型。数据库中的每个列都应该有适当的数据类型，用于限制或允许该列中存储的数据。例如，列中存储的为数字，则相应的数据类型应该为数值类型。如果使用错误的数据类型可能会严重影响应用程序的功能和性能，所以在设计表时，应该特别重视数据列所用的数据类型。更改包含数据的列不是一件小事，这样做可能会导致数据丢失。因此，在创建表时必须为每个列设置正确的数据类型和长度。MySQL 的数据类型可以分为整数类型、浮点数类型、定点数类型、日期和时间类型、字符串类型、二进制类型等。 整数类型tinyint：1个字节（微小整数）smallint：2个字节（小整数）mediumint：3个字节（中等大小的整数）int（integer）：4个字节（普通大小整数）bigint：8个字节（大整数） 浮点数类型float：4个字节，单精度（最多5位小数）double：8个字节，双精度（最多16位小数） 定点数类型decimal：定点数类型。底层实际上采用字符串的形式存储数字。语法：decimal(m, d)例如：decimal(3, 2) 表示3个有效数字，2个小数。（有效数字最多65个，小数位最多30个） 日期和时间类型year：1个字节，只存储年，格式YYYYtime：3个字节，只存储时间，格式HH:MM:SS / HHMMSSdate：3个字节，只存储年月日，格式：YYYY-MM-DDdatetime：8个字节，存储年月日+时分秒，格式：YYYY-MM-DD HH:MM:SS（从公元1000年公元9999年）timestamp：4个字节，存储年月日+时分秒，格式：YYYY-MM-DD HH:MM:SS（从公元1980年公元2040年）或者格式为 YYYYMMDDHHMMSS（采用这种格式不需要使用单引号，当然你使用单引号也可以） 字符串类型charchar(m)：m长度是0~255个字符。固定长度字符串，在定义时指定字符串列长。当保存时，在右侧填充空格以达到指定的长度。m表示列的长度，范围是 0～255 个字符。例如，CHAR(4) 定义了一个固定长度的字符串列，包含的字符个数最大为 4。当插入的字符长度大于4，则报错（除非超过4个长度之后都是空格字符，则空格字符会自动被删除用来保证插入的成功）。 varcharvarchar(m)：m长度是0~16383个字符长度可变的字符串。varchar 的最大实际长度由最长的行的大小和使用的字符集确定，而实际占用的空间为字符串的实际长度加 1。例如，varchar(50) 定义了一个最大长度为 50 的字符串，如果插入的字符串只有 10 个字符，则实际存储的字符串为 10 个字符和一个字符串结束字符。varchar在值保存和检索时尾部的空格仍保留。 texttext类型： tinytext 表示长度为 255字符的 TEXT 列。 text 表示长度为 65535字符的 TEXT 列。 mediumtext 表示长度为 16777215字符的 TEXT 列。 longtext 表示长度为 4294967295 或 4GB 字符的 TEXT 列。enum enum类型： 语法：&lt;字段名&gt; enum(‘值1’,’值2’,…) 该字段插入值时，只能是指定的枚举值。 set set类型： 语法：&lt;字段名&gt; set(‘值1’,’值2’,’值3’,…) 注意：值不可重复。 该字段插入值时，只能是指定的值。 二进制类型BLOB（Binary Large Object）类型：二进制大对象，可以存储图片、声音、视频等文件。 blob：小的，最大长度65535个字节 mediumblob：中等的，最大长度16777215个字节 longblob：大的，最大长度4GB的字节增删改表结构DDL创建一个学生表12345create table t_student( no bigint, name varchar(255), age int comment '年龄'); 查看建表语句1show create table 表名; 修改表名1alter table 表名 rename 新表名; 新增字段1alter table 表名 add 字段名 数据类型; 修改字段名1alter table 表名 change 旧字段名 新字段名 数据类型; 修改字段数据类型1alter table 表名 modify column 字段名 数据类型; 删除字段1alter table 表名 drop 字段名; DML语句当我们对表中的数据进行增删改的时候，称它为DML语句。（数据操纵语言），主要包括：insert、delete、update insert 增语法格式： 1insert into 表名(字段名1,字段名2,字段名3,...) values(值1,值2,值3,...); 表名后面的小括号当中的字段名如果省略掉，表示自动将所有字段都列出来了，并且字段的顺序和建表时的顺序一致。一般为了可读性强，建议把字段名写上。 1insert into 表名 values(值1,值2,值3,...); 一次可以插入多条记录： 1insert into t_stu(no,name,age) values(1,'jack',20),(2,'lucy',30); delete 删语法格式： 12345# 将所有记录全部删除delete from 表名;# 删除符合条件的记录delete from 表名 where 条件; 以上的删除属于DML的方式删除，这种删除的数据是可以通过事务回滚的方式重新恢复的，但是删除的效率较低。（这种删除是支持事务的。）另外还有一种删除表中数据的方式，但是这种方式不支持事务，不可以回滚，删了之后数据是永远也找不回来了。这种删除叫做：表被截断。注意：这个语句删除效率非常高，巨大的表，瞬间干掉所有数据。但不可恢复。 1truncate table 表名; update 改语法格式： 1update 表名 set 字段名1=值1, 字段名2=值2, 字段名3=值3 where 条件; 如果没有更新条件的话，所有记录全部更新。 约束constraint创建表时，可以给表的字段添加约束，可以保证数据的完整性、有效性。比如大家上网注册用户时常见的：用户名不能为空。对不起，用户名已存在。等提示信息。约束通常包括： 非空约束：not null 检查约束：check 唯一性约束：unique 主键约束：primary key 外键约束：foreign key非空约束语法格式：12345create table t_stu( no int, name varchar(255) not null, age int); name字段不能为空。插入数据时如果没有给name指定值，则报错。 检查约束123456create table t_stu( no int, name varchar(255), age int, check(age &gt; 18)); 唯一性约束语法格式： 12345create table t_stu( no int, name varchar(255), email varchar(255) unique); email字段设置为唯一性，唯一性的字段值是可以为NULL的。但不能重复。以上在字段后面添加的约束，叫做列级约束。当然，添加约束还有另一种方式：表级约束： 123456create table t_stu( no int, name varchar(255), email varchar(255), unique(email)); 使用表级约束可以为多个字段添加联合唯一。 123456create table t_stu( no int, name varchar(255), email varchar(255), unique(name,email)); 创建约束时也可以给约束起名字，将来可以通过约束的名字来删除约束： 123456create table t_stu( no int, name varchar(255), email varchar(255), constraint t_stu_name_email_unique unique(name,email)); 所有的约束都存储在一个系统表当中：table_constraints。这个系统表在这个数据库当中：information_schema 主键约束 主键：primary key，简称PK 主键约束的字段不能为NULL，并且不能重复。 任何一张表都应该有主键，没有主键的表可以视为无效表。 主键值是这行记录的身份证号，是唯一标识。在数据库表中即使两条数据一模一样，但由于主键值不同，我们也会认为是两条完全的不同的数据。 主键分类： 根据字段数量分类： 单一主键（1个字段作为主键）==&gt;建议的 复合主键（2个或2个以上的字段作为主键） 根据业务分类： 自然主键（主键和任何业务都无关，只是一个单纯的自然数据）===&gt;建议的 业务主键（主键和业务挂钩，例如：银行卡账号作为主键） 单一主键（建议使用这种方式） 12345create table t_student( id bigint primary key, sno varchar(255) unique, sname varchar(255) not null) 复合主键（很少用，了解） 123456create table t_user( no int, name varchar(255), age int, primary key(no,name)); 主键自增：既然主键值是一个自然的数字，mysql为主键值提供了一种自增机制，不需要我们程序员维护，mysql自动维护该字段 1234create table t_vip( no int primary key auto_increment, name varchar(255)); 外键约束 有这样一个需求：要求设计表，能够存储学生以及学校信息。 第一种方案：一张表 这种方式会导致数据冗余，浪费空间。 第二种方案：两张表：一张存储学生，一张存储学校 t_school 表t_student 表如果采用以上两张表存储数据，对于学生表来说，sno这个字段的值是不能随便填的，这个sno是学校编号，必须要求这个字段中的值来自学校表的sno。为了达到要求，此时就必须要给t_student表的sno字段添加外键约束了。 外键约束：foreign key，简称FK。 添加了外键约束的字段中的数据必须来自其他字段，不能随便填。 假设给a字段添加了外键约束，要求a字段中的数据必须来自b字段，b字段不一定是主键，但至少要有唯一性。 外键约束可以给单个字段添加，叫做单一外键。也可以给多个字段联合添加，叫做复合外键。复合外键很少用。 a表如果引用b表中的数据，可以把b表叫做父表，把a表叫做子表。 创建表时，先创建父表，再创建子表。 插入数据时，先插入父表，在插入子表。 删除数据时，先删除子表，再删除父表。 删除表时，先删除子表，再删除父表。 如何添加外键：1234567891011create table t_school( sno int primary key, sname varchar(255) ); create table t_student( no int primary key, name varchar(255), age int, sno int, constraint t_school_sno_fk foreign key(sno) references t_school(sno) ); 级联删除 创建子表时，外键可以添加：on delete cascade，这样在删除父表数据时，子表会级联删除。谨慎使用。 1234567create table t_student( no int primary key, name varchar(255), age int, sno int, constraint t_school_sno_fk foreign key(sno) references t_school(sno) on delete cascade ); 1234###删除约束alert table t_student drop foreign key t_student_sno_fk;###添加约束alert table t_student add constraint t_student_sno_fk foreign key(sno) references t_school(sno) on delete cascade; 级联更新 1234567create table t_student( no int primary key, name varchar(255), age int, sno int, constraint t_school_sno_fk foreign key(sno) references t_school(sno) on update cascade ); 级联置空 1234567create table t_student( no int primary key, name varchar(255), age int, sno int, constraint t_school_sno_fk foreign key(sno) references t_school(sno) on delete set null );","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://xiaofanshutu.github.io/categories/MySQL/"}],"tags":[]},{"title":"MySQL数据库概述","slug":"动力节点MySQL/第01章 数据库概述","date":"2025-06-29T23:08:23.981Z","updated":"2025-06-29T23:37:55.231Z","comments":true,"path":"posts/ca9a1c2c.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/ca9a1c2c.html","excerpt":"什么是数据库 数据库是一门独立的学科，只要是做软件开发的，数据库都要学。 数据库（电子化的文件柜）是“按照数据结构来组织、存储和管理数据的仓库”。是一个长期存储在计算机内的、有组织的、可共享的、统一管理的大量数据的集合。 它的存储空间很大，可以存放百万条、千万条、上亿条数据。 数据库并不是随意地将数据进行存放，是有一定的规则的，否则查询的效率会很低。 当今世界是一个充满着数据的互联网世界，充斥着大量的数据。即这个互联网世界就是数据世界。数据的来源有很多，比如出行记录、消费记录、浏览的网页、发送的消息等等。除了文本类型的数据，图像、音乐、声音都是数据。 数据库对应的英文单词是DataBase，简称DB。 数据库类型 关系型数据库 关系型数据库是依据关系模型来创建的数据库。所谓关系模型就是“一对一、一对多、多对多”等关系模型，关系模型就是指二维表格模型，因而一个关系型数据库就是由二维表及其之间的联系组成的一个数据组织。 关系型数据可以很好地存储一些关系模型的数据，比如一个老师对应多个学生的数据（“多对多”），一本书对应多个作者（“一对多”），一本书对应一个出版日期（“一对一”）。 关系模型包括数据结构（数据存储的问题，二维表）、操作指令集合（SQL语句）、完整性约束(表内数据约束、表与表之间的约束)。 非关系型数据库（NoSQL） NoSQL，泛指非关系型的数据库。随着互联网web2.0网站的兴起，传统的关系数据库在处理web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，出现了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。 NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，特别是大数据应用难题。NoSQL最常见的解释是“non-relational”， “Not Only SQL”也被很多人接受。 NoSQL仅仅是一个概念，泛指非关系型的数据库，区别于关系数据库，它们不保证关系数据的ACID特性。NoSQL是一项全新的数据库革命性运动，其拥护者们提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入。 NoSQL有如下优点：易扩展，NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。无形之间也在架构的层面上带来了可扩展的能力。大数据量，高性能，NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单。数据库管理系统 数据库管理系统（Database Management System，简称DBMS）是为管理数据库而设计的电脑软件系统，一般具有存储、截取、安全保障、备份等基础功能。 数据库管理系统是数据库系统的核心组成部分，主要完成对数据库的操作与管理功能，实现数据库对象的创建、数据库存储数据的查询、添加、修改与删除操作和数据库的用户管理、权限管理等。 常见的数据库管理系统有：MySQL、Oracle、DB2、MS SQL Server、SQLite、PostgreSQL、Sybase等。 什么是SQL 结构化查询语言（Structured Query Language）简称SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。 结构化查询语言是高级的非过程化编程语言，允许用户在高层数据结构上工作。它不要求用户指定对数据的存放方法，也不需要用户了解具体的数据存放方式，所以具有完全不同底层结构的不同数据库系统, 可以使用相同的结构化查询语言作为数据输入与管理的接口。结构化查询语言语句可以嵌套，这使它具有极大的灵活性和强大的功能。 SQL的分类 DQL 数据查询语言（Data Query Language, DQL）是SQL语言中，负责进行数据查询而不会对数据本身进行修改的语句，这是最基本的SQL语句。保留字SELECT是DQL（也是所有SQL）用得最多的动词，其他DQL常用的保留字有FROM，WHERE，GROUP BY，HAVING和ORDER BY。这些DQL保留字常与其他类型的SQL语句一起使用。 DDL 数据定义语言 (Data Definition Language, DDL) 是SQL语言集中，负责数据结构定义与数据库对象定义的语言，由CREATE、ALTER与DROP三个语法所组成，最早是由 Codasyl (Conference on Data Systems Languages) 数据模型开始，现在被纳入 SQL 指令中作为其中一个子集。 DML 数据操纵语言（Data Manipulation Language, DML）是SQL语言中，负责对数据库对象运行数据访问工作的指令集，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入、更新与删除。 DCL 数据控制语言 (Data Control Language) 在SQL语言中，是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。由 GRANT 和 REVOKE 两个指令组成。DCL以控制用户的访问权限为主，GRANT为授权语句，对应的REVOKE是撤销授权语句。 TPL 数据事务管理语言（Transaction Processing Language）它的语句能确保被DML语句影响的表的所有行及时得以更新。TPL语句包括BEGIN TRANSACTION，COMMIT和ROLLBACK。 CCL 指针控制语言（Cursor Control Language），它的语句，像DECLARE CURSOR，FETCH INTO和UPDATE WHERE CURRENT用于对一个或多个表单独行的操作。 DBMS、SQL、DB之间的关系 DBMS通过执行SQL来操作DB中的数据。","text":"什么是数据库 数据库是一门独立的学科，只要是做软件开发的，数据库都要学。 数据库（电子化的文件柜）是“按照数据结构来组织、存储和管理数据的仓库”。是一个长期存储在计算机内的、有组织的、可共享的、统一管理的大量数据的集合。 它的存储空间很大，可以存放百万条、千万条、上亿条数据。 数据库并不是随意地将数据进行存放，是有一定的规则的，否则查询的效率会很低。 当今世界是一个充满着数据的互联网世界，充斥着大量的数据。即这个互联网世界就是数据世界。数据的来源有很多，比如出行记录、消费记录、浏览的网页、发送的消息等等。除了文本类型的数据，图像、音乐、声音都是数据。 数据库对应的英文单词是DataBase，简称DB。 数据库类型 关系型数据库 关系型数据库是依据关系模型来创建的数据库。所谓关系模型就是“一对一、一对多、多对多”等关系模型，关系模型就是指二维表格模型，因而一个关系型数据库就是由二维表及其之间的联系组成的一个数据组织。 关系型数据可以很好地存储一些关系模型的数据，比如一个老师对应多个学生的数据（“多对多”），一本书对应多个作者（“一对多”），一本书对应一个出版日期（“一对一”）。 关系模型包括数据结构（数据存储的问题，二维表）、操作指令集合（SQL语句）、完整性约束(表内数据约束、表与表之间的约束)。 非关系型数据库（NoSQL） NoSQL，泛指非关系型的数据库。随着互联网web2.0网站的兴起，传统的关系数据库在处理web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，出现了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。 NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，特别是大数据应用难题。NoSQL最常见的解释是“non-relational”， “Not Only SQL”也被很多人接受。 NoSQL仅仅是一个概念，泛指非关系型的数据库，区别于关系数据库，它们不保证关系数据的ACID特性。NoSQL是一项全新的数据库革命性运动，其拥护者们提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入。 NoSQL有如下优点：易扩展，NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。无形之间也在架构的层面上带来了可扩展的能力。大数据量，高性能，NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单。数据库管理系统 数据库管理系统（Database Management System，简称DBMS）是为管理数据库而设计的电脑软件系统，一般具有存储、截取、安全保障、备份等基础功能。 数据库管理系统是数据库系统的核心组成部分，主要完成对数据库的操作与管理功能，实现数据库对象的创建、数据库存储数据的查询、添加、修改与删除操作和数据库的用户管理、权限管理等。 常见的数据库管理系统有：MySQL、Oracle、DB2、MS SQL Server、SQLite、PostgreSQL、Sybase等。 什么是SQL 结构化查询语言（Structured Query Language）简称SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。 结构化查询语言是高级的非过程化编程语言，允许用户在高层数据结构上工作。它不要求用户指定对数据的存放方法，也不需要用户了解具体的数据存放方式，所以具有完全不同底层结构的不同数据库系统, 可以使用相同的结构化查询语言作为数据输入与管理的接口。结构化查询语言语句可以嵌套，这使它具有极大的灵活性和强大的功能。 SQL的分类 DQL 数据查询语言（Data Query Language, DQL）是SQL语言中，负责进行数据查询而不会对数据本身进行修改的语句，这是最基本的SQL语句。保留字SELECT是DQL（也是所有SQL）用得最多的动词，其他DQL常用的保留字有FROM，WHERE，GROUP BY，HAVING和ORDER BY。这些DQL保留字常与其他类型的SQL语句一起使用。 DDL 数据定义语言 (Data Definition Language, DDL) 是SQL语言集中，负责数据结构定义与数据库对象定义的语言，由CREATE、ALTER与DROP三个语法所组成，最早是由 Codasyl (Conference on Data Systems Languages) 数据模型开始，现在被纳入 SQL 指令中作为其中一个子集。 DML 数据操纵语言（Data Manipulation Language, DML）是SQL语言中，负责对数据库对象运行数据访问工作的指令集，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入、更新与删除。 DCL 数据控制语言 (Data Control Language) 在SQL语言中，是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。由 GRANT 和 REVOKE 两个指令组成。DCL以控制用户的访问权限为主，GRANT为授权语句，对应的REVOKE是撤销授权语句。 TPL 数据事务管理语言（Transaction Processing Language）它的语句能确保被DML语句影响的表的所有行及时得以更新。TPL语句包括BEGIN TRANSACTION，COMMIT和ROLLBACK。 CCL 指针控制语言（Cursor Control Language），它的语句，像DECLARE CURSOR，FETCH INTO和UPDATE WHERE CURRENT用于对一个或多个表单独行的操作。 DBMS、SQL、DB之间的关系 DBMS通过执行SQL来操作DB中的数据。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://xiaofanshutu.github.io/categories/MySQL/"}],"tags":[]},{"title":"MySQL初始化数据","slug":"动力节点MySQL/第03章 初始化数据","date":"2025-06-29T23:08:23.981Z","updated":"2025-06-30T14:17:31.084Z","comments":true,"path":"posts/f4fc1fe7.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/f4fc1fe7.html","excerpt":"MySQL命令行基本命令 列出当前数据库管理系统中有哪些数据库。1show databases; 创建数据库，起名bjpowernode。 1create database bjpowernode1; 使用bjpowernode数据库。 1use bjpowernode; 查看当前用的是哪个数据库。 1select database(); 查看当前数据库中有哪些表。 1show tables; 删除数据库bjpowernode。 1drop database bjpowernode; 退出mysql exit quit ctrl + c 查看当前mysql版本 1select version(); 还可以使用mysql.exe命令来查看版本信息（在没有登录mysql之前使用）：mysql –version 数据库表的概述 name age gender 张三 20 男 李四 22 女","text":"MySQL命令行基本命令 列出当前数据库管理系统中有哪些数据库。1show databases; 创建数据库，起名bjpowernode。 1create database bjpowernode1; 使用bjpowernode数据库。 1use bjpowernode; 查看当前用的是哪个数据库。 1select database(); 查看当前数据库中有哪些表。 1show tables; 删除数据库bjpowernode。 1drop database bjpowernode; 退出mysql exit quit ctrl + c 查看当前mysql版本 1select version(); 还可以使用mysql.exe命令来查看版本信息（在没有登录mysql之前使用）：mysql –version 数据库表的概述 name age gender 张三 20 男 李四 22 女 以上就是数据库表格的直观展示形式。 表格英文单词table。 表是数据库存储数据的基本单元，数据库存储数据的时候，是将数据存储在表对象当中的。为什么将数据存储在表中呢？因为表存储数据非常直观。 任何一张表都有行和列： 行：记录（一行就是一条数据） 列：字段（name字段、age字段、gender字段） 每个字段包含以下属性： 字段名：name、age、gender都是字段的名字 字段的数据类型：每个字段都有数据类型，比如：字符类型、数字类型、日期类型 字段的数据长度：每个字段有可能会有长度的限制 字段的约束：比如某些字段要求该字段下的数据不能重复、不能为空等，用来保证表格中数据合法有效 初始化测试数据为了方便后面内容的学习，老师提前准备了表以及表中的测试数据，以下是建表并且初始化数据的sql脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051DROP TABLE IF EXISTS EMP;DROP TABLE IF EXISTS DEPT;DROP TABLE IF EXISTS SALGRADE;CREATE TABLE DEPT(DEPTNO int(2) not null , DNAME VARCHAR(14) , LOC VARCHAR(13), primary key (DEPTNO));CREATE TABLE EMP(EMPNO int(4) not null , ENAME VARCHAR(10), JOB VARCHAR(9), MGR INT(4), HIREDATE DATE DEFAULT NULL, SAL DOUBLE(7,2), COMM DOUBLE(7,2), primary key (EMPNO), DEPTNO INT(2) );CREATE TABLE SALGRADE( GRADE INT, LOSAL INT, HISAL INT);INSERT INTO DEPT ( DEPTNO, DNAME, LOC ) VALUES ( 10, 'ACCOUNTING', 'NEW YORK'); INSERT INTO DEPT ( DEPTNO, DNAME, LOC ) VALUES ( 20, 'RESEARCH', 'DALLAS'); INSERT INTO DEPT ( DEPTNO, DNAME, LOC ) VALUES ( 30, 'SALES', 'CHICAGO'); INSERT INTO DEPT ( DEPTNO, DNAME, LOC ) VALUES ( 40, 'OPERATIONS', 'BOSTON'); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7369, 'SMITH', 'CLERK', 7902, '1980-12-17', 800, NULL, 20); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7499, 'ALLEN', 'SALESMAN', 7698, '1981-02-20', 1600, 300, 30); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7521, 'WARD', 'SALESMAN', 7698, '1981-02-22', 1250, 500, 30); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7566, 'JONES', 'MANAGER', 7839, '1981-04-02', 2975, NULL, 20); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7654, 'MARTIN', 'SALESMAN', 7698, '1981-09-28', 1250, 1400, 30); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7698, 'BLAKE', 'MANAGER', 7839, '1981-05-01', 2850, NULL, 30); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7782, 'CLARK', 'MANAGER', 7839, '1981-06-09', 2450, NULL, 10); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7788, 'SCOTT', 'ANALYST', 7566, '1987-04-19', 3000, NULL, 20); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7839, 'KING', 'PRESIDENT', NULL, '1981-11-17', 5000, NULL, 10); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7844, 'TURNER', 'SALESMAN', 7698, '1981-09-08', 1500, 0, 30); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7876, 'ADAMS', 'CLERK', 7788, '1987-05-23', 1100, NULL, 20); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7900, 'JAMES', 'CLERK', 7698, '1981-12-03', 950, NULL, 30); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7902, 'FORD', 'ANALYST', 7566, '1981-12-03', 3000, NULL, 20); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7934, 'MILLER', 'CLERK', 7782, '1982-01-23', 1300, NULL, 10); INSERT INTO SALGRADE ( GRADE, LOSAL, HISAL ) VALUES ( 1, 700, 1200); INSERT INTO SALGRADE ( GRADE, LOSAL, HISAL ) VALUES ( 2, 1201, 1400); INSERT INTO SALGRADE ( GRADE, LOSAL, HISAL ) VALUES ( 3, 1401, 2000); INSERT INTO SALGRADE ( GRADE, LOSAL, HISAL ) VALUES ( 4, 2001, 3000); INSERT INTO SALGRADE ( GRADE, LOSAL, HISAL ) VALUES ( 5, 3001, 9999); commit; 什么是sql脚本：文件名是.sql，并且该文件中编写了大量的SQL语句，执行sql脚本程序就相当于批量执行SQL语句。 你入职的时候，项目一般都是进展了一部分，多数情况下你进项目组的时候数据库的表以及数据都是有的，项目经理第一天可能会给你一个较大的sql脚本文件，你需要执行这个脚本文件来初始化你的本地数据库。（当然，也有可能数据库是共享的。） 创建文件：bjpowernode.sql，把以上SQL语句全部复制到sql脚本文件中。 执行SQL脚本文件，初始化数据库 第一步：命令窗口登录mysql 第二步：创建数据库bjpowernode（如果之前已经创建就不需要再创建了）：create database bjpowernode; 第三步：使用数据库bjpowernode：use bjpowernode; 第四步：source命令执行sql脚本，注意：source命令后面是sql脚本文件的绝对路径。 &nbsp; 第五步：查看是否初始化成功，执行：show tables; &nbsp; 使用其他的mysql客户端工具也可以执行sql脚本，比如navicat。使用source命令执行sql脚本的优点：可支持大文件。 熟悉测试数据emp dept salgrade三张表分别存储什么信息 emp：员工信息 dept：部门信息 salgrade：工资等级信息 查看表结构：desc或describe，语法格式：desc或describe +表名以上的结果展示的不是表中的数据，而是表的结构。 Field是字段名 Type是这个字段的数据类型 Null是这个字段是否允许为空 Key是这个字段是否为主键或外键 Default是这个字段的默认值 对以上表结构进行解释说明： emp表 empno：员工编号，int类型（整数），不能为空，主键（主键后期学习约束时会进行说明） ename：员工姓名，varchar类型（字符串） job：工作岗位，varchar类型 mgr：上级领导编号，int类型 hiredate：雇佣日期，date类型（日期类型） sal：月薪，double类型（带有浮点的数字） comm：补助津贴，double类型 deptno：部门编号，int类型 dept表 deptno：部门编号，int类型，主键 dname：部门名称，varchar类型 loc：位置，varchar类型 salgrade表 grade：等级，int类型 losal：最低工资，int类型 hisal：最高工资，int类型 对于以上表结构要提前了解，后面学习的内容需要你马上反应出：哪个字段是什么意思。查看一下表中的数据，来加深一下印象（以下SQL语句会在后面课程中学习）：","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://xiaofanshutu.github.io/categories/MySQL/"}],"tags":[]},{"title":"MySQL数据库安装","slug":"动力节点MySQL/第02章 MySQL的安装","date":"2025-06-29T23:08:23.981Z","updated":"2025-06-30T14:07:52.359Z","comments":true,"path":"posts/1bbb3b3c.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/1bbb3b3c.html","excerpt":"MySQL概述 MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，MySQL AB公司被Sun公司收购，Sun公司又被Oracle公司收购，目前属于Oracle公司。 MySQL是目前最流行的关系型数据库管理系统，在WEB应用方面MySQL是最好的RDBMS应用软件之一。 国内淘宝网站就使用的是MySQL集群。 MySQL特点 MySQL有开源版本和收费版本，你使用开源版本是不收费的。 MySQL支持大型数据库，可以处理上千万记录的大型数据库。 MySQL使用标准的SQL数据库语言形式。 MySQL在很多系统上面都支持。 MySQL对Java，C都有很好的支持，当然其他的语言也支持比如Python、PHP。 MySQL是可以定制的，采用了GPL协议，你可以修改源码来开发自己的MySQL系统。 MySQL的下载官网下载 第一步：打开MySQL官网https://www.mysql.com/ 第二步：点击”DOWNLOADS”","text":"MySQL概述 MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，MySQL AB公司被Sun公司收购，Sun公司又被Oracle公司收购，目前属于Oracle公司。 MySQL是目前最流行的关系型数据库管理系统，在WEB应用方面MySQL是最好的RDBMS应用软件之一。 国内淘宝网站就使用的是MySQL集群。 MySQL特点 MySQL有开源版本和收费版本，你使用开源版本是不收费的。 MySQL支持大型数据库，可以处理上千万记录的大型数据库。 MySQL使用标准的SQL数据库语言形式。 MySQL在很多系统上面都支持。 MySQL对Java，C都有很好的支持，当然其他的语言也支持比如Python、PHP。 MySQL是可以定制的，采用了GPL协议，你可以修改源码来开发自己的MySQL系统。 MySQL的下载官网下载 第一步：打开MySQL官网https://www.mysql.com/ 第二步：点击”DOWNLOADS” 第三步：当前页继续下拉，直到找到下图链接 第四步：点击上图链接，进入下面页面，其中“MySQL Community Server”是解压版mysql，“MySQL Installer for Windows”是安装版，这里我们选择解压版 第五步：点击上图“MySQL Community Server” 第六步：点击上图第1个“Download” 第七步：点击上图“No thanks, just start my download.”开始下载，直到下载完毕。 网盘下载链接：https://pan.baidu.com/s/1lRWC069K8GE-8rxr259ArQ?pwd=2009 提取码：2009 MySQL安装与配置 将下载的zip压缩包解压，我这里直接解压到C盘的根目录下 mysql的根目录为：C:\\mysql-8.0.24-winx64 将C:\\mysql-8.0.24-winx64\\bin目录配置到环境变量path当中 初始化data目录 使用管理员身份打开dos命令窗口（按win键，输入cmd，点击管理员身份运行） cd命令切换到mysql的bin目录下，执行mysqld –initialize –console进行data目录初始化，此时会在控制台生成一个随机密码，下图红框中就是随机密码 技巧：左键选中密码，直接点击右键，此时密码已经复制到剪贴板中了，然后随便找一个文件，将密码粘贴到文件中保存起来。 安装MySQL服务：cd命令切换到bin目录下，执行命令mysqld -install 查看mysql服务名称：此电脑-右键-管理-服务和应用程序-服务-找MySQL服务，如下图mysql服务名称：MySQL 启动MySQL服务：net start mysql，注意start后面是mysql服务的名称 停止mysql服务的命令：net stop mysql注意：启停mysql服务也可以在上一步的图中点击右键进行启停服务。 登录mysql：输入mysql -uroot -p，然后回车，输入刚才的随机密码，然后回车，看到下图表示成功登录mysql 修改MySQL的root账户密码：ALTER USER ‘root’@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘新密码’; 使用新密码登录mysql MySQL卸载 停止mysql的服务 删除mysql服务 删除mysql的目录 登录MySQL本地登录 如果mysql的服务是启动的，打开dos命令窗口，输入：mysql -uroot -p，回车，然后输入root账户的密码 解释“mysql -uroot -p”：mysql是一个命令，在bin目录下，对应的命令文件是mysql.exe，如果将bin目录配置到环境变量path中，才可以在以上位置使用该命令。-uroot 表示登录的用户是root，u实际上是user单词的首字母。-p 表示登录时使用密码，p实际上是password单词的首字母。 也可以将密码以明文的形式写到-p后面，这样做可能会导致你的密码泄露 远程登录 假设mysql安装在A机器上，现在你要在B机器上连接mysql数据库，此时需要使用远程登录，远程登录时加上远程机器的ip地址即可 -h中的h实际上是host单词的首字母。在-h后面的是远程计算机的ip地址。127.0.0.1是计算机默认的本机IP地址。127.0.0.1又可以写作：localhost，他们是等效的。注意：mysql默认情况下root账户是不支持远程登录的，其实这是一种安全策略，为了保护root账户的安全。如果希望root账户支持远程登录，这是需要进行设置的。 mysql8 开放root账户远程登录权限（危险动作） 第一步：现在本地使用root账户登录mysql 第二步：use mysql; 第三步：update user set host = ‘%’ where user = ‘root’; 第四步：flush privileges;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://xiaofanshutu.github.io/categories/MySQL/"}],"tags":[]},{"title":"MySQL查询DQL专题","slug":"动力节点MySQL/第04章 查询DQL专题","date":"2025-06-29T23:08:23.976Z","updated":"2025-06-30T23:15:59.024Z","comments":true,"path":"posts/5d301c0f.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/5d301c0f.html","excerpt":"简单查询查询是SQL语言的核心，用于表达SQL查询的select查询命令是功能最强也是最为复杂的SQL语句，它的作用就是从数据库中检索数据，并将查询结果返回给用户。 select语句由：select子句(查询内容)、from子句(查询对象)、where子句(查询条件)、order by子句(排序方式)、group by子句(分组方式)等组成。查询语句属于SQL语句中的DQL语句，是所有SQL语句中最为复杂也是最重要的语句，所以必须掌握。接下来我们先从简单查询语句开始学习。 查一个字段查询一个字段说的是：一个表有多列，查询其中的一列。语法格式：select 字段名 from 表名; select和from是关键字，不能随便写 一条SQL语句必须以“;”结尾 对于SQL语句来说，大小写都可以 字段名和表名属于标识符，按照表的实际情况填写，不知道字段名的，可以使用desc命令查看表结构 案例1：查询公司中所有员工编号 1select empno from emp; 案例2：查询公司中所有员工姓名 1SELECT ENAME FROM EMP;","text":"简单查询查询是SQL语言的核心，用于表达SQL查询的select查询命令是功能最强也是最为复杂的SQL语句，它的作用就是从数据库中检索数据，并将查询结果返回给用户。 select语句由：select子句(查询内容)、from子句(查询对象)、where子句(查询条件)、order by子句(排序方式)、group by子句(分组方式)等组成。查询语句属于SQL语句中的DQL语句，是所有SQL语句中最为复杂也是最重要的语句，所以必须掌握。接下来我们先从简单查询语句开始学习。 查一个字段查询一个字段说的是：一个表有多列，查询其中的一列。语法格式：select 字段名 from 表名; select和from是关键字，不能随便写 一条SQL语句必须以“;”结尾 对于SQL语句来说，大小写都可以 字段名和表名属于标识符，按照表的实际情况填写，不知道字段名的，可以使用desc命令查看表结构 案例1：查询公司中所有员工编号 1select empno from emp; 案例2：查询公司中所有员工姓名 1SELECT ENAME FROM EMP; 在mysql命令行客户端中，sql语句没有分号是不会执行的：末尾加上“;”就执行了：以上sql虽然以分号结尾之后执行了，但是报错了，错误信息显示：语法错误。假设一个SQL语句在书写过程中出错了，怎么终止这条SQL呢？\\c 任务1：查询所有部门名称。 任务2：查询所有薪资等级。 查多个字段查询多个字段时，在字段名和字段名之间添加“,”即可。语法格式：select 字段名1,字段名2,字段名3 from 表名;案例1：查询员工编号以及员工姓名。 1select empno, ename from emp; 字段的前后顺序无所谓（只是显示结果列的时候顺序变了)： 1select ename, empno from emp; 任务1：查询部门编号、部门名称以及位置。 任务2：查询员工的名字以及工作岗位。 查所有字段查询所有字段的可以将每个字段都列出来查询，也可以采用“*”来代表所有字段案例1：查询员工的所有信息 1select * from emp; 案例2：查询所有部门信息 1select * from dept; 采用“*”进行查询存在的缺点： select * from dept; 在执行的时候会被解析为 select DEPTNO, DNAME, LOC from dept; 再执行，所以这种效率方面弱一些。 采用“”的可读性较差，通过“”很难看出都有哪些具体的字段。 什么时候使用“*”？ 这个SQL语句不在项目编码中使用，如果平时自己想快速查看表中所有数据的话，这种写法还是很给力的。 任务1：查询所有的薪资等级以及每个薪资等级的最低工资和最高工资。 查询时字段可参与数学运算在进行查询操作的时候，字段是可以参与数学运算的，例如加减乘除等。案例1：查询每个员工的月薪 1select ename, sal from emp; 案例2：查询每个员工的年薪（月薪 * 12) 1select ename, sal * 12 from emp; 任务1：查询每个员工月薪加1000之后的月薪 任务2：查询每个员工月薪加1000之后的年薪 查询时字段可起别名我们借用一下之前的SQL语句 1select ename, sal * 12 from emp; 以上的查询结果列名“sal * 12”可读性较差，是否可以给查询结果的列名进行重命名呢？ as关键字 使用as关键字1select ename, sal * 12 as yearsal from emp; 通过as关键字起别名后，查询结果列显示yearsal，可读性增强。 省略as关键字 其实as关键字可以省略，只要使用空格即可 1select ename, sal * 12 yearsal from emp; 通过以上测试，得知as可以省略，可以使用空格代替as，但如果别名中有空格呢？ 别名中有空格1select ename, sal * 12 year sal from emp; 可以看出，执行报错了，说语法有问题，这是为什么？分析一下：SQL语句编译器在检查该语句的时候，在year后面遇到了空格，会继续找from关键字，但year后面不是from关键字，所以编译器报错了。怎么解决这个问题？记住：如果别名中有空格的话，可以将这个别名使用双引号或者单引号将其括起来。 12select ename, sal * 12 \"year sal\" from emp;select ename, sal * 12 'year sal' from emp; 在mysql中，字符串既可以使用双引号也可以使用单引号，但还是建议使用单引号，因为单引号属于标准SQL。 别名中有中文 如果别名采用中文呢？1select ename, sal * 12 年薪 from emp; 别名是中文是可以的，但是对于低版本的mysql来说会报错，需要添加双引号或单引号。我们当前使用的mysql版本是：8.0.24 任务：查询所有员工的信息，要求每个字段名采用中文显示。 条件查询通常在进行查询操作的时候，都是查询符合某些条件的数据，很少将表中所有数据都取出来。怎么取出表的部分数据？需要在查询语句中添加条件进行数据的过滤。常见的过滤条件如下： 条件 说明 = 等于 &lt;&gt;或!= 不等于 &gt;= 大于等于 &lt;= 小于等于 &gt; 大于 &lt; 小于 between…and… 等同于 &gt;= and &lt;= is null 为空 is not null 不为空 &lt;=&gt; 安全等于（可读性差，很少使用了）。 and 或 &amp;&amp; 并且 or 或 || 或者 in 在指定的值当中 not in 不在指定的值当中 exists not exists like 模糊查询 条件查询语法格式123456select ...from ...where 过滤条件; 过滤条件放在where子句当中，以上语句的执行顺序是： 第一步：先执行from 第二步：再通过where条件过滤 第三步：最后执行select，查询并将结果展示到控制台 等于、不等于等于 =判断等量关系，支持多种数据类型，比如：数字、字符串、日期等。案例1：查询月薪3000的员工编号及姓名 123456select empno,enamefrom empwhere sal = 3000; 案例2：查询员工FORD的岗位及月薪 123456select job, salfrom empwhere ename = 'FORD'; 存储在表emp中的员工姓名是FORD，全部大写，如果在查询的时候，写成全部小写会怎样呢？ 123456select job, salfrom empwhere ename = 'ford'; 通过测试发现，即使写成小写ford，也是可以查询到结果的，不过这里需要注意的是：在Oracle数据库当中是查询不到数据的，Oracle的语法要比MySQL的语法严谨。对于SQL语句本身来说是不区分大小写的，但是对于表中真实存储的数据，大写A和小写a还是不一样的，这一点Oracle做的很好。MySQL的语法更随性。另外在Oracle当中，字符串是必须使用单引号括起来的，但在MySQL当中，字符串可以使用单引号，也可以使用双引号，如下： 123456select job, salfrom empwhere ename = \"FORD\"; 案例3：查询岗位是MANAGER的员工编号及姓名 123456select empno, enamefrom empwhere job = 'MANAGER'; 任务：查询工资级别是1的最低工资以及最高工资 不等于 &lt;&gt; 或 !=判断非等量关系，支持字符串、数字、日期类型等。不等号有两种写法，第一种&lt;&gt;，第二种!=，第二种写法和Java程序中的不等号相同，第一种写法比较诡异，不过也很好理解，比如&lt;&gt;3，表示小于3、大于3，就是不等于3。你get到了吗？案例1：查询工资不是3000的员工编号、姓名、薪资 123456select empno,ename,salfrom empwhere sal &lt;&gt; 3000; 案例2：查询工作岗位不是MANAGER的员工姓名和岗位 123456select ename,jobfrom empwhere job &lt;&gt; 'MANAGER'; 任务：查询不在部门编号为10的部门工作的员工信息 大于、大于等于、小于、小于等于大于 &gt;案例：找出薪资大于3000的员工姓名、薪资 123456select ename, salfrom empwhere sal &gt; 3000; 大于等于 &gt;=案例：找出薪资大于等于3000的员工姓名、薪资 123456select ename, salfrom empwhere sal &gt;= 3000; 小于 &lt;案例：找出薪资小于3000的员工姓名、薪资 123456select ename, salfrom empwhere sal &lt; 3000; 小于等于 &lt;=案例：找出薪资小于等于3000的员工姓名、薪资 123456select ename, salfrom empwhere sal &lt;= 3000; andand表示并且，还有另一种写法：&amp;&amp;案例：找出薪资大于等于3000并且小于等于5000的员工姓名、薪资。 123456select ename,salfrom empwhere sal &gt;= 3000 and sal &lt;= 5000; 任务：找出工资级别为2~4（包含2和4）的最低工资和最高工资。 oror表示或者，还有另一种写法：||案例：找出工作岗位是MANAGER和SALESMAN的员工姓名、工作岗位 123456select ename, jobfrom empwhere job = 'MANAGER' or job = 'SALESMAN'; 注意：这个题目描述中有这样一句话：MANAGER和SALESMAN，有的同学一看到“和”，就直接使用“and”了，因为“和”对应的英文单词是“and”，如果是这样的话，就大错特错了，因为and表示并且，使用and表示工作岗位既是MANAGER又是SALESMAN的员工，这样的员工是不存在的，因为每一个员工只有一个岗位，不可能同时从事两个岗位。所以使用and是查询不到任何结果的。如下 123456select ename, jobfrom empwhere job = 'MANAGER' and job = 'SALESMAN'; 任务：查询20和30部门的员工信息。 and和or的优先级问题and和or同时出现时，and优先级较高，会先执行，如果希望or先执行，这个时候需要给or条件添加小括号。另外，以后遇到不确定的优先级时，可以通过添加小括号的方式来解决。对于优先级问题没必要记忆。案例：找出薪资小于1500，并且部门编号是20或30的员工姓名、薪资、部门编号。先来看一下错误写法： 123456select ename,sal,deptnofrom empwhere sal &lt; 1500 and deptno = 20 or deptno = 30; 认真解读题意得知：薪资小于1500是一个大前提，要找出的是薪资小于1500的，满足这个条件的前提下，再找部门编号是20或30的，显然以上的运行结果中出现了薪资为1600的，为什么1600的会出现呢？这是因为“sal &lt; 1500 and deptno = 20”结合在一起了，“depnto = 30”成了一个独立的条件。会导致部门编号为30的所有员工全部查询出来。我们应该让“deptno = 20 or deptno = 30”结合在一起，正确写法如下： 123456select ename,sal,deptnofrom empwhere sal &lt; 1500 and (deptno = 20 or deptno = 30); 任务：找出薪资小于1500的，并且工作岗位是CLERK和SALESMAN的员工姓名、薪资、岗位。 between…and…between…and…等同于 &gt;= and &lt;=做区间判断的，包含左右两个边界值。它支持数字、日期、字符串等数据类型。between…and…在使用时一定是**左小右大**。左大右小时无法查询到数据。between…and… 和 &gt;= and &lt;=只是在写法结构上有区别，执行原理和效率方面没有区别。案例：找出薪资在1600到3000的员工姓名、薪资 123456select ename,salfrom empwhere sal between 1600 and 3000; 采用左大右小的方式： 123456select ename,salfrom empwhere sal between 3000 and 1600; 没有查询到任何数据，所以在使用的时候一定要注意：左小右大。 任务：查询在1982-01-23到1987-04-19之间入职的员工 注意：以上SQL语句中日期需要加上单引号。 is null、is not null判断某个数据是否为null，不能使用等号，只能使用 is null判断某个数据是否不为null，不能使用不等号，只能使用 is not null在数据库中null不是一个值，不能用等号和不等号衡量，null代表什么也没有，没有数据，没有值 is null案例1：找出津贴为空的员工姓名、薪资、津贴。 123456select ename,sal,commfrom empwhere comm is null; 我们使用等号，尝试一下： 123456select ename,sal,commfrom empwhere comm = null; 查询不到任何数据，所以判断是否为空，不能用等号。 is not null案例2：找出津贴不为空的员工姓名、薪资、津贴 123456select ename,sal,commfrom empwhere comm is not null; in、not ininjob in(‘MANAGER’,’SALESMAN’,’CLERK’) 等同于 job = ‘MANAGER’ or job = ‘SALESMAN’ or job = ‘CLERK’sal in(1600, 3000, 5000) 等同于 sal = 1600 or sal = 3000 or sal = 5000in后面有一个小括号，小括号当中有多个值，值和值之间采用逗号隔开sal in(1500, 5000)，需要注意的是：这个并不是说薪资在1500到5000之间，in不代表区间，表示sal是1500的和sal是5000的案例1：找出工作岗位是MANAGER和SALESMAN的员工姓名、薪资、工作岗位第一种：使用or 123456select ename,sal,jobfrom empwhere job = 'MANAGER' or job = 'SALESMAN'; 第二种：使用in 123456select ename,sal,jobfrom empwhere job in('MANAGER', 'SALESMAN'); 案例2：找出薪资是1500/1600/3000的员工姓名、工作岗位 123456select ename,jobfrom empwhere sal in(1500, 1600, 3000); 任务：找出部门编号是10和20的员工编号、姓名。（要求使用两种方案） not injob not in(‘MANAGER’,’SALESMAN’) 等同于 job &lt;&gt; ‘MANAGER’ and job &lt;&gt; ‘SALESMAN’sal not in(1600, 5000) 等同于 sal &lt;&gt; 1600 and sal &lt;&gt; 5000案例：找出工作岗位不是MANAGER和SALESMAN的员工姓名、工作岗位第一种：使用and 123456select ename,jobfrom empwhere job &lt;&gt; 'MANAGER' and job &lt;&gt; 'SALESMAN'; 第二种：使用not in 123456select ename,jobfrom empwhere job not in('MANAGER', 'SALESMAN'); 任务：找出薪资不是1600和3000的员工姓名、薪资。 in、not in 与 NULL先来看一下emp表中的数据 1select * from emp; 通过表中数据观察到，有4个员工的津贴不为NULL，剩下10个员工的津贴都是NULL。写这样一条SQL语句： 1select * from emp where comm in(NULL, 300); 为什么以上执行结果只有一条记录呢？分析一下：首先你要知道in的执行原理实际上是采用=和or的方式，也就是说，以上SQL语句实际上是： 1select * from emp where comm = NULL or comm = 300; 其中NULL不能用等号=进行判断，所以comm = NULL结果是false，然而中间使用的是or，所以comm = NULL被忽略了。所以查询结果就以上一条数据。通过以上的测试得知：in是自动忽略NULL的。再写这样一条SQL语句： 1select * from emp where comm not in(NULL, 300); 以上的执行结果奇怪了，为什么没有查到任何数据呢？我们分析一下：首先你要知道not in的执行原理实际上是采用&lt;&gt;和and的方式，也就是说，以上SQL语句实际上是： 1select * from emp where comm &lt;&gt; NULL and comm &lt;&gt; 300; 其中NULL的判断不能使用&lt;&gt;，所以comm &lt;&gt; NULL结果是false，由于后面是and，and表示并且，comm &lt;&gt; NULL已经是false了，所以and右边的就没必要运算了，comm &lt;&gt; NULL and comm &lt;&gt; 300的整体运算结果就是false。所以查询不到任何数据。通过以上测试得知，not in是不会自动忽略NULL的，所以在使用not in的时候一定要提前过滤掉NULL。 in和or的效率比拼在MySQL当中，如何统计一个SQL语句的执行时长？ 可以使用这个命令：show profiles; 这个命令可以查看在mysql中执行的所有SQL以及命令的耗费时长。 show profiles; 是在mysql5.0.37之后添加的。所以要确保你的mysql版本没问题。 如何开启时长统计功能：set profiling = 1; 查看时长统计功能是否开启：show variables like ‘%pro%’; 查看每条SQL的耗时：show profiles; 查看其中某条SQL耗时明细：show profile for query query_id; 查看最新一条SQL的耗时明细：show profile; 查看cpu，io等信息：show profile block io, cpu for query query_id; or的效率为O(n)，而in的效率为O(log n), 当n越大的时候效率相差越明显（也就是说数据量越大的时候，in的效率越高）。以下是测试过程：第一步，创建测试表，并生成测试数据，测试数据为1000万条记录。数据库中关闭了query cache，因此数据库缓存不会对查询造成影响。具体的代码如下： 123456789101112131415161718192021222324252627#创建测试的test表DROP TABLE IF EXISTS test; CREATE TABLE test( ID INT(10) NOT NULL, `Name` VARCHAR(20) DEFAULT '' NOT NULL, PRIMARY KEY( ID ) )ENGINE=INNODB DEFAULT CHARSET utf8; #创建生成测试数据的存储过程DROP PROCEDURE IF EXISTS pre_test; DELIMITER //CREATE PROCEDURE pre_test() BEGIN DECLARE i INT DEFAULT 0; SET autocommit = 0; WHILE i&lt;10000000 DO INSERT INTO test ( ID,`Name` ) VALUES( i, CONCAT( 'Carl', i ) ); SET i = i+1; IF i%2000 = 0 THEN COMMIT; END IF; END WHILE; END; //DELIMITER ;#执行存储过程生成测试数据CALL pre_test(); 以上SQL看不懂没关系，先执行它，进行数据初始化准备工作。第二步：分三种情况进行测试，分别是：第1种情况：in和or所在列为主键的情形。第2种情况：in和or所在列创建有索引的情形。第3种情况：in和or所在列没有索引的情形。每种情况又采用不同的in和or的数量进行测试。由于测试语句的数据量有4种情况，我这里就称为A组、B组、C组、D组，其中A组为3个值，B组为150个值，C组为300个值，D组为1000个值。具体的测试语句如下： 1234567891011121314151617181920212223#A组#in和or中有3条数据的情况SELECT * FROM test WHERE id IN (1,23,48);SELECT * FROM test WHERE id =1 OR id=23 OR id=48;#B组#in和or中有150条数据的情况SELECT * FROM test WHERE id IN (59617932,98114476,89047409,26968186,56586105,35488201,53251989,18182139,71164231,57655852,7948544,60658339,50758185,66667117,34771253,68699137,27877290,44275282,1585444,71219424,90937482,83928635,24588528,81933207,9607562,12013895,84640278,85549596,53249244,8567444,85402877,15040223,54266509,17718135,91687882,22930500,94756430,66031097,13084573,18137443,89917778,46845456,43939093,35943480,18213703,46362815,49835919,83137546,2101409,74932951,11984477,93113331,77848222,68546065,33728734,90793684,44975642,61387237,52483391,97716233,49449060,22411182,30776331,60597240,6911731,45789095,62075344,8379933,97910423,86861971,81342386,93423963,83852896,18566482,22747687,51420625,75862064,26402882,93958561,85202979,97049369,67674725,9475653,92302381,78133617,49295001,36517340,81387142,15707241,60832834,93157830,64171432,58537826,70141767,7326025,36632075,9639624,8900056,99702164,35108945,87820933,57302965,16652391,41845132,62184393,70136913,79574630,32562398,94616790,61258220,73162018,81644480,19453596,97380163,1204733,33357040,84854495,13888863,49041868,89272326,38405345,571248,6349029,70755321,79307694,60619684,92624181,73135306,23279848,95612954,55845916,6223606,43836918,37459781,67969314,99398872,7616960,37189193,50151920,62881879,12364637,33204320,27135672,28441504,47373461,87967926,30631796,20053540,18735984,83406724);SELECT * FROM test WHERE id=59617932 OR id=98114476 OR id=89047409 OR id=26968186 OR id=56586105 OR id=35488201 OR id=53251989 OR id=18182139 OR id=71164231 OR id=57655852 OR id=7948544 OR id=60658339 OR id=50758185 OR id=66667117 OR id=34771253 OR id=68699137 OR id=27877290 OR id=44275282 OR id=1585444 OR id=71219424 OR id=90937482 OR id=83928635 OR id=24588528 OR id=81933207 OR id=9607562 OR id=12013895 OR id=84640278 OR id=85549596 OR id=53249244 OR id=8567444 OR id=85402877 OR id=15040223 OR id=54266509 OR id=17718135 OR id=91687882 OR id=22930500 OR id=94756430 OR id=66031097 OR id=13084573 OR id=18137443 OR id=89917778 OR id=46845456 OR id=43939093 OR id=35943480 OR id=18213703 OR id=46362815 OR id=49835919 OR id=83137546 OR id=2101409 OR id=74932951 OR id=11984477 OR id=93113331 OR id=77848222 OR id=68546065 OR id=33728734 OR id=90793684 OR id=44975642 OR id=61387237 OR id=52483391 OR id=97716233 OR id=49449060 OR id=22411182 OR id=30776331 OR id=60597240 OR id=6911731 OR id=45789095 OR id=62075344 OR id=8379933 OR id=97910423 OR id=86861971 OR id=81342386 OR id=93423963 OR id=83852896 OR id=18566482 OR id=22747687 OR id=51420625 OR id=75862064 OR id=26402882 OR id=93958561 OR id=85202979 OR id=97049369 OR id=67674725 OR id=9475653 OR id=92302381 OR id=78133617 OR id=49295001 OR id=36517340 OR id=81387142 OR id=15707241 OR id=60832834 OR id=93157830 OR id=64171432 OR id=58537826 OR id=70141767 OR id=7326025 OR id=36632075 OR id=9639624 OR id=8900056 OR id=99702164 OR id=35108945 OR id=87820933 OR id=57302965 OR id=16652391 OR id=41845132 OR id=62184393 OR id=70136913 OR id=79574630 OR id=32562398 OR id=94616790 OR id=61258220 OR id=73162018 OR id=81644480 OR id=19453596 OR id=97380163 OR id=1204733 OR id=33357040 OR id=84854495 OR id=13888863 OR id=49041868 OR id=89272326 OR id=38405345 OR id=571248 OR id=6349029 OR id=70755321 OR id=79307694 OR id=60619684 OR id=92624181 OR id=73135306 OR id=23279848 OR id=95612954 OR id=55845916 OR id=6223606 OR id=43836918 OR id=37459781 OR id=67969314 OR id=99398872 OR id=7616960 OR id=37189193 OR id=50151920 OR id=62881879 OR id=12364637 OR id=33204320 OR id=27135672 OR id=28441504 OR id=47373461 OR id=87967926 OR id=30631796 OR id=20053540 OR id=18735984 OR id=83406724;#C组#in和or中有300条数据的情况SELECT * FROM test WHERE id IN (37092877,94859722,74276090,8763830,38727241,95732954,93414819,55070016,3591352,73857925,92290525,15210159,83905516,54934589,83004136,31442143,6060569,22209206,27649629,11464943,77822402,28714780,10058522,62252663,13751461,38997875,47320577,64507359,36137908,54297630,97411161,56542672,22017966,55190708,70072386,24300664,93413617,23621629,74772508,62774612,43001947,46161388,85563006,70177147,63960440,18001207,81734850,10635060,6551152,54877885,44426798,73950635,18713144,21690065,82153543,26048520,79954773,22411093,97307339,74193176,1413532,88006544,36062746,24043946,17132007,95958217,26112542,27303972,17247403,56778979,60928031,69369613,90584759,86234538,41726089,25315005,27568726,25091624,15307765,83130887,42726438,75872353,18991223,47819224,75457713,54659391,54889687,65229322,17124556,38376043,1989975,45973571,48597804,58632319,43388664,97010450,94745635,13217373,40472912,40220510,58319808,48228318,48936085,86281500,65466706,96815281,11751559,50188155,76649755,35315411,20360954,17739218,10918461,51429591,41447650,65170472,26810295,80912347,17157209,75851858,61150903,4408208,61200404,6655467,66863737,51549112,61951371,14368308,14663119,8762531,31765056,30560647,41048147,95526521,94929131,56881239,79014587,62705983,15892901,66151473,98846144,79336731,35949035,26250054,97536202,40575682,6965144,91059908,97939380,30854180,1965937,17193347,76584991,70467475,6559872,97386594,13939914,20379091,84906436,45989448,17337270,4949675,96963499,12561575,77153018,73213368,68283041,33977574,86290771,70381017,73095085,454900,44614195,48171334,49603342,7430998,29447060,47643508,82393912,83169846,94256496,35275444,40024984,25377535,46571333,32510994,70927802,92017916,97302502,22859741,32726786,79071601,93977472,47409421,49311618,77366144,84838598,59401507,67110877,42075938,76962007,27984930,72982484,81363683,75017478,88624177,67220235,88290070,26311443,87681081,77960250,4996033,68448074,67762279,99650583,36766422,27233152,71436659,25428777,81481679,51070397,88351803,78755075,26783938,83610840,45650662,86305644,1717314,66176062,6507047,45084786,74402982,55661367,35721238,40424913,24294239,30223531,55367671,56777532,12604154,4870493,14750488,74039611,42549918,70710424,56247316,63002053,71117605,16510883,67417211,34057637,74185092,58603491,66987830,73584171,9178319,47096502,1554825,37756804,85168245,92690138,6120773,99586029,74696745,61803307,56631845,42681796,58965644,68703695,69660559,15879062,26713059,85186928,63117471,53007808,74576547,32187857,13701205,88645881,24507258,87453800,39624977,75862710,62419627,70804059,10461373,18265782,56366177,68093007,75760763,43931574,65808002,49148775,98019987,71183123,53762434,78851856,37767085,89124453,47566746);SELECT * FROM test WHERE id=37092877 OR id=94859722 OR id=74276090 OR id=8763830 OR id=38727241 OR id=95732954 OR id=93414819 OR id=55070016 OR id=3591352 OR id=73857925 OR id=92290525 OR id=15210159 OR id=83905516 OR id=54934589 OR id=83004136 OR id=31442143 OR id=6060569 OR id=22209206 OR id=27649629 OR id=11464943 OR id=77822402 OR id=28714780 OR id=10058522 OR id=62252663 OR id=13751461 OR id=38997875 OR id=47320577 OR id=64507359 OR id=36137908 OR id=54297630 OR id=97411161 OR id=56542672 OR id=22017966 OR id=55190708 OR id=70072386 OR id=24300664 OR id=93413617 OR id=23621629 OR id=74772508 OR id=62774612 OR id=43001947 OR id=46161388 OR id=85563006 OR id=70177147 OR id=63960440 OR id=18001207 OR id=81734850 OR id=10635060 OR id=6551152 OR id=54877885 OR id=44426798 OR id=73950635 OR id=18713144 OR id=21690065 OR id=82153543 OR id=26048520 OR id=79954773 OR id=22411093 OR id=97307339 OR id=74193176 OR id=1413532 OR id=88006544 OR id=36062746 OR id=24043946 OR id=17132007 OR id=95958217 OR id=26112542 OR id=27303972 OR id=17247403 OR id=56778979 OR id=60928031 OR id=69369613 OR id=90584759 OR id=86234538 OR id=41726089 OR id=25315005 OR id=27568726 OR id=25091624 OR id=15307765 OR id=83130887 OR id=42726438 OR id=75872353 OR id=18991223 OR id=47819224 OR id=75457713 OR id=54659391 OR id=54889687 OR id=65229322 OR id=17124556 OR id=38376043 OR id=1989975 OR id=45973571 OR id=48597804 OR id=58632319 OR id=43388664 OR id=97010450 OR id=94745635 OR id=13217373 OR id=40472912 OR id=40220510 OR id=58319808 OR id=48228318 OR id=48936085 OR id=86281500 OR id=65466706 OR id=96815281 OR id=11751559 OR id=50188155 OR id=76649755 OR id=35315411 OR id=20360954 OR id=17739218 OR id=10918461 OR id=51429591 OR id=41447650 OR id=65170472 OR id=26810295 OR id=80912347 OR id=17157209 OR id=75851858 OR id=61150903 OR id=4408208 OR id=61200404 OR id=6655467 OR id=66863737 OR id=51549112 OR id=61951371 OR id=14368308 OR id=14663119 OR id=8762531 OR id=31765056 OR id=30560647 OR id=41048147 OR id=95526521 OR id=94929131 OR id=56881239 OR id=79014587 OR id=62705983 OR id=15892901 OR id=66151473 OR id=98846144 OR id=79336731 OR id=35949035 OR id=26250054 OR id=97536202 OR id=40575682 OR id=6965144 OR id=91059908 OR id=97939380 OR id=30854180 OR id=1965937 OR id=17193347 OR id=76584991 OR id=70467475 OR id=6559872 OR id=97386594 OR id=13939914 OR id=20379091 OR id=84906436 OR id=45989448 OR id=17337270 OR id=4949675 OR id=96963499 OR id=12561575 OR id=77153018 OR id=73213368 OR id=68283041 OR id=33977574 OR id=86290771 OR id=70381017 OR id=73095085 OR id=454900 OR id=44614195 OR id=48171334 OR id=49603342 OR id=7430998 OR id=29447060 OR id=47643508 OR id=82393912 OR id=83169846 OR id=94256496 OR id=35275444 OR id=40024984 OR id=25377535 OR id=46571333 OR id=32510994 OR id=70927802 OR id=92017916 OR id=97302502 OR id=22859741 OR id=32726786 OR id=79071601 OR id=93977472 OR id=47409421 OR id=49311618 OR id=77366144 OR id=84838598 OR id=59401507 OR id=67110877 OR id=42075938 OR id=76962007 OR id=27984930 OR id=72982484 OR id=81363683 OR id=75017478 OR id=88624177 OR id=67220235 OR id=88290070 OR id=26311443 OR id=87681081 OR id=77960250 OR id=4996033 OR id=68448074 OR id=67762279 OR id=99650583 OR id=36766422 OR id=27233152 OR id=71436659 OR id=25428777 OR id=81481679 OR id=51070397 OR id=88351803 OR id=78755075 OR id=26783938 OR id=83610840 OR id=45650662 OR id=86305644 OR id=1717314 OR id=66176062 OR id=6507047 OR id=45084786 OR id=74402982 OR id=55661367 OR id=35721238 OR id=40424913 OR id=24294239 OR id=30223531 OR id=55367671 OR id=56777532 OR id=12604154 OR id=4870493 OR id=14750488 OR id=74039611 OR id=42549918 OR id=70710424 OR id=56247316 OR id=63002053 OR id=71117605 OR id=16510883 OR id=67417211 OR id=34057637 OR id=74185092 OR id=58603491 OR id=66987830 OR id=73584171 OR id=9178319 OR id=47096502 OR id=1554825 OR id=37756804 OR id=85168245 OR id=92690138 OR id=6120773 OR id=99586029 OR id=74696745 OR id=61803307 OR id=56631845 OR id=42681796 OR id=58965644 OR id=68703695 OR id=69660559 OR id=15879062 OR id=26713059 OR id=85186928 OR id=63117471 OR id=53007808 OR id=74576547 OR id=32187857 OR id=13701205 OR id=88645881 OR id=24507258 OR id=87453800 OR id=39624977 OR id=75862710 OR id=62419627 OR id=70804059 OR id=10461373 OR id=18265782 OR id=56366177 OR id=68093007 OR id=75760763 OR id=43931574 OR id=65808002 OR id=49148775 OR id=98019987 OR id=71183123 OR id=53762434 OR id=78851856 OR id=37767085 OR id=89124453 OR id=47566746;#D组#in和or中有1000条数据的情况SELECT * FROM test WHERE id IN (93674701,9720356,31732184,53855095,33144472,71864888,27541768,27238726,83648428,12942332,26918445,19781953,81861032,74800064,12286132,6624397,64942581,70512799,46356598,88292448,87069909,38175756,98121997,62570414,15900806,51527968,89092372,8084203,53772848,78871524,3608561,85909562,41702172,61800503,57877634,93407278,30824340,13159046,49055339,73058078,983603,73571456,51694978,75136628,82716874,83551181,7964224,47505945,92695321,15885152,79282709,18572099,27392970,14552787,19848227,4518183,11773920,22285326,71605145,2402625,63365854,70973600,10584706,83688869,84268419,6026005,36545233,24462648,19293921,17561083,52105483,59243514,35230465,34650779,30053489,24225251,59642405,81933853,94495716,26364324,25980634,5579237,14569289,89417845,71178959,4143920,20467990,53316808,21288525,82249537,37737589,44712689,36788133,15668654,4697556,63785060,11555169,36401204,92276179,4135929,75453019,28231031,8649240,11576980,20262028,56242424,11305608,5655216,90240601,28569373,5296027,10739594,72751648,22531251,12535926,36347415,19740655,69125465,7523885,88128548,88830806,25010302,29411467,99614288,32646290,16592563,69036910,32604729,88737786,90169676,57646877,72105460,40027541,70362483,37221415,25284914,69691185,17972978,1544661,47324366,25337670,91133621,63697117,48652228,18538437,79966496,26066529,65334307,8305141,86289387,20178085,88836090,74948034,14101728,7837868,83548120,65602502,83129211,24785681,65000269,49140174,62636621,31096695,52276400,28546681,83631937,57100225,42531528,28326396,38641032,93055463,20525612,66073509,35154065,29007664,12600294,76829494,73917074,67226149,12478806,39842542,70312958,82792046,49668650,46280815,96555182,22966062,83158116,87566530,66277804,7944142,90649884,64342810,9881875,14833854,82959569,50523207,48788762,3801076,14677723,63080506,96215352,36302231,35067168,11695282,19447382,66401373,40822285,41406321,48630216,78955925,57194625,52097877,16169037,44834346,2593695,29948466,41842778,50510473,39669493,64590865,26160800,94882286,2703212,41243905,89363549,82819429,25565895,86836890,58385785,55898457,99305620,43332680,98223672,4494624,25408421,28054121,48197701,90633404,25825550,90631154,24867226,61846156,38911183,67826056,10676975,57116645,474292,82387517,56211477,46555785,49282428,99468990,81172472,26720330,38692582,96073680,88412290,28829489,1816508,75321051,81650509,23175973,42008725,60743468,52532114,731909,77811415,86804961,29675484,33584929,180367,93687804,41093066,5987495,27291494,78229979,63194139,34357776,9992084,22643334,22407822,69740170,29581361,50036776,88768091,82537322,83709895,55361776,90616169,44595355,9468440,54552233,73496954,46104486,92947715,38522993,88515232,57725249,48507967,25309486,91597013,85635814,69579638,68775627,57556546,77900275,95965693,9601780,5448068,54075952,64335883,80114875,14793294,21016639,1959922,93176996,7893733,51407895,45849129,33857790,30096194,78021982,66555961,15842998,77678123,56648395,8171848,80152264,78616680,80098122,22882409,77242219,3124519,60865422,43164198,43256621,73261157,12541949,49780175,23167183,10509251,41809106,25655902,6752559,39850293,50992519,40061483,84526968,93056718,53267125,53914467,39404926,83672449,21484465,34147538,13437853,74079093,50400032,85705998,7557614,10300505,79264856,65669946,23899714,53506926,36081544,11113765,65755643,5826515,60392667,55562374,98132987,80904530,92663352,7283593,3709276,52078745,84847057,34235334,63889320,70036669,58603533,27394053,54766781,50920854,80202681,67618417,82912294,20150728,20042189,86403320,38738266,58393070,50887299,12170654,16212895,37361223,13677457,19503506,20213757,84240441,39618969,26401150,47937678,55871130,79189571,5717133,12444503,95283334,14827147,22008485,56345882,43237192,56980197,68699371,46407250,72120555,70694039,46438829,17774982,36484024,138767,89563532,54847019,7815592,44909604,50479084,17462504,96594465,58317102,92426225,91894699,4501659,43315607,9442814,19705166,87751308,95588126,92372510,20281564,19251355,10321183,34573093,19074704,84678191,24383998,27670253,50223562,34091936,99304371,32477827,54273037,86525073,73253547,33316827,6724062,76707318,78171148,44729510,16697684,68966388,57448392,51380186,35344477,98153122,51825492,27202774,26901641,37527637,88241695,15100257,30418000,21821200,95511035,9289513,83870196,54628801,39402988,88345504,84232433,13925255,70816934,6822742,14400466,430652,87397095,89773413,10883914,89939310,39597573,49356789,62857680,93292662,55644642,81922551,94304087,63705961,137763,22392805,65195561,39498904,22576234,59467794,46389072,66341462,44602153,18204976,45366397,3880945,98231882,27999162,38209350,10599910,77139550,35114264,57109708,93064441,34801782,24938667,84955486,53018874,37969943,64372852,69596670,21288762,12774121,97588451,23575359,10954061,50363988,56263940,61520763,85096643,36250068,19807406,20984386,24520668,44631794,62587890,44963362,7663521,78505677,98442373,90280978,14494324,16069861,11397153,87726305,26133866,42024935,93393929,72575268,76384597,42272046,81658814,40811718,86054463,35997739,51075676,62839927,68179261,19292480,10464999,6342696,75842285,28671096,30029838,19617648,94667632,75855376,83477767,456684,81197213,1961395,79590898,470693,64786459,90138714,30486571,75566704,64467558,21380112,17742907,7733647,92017,64615799,72272722,66873854,77198963,35594848,42694993,12431322,2247181,11020746,42416726,19127785,95444937,36842133,4203521,48149533,45322440,59710953,38250773,31370132,26889920,45927952,55298246,31197238,44744953,35531670,38850041,29759177,76433451,33696500,2823716,68574340,68889919,35744793,64772909,41562277,72606631,54617176,76086087,61060196,1593669,4666059,44201567,97015910,51039786,47534369,36899420,95163693,34278055,24361819,93200909,29991418,63172824,53644148,61454424,44726508,64910883,31088636,14005026,83267869,28497493,12406441,34686539,70646963,7687253,23115957,64556990,49701688,76843379,22370877,11199132,15492661,72101877,47154152,54969058,96696025,33567129,95788960,13301506,38695877,52992551,37817234,82136809,28111091,84977065,93404791,56350318,27576451,84170153,37381626,22432144,35119973,23922989,98961080,14336913,49612713,47410677,41559348,64216475,75502736,16203656,81726720,64541981,82181762,95869963,1086041,76856852,99484886,47292021,99746735,79082859,67416188,46391963,58631281,80994168,9464550,5851058,16534935,63307701,91875109,18716507,15870646,6003995,836024,35610568,39574140,76244639,83403189,51252728,6516065,94907007,81605606,40398075,40258386,6692981,50852074,2869416,97682971,44427361,9608914,58464559,81806036,20047387,66264452,58063775,54179837,48463792,17877188,31718426,64192249,35574859,3671766,88905164,78137697,46929619,21063327,83078770,93293821,41618319,3832324,91310612,79854291,68734227,8826717,80881657,95208907,7079422,30037415,5494004,44809486,97620027,35689182,13120783,26108678,1537176,16538727,50841024,36515680,82635278,11112660,16276555,72997511,93487848,88201238,53997085,15198916,61214583,78412499,3585265,1402827,56445518,47661453,25615629,58263458,62155263,46608555,15822703,82285214,76021596,84571697,45999350,40074628,8219220,5429523,74024203,22354037,17605466,60436920,52777032,65801717,43656316,10424270,48035786,29493228,83897372,62101275,84793857,56894828,70636689,72497148,67388694,68146510,64298548,97117498,25553211,54226533,90395845,24172623,91712292,98280822,54042497,25032894,6833135,39011254,9837753,63507766,26747954,45941264,99955245,80051546,78510759,71322333,92407609,95809491,18999217,23430377,11861293,42583098,24163209,11358738,3237302,3176665,87151132,2789150,63905882,59864282,3673596,19570439,22883042,72375525,51614404,47526636,98443133,99140135,33855918,28333489,81416033,2670097,4897577,24439616,36643479,40817600,76022791,40072872,95193435,96967607,24983145,49883271,94602753,83555050,85455145,34563229,72328311,12002151,71481181,72998351,1489188,38426973,91893116,61594591,89693630,6268166,20056665,62169880,17143472,35103925,22452590,54272289,34236829,78028543,84474414,40386926,50550952,49413559,48781941,22927237,44447815,29960478,47578119,10192558,87733936,88699383,38808712,79944807,84014713,31865463,72617685,19557568,47865990,39069638,20086122,1777562,29018078,78358083,94561719,46281152,99789008,86929490,16534451,55989144,52455669,54561585,97379646,20416183,87617750,76115505,3282482,8383619,45456319,29576432,67750627,61736333,33745442,51502165,35349384,78106651,23232822,94851387,78254073,82406754,10317954,70125940,45067526,27061875,25640164,52574899,93819227,93789607,96122951,31673246,70431904,54067896,37146857,37817889,14058940,60710246,64844350,91604383,71972005,13888349,19093493,27397281,61085409,66529387,82761299,72236310,19277077,96599501,68304096,48292937,97503321,88011133,29224803,79782945,79965966,83716914,90432214,48938902,12498489,30246261,91624049,68652396,23677785,44084687,3865123,37823170,45287730,38784682,28058351,68226368,61569897,44737876,70575908,25568463,24668386,88650569,35559584,1897737,77844785,29780669,84004602,29029776,91003545,48058106,9463847);SELECT * FROM test WHERE id=93674701 OR id=9720356 OR id=31732184 OR id=53855095 OR id=33144472 OR id=71864888 OR id=27541768 OR id=27238726 OR id=83648428 OR id=12942332 OR id=26918445 OR id=19781953 OR id=81861032 OR id=74800064 OR id=12286132 OR id=6624397 OR id=64942581 OR id=70512799 OR id=46356598 OR id=88292448 OR id=87069909 OR id=38175756 OR id=98121997 OR id=62570414 OR id=15900806 OR id=51527968 OR id=89092372 OR id=8084203 OR id=53772848 OR id=78871524 OR id=3608561 OR id=85909562 OR id=41702172 OR id=61800503 OR id=57877634 OR id=93407278 OR id=30824340 OR id=13159046 OR id=49055339 OR id=73058078 OR id=983603 OR id=73571456 OR id=51694978 OR id=75136628 OR id=82716874 OR id=83551181 OR id=7964224 OR id=47505945 OR id=92695321 OR id=15885152 OR id=79282709 OR id=18572099 OR id=27392970 OR id=14552787 OR id=19848227 OR id=4518183 OR id=11773920 OR id=22285326 OR id=71605145 OR id=2402625 OR id=63365854 OR id=70973600 OR id=10584706 OR id=83688869 OR id=84268419 OR id=6026005 OR id=36545233 OR id=24462648 OR id=19293921 OR id=17561083 OR id=52105483 OR id=59243514 OR id=35230465 OR id=34650779 OR id=30053489 OR id=24225251 OR id=59642405 OR id=81933853 OR id=94495716 OR id=26364324 OR id=25980634 OR id=5579237 OR id=14569289 OR id=89417845 OR id=71178959 OR id=4143920 OR id=20467990 OR id=53316808 OR id=21288525 OR id=82249537 OR id=37737589 OR id=44712689 OR id=36788133 OR id=15668654 OR id=4697556 OR id=63785060 OR id=11555169 OR id=36401204 OR id=92276179 OR id=4135929 OR id=75453019 OR id=28231031 OR id=8649240 OR id=11576980 OR id=20262028 OR id=56242424 OR id=11305608 OR id=5655216 OR id=90240601 OR id=28569373 OR id=5296027 OR id=10739594 OR id=72751648 OR id=22531251 OR id=12535926 OR id=36347415 OR id=19740655 OR id=69125465 OR id=7523885 OR id=88128548 OR id=88830806 OR id=25010302 OR id=29411467 OR id=99614288 OR id=32646290 OR id=16592563 OR id=69036910 OR id=32604729 OR id=88737786 OR id=90169676 OR id=57646877 OR id=72105460 OR id=40027541 OR id=70362483 OR id=37221415 OR id=25284914 OR id=69691185 OR id=17972978 OR id=1544661 OR id=47324366 OR id=25337670 OR id=91133621 OR id=63697117 OR id=48652228 OR id=18538437 OR id=79966496 OR id=26066529 OR id=65334307 OR id=8305141 OR id=86289387 OR id=20178085 OR id=88836090 OR id=74948034 OR id=14101728 OR id=7837868 OR id=83548120 OR id=65602502 OR id=83129211 OR id=24785681 OR id=65000269 OR id=49140174 OR id=62636621 OR id=31096695 OR id=52276400 OR id=28546681 OR id=83631937 OR id=57100225 OR id=42531528 OR id=28326396 OR id=38641032 OR id=93055463 OR id=20525612 OR id=66073509 OR id=35154065 OR id=29007664 OR id=12600294 OR id=76829494 OR id=73917074 OR id=67226149 OR id=12478806 OR id=39842542 OR id=70312958 OR id=82792046 OR id=49668650 OR id=46280815 OR id=96555182 OR id=22966062 OR id=83158116 OR id=87566530 OR id=66277804 OR id=7944142 OR id=90649884 OR id=64342810 OR id=9881875 OR id=14833854 OR id=82959569 OR id=50523207 OR id=48788762 OR id=3801076 OR id=14677723 OR id=63080506 OR id=96215352 OR id=36302231 OR id=35067168 OR id=11695282 OR id=19447382 OR id=66401373 OR id=40822285 OR id=41406321 OR id=48630216 OR id=78955925 OR id=57194625 OR id=52097877 OR id=16169037 OR id=44834346 OR id=2593695 OR id=29948466 OR id=41842778 OR id=50510473 OR id=39669493 OR id=64590865 OR id=26160800 OR id=94882286 OR id=2703212 OR id=41243905 OR id=89363549 OR id=82819429 OR id=25565895 OR id=86836890 OR id=58385785 OR id=55898457 OR id=99305620 OR id=43332680 OR id=98223672 OR id=4494624 OR id=25408421 OR id=28054121 OR id=48197701 OR id=90633404 OR id=25825550 OR id=90631154 OR id=24867226 OR id=61846156 OR id=38911183 OR id=67826056 OR id=10676975 OR id=57116645 OR id=474292 OR id=82387517 OR id=56211477 OR id=46555785 OR id=49282428 OR id=99468990 OR id=81172472 OR id=26720330 OR id=38692582 OR id=96073680 OR id=88412290 OR id=28829489 OR id=1816508 OR id=75321051 OR id=81650509 OR id=23175973 OR id=42008725 OR id=60743468 OR id=52532114 OR id=731909 OR id=77811415 OR id=86804961 OR id=29675484 OR id=33584929 OR id=180367 OR id=93687804 OR id=41093066 OR id=5987495 OR id=27291494 OR id=78229979 OR id=63194139 OR id=34357776 OR id=9992084 OR id=22643334 OR id=22407822 OR id=69740170 OR id=29581361 OR id=50036776 OR id=88768091 OR id=82537322 OR id=83709895 OR id=55361776 OR id=90616169 OR id=44595355 OR id=9468440 OR id=54552233 OR id=73496954 OR id=46104486 OR id=92947715 OR id=38522993 OR id=88515232 OR id=57725249 OR id=48507967 OR id=25309486 OR id=91597013 OR id=85635814 OR id=69579638 OR id=68775627 OR id=57556546 OR id=77900275 OR id=95965693 OR id=9601780 OR id=5448068 OR id=54075952 OR id=64335883 OR id=80114875 OR id=14793294 OR id=21016639 OR id=1959922 OR id=93176996 OR id=7893733 OR id=51407895 OR id=45849129 OR id=33857790 OR id=30096194 OR id=78021982 OR id=66555961 OR id=15842998 OR id=77678123 OR id=56648395 OR id=8171848 OR id=80152264 OR id=78616680 OR id=80098122 OR id=22882409 OR id=77242219 OR id=3124519 OR id=60865422 OR id=43164198 OR id=43256621 OR id=73261157 OR id=12541949 OR id=49780175 OR id=23167183 OR id=10509251 OR id=41809106 OR id=25655902 OR id=6752559 OR id=39850293 OR id=50992519 OR id=40061483 OR id=84526968 OR id=93056718 OR id=53267125 OR id=53914467 OR id=39404926 OR id=83672449 OR id=21484465 OR id=34147538 OR id=13437853 OR id=74079093 OR id=50400032 OR id=85705998 OR id=7557614 OR id=10300505 OR id=79264856 OR id=65669946 OR id=23899714 OR id=53506926 OR id=36081544 OR id=11113765 OR id=65755643 OR id=5826515 OR id=60392667 OR id=55562374 OR id=98132987 OR id=80904530 OR id=92663352 OR id=7283593 OR id=3709276 OR id=52078745 OR id=84847057 OR id=34235334 OR id=63889320 OR id=70036669 OR id=58603533 OR id=27394053 OR id=54766781 OR id=50920854 OR id=80202681 OR id=67618417 OR id=82912294 OR id=20150728 OR id=20042189 OR id=86403320 OR id=38738266 OR id=58393070 OR id=50887299 OR id=12170654 OR id=16212895 OR id=37361223 OR id=13677457 OR id=19503506 OR id=20213757 OR id=84240441 OR id=39618969 OR id=26401150 OR id=47937678 OR id=55871130 OR id=79189571 OR id=5717133 OR id=12444503 OR id=95283334 OR id=14827147 OR id=22008485 OR id=56345882 OR id=43237192 OR id=56980197 OR id=68699371 OR id=46407250 OR id=72120555 OR id=70694039 OR id=46438829 OR id=17774982 OR id=36484024 OR id=138767 OR id=89563532 OR id=54847019 OR id=7815592 OR id=44909604 OR id=50479084 OR id=17462504 OR id=96594465 OR id=58317102 OR id=92426225 OR id=91894699 OR id=4501659 OR id=43315607 OR id=9442814 OR id=19705166 OR id=87751308 OR id=95588126 OR id=92372510 OR id=20281564 OR id=19251355 OR id=10321183 OR id=34573093 OR id=19074704 OR id=84678191 OR id=24383998 OR id=27670253 OR id=50223562 OR id=34091936 OR id=99304371 OR id=32477827 OR id=54273037 OR id=86525073 OR id=73253547 OR id=33316827 OR id=6724062 OR id=76707318 OR id=78171148 OR id=44729510 OR id=16697684 OR id=68966388 OR id=57448392 OR id=51380186 OR id=35344477 OR id=98153122 OR id=51825492 OR id=27202774 OR id=26901641 OR id=37527637 OR id=88241695 OR id=15100257 OR id=30418000 OR id=21821200 OR id=95511035 OR id=9289513 OR id=83870196 OR id=54628801 OR id=39402988 OR id=88345504 OR id=84232433 OR id=13925255 OR id=70816934 OR id=6822742 OR id=14400466 OR id=430652 OR id=87397095 OR id=89773413 OR id=10883914 OR id=89939310 OR id=39597573 OR id=49356789 OR id=62857680 OR id=93292662 OR id=55644642 OR id=81922551 OR id=94304087 OR id=63705961 OR id=137763 OR id=22392805 OR id=65195561 OR id=39498904 OR id=22576234 OR id=59467794 OR id=46389072 OR id=66341462 OR id=44602153 OR id=18204976 OR id=45366397 OR id=3880945 OR id=98231882 OR id=27999162 OR id=38209350 OR id=10599910 OR id=77139550 OR id=35114264 OR id=57109708 OR id=93064441 OR id=34801782 OR id=24938667 OR id=84955486 OR id=53018874 OR id=37969943 OR id=64372852 OR id=69596670 OR id=21288762 OR id=12774121 OR id=97588451 OR id=23575359 OR id=10954061 OR id=50363988 OR id=56263940 OR id=61520763 OR id=85096643 OR id=36250068 OR id=19807406 OR id=20984386 OR id=24520668 OR id=44631794 OR id=62587890 OR id=44963362 OR id=7663521 OR id=78505677 OR id=98442373 OR id=90280978 OR id=14494324 OR id=16069861 OR id=11397153 OR id=87726305 OR id=26133866 OR id=42024935 OR id=93393929 OR id=72575268 OR id=76384597 OR id=42272046 OR id=81658814 OR id=40811718 OR id=86054463 OR id=35997739 OR id=51075676 OR id=62839927 OR id=68179261 OR id=19292480 OR id=10464999 OR id=6342696 OR id=75842285 OR id=28671096 OR id=30029838 OR id=19617648 OR id=94667632 OR id=75855376 OR id=83477767 OR id=456684 OR id=81197213 OR id=1961395 OR id=79590898 OR id=470693 OR id=64786459 OR id=90138714 OR id=30486571 OR id=75566704 OR id=64467558 OR id=21380112 OR id=17742907 OR id=7733647 OR id=92017 OR id=64615799 OR id=72272722 OR id=66873854 OR id=77198963 OR id=35594848 OR id=42694993 OR id=12431322 OR id=2247181 OR id=11020746 OR id=42416726 OR id=19127785 OR id=95444937 OR id=36842133 OR id=4203521 OR id=48149533 OR id=45322440 OR id=59710953 OR id=38250773 OR id=31370132 OR id=26889920 OR id=45927952 OR id=55298246 OR id=31197238 OR id=44744953 OR id=35531670 OR id=38850041 OR id=29759177 OR id=76433451 OR id=33696500 OR id=2823716 OR id=68574340 OR id=68889919 OR id=35744793 OR id=64772909 OR id=41562277 OR id=72606631 OR id=54617176 OR id=76086087 OR id=61060196 OR id=1593669 OR id=4666059 OR id=44201567 OR id=97015910 OR id=51039786 OR id=47534369 OR id=36899420 OR id=95163693 OR id=34278055 OR id=24361819 OR id=93200909 OR id=29991418 OR id=63172824 OR id=53644148 OR id=61454424 OR id=44726508 OR id=64910883 OR id=31088636 OR id=14005026 OR id=83267869 OR id=28497493 OR id=12406441 OR id=34686539 OR id=70646963 OR id=7687253 OR id=23115957 OR id=64556990 OR id=49701688 OR id=76843379 OR id=22370877 OR id=11199132 OR id=15492661 OR id=72101877 OR id=47154152 OR id=54969058 OR id=96696025 OR id=33567129 OR id=95788960 OR id=13301506 OR id=38695877 OR id=52992551 OR id=37817234 OR id=82136809 OR id=28111091 OR id=84977065 OR id=93404791 OR id=56350318 OR id=27576451 OR id=84170153 OR id=37381626 OR id=22432144 OR id=35119973 OR id=23922989 OR id=98961080 OR id=14336913 OR id=49612713 OR id=47410677 OR id=41559348 OR id=64216475 OR id=75502736 OR id=16203656 OR id=81726720 OR id=64541981 OR id=82181762 OR id=95869963 OR id=1086041 OR id=76856852 OR id=99484886 OR id=47292021 OR id=99746735 OR id=79082859 OR id=67416188 OR id=46391963 OR id=58631281 OR id=80994168 OR id=9464550 OR id=5851058 OR id=16534935 OR id=63307701 OR id=91875109 OR id=18716507 OR id=15870646 OR id=6003995 OR id=836024 OR id=35610568 OR id=39574140 OR id=76244639 OR id=83403189 OR id=51252728 OR id=6516065 OR id=94907007 OR id=81605606 OR id=40398075 OR id=40258386 OR id=6692981 OR id=50852074 OR id=2869416 OR id=97682971 OR id=44427361 OR id=9608914 OR id=58464559 OR id=81806036 OR id=20047387 OR id=66264452 OR id=58063775 OR id=54179837 OR id=48463792 OR id=17877188 OR id=31718426 OR id=64192249 OR id=35574859 OR id=3671766 OR id=88905164 OR id=78137697 OR id=46929619 OR id=21063327 OR id=83078770 OR id=93293821 OR id=41618319 OR id=3832324 OR id=91310612 OR id=79854291 OR id=68734227 OR id=8826717 OR id=80881657 OR id=95208907 OR id=7079422 OR id=30037415 OR id=5494004 OR id=44809486 OR id=97620027 OR id=35689182 OR id=13120783 OR id=26108678 OR id=1537176 OR id=16538727 OR id=50841024 OR id=36515680 OR id=82635278 OR id=11112660 OR id=16276555 OR id=72997511 OR id=93487848 OR id=88201238 OR id=53997085 OR id=15198916 OR id=61214583 OR id=78412499 OR id=3585265 OR id=1402827 OR id=56445518 OR id=47661453 OR id=25615629 OR id=58263458 OR id=62155263 OR id=46608555 OR id=15822703 OR id=82285214 OR id=76021596 OR id=84571697 OR id=45999350 OR id=40074628 OR id=8219220 OR id=5429523 OR id=74024203 OR id=22354037 OR id=17605466 OR id=60436920 OR id=52777032 OR id=65801717 OR id=43656316 OR id=10424270 OR id=48035786 OR id=29493228 OR id=83897372 OR id=62101275 OR id=84793857 OR id=56894828 OR id=70636689 OR id=72497148 OR id=67388694 OR id=68146510 OR id=64298548 OR id=97117498 OR id=25553211 OR id=54226533 OR id=90395845 OR id=24172623 OR id=91712292 OR id=98280822 OR id=54042497 OR id=25032894 OR id=6833135 OR id=39011254 OR id=9837753 OR id=63507766 OR id=26747954 OR id=45941264 OR id=99955245 OR id=80051546 OR id=78510759 OR id=71322333 OR id=92407609 OR id=95809491 OR id=18999217 OR id=23430377 OR id=11861293 OR id=42583098 OR id=24163209 OR id=11358738 OR id=3237302 OR id=3176665 OR id=87151132 OR id=2789150 OR id=63905882 OR id=59864282 OR id=3673596 OR id=19570439 OR id=22883042 OR id=72375525 OR id=51614404 OR id=47526636 OR id=98443133 OR id=99140135 OR id=33855918 OR id=28333489 OR id=81416033 OR id=2670097 OR id=4897577 OR id=24439616 OR id=36643479 OR id=40817600 OR id=76022791 OR id=40072872 OR id=95193435 OR id=96967607 OR id=24983145 OR id=49883271 OR id=94602753 OR id=83555050 OR id=85455145 OR id=34563229 OR id=72328311 OR id=12002151 OR id=71481181 OR id=72998351 OR id=1489188 OR id=38426973 OR id=91893116 OR id=61594591 OR id=89693630 OR id=6268166 OR id=20056665 OR id=62169880 OR id=17143472 OR id=35103925 OR id=22452590 OR id=54272289 OR id=34236829 OR id=78028543 OR id=84474414 OR id=40386926 OR id=50550952 OR id=49413559 OR id=48781941 OR id=22927237 OR id=44447815 OR id=29960478 OR id=47578119 OR id=10192558 OR id=87733936 OR id=88699383 OR id=38808712 OR id=79944807 OR id=84014713 OR id=31865463 OR id=72617685 OR id=19557568 OR id=47865990 OR id=39069638 OR id=20086122 OR id=1777562 OR id=29018078 OR id=78358083 OR id=94561719 OR id=46281152 OR id=99789008 OR id=86929490 OR id=16534451 OR id=55989144 OR id=52455669 OR id=54561585 OR id=97379646 OR id=20416183 OR id=87617750 OR id=76115505 OR id=3282482 OR id=8383619 OR id=45456319 OR id=29576432 OR id=67750627 OR id=61736333 OR id=33745442 OR id=51502165 OR id=35349384 OR id=78106651 OR id=23232822 OR id=94851387 OR id=78254073 OR id=82406754 OR id=10317954 OR id=70125940 OR id=45067526 OR id=27061875 OR id=25640164 OR id=52574899 OR id=93819227 OR id=93789607 OR id=96122951 OR id=31673246 OR id=70431904 OR id=54067896 OR id=37146857 OR id=37817889 OR id=14058940 OR id=60710246 OR id=64844350 OR id=91604383 OR id=71972005 OR id=13888349 OR id=19093493 OR id=27397281 OR id=61085409 OR id=66529387 OR id=82761299 OR id=72236310 OR id=19277077 OR id=96599501 OR id=68304096 OR id=48292937 OR id=97503321 OR id=88011133 OR id=29224803 OR id=79782945 OR id=79965966 OR id=83716914 OR id=90432214 OR id=48938902 OR id=12498489 OR id=30246261 OR id=91624049 OR id=68652396 OR id=23677785 OR id=44084687 OR id=3865123 OR id=37823170 OR id=45287730 OR id=38784682 OR id=28058351 OR id=68226368 OR id=61569897 OR id=44737876 OR id=70575908 OR id=25568463 OR id=24668386 OR id=88650569 OR id=35559584 OR id=1897737 OR id=77844785 OR id=29780669 OR id=84004602 OR id=29029776 OR id=91003545 OR id=48058106 OR id=9463847; 测试结果如下：第一种情况，ID列为主键的情况，4组测试执行计划一样，执行的时间也基本没有区别。A组or和in的执行时间： or的执行时间为：0.002s &nbsp; &nbsp; in的执行时间为：0.002sB组or和in的执行时间： or的执行时间为：0.004s &nbsp; &nbsp; in的执行时间为：0.004sC组or和in的执行时间： or的执行时间为：0.006s &nbsp; &nbsp; in的执行时间为：0.005sD组or和in的执行时间： or的执行时间为：0.018s &nbsp; &nbsp; in的执行时间为：0.014s第二种情况，ID列为一般索引的情况，4组测试执行计划一样，执行的时间也基本没有区别。A组or和in的执行时间： or的执行时间为：0.002s &nbsp; &nbsp; in的执行时间为：0.002sB组or和in的执行时间： or的执行时间为：0.006s &nbsp; &nbsp; in的执行时间为：0.005s &nbsp;C组or和in的执行时间： or的执行时间为：0.008s &nbsp; &nbsp; in的执行时间为：0.008sD组or和in的执行时间： or的执行时间为：0.021s &nbsp; &nbsp; in的执行时间为：0.020s &nbsp;第三种情况，ID列没有索引的情况，4组测试执行计划一样，执行的时间有很大的区别。A组or和in的执行时间： or的执行时间为：5.016s &nbsp; &nbsp; &nbsp;in的执行时间为：5.071sB组or和in的执行时间： or的执行时间为：1min 02s &nbsp; &nbsp; in的执行时间为：5.018sC组or和in的执行时间： or的执行时间为：1min 55s &nbsp; &nbsp; in的执行时间为：5.018sD组or和in的执行时间： or的执行时间为：6min 17s &nbsp; &nbsp; in的执行时间为：5.057s 结论：从上面的测试结果，可以看出如果in和or所在列有索引或者主键的话，or和in没啥差别，执行计划和执行时间都几乎一样。如果in和or所在列没有索引的话，性能差别就很大了。在没有索引的情况下，随着in或者or后面的数据量越多，in的效率不会有太大的下降，但是or会随着记录越多的话性能下降非常厉害，从第三种测试情况中可以很明显地看出了，基本上是指数级增长。因此在给in和or的效率下定义的时候，应该再加上一个条件，就是所在的列是否有索引或者是否是主键。如果有索引或者主键性能没啥差别，如果没有索引，性能差别不是一点点！ 模糊查询like模糊查询又被称为模糊匹配，在实际开发中使用较多，比如：查询公司中所有姓张的，查询岗位中带有经理两个字的职位等等，这些都需要使用模糊查询。模糊查询的语法格式如下： 1select .. from .. where 字段 like '通配符表达式'; 在模糊查询中，通配符主要包括两个：一个是%，一个是下划线_。其中%代表任意多个字符。下划线_代表任意一个字符。案例1：查询员工名字以’S’开始的员工姓名 1select ename from emp where ename like 'S%'; 案例2：查询员工名字以’T’结尾的员工姓名 1select ename from emp where ename like '%T'; 案例3：查询员工名字中含有’O’的员工姓名 1select ename from emp where ename like '%O%'; 案例4：查询员工名字中第二个字母是’A’的员工姓名 1select ename from emp where ename like '_A%'; 案例5：查询学员名字中含有下划线的。执行以下SQL语句，先准备测试数据： 123456789drop table if exists student;create table student( id int, name varchar(255));insert into student(id,name) values(1, 'susan');insert into student(id,name) values(2, 'lucy');insert into student(id,name) values(3, 'jack_son');select * from student; 查询学员名字中含有下划线的，执行以下SQL试试： 1select * from student where name like '%_%'; 显然这个查询结果不是我们想要的，以上SQL之所以将所有数据全部显示了，因为下划线代表任意单个字符，如果你想让这个下划线变成一个普通的下划线字符，就要使用转义字符了，在mysql当中转义字符是“\\”，这个和java语言中的转义字符是一样的： 1select * from student where name like '%\\_%'; 排序操作排序操作很常用，比如查询学员成绩，按照成绩降序排列。排序的SQL语法： 1select .. from .. order by 字段 asc/desc 单一字段升序查询员工的编号、姓名、薪资，按照薪资升序排列。 1select empno,ename,sal from emp order by sal asc; 单一字段降序查询员工的编号、姓名、薪资，按照薪资降序排列。 1select empno,ename,sal from emp order by sal desc; 默认采用升序查询员工的编号、姓名、薪资，按照薪资升序排列。 1select empno,ename,sal from emp order by sal; 查询员工的编号、姓名，按照姓名升序排列。 1select empno,ename from emp order by ename; 多个字段排序查询员工的编号、姓名、薪资，按照薪资升序排列，如果薪资相同的，再按照姓名升序排列。 1select empno,ename,sal from emp order by sal asc, ename asc; where和order by的位置找出岗位是MANAGER的员工姓名和薪资，按照薪资升序排列。 1select ename,sal from emp where job = 'MANAGER' order by sal asc; 通过这个例子主要是想告诉大家：where先执行，order by语句是最后执行的。 distinct去重查询工作岗位 1select job from emp; 可以看到工作岗位中有重复的记录，如何在显示的时候去除重复记录呢？在字段前添加distinct关键字。 1select distinct job from emp; 注意：这个去重只是将显示的结果去重，原表数据不会被更改。接下来测试一下，在distinct关键字前添加其它字段是否可以？ 1select ename, distinct job from emp; 分析一下：ename是14条记录，distinct job是5条记录，可以同时显示吗？报错了，通过测试得知，distinct只能出现在所有字段的最前面。当distinct出现后，后面多个字段一定是联合去重的，我们来做两个练习就知道了：练习1：找出公司中所有的工作岗位。 练习2：找出公司中不同部门的不同工作岗位。 数据处理函数关于select语句，我们之前都是这样写：select 字段名 from 表名; 其实，这里的字段名可以看做“变量”，select后面既然可以跟变量，那么可以跟常量吗，尝试一下：通过以上sql的测试得知，select后面既可以跟变量，又可以跟常量。以上三条SQL中前两条中100和’abc’都是常量，最后一条SQL的abc没有添加单引号，它会被当做某个表的字段名，因为没有这个字段所以报错。 字符串相关转大写upper和ucase12# 查询所有员工名字，以大写形式展现select upper(ename) as ename from emp; 还有一个和upper函数功能相同的函数ucase，也可以转大写，了解一下即可： 12# 查询所有员工姓名，以大写形式展现select ucase(ename) as ename from emp; 12# 查询员工smith的岗位、薪资（假如你不知道数据库表中的人名是大写、小写还是大小写混合）select ename, job, sal from emp where upper(ename) = 'SMITH'; 转小写lower和lcase很简单，不再赘述，直接上代码： 123# 查询员工姓名，以小写形式展现select lower(ename) as ename from emp;select lcase(ename) as ename from emp; 截取字符串substr语法：substr(‘被截取的字符串’, 起始下标, 截取长度)有两种写法：第一种：substr(‘被截取的字符串’, 起始下标, 截取长度)第二种：substr(‘被截取的字符串’, 起始下标)，当第三个参数“截取长度”缺失时，截取到字符串末尾注意：起始下标从1开始，不是从0开始。（1表示从左侧开始的第一个位置，-1表示从右侧开始的第一个位置。） 练习：找出员工名字中第二个字母是A的 1select ename from emp where substr(ename, 2, 1) = 'A'; 获取字符串长度length注意：一个汉字是2个长度。 获取字符的个数char_length 字符串拼接语法：concat(‘字符串1’, ‘字符串2’, ‘字符串3’….)拼接的字符串数量没有限制。注意：在mysql8之前，双竖线||也是可以完成字符串拼接的。但在mysql8之后，||只作为逻辑运算符，不能再进行字符串拼接了。 1select 'abc' || 'def' || 'xyz'; mysql8之后，|| 只作为“或者”运算符，例如：找出工资高于3000或者低于900的员工姓名和薪资： 1select ename, sal from emp where sal &gt; 3000 || sal &lt; 900; mysql中可以使用+进行字符串的拼接吗？不可以，在mysql中+只作加法运算，在进行加法运算时，会将加号两边的数据尽最大的努力转换成数字再求和，如果无法转换成数字，最终运算结果通通是0 去除字符串前后空白trim1select concat(trim(' abc '), 'def'); 默认是去除前后空白，也可以去除指定的前缀后缀，例如：去除前置0 1select trim(leading '0' from '000111000'); 去除后置0 1select trim(trailing '0' from '000111000'); 前置0和后置0全部去除 1select trim(both '0' from '000111000'); 数字相关rand()和rand(x)rand()生成0到1的随机浮点数。rand(x)生成0到1的随机浮点数，通过指定整数x来确定每次获取到相同的浮点值。 round(x)和round(x,y)四舍五入round(x) 四舍五入，保留整数位，舍去所有小数round(x,y) 四舍五入，保留y位小数 truncate(x, y)舍去以上SQL表示保留两位小数，剩下的全部舍去。 ceil与floor数字处理函数除了以上的之外，还有ceil和floor函数： ceil函数：返回大于或等于数值x的最小整数 floor函数：返回小于或等于数值x的最大整数 空处理ifnull(x, y)，空处理函数，当x为NULL时，将x当做y处理。ifnull(comm, 0)，表示如果员工的津贴是NULL时当做0处理。在SQL语句中，凡是有NULL参与的数学运算，最终的计算结果都是NULL：看这样一个需求：查询每个员工的年薪。（年薪 = (月薪 + 津贴) * 12个月。注意：有的员工津贴comm是NULL。） 以上查询结果中显示SMITH等人的年薪是NULL，这是为什么，这是因为SMITH等人的津贴comm是NULL，有NULL参与的数学运算，最终结果都是NULL，显然这个需要空处理，此时就用到了ifnull函数： 日期和时间相关函数获取当前日期和时间now()和sysdate()的区别： now()：获取的是执行select语句的时刻。 sysdate()：获取的是执行sysdate()函数的时刻。 获取当前日期获取当前日期有三种写法，掌握任意一种即可： curdate() current_date() current_date 获取当前时间获取档期时间有三种写法，掌握其中一种即可： curtime() current_time() current_time 获取单独的年、月、日、时、分、秒注意：这些函数在使用的时候，需要传递一个日期参数给它，它可以获取到你给定的这个日期相关的年、月、日、时、分、秒的信息。一次性提取一个给定日期的“年月日”部分，可以使用date()函数，例如：一次性提取一个给定日期的“时分秒”部分，可以使用time()函数，例如： date_add函数date_add函数的作用：给指定的日期添加间隔的时间，从而得到一个新的日期。date_add函数的语法格式：date_add(日期, interval expr 单位)，例如：以’2023-01-03’为基准，间隔3天之后的日期：’2023-01-06’ 以’2023-01-03’为基准，间隔3个月之后的日期：’2023-04-03’详细解释一下这个函数的相关参数： 日期：一个日期类型的数据 interval：关键字，翻译为“间隔”，固定写法 expr：指定具体的间隔量，一般是一个数字。也可以为负数，如果为负数，效果和date_sub函数相同。 单位： year：年 month：月 day：日 hour：时 minute：分 second：秒 microsecond：微秒（1秒等于1000毫秒，1毫秒等于1000微秒） week：周 quarter：季度 请分析下面这条SQL语句所表达的含义：以上SQL表示：以2022-10-01 10:10:10为基准，在这个时间基础上添加-1微秒，也就是减去1微秒。以上SQL也可以采用date_sub函数完成，例如：另外，单位也可以采用复合型单位，例如： SECOND_MICROSECOND MINUTE_MICROSECOND MINUTE_SECOND：几分几秒之后 HOUR_MICROSECOND HOUR_SECOND HOUR_MINUTE：几小时几分之后 DAY_MICROSECOND DAY_SECOND DAY_MINUTE DAY_HOUR：几天几小时之后 YEAR_MONTH：几年几个月之后 如果单位采用复合型的话，expr该怎么写呢？例如单位采用：day_hour，假设我要表示3天2小时之后，怎么写？‘3,2’这个应该很好理解，表示3天2个小时之后。’3,2’和day_hour是对应的。 date_format日期格式化函数将日期转换成具有某种格式的日期字符串，通常用在查询操作当中。（date类型转换成char类型）语法格式：date_format(日期, ‘日期格式’)该函数有两个参数： 第一个参数：日期。这个参数就是即将要被格式化的日期。类型是date类型。 第二个参数：指定要格式化的格式字符串。 %Y：四位年份 %y：两位年份 %m：月份（1..12） %d：日（1..30） %H：小时（0..23） %i：分（0..59） %s：秒（0..59） 例如：获取当前系统时间，让其以这个格式展示：2000-10-11 20:15:30注意：在mysql当中，默认的日期格式就是：%Y-%m-%d %H:%i:%s，所以当你直接输出日期数据的时候，会自动转换成该格式的字符串： str_to_date函数该函数的作用是将char类型的日期字符串转换成日期类型date，通常使用在插入和修改操作当中。（char类型转换成date类型）假设有一个学生表t_student，学生有一个生日的字段，类型是date类型： 123456drop table if exists t_student;create table t_student( name varchar(255), birth date);desc t_student; 我们要给这个表插入一条数据：姓名zhangsan，生日85年10月1日，执行以下insert语句：错误原因：日期值不正确。意思是：birth字段需要一个日期，你给的这个字符串’10/01/1985’我识别不了。这种情况下，我们就可以使用str_to_date函数进行类型转换：当然，如果你提供的日期字符串格式能够被mysql解析，str_to_date函数是可以省略的，底层会自动调用该函数进行类型转换：如果日期格式符合以上的几种格式，mysql都会自动进行类型转换的。 dayofweek、dayofmonth、dayofyear函数dayofweek：一周中的第几天（17），周日是1，周六是7。dayofmonth：一个月中的第几天（131）dayofyear：一年中的第几天（1~366) last_day函数获取给定日期所在月的最后一天的日期： datediff函数计算两个日期之间所差天数：时分秒不算，只计算日期部分相差的天数。 timediff函数计算两个日期所差时间，例如日期1和日期2所差10:20:30，表示差10小时20分钟30秒。 if函数如果条件为TRUE则返回“YES”，如果条件为FALSE则返回“NO”： 1SELECT IF(500&lt;1000, \"YES\", \"NO\"); 例如：如果工资高于3000，则输出1，反之则输出0再例如：如果名字是SMITH的，工资上调10%，其他员工工资正常显示。再例如：工作岗位是MANAGER的工资上调10%，是SALESMAN的工资上调20%，其他岗位工资正常。上面这个需求也可以使用：case.. when.. then.. when.. then.. else.. end来完成： cast函数cast函数用于将值从一种数据类型转换为表达式中指定的另一种数据类型语法：cast(值 as 数据类型)例如：cast(‘2020-10-11’ as date)，表示将字符串’2020-10-11’转换成日期date类型。在使用cast函数时，可用的数据类型包括： date：日期类型 time：时间类型 datetime：日期时间类型 signed：有符号的int类型（有符号指的是正数负数） char：定长字符串类型 decimal：浮点型 加密函数md5函数，可以将给定的字符串经过md5算法进行加密处理，字符串经过加密之后会生成一个固定长度32位的字符串，md5加密之后的密文通常是不能解密的： 分组函数分组函数的执行原则：先分组，然后对每一组数据执行分组函数。如果没有分组语句group by的话，整张表的数据自成一组。分组函数包括五个： max：最大值 min：最小值 avg：平均值 sum：求和 count：计数 max找出员工的最高薪资 1select max(sal) from emp; min找出员工的最低工资 1select min(sal) from emp; avg计算员工的平均薪资 1select avg(sal) from emp; sum计算员工的工资和 1select sum(sal) from emp; 计算员工的津贴之和 1select sum(comm) from emp; 重点：所有的分组函数都是自动忽略NULL的。 count统计员工人数 123select count(ename) from emp;select count(*) from emp;select count(1) from emp; count(*)和count(1)的效果一样，统计该组中总记录行数。count(ename)统计的是这个ename字段中不为NULL个数总和。例如：count(comm) 结果是 4，而不是14 1select count(comm) from emp; 统计岗位数量 1select count(distinct job) from emp; 分组函数组合使用select count(*),max(sal),min(sal),avg(sal),sum(sal) from emp; 分组函数注意事项分组函数不能直接使用在where子句当中select ename,job from emp where sal &gt; avg(sal); 这个会报错的原因：分组的行为是在where执行之后才开始的。 分组查询group by按照某个字段分组，或者按照某些字段联合分组。注意：group by的执行是在where之后执行。语法：group by 字段group by 字段1,字段2,字段3….找出每个岗位的平均薪资 1select job, avg(sal) from emp group by job; 找出每个部门最高工资 1select deptno,max(sal) from emp group by deptno; 找出每个部门不同岗位的平均薪资 1select deptno,job,avg(sal) from emp group by deptno,job; 当select语句中有group by的话，select后面只能跟分组函数或参加分组的字段 1select ename,deptno,avg(sal) from emp group by deptno; // 这个SQL执行后会报错。 havinghaving写在group by的后面，当你对分组之后的数据不满意，可以继续通过having对分组之后的数据进行过滤。where的过滤是在分组前进行过滤。使用原则：尽量在where中过滤，实在不行，再使用having。越早过滤效率越高。 找出除20部分之外，其它部门的平均薪资。 12select deptno,avg(sal) from emp where deptno&lt;&gt;20 group by deptno; // 建议select deptno,avg(sal) from emp group by deptno having deptno &lt;&gt; 20; // 不建议 查询每个部门平均薪资，找出平均薪资高于2000的。 1select deptno,avg(sal) from emp group by deptno having avg(sal) &gt; 2000; 组内排序案例：找出每个工作岗位的工资排名在前两名的。substring_index函数的使用：group_concat函数的使用：学习了这两个函数之后，自己可以尝试写出来吗？ 总结单表的DQL语句select …5from …1where …2group by …3having …4order by …6重点掌握一个完整的DQL语句执行顺序。 连接查询什么是连接查询 从一张表中查询数据称为单表查询。 从两张或更多张表中联合查询数据称为多表查询，又叫做连接查询。 什么时候需要使用连接查询？ 比如这样的需求：员工表中有员工姓名，部门表中有部门名字，要求查询每个员工所在的部门名字，这个时候就需要连接查询。连接查询的分类 根据语法出现的年代进行分类： SQL92（这种语法很少用，可以不用学。） SQL99（我们主要学习这种语法。） 根据连接方式的不同进行分类： 内连接 等值连接 非等值连接 自连接 外连接 左外连接（左连接） 右外连接（右连接） 全连接 笛卡尔积现象 当两张表进行连接查询时，如果没有任何条件进行过滤，最终的查询结果条数是两张表条数的乘积。为了避免笛卡尔积现象的发生，需要添加条件进行筛选过滤。 需要注意：添加条件之后，虽然避免了笛卡尔积现象，但是匹配的次数没有减少。 为了SQL语句的可读性，为了执行效率，建议给表起别名。内连接什么叫内连接满足条件的记录才会出现在结果集中。 内连接之等值连接连接时，条件为等量关系。案例：查询每个员工所在的部门名称，要求显示员工名、部门名。 12345678select e.ename,d.dnamefrom emp einner join dept don e.deptno = d.deptno; 注意：inner可以省略。 内连接之非等值连接连接时，条件是非等量关系。案例：查询每个员工的工资等级，要求显示员工名、工资、工资等级。 12345678select e.ename,e.sal,s.gradefrom emp ejoin salgrade son e.sal between s.losal and s.hisal; 内连接之自连接连接时，一张表看做两张表，自己和自己进行连接。案例：找出每个员工的直属领导，要求显示员工名、领导名。 12345678select e.ename 员工名, l.ename 领导名from emp ejoin emp lon e.mgr = l.empno; 思路：将emp表当做员工表 e将emp表当做领导表 l可以发现连接条件是：e.mgr = l.empno（员工的领导编号=领导的员工编号)注意：KING这个员工没有查询出来。如果想将KING也查询出来，需要使用外连接。 外连接什么叫外连接内连接是满足条件的记录查询出来。也就是两张表的交集。外连接是除了满足条件的记录查询出来，再将其中一张表的记录全部查询出来，另一张表如果没有与之匹配的记录，自动模拟出NULL与其匹配。左外连接：右外连接： 外连接之左外连接（左连接）案例：查询所有部门信息，并且找出每个部门下的员工。 12345678select d.*,e.enamefrom dept dleft outer join emp eon d.deptno = e.deptno; 注意：outer可以省略。任何一个左连接都可以写作右连接。 外连接之右外连接（右连接）还是上面的案例，可以写作右连接。 12345678select d.*,e.enamefrom emp eright outer join dept don d.deptno = e.deptno; 案例：找出所有员工的上级领导，要求显示员工名和领导名。 12345678select e.ename 员工名,l.ename 领导名 from emp e left join emp l on e.mgr = l.empno; 12345678select e.ename 员工名,l.ename 领导名 from emp l right join emp e on e.mgr = l.empno; 全连接什么是全连接？MySQL不支持full join。oracle数据库支持。两张表数据全部查询出来，没有匹配的记录，各自为对方模拟出NULL进行匹配。客户表：t_customer订单表：t_order案例：查询所有的客户和订单。 12345678select c.*,o.* from t_customer c full join t_order o on c.cid = o.cid; 多张表连接三张表甚至更多张表如何进行表连接案例：找出每个员工的部门，并且要求显示每个员工的薪资等级。 123456789101112select e.ename,d.dname,s.grade from emp e join dept d on e.deptno = d.deptno join salgrade s on e.sal between s.losal and s.hisal; 子查询什么是子查询 select语句中嵌套select语句就叫做子查询。 select语句可以嵌套在哪里？ where后面、from后面、select后面都是可以的。 123select ..(select)..from ..(select)..where ..(select).. where后面使用子查询案例：找出高于平均薪资的员工姓名和薪资。错误的示范： 1select ename,sal from emp where sal &gt; avg(sal); 错误原因：where后面不能直接使用分组函数。可以使用子查询： 1select ename,sal from emp where sal &gt; (select avg(sal) from emp); from后面使用子查询小窍门：from后面的子查询可以看做一张临时表。案例：找出每个部门的平均工资的等级。第一步：先找出每个部门平均工资。 1select deptno, avg(sal) avgsal from emp group by deptno; 第二步：将以上查询结果当做临时表t，t表和salgrade表进行连接查询。条件：t.avgsal between s.losal and s.hisal 1select t.*,s.grade from (select deptno, avg(sal) avgsal from emp group by deptno) t join salgrade s on t.avgsal between s.losal and s.hisal; select后面使用子查询1select e.ename,(select d.dname from dept d where e.deptno = d.deptno) as dname from emp e; exists、not exists在 MySQL 数据库中，EXISTS（存在）用于检查子查询的查询结果行数是否大于0。如果子查询的查询结果行数大于0，则 EXISTS 条件为真。（即存在查询结果则是true。） 主要应用场景： EXISTS 可以与 SELECT、UPDATE、DELETE 一起使用，用于检查另一个查询是否返回任何行； EXISTS 可以用于验证条件子句中的表达式是否存在； EXISTS 常用于子查询条件过滤，例如查询有订单的用户等。 1234567891011121314151617181920212223242526drop table if exists t_customer;drop table if exists t_order;create table t_customer( customer_id int, customer_name varchar(32));create table t_order( order_id int, order_price decimal(5,1), customer_id int);insert into t_customer(customer_id,customer_name) values(1,'zhangsan');insert into t_customer(customer_id,customer_name) values(2,'lisi');insert into t_customer(customer_id,customer_name) values(3,'wangwu');insert into t_order(order_id, order_price, customer_id) values(10, 1000.0, 1);insert into t_order(order_id, order_price, customer_id) values(20, 2000.0, 1);insert into t_order(order_id, order_price, customer_id) values(30, 3000.0, 2);insert into t_order(order_id, order_price, customer_id) values(40, 4000.0, 2);commit;select * from t_customer;select * from t_order; 现在我们来看一个简单的案例，假设我们要查询先前有过订单的顾客，而订单信息保存在 t_order 表中，顾客信息保存在 t_customer 表中。我们可以使用以下 sql 语句： 1select * from t_customer c where exists(select * from t_order o where o.customer_id=c.customer_id); 在这个查询语句中，子查询用于检查是否有订单与每个客户相关联。如果子查询返回至少一行，则表示该顾客已经下过订单，并返回此客户的所有信息，否则该顾客将不被包含在结果中。 以下是这个查询语句的执行过程： 首先查询表 t_customer 中的所有顾客信息（以下简称为顾客表）； 对于顾客表中的每一行，都执行一次子查询，子查询查询该顾客有没有订单，如果有，则在结果集中保留该顾客信息；如果没有，则将该顾客排除； 最终返回有订单顾客的所有信息。 除了 EXISTS，也可以使用 NOT EXISTS 条件从 SELECT、UPDATE、DELETE 语句中获取子查询的返回结果。NOT EXISTS 用于检查一个子查询是否返回任何行，如果没有行返回，那么 NOT EXISTS 将返回 true。 例如，我们想要查找所有没有下过订单的顾客，可以使用以下 sql 语句： 1select * from t_customer c where not exists(select * from t_order o where o.customer_id=c.customer_id); 在这个查询语句中，如果没有任何与顾客相关联的订单，则 NOT EXISTS 子查询将返回一个空结果集，这时候 WHERE 条件为 true，并将返回所有顾客信息。如果顾客有订单，则 NOT EXISTS 子查询的结果集将不为空，WHERE 条件为 false，则不会返回该顾客的信息。 总之，无论是 EXISTS 还是 NOT EXISTS，都是非常有用的 SQL 工具。可以通过它们来结合子查询来动态过滤查询结果，使 SQL 查询变得更加灵活和高效。 in和exists区别IN 和 EXISTS 都是用于关系型数据库查询的操作符。不同之处在于： IN 操作符是根据指定列表中的值来判断是否满足条件，而 EXISTS 操作符则是根据子查询的结果是否有返回记录集来判断。 EXISTS 操作符通常比 IN 操作符更快，尤其是在子查询返回记录数很大的情况下。因为 EXISTS 只需要判断是否存在符合条件的记录，而 IN 操作符需要比对整个列表，因此执行效率相对较低。 IN 操作符可同时匹配多个值，而 EXISTS 只能匹配一组条件。 下面是一个简单的示例，用于演示 IN 和 EXISTS 之间的区别。假设我们有两个表 orders 和 products，orders 表中记录了订单信息，products 表中记录了商品信息。现在我们想查询所有“手机”和“平板电脑”这两种商品中，至少有一笔订单销售了 $1000 以上的商品： 使用 IN 操作符： 12345678SELECT *FROM productsWHERE product_name IN ('手机', '平板电脑')AND product_id IN ( SELECT product_id FROM orders WHERE order_amount &gt; 1000); 使用 EXISTS 操作符： 123456789SELECT *FROM productsWHERE product_name IN ('手机', '平板电脑')AND EXISTS ( SELECT * FROM orders WHERE orders.product_id = products.product_id AND order_amount &gt; 1000); 总之，IN 和 EXISTS 都是用于条件过滤的操作符，但其实现方式和性能特点都不同，需要根据具体情况进行选择和使用。 union&amp;union all不管是union还是union all都可以将两个查询结果集进行合并。union会对合并之后的查询结果集进行去重操作。union all是直接将查询结果集合并，不进行去重操作。（union all和union都可以完成的话，优先选择union all，union all因为不需要去重，所以效率高一些。）案例：查询工作岗位是MANAGER和SALESMAN的员工。 123select ename,sal from emp where job='MANAGER'union allselect ename,sal from emp where job='SALESMAN'; 以上案例采用or也可以完成，那or和union all有什么区别？考虑走索引优化之类的选择union all，其它选择or。两个结果集合并时，列数量要相同： limit limit作用：查询第几条到第几条的记录。通常是因为表中数据量太大，需要分页显示。 limit语法格式： limit 开始下标, 长度 案例：查询员工表前5条记录 1select ename,sal from emp limit 0, 5; 如果下标是从0开始，可以简写为： 1select ename,sal from emp limit 5; 查询工资排名在前5名的员工（limit是在order by执行之后才会执行的） 1select ename,sal from emp order by sal desc limit 5; 通用的分页sql 假设每页显示3条记录：pageSize = 3第1页：limit 0, 3第2页：limit 3, 3第3页：limit 6, 3第pageNo页：limit (pageNo - 1)*pageSize, pageSize 35个DQL练手题第1题 取得每个部门最高薪水的人员名称 第一步：取得每个部门最高薪水 1select deptno,max(sal) as maxsal from emp group by deptno; 第二步：将上面第一步的查询结果当做一张临时表t，进行表连接，条件是：t.deptno=e.deptno and t.maxsal=e.sal 1select e.ename,t.* from emp e join (select deptno,max(sal) as maxsal from emp group by deptno) t on e.deptno = t.deptno and e.sal = t.maxsal; 第2题 哪些人的薪水在部门的平均薪水之上 第一步：取得每个部门的平均薪水 1select deptno,avg(sal) as avgsal from emp group by deptno; 第二步：将上面的查询结果当做临时表t，让t和emp e表进行表连接，条件是：t.deptno=e.deptno and e.sal&gt;t.avgsal 1select e.ename,e.sal,t.* from emp e join (select deptno,avg(sal) as avgsal from emp group by deptno) t on t.deptno=e.deptno and e.sal&gt;t.avgsal; 第3题 取得每个部门平均薪水的等级 第一步：取得每个部门的平均薪水 1select deptno,avg(sal) as avgsal from emp group by deptno; 第二步：将上面的查询结果当做临时表t，然后t和salgrade s表进行连接，条件是：t.avgsal between s.losal and s.hisal 1select t.*,s.grade from (select deptno,avg(sal) as avgsal from emp group by deptno) t join salgrade s on t.avgsal between s.losal and s.hisal; 第4题 取得部门中（所有人的）平均的薪水等级 第一步：找出每个人的薪水等级 1select e.ename,e.sal,s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal; 第二步：在上面的查询结果当中继续按照部门编号进行分组，求平均值。（不需要将上面的查询结果当做临时表，继续基于它进行分组即可。） 12345678910select e.deptno,avg(s.grade) from emp e join salgrade s on e.sal between s.losal and s.hisal group by e.deptno; 第5题 不准用组函数（Max），取得最高薪水（给出两种解决方案） 第一种方案：按照薪资降序排列，取第一个。 1select sal from emp order by sal desc limit 1; 第二种方案：采用表的自连接方式。 1select ename,sal from emp where sal not in(select distinct a.sal from emp a join emp b on a.sal &lt; b.sal); 第6题 取得平均薪水最高的部门的部门编号（至少给出两种解决方案） 第一种方案：降序排列取第一个 1select deptno,avg(sal) as avgsal from emp group by deptno order by avgsal desc limit 1; 第二种方案：max函数 1select deptno,avg(sal) as avgsal from emp group by deptno having avg(sal)=(select max(t.avgsal) from (select avg(sal) as avgsal from emp group by deptno) t); 第7题 取得平均薪水最高的部门的部门名称 比上面的题目多一个表连接，和dept表连接，按照部门名称进行分组。 1select d.dname,avg(e.sal) as avgsal from emp e join dept d on e.deptno=d.deptno group by d.dname order by avgsal desc limit 1; 第8题 求平均薪水的等级最低的部门的部门名称 第一步：求每个部门的平均薪水 1select d.dname,avg(e.sal) as avgsal from emp e join dept d on e.deptno = d.deptno group by d.dname; 第二步：求每个部门的平均薪水等级（将以上的执行结果当做临时表t，t和salgrade s表进行连接，条件：t.avgsal between .s.losal and s.hisal） 1select t.*,s.grade from (select d.dname,avg(e.sal) as avgsal from emp e join dept d on e.deptno = d.deptno group by d.dname) t join salgrade s on t.avgsal between s.losal and s.hisal; 第三步：找到最低的部门名称（以上结果继续按照grade进行升序，然后limit 1） 1select t.*,s.grade from (select d.dname,avg(e.sal) as avgsal from emp e join dept d on e.deptno = d.deptno group by d.dname) t join salgrade s on t.avgsal between s.losal and s.hisal order by s.grade asc limit 1; 第9题 取得比普通员工(员工代码没有在mgr字段上出现的)的最高薪水还要高的领导人姓名 第一步：找出所有的普通员工的最高薪水 1select max(sal) from emp where empno not in(select mgr from emp where mgr is not null); 第二步：大于以上最高薪水的一定是要找的领导人。 1select ename,sal from emp where sal &gt; (select max(sal) from emp where empno not in(select mgr from emp where mgr is not null)); 第10题 取得薪水最高的前五名员工 1select ename,sal from emp order by sal desc limit 5; 第11题 取得薪水最高的第六到第十名员工 1select ename,sal from emp order by sal desc limit 5, 5; 第12题 取得最后入职的5名员工 1select ename,sal,hiredate from emp order by hiredate desc limit 5; 第13题 取得每个薪水等级有多少员工 第一步：找出每个员工的薪水等级 1select e.ename,s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal; 第二步：基于以上的记录继续根据等级分组，count即可。 1select s.grade,count(*) from emp e join salgrade s on e.sal between s.losal and s.hisal group by s.grade; 第14题 列出所有员工及领导的姓名 1select e.ename 员工名, l.ename 领导名 from emp e left join emp l on e.mgr = l.empno; 第15题 列出受雇日期早于其直接上级的所有员工的编号,姓名,部门名称 1select e.ename 员工名,e.hiredate, l.ename 领导名,l.hiredate,d.dname from emp e join emp l on e.mgr = l.empno join dept d on e.deptno = d.deptno where e.hiredate &lt; l.hiredate; 第16题 列出部门名称和这些部门的员工信息,同时列出那些没有员工的部门 1select d.dname,e.ename,e.sal from dept d left join emp e on d.deptno = e.deptno; 第17题 列出至少有5个员工的所有部门 1select deptno, count(*) from emp group by deptno having count(*) &gt;= 5; 第18题 列出薪金比”SMITH”多的所有员工信息 1select ename,sal from emp where sal &gt; (select sal from emp where ename = 'SMITH'); 第19题 列出所有”CLERK”(办事员)的姓名及其部门名称,部门的人数 1select t1.ename,t1.dname,t2.total from (select e.ename,d.dname,d.deptno from emp e join dept d on e.deptno = d.deptno where e.job = 'CLERK') t1 join (select count(*) as total,deptno from emp group by deptno) t2 on t1.deptno = t2.deptno; 第20题 列出最低薪金大于1500的各种工作及从事此工作的全部雇员人数 1select job,min(sal),count(*) from emp group by job having min(sal)&gt;1500; 第21题 列出在部门”SALES”&lt;销售部&gt;工作的员工的姓名,假定不知道销售部的部门编号 1select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno where d.dname='sales'; 第22题 列出薪金高于公司平均薪金的所有员工,所在部门,上级领导,雇员的工资等级 12345select e.ename 员工,l.ename 领导,d.dname,s.grade from emp e left join emp l on e.mgr = l.empno join dept d on e.deptno = d.deptno join salgrade s on e.sal between s.losal and s.hisal where e.sal &gt; (select avg(sal) from emp); 第23题 列出与”SCOTT”从事相同工作的所有员工及部门名称 1select e.ename,d.dname,e.job from emp e join dept d on e.deptno=d.deptno where job=(select job from emp where ename ='scott'); 第24题 列出薪金等于部门30中员工的薪金的其他员工的姓名和薪金 1select ename,sal,deptno from emp where sal in(select distinct sal from emp where deptno=30) and deptno &lt;&gt; 30; 第25题 列出薪金高于在部门30工作的所有员工的薪金的员工姓名和薪金.部门名称 1select e.ename,e.sal,d.dname from emp e join dept d on e.deptno = d.deptno where sal &gt; (select max(sal) from emp where deptno=30); 第26题 列出在每个部门工作的员工数量,平均工资和平均服务期限 1select avg(sal),count(*),deptno,avg(datediff(now(),hiredate)) as avgtime from emp group by deptno; 第27题 列出所有员工的姓名、部门名称和工资 1select e.ename,e.sal,d.dname from emp e join dept d on e.deptno = d.deptno; 第28题 列出所有部门的详细信息和人数 1select d.deptno,d.dname,d.loc,count(e.deptno) from emp e right join dept d on e.deptno=d.deptno group by d.deptno,d.dname,d.loc; 第29题 列出各种工作的最低工资及从事此工作的雇员姓名 1select t.job,t.minsal,e.ename from emp e join (select job,min(sal) as minsal from emp group by job) t on e.job=t.job and e.sal=t.minsal; 第30题 列出各个部门的MANAGER(领导)的最低薪金 1select deptno,min(sal) from emp where job='MANAGER' group by deptno 第31题 列出所有员工的年工资,按年薪从低到高排序 1select ename,(sal+ifnull(comm,0))*12 as yearsal from emp order by yearsal asc; 第32题 求出员工领导的薪水超过3000的员工名称与领导名称 1select e.ename 员工名, l.ename 领导名 from emp e join emp l on e.mgr = l.empno where l.sal&gt;3000; 第33题 求出部门名称中,带’S’字符的部门员工的工资合计、部门人数 1select d.dname,ifnull(sum(sal),0) as sumsal,count(e.ename) from emp e right join dept d on e.deptno=d.deptno where d.dname like '%S%' group by d.dname; 第34题 给任职日期超过30年的员工加薪10% 1update emp set sal=sal*1.1 where datediff(now(),hiredate)/365 &gt; 30; 第35题 某公司面试题 有3个表S（学生表），C（课程表），SC（学生选课表）S（SNO，SNAME）代表（学号，姓名）C（CNO，CNAME，CTEACHER）代表（课号，课名，教师）SC（SNO，CNO，SCGRADE）代表（学号，课号，成绩） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546CREATE TABLE SC( SNO VARCHAR(200), CNO VARCHAR(200), SCGRADE VARCHAR(200));CREATE TABLE S( SNO VARCHAR(200 ), SNAME VARCHAR(200));CREATE TABLE C( CNO VARCHAR(200), CNAME VARCHAR(200), CTEACHER VARCHAR(200));INSERT INTO C ( CNO, CNAME, CTEACHER ) VALUES ( '1', '语文', '张'); INSERT INTO C ( CNO, CNAME, CTEACHER ) VALUES ( '2', '政治', '王'); INSERT INTO C ( CNO, CNAME, CTEACHER ) VALUES ( '3', '英语', '李'); INSERT INTO C ( CNO, CNAME, CTEACHER ) VALUES ( '4', '数学', '赵'); INSERT INTO C ( CNO, CNAME, CTEACHER ) VALUES ( '5', '物理', '黎明'); commit; INSERT INTO S ( SNO, SNAME ) VALUES ( '1', '学生1'); INSERT INTO S ( SNO, SNAME ) VALUES ( '2', '学生2'); INSERT INTO S ( SNO, SNAME ) VALUES ( '3', '学生3'); INSERT INTO S ( SNO, SNAME ) VALUES ( '4', '学生4'); commit; INSERT INTO SC ( SNO, CNO, SCGRADE ) VALUES ( '1', '1', '40'); INSERT INTO SC ( SNO, CNO, SCGRADE ) VALUES ( '1', '2', '30'); INSERT INTO SC ( SNO, CNO, SCGRADE ) VALUES ( '1', '3', '20'); INSERT INTO SC ( SNO, CNO, SCGRADE ) VALUES ( '1', '4', '80'); INSERT INTO SC ( SNO, CNO, SCGRADE ) VALUES ( '1', '5', '60'); INSERT INTO SC ( SNO, CNO, SCGRADE ) VALUES ( '2', '1', '60'); INSERT INTO SC ( SNO, CNO, SCGRADE ) VALUES ( '2', '2', '60'); INSERT INTO SC ( SNO, CNO, SCGRADE ) VALUES ( '2', '3', '60'); INSERT INTO SC ( SNO, CNO, SCGRADE ) VALUES ( '2', '4', '60'); INSERT INTO SC ( SNO, CNO, SCGRADE ) VALUES ( '2', '5', '40'); INSERT INTO SC ( SNO, CNO, SCGRADE ) VALUES ( '3', '1', '60'); INSERT INTO SC ( SNO, CNO, SCGRADE ) VALUES ( '3', '3', '80'); commit; 问题：1，找出没选过“黎明”老师的所有学生姓名。 1select sname from s where sno not in(select sno from sc where cno=(select cno from c where cteacher='黎明')); 2，列出2门以上（含2门）不及格学生姓名及平均成绩。 1select a.*,b.avgscore from (select s.sno,s.sname,count(sc.scgrade) as num from sc join s on sc.sno=s.sno where sc.scgrade &lt; 60 group by s.sname,s.sno having count(sc.scgrade) &gt;= 2) a join (select sno,avg(scgrade) avgscore from sc group by sno) b on a.sno = b.sno; 3，既学过1号课程又学过2号课所有学生的姓名。 1select sc.sno,s.sname from sc join s on sc.sno=s.sno where sc.cno=1 and sc.sno in(select sno from sc where cno=2);","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://xiaofanshutu.github.io/categories/MySQL/"}],"tags":[]},{"title":"Java异常","slug":"动力节点Java/Chapter5_异常","date":"2025-06-25T22:56:00.318Z","updated":"2025-06-29T23:23:29.551Z","comments":true,"path":"posts/f495a96f.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/f495a96f.html","excerpt":"异常继承结构 所有的异常和错误都是可抛出的。都继承了Throwable类。 Error是无法处理的，出现后只有一个结果：JVM终止。 Exception是可以处理的。 Exception的分类： 所有的RuntimeException的子类：运行时异常/未检查异常(UncheckedException)/非受控异常 Exception的子类（除RuntimeException之外）：编译时异常/检查异常(CheckedException)/受控异常 编译时异常和运行时异常区别： 编译时异常特点：在编译阶段必须提前处理，如果不处理编译器报错。 运行时异常特点：在编译阶段可以选择处理，也可以不处理，没有硬性要求。 编译时异常一般是由外部环境或外在条件引起的，如网络故障、磁盘空间不足、文件找不到等 运行时异常一般是由程序员的错误引起的，并且不需要强制进行异常处理 注意：编译时异常并不是在编译阶段发生的异常，所有的异常发生都是在运行阶段的，因为每个异常发生都是会new异常对象的，new异常对象只能在运行阶段完成。那为什么叫做编译时异常呢？这是因为这种异常必须在编译阶段提前预处理，如果不处理编译器报错，因此而得名编译时异常。 异常的处理异常的处理包括两种方式： 声明异常：类似于推卸责任的处理方式 在方法定义时使用throws关键字声明异常，告知调用者，调用这个方法可能会出现异常。这种处理方式的态度是：如果出现了异常则会抛给调用者来处理。 捕捉异常：真正的处理捕捉异常 在可能出现异常的代码上使用try..catch进行捕捉处理。这种处理方式的态度是：把异常抓住。其它方法如果调用这个方法，对于调用者来说是不知道这个异常发生的。因为这个异常被抓住并处理掉了。 异常在处理的整个过程中应该是：声明和捕捉联合使用。 什么时候捕捉？什么时候声明？如果异常发生后需要调用者来处理的，需要调用者知道的，则采用声明方式。否则采用捕捉。 声明异常(throws 关键字) 如果一个异常发生后希望调用者来处理的，使用声明异常（俗话说：交给上级处理） public void m() throws AException, BException... {} 如果AException和BException都继承了XException，那么也可以这样写： public void m() throws XException{} 调用者在调用m()方法时，编译器会检测到该方法上用throws声明了异常，表示可能会抛出异常，编译器会继续检测该异常是否为编译时异常，如果为编译时异常则必须在编译阶段进行处理，如果不处理编译器就会报错。 如果所有位置都采用throws，包括main方法的处理态度也是throws，如果运行时出现了异常，最终异常是抛给了main方法的调用者（JVM），JVM则会终止程序的执行。因此为了保证程序在出现异常后不被中断，至少main方法不要再使用throws进行声明了。 发生异常后，在发生异常的位置上，往下的代码是不会执行的，除非进行了异常的捕捉。 捕捉异常 (try…catch…关键字)","text":"异常继承结构 所有的异常和错误都是可抛出的。都继承了Throwable类。 Error是无法处理的，出现后只有一个结果：JVM终止。 Exception是可以处理的。 Exception的分类： 所有的RuntimeException的子类：运行时异常/未检查异常(UncheckedException)/非受控异常 Exception的子类（除RuntimeException之外）：编译时异常/检查异常(CheckedException)/受控异常 编译时异常和运行时异常区别： 编译时异常特点：在编译阶段必须提前处理，如果不处理编译器报错。 运行时异常特点：在编译阶段可以选择处理，也可以不处理，没有硬性要求。 编译时异常一般是由外部环境或外在条件引起的，如网络故障、磁盘空间不足、文件找不到等 运行时异常一般是由程序员的错误引起的，并且不需要强制进行异常处理 注意：编译时异常并不是在编译阶段发生的异常，所有的异常发生都是在运行阶段的，因为每个异常发生都是会new异常对象的，new异常对象只能在运行阶段完成。那为什么叫做编译时异常呢？这是因为这种异常必须在编译阶段提前预处理，如果不处理编译器报错，因此而得名编译时异常。 异常的处理异常的处理包括两种方式： 声明异常：类似于推卸责任的处理方式 在方法定义时使用throws关键字声明异常，告知调用者，调用这个方法可能会出现异常。这种处理方式的态度是：如果出现了异常则会抛给调用者来处理。 捕捉异常：真正的处理捕捉异常 在可能出现异常的代码上使用try..catch进行捕捉处理。这种处理方式的态度是：把异常抓住。其它方法如果调用这个方法，对于调用者来说是不知道这个异常发生的。因为这个异常被抓住并处理掉了。 异常在处理的整个过程中应该是：声明和捕捉联合使用。 什么时候捕捉？什么时候声明？如果异常发生后需要调用者来处理的，需要调用者知道的，则采用声明方式。否则采用捕捉。 声明异常(throws 关键字) 如果一个异常发生后希望调用者来处理的，使用声明异常（俗话说：交给上级处理） public void m() throws AException, BException... {} 如果AException和BException都继承了XException，那么也可以这样写： public void m() throws XException{} 调用者在调用m()方法时，编译器会检测到该方法上用throws声明了异常，表示可能会抛出异常，编译器会继续检测该异常是否为编译时异常，如果为编译时异常则必须在编译阶段进行处理，如果不处理编译器就会报错。 如果所有位置都采用throws，包括main方法的处理态度也是throws，如果运行时出现了异常，最终异常是抛给了main方法的调用者（JVM），JVM则会终止程序的执行。因此为了保证程序在出现异常后不被中断，至少main方法不要再使用throws进行声明了。 发生异常后，在发生异常的位置上，往下的代码是不会执行的，除非进行了异常的捕捉。 捕捉异常 (try…catch…关键字) 如果一个异常发生后，不需要调用者知道，也不需要调用者来处理，选择使用捕捉方式处理。 try{ // 尝试执行可能会出现异常的代码 // try块中的代码如果执行出现异常，出现异常的位置往下的代码是不会执行的，直接进入catch块执行 }catch(AException e){ // 如果捕捉到AException类型的异常，在这里处理 }catch(BException e){ // 如果捕捉到BException类型的异常，在这里处理 }catch(XException e){ // 如果捕捉到XException类型的异常，在这里处理} // 当try..catch..将所有发生的异常捕捉后，这里的代码是会继续往下执行的。 catch可以写多个。并且遵循自上而下，从小到大。 Java7新特性：catch后面小括号中可以编写多个异常，使用运算符“|”隔开。 异常的常用方法 获取异常的简单描述信息： exception.getMessage(); 获取的message是通过构造方法创建异常对象时传递过去的message。 打印异常堆栈信息： exception.printStackTrace(); 要会看异常的堆栈信息： 异常信息的打印是符合栈数据结构的。 看异常信息主要看最开始的描述信息。看栈顶信息。 finally语句块概念 finally语句块中的代码是一定会执行的。 finally语句块不能单独使用，至少需要配合try语句块一起使用： try…finally try…catch…finally 资源释放的工作比较重要，如果资源没有释放会一直占用内存。 为了保证资源的关闭，也就是说：不管程序是否出现异常，关闭资源的代码一定要保证执行。 因此在finally语句块中通常进行资源的释放。 final、finally、finalize分别是什么？ final是一个关键字，修饰的类无法继承，修饰的方法无法覆盖，修饰的变量不能修改。 finally是一个关键字，和try一起使用，finally语句块中的代码一定会执行。 finalize是一个标识符，它是Object类中的一个方法名。 练习以下程序的执行结果？ 以下程序的执行结果？ 方法覆盖与异常方法重写之后，不能比父类方法抛出更多的异常，可以更少。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaofanshutu.github.io/categories/Java/"}],"tags":[]},{"title":"Java数组","slug":"动力节点Java/Chapter4_数组","date":"2025-06-19T13:25:52.900Z","updated":"2025-06-25T22:53:49.990Z","comments":true,"path":"posts/e3345db4.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/e3345db4.html","excerpt":"数组概述 什么是数组？ 在Java中，数组是一种用于存储多个相同数据类型元素的容器。 例如一个存储整数的数组：int[] nums = {100, 200, 300}; 例如一个存储字符串的数组：String[] names = {“jack”,“lucy”,“lisi”}; 数组是一种引用数据类型，隐式继承Object。因此数组也可以调用Object类中的方法。 数组对象存储在堆内存中。 数组的分类？ 根据维数进行分类：一维数组，二维数组，三维数组，多维数组。 根据数组中存储的元素类型分类：基本类型数组，引用类型数组。 根据数组初始化方式不同分类：静态数组，动态数组。 Java数组存储元素的特点？ 数组长度一旦确定不可变。 数组中元素数据类型一致，每个元素占用空间大小相同。 数组中每个元素在空间存储上，内存地址是连续的。 每个元素有索引，首元素索引0，以1递增。 以首元素的内存地址作为数组对象在堆内存中的地址。 所有数组对象都有length属性用来获取数组元素个数。末尾元素下标：length-1 数组优点？ 根据下标查询某个元素的效率极高。数组中有100个元素和有100万个元素，查询效率相同。时间复杂度O(1)。也就是说在数组中根据下标查询某个元素时，不管数组的长短，耗费时间是固定不变的。 原因：知道首元素内存地址，元素在空间存储上内存地址又是连续的，每个元素占用空间大小相同，只要知道下标，就可以通过数学表达式计算出来要查找元素的内存地址。直接通过内存地址定位元素。 数组缺点？ 随机增删元素的效率较低。因为随机增删元素时，为了保证数组中元素的内存地址连续，就需要涉及到后续元素的位移问题。时间复杂度O(n)。O(n)表示的是线性阶，随着问题规模n的不断增大，时间复杂度不断增大，算法的执行效率越低。（不过需要注意的是：对数组末尾元素的增删效率是不受影响的。） 无法存储大量数据，因为很难在内存上找到非常大的一块连续的内存。 一维数组 一维数组是线性结构。二维数组，三维数组，多维数组是非线性结构。 如何静态初始化一维数组？ 第一种：int[] arr = {55,67,22}; 或者 int arr[] = {55,67,22}; 第二种：int[] arr = new int[]{55,67,22}; 如何访问数组中的元素？ ​ 通过下标来访问。注意ArrayIndexOutOfBoundsException异常的发生。 如何遍历数组？ ​ 普通for循环遍历 ​ for-each遍历（优点是代码简洁。缺点是没有下标。） 如何动态初始化一维数组？ ​ int[] arr = new int[4]; ​ Object[] objs = new Object[5]; ​ 数组动态初始化的时候，确定长度，并且数组中每个元素采用默认值。 一维数组中存储引用时的内存图 关于main方法的形参args？ 接收命令行参数 在DOS命令窗口中怎么传？在IDEA中怎么传？ 关于方法的可变长度参数？ 可变长参数只能出现在形参列表中的最后一个位置。 可变长参数可以当做数组来处理。","text":"数组概述 什么是数组？ 在Java中，数组是一种用于存储多个相同数据类型元素的容器。 例如一个存储整数的数组：int[] nums = {100, 200, 300}; 例如一个存储字符串的数组：String[] names = {“jack”,“lucy”,“lisi”}; 数组是一种引用数据类型，隐式继承Object。因此数组也可以调用Object类中的方法。 数组对象存储在堆内存中。 数组的分类？ 根据维数进行分类：一维数组，二维数组，三维数组，多维数组。 根据数组中存储的元素类型分类：基本类型数组，引用类型数组。 根据数组初始化方式不同分类：静态数组，动态数组。 Java数组存储元素的特点？ 数组长度一旦确定不可变。 数组中元素数据类型一致，每个元素占用空间大小相同。 数组中每个元素在空间存储上，内存地址是连续的。 每个元素有索引，首元素索引0，以1递增。 以首元素的内存地址作为数组对象在堆内存中的地址。 所有数组对象都有length属性用来获取数组元素个数。末尾元素下标：length-1 数组优点？ 根据下标查询某个元素的效率极高。数组中有100个元素和有100万个元素，查询效率相同。时间复杂度O(1)。也就是说在数组中根据下标查询某个元素时，不管数组的长短，耗费时间是固定不变的。 原因：知道首元素内存地址，元素在空间存储上内存地址又是连续的，每个元素占用空间大小相同，只要知道下标，就可以通过数学表达式计算出来要查找元素的内存地址。直接通过内存地址定位元素。 数组缺点？ 随机增删元素的效率较低。因为随机增删元素时，为了保证数组中元素的内存地址连续，就需要涉及到后续元素的位移问题。时间复杂度O(n)。O(n)表示的是线性阶，随着问题规模n的不断增大，时间复杂度不断增大，算法的执行效率越低。（不过需要注意的是：对数组末尾元素的增删效率是不受影响的。） 无法存储大量数据，因为很难在内存上找到非常大的一块连续的内存。 一维数组 一维数组是线性结构。二维数组，三维数组，多维数组是非线性结构。 如何静态初始化一维数组？ 第一种：int[] arr = {55,67,22}; 或者 int arr[] = {55,67,22}; 第二种：int[] arr = new int[]{55,67,22}; 如何访问数组中的元素？ ​ 通过下标来访问。注意ArrayIndexOutOfBoundsException异常的发生。 如何遍历数组？ ​ 普通for循环遍历 ​ for-each遍历（优点是代码简洁。缺点是没有下标。） 如何动态初始化一维数组？ ​ int[] arr = new int[4]; ​ Object[] objs = new Object[5]; ​ 数组动态初始化的时候，确定长度，并且数组中每个元素采用默认值。 一维数组中存储引用时的内存图 关于main方法的形参args？ 接收命令行参数 在DOS命令窗口中怎么传？在IDEA中怎么传？ 关于方法的可变长度参数？ 可变长参数只能出现在形参列表中的最后一个位置。 可变长参数可以当做数组来处理。 一维数组的扩容 数组长度一旦确定不可变。 那数组应该如何扩容？ 只能创建一个更大的数组将原数组中的数据全部拷贝到新数组中 可以使用System.arraycopy()方法完成数组的拷贝。 数组扩容会影响程序的执行效率，因此尽可能预测数据量，创建一个接近数量的数组，减少扩容次数 二维数组 二维数组是一个特殊的一维数组，特殊在：这个一维数组中每个元素是一个一维数组。 二维数组的静态初始化 int[][] arr = new int[][]{{},{},{}}; int[][] arr = {{},{},{}}; 二维数组的动态初始化(等长) int[][] arr = new int[3][4]; 二维数组的动态初始化（不等长） int[][] arr = new int[3][]; 二维数组中元素的访问 第一个元素：arr[0][0] 最后一个元素：arr[arr.length-1][arr[arr.length-1].length-1] 二维数组中元素的遍历 IDEA中的Debug调试 在可能出现问题的代码附近添加断点。一般是将断点添加在方法体的某一行代码上。 断点可以添加多个。点一次添加一个断点。再点一次断点则消失。 添加断点后，如果想让程序运行到断点处停下来，需要使用Debug模式运行程序。 Debug窗口中的按钮 给断点添加条件 Debug窗口中的隐藏按钮 数据结构与算法数据结构概述 数据结构概述数据结构是指用来存储和组织数据的一种方式，就像在生活中我们用文件柜、书架、衣柜等来整理我们的物品一样，数据结构也可以帮助我们整理和管理程序中的数据。 数据结构分为：数据的逻辑结构、数据的物理结构 逻辑结构是指数据元素之间的逻辑关系，它是从抽象的角度描述数据元素之间的关系，不涉及具体的存储方式或实现细节。逻辑结构主要关注问题的本质、特点和抽象模型，是数据结构的逻辑表示。 物理结构是指数据结构在计算机内存中实际存储和组织的方式。它是从具体的角度描述数据结构的实现方式和存储结构，包括数据元素在内存中的存储分布和访问方式等。物理结构主要关注问题的具体实现和操作。 因此，逻辑结构与物理结构的区别在于：逻辑结构是从抽象的角度描述数据元素之间的关系，物理结构是从具体的角度描述内存中数据元素的存储方式和组织形式。逻辑结构主要关注问题的本质和特点，物理结构主要关注问题的具体实现和操作。 逻辑结构的划分？ 集合结构：数据结构中的元素之间除了在“同属一个集合”的关系外，别无其它关系； 线性结构：数据结构中的元素存在“一对一”的线性关系，例如冰糖葫芦； 树形结构：数据结构中的元素存在“一对多”的层次关系，例如公司组织架构； 图形结构或网状结构：数据结构中的元素存在“多对多”的任意关系，例如地图。 物理结构的划分？ 顺序存储结构：用一组连续的存储空间单元来依次的存储数据元素，例如数组。 链式存储结构：用一组任意的存储单元来存储元素，通过保存地址找到相关联的元素，元素之间的逻辑关系用引用来表示，例如链表。 散列存储结构：根据节点key计算出该节点的存储地址。例如：java集合中的HashMap采用了散列存储结构，添加、查询速度都很快。 算法概述 什么是算法？ 算法就是解决问题的方法和步骤，可以让计算机完成特定任务，并提高计算机系统的效率和性能。就像烹饪食品需要遵循一定的步骤和配方一样，例如，做牛排需要选择牛排肉、煎炸的方式、烹饪的时间等，按照一定的步骤最终会有一个好的成品。一个良好的算法可以提高程序的执行效率。 怎么评价一个算法好不好？ 如何计算1+2+3+…+100的结果？ 算法1：通过循环，依次累加来实现。耗费时间 算法2：使用递归来实现。耗费内存 算法3：高斯算法。(1 + 100)*50。既节省时间，又节省空间。 同一问题可用不同的算法来解决，而一个算法的质量优劣将影响到算法乃至程序的效率。因此，我们学习算法目的在于选择合适算法和改进算法，一个算法的评价主要从时间复杂度和空间复杂度来考虑。 时间复杂度：评估执行程序所需的时间，可以估算出程序对处理器的使用程度。 空间复杂度：评估执行程序所需的存储空间，可以估算出程序对计算机内存的使用程度。 数组的排序算法冒泡排序核心思想 相邻两个元素做比较大小，如果前一个元素大于后一个元素，则交换位置 12345678910111213private static void bubbleSort(int[] arr) { for (int i = 0; i &lt; arr.length - 1; i++) { for (int j = 0; j &lt; arr.length - 1 - i; j++) { System.out.println(\"============================\"); // 两个两个进行比较 if(arr[j] &gt; arr[j+1]) { int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } }} 结果： 1234567891011========================================================================================================================================================================================================================================================================================[1, 2, 3, 4, 5] 12345678910111213141516171819202122/** * 冒泡排序算法的优化。*/private static void bubbleSort(int[] arr) { for (int i = arr.length - 1; i &gt;= 0; i--) { // 默认是排好序的。 boolean flag = true; for (int j = 0; j &lt; i; j++) { System.out.println(\"=======================\"); // 两个两个进行比较 if(arr[j] &gt; arr[j+1]) { int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; flag = false; } } if(flag){ break; } }} 结果： 12345============================================================================================[1, 2, 3, 4, 5] 选择排序核心思想 在未排序的序列中，把未排序第一个元素和未排序的最小元素交换位置。 123456789101112131415161718/** * 选择排序： * 核心原理：找出参与比较的这些数据中最小的，然后拿着这个最小的数据和参与比较的这堆数据中最左边的元素交换位置。 * 优点：交换的次数比冒泡排序的少。执行效率比冒泡排序高。（冒泡排序中的元素每一次比完之后就交换，这个交换有时是没必要的。） * * 原理： * (1)参与比较的数据：3, 2, 7, 6, 1 * 第一次循环之后的结果：1, 2, 7, 6, 3 * * (2)参与比较的数据：x, 2, 7, 6, 3 * 第二次循环之后的结果：1, 2, 7, 6, 3 * * (3)参与比较的数据：x, x, 7, 6, 3 * 第三次循环之后的结果：1, 2, 3, 6, 7 * * (4)参与比较的数据：x, x, x, 6, 7 * 第四次循环之后的结果：1, 2, 3, 6, 7 */ 1234567891011121314151617181920212223public static void main(String[] args) { int[] arr = {3, 2, 7, 6, 1, 100, 200, 80, 870}; selectSort(arr); System.out.println(Arrays.toString(arr));}private static void selectSort(int[] arr) { for (int i = 0; i &lt; arr.length - 1; i++) { // 假定参与比较的这些数据中最左边的是最小的。 int min = i; for(int j = i+1; j &lt; arr.length; j++){ if (arr[j] &lt; arr[min]) { min = j; } } if(min != i){ // 说明有更小的值 // 交换位置（拿着当下的最小值和参与比较的这些数据中最前面的值交换位置） int temp = arr[min]; arr[min] = arr[i]; arr[i] = temp; } }} 1[1, 2, 3, 6, 7, 80, 100, 200, 870] 数组的查找算法线性查找①线性查找是一种最简单粗暴的查找法了，采用逐一比对的方式进行对数组的遍历，如果发现了匹配值，返回数组下标即可。 ②线性查找，优点是查找数组无需有序；其缺点是查找的次数多，效率低下。 12345678910111213141516public static void main(String[] args) { int[] arr = {102,3,4,54,5,6,67,7,78,8,8,87,67,6}; // 找出以上数组中67元素的下标（67元素第一次出现处的下标） int num = 67; int index = search(arr, num); System.out.println(index &gt;= 0 ? num + \" first occur at: \" + index : \"don't have this data\");}private static int search(int[] arr, int num) { for (int i = 0; i &lt; arr.length; i++) { if(num == arr[i]){ return i; } } return -1;} 167 first occur at: 6 二分法查找①二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好；缺点是要求待查数组必须排序，且执行插入和删除操作困难。因此，折半查找方法适用于不经常变动而查找频繁的数组。 ②查找思路： 假设查找的数组为升序排序，则首先定义两个变量，分别用于保存查找元素（value）所在范围的最小索引值（min）和最大索引值（max）。 然后开启二分查找，每次查找前都定义一个mid变量，并设置该变量的初始值为：(max + min)/2。在查找的过程中，发生以下三种情况，则做对应的处理。 如果arr[mid]大于value，则证明查找的元素在mid的左侧，那么更新max的值为：mid-1 如果arr[mid]小于value，则证明查找的元素在mid的右侧，那么更新min的值为：mid+1 如果arr[mid]等于value，则证明查找元素的索引值就是mid，返回mid的值即可！ 在以上的操作中，我们不停的更改min和max的值，如果发生min大于max的情况，则证明查找的元素不存在，那么返回-1（表示找不到）即可！ 12345678910111213141516171819202122public static void main(String[] args) { int[] arr = {1,20,50,77,80,99,101,256,666,888}; int num = 101; int index = binarySearch(arr, num); System.out.println(index &gt;= 0 ? num + \"'s index is: \" + index : \"can't find this data\");}private static int binarySearch(int[] arr, int num) { int begin = 0; int end = arr.length - 1; while(begin &lt;= end){ int mid = (begin + end) / 2; if(arr[mid] == num) { return mid; }else if(num &gt; arr[mid]){ begin = mid + 1; }else{ end = mid - 1; } } return -1;} 1101's index is: 6 Arrays工具类①Arrays.toString()方法：将数组转换成字符串 ②Arrays.deepToString()方法：可以将二维数组转换成字符串 ③Arrays.equals(int[] arr1, int[] arr2)方法：判断两个数组是否相等 ④Arrays.equals(Object[] arr1, Object[] arr2)方法 ⑤Arrays.deepEquals(Object[] arr1, Object[] arr2)方法：判断两个二维数组是否相等 ⑥Arrays.sort(int[] arr)方法：基于快速排序算法，适合小型数据量排序。 ⑦Arrays.sort(String[] arr)方法 ⑧Arrays.parallelSort(int[] arr)方法：基于分治的归并排序算法，支持多核CPU排序，适合大数据量排序。 ⑨int binarySearch(int[] arr, int elt)方法：二分法查找 ⑩Arrays.fill(int[] arr, int data)方法：填充数组 ⑪Arrays.fill(int[] a, int fromIndex, int toIndex, int val)方法 ⑫int[] Arrays.copyOf(int[] original, int newLength)方法：数组拷贝 ⑬int[] Arrays.copyOfRange(int[] original, int from, int to) ⑭Arrays.asList(T… data)方法：将一组数据转换成List集合。 12345678910@Testpublic void testToString() { int[] arr = {1, 2, 3, 34, 54}; System.out.println(arr); // [I@3d3fcdb0 System.out.println(Arrays.toString(arr)); // [1, 2, 3, 34, 54] String[] names = {\"zhangsan\", \"lisi\", \"wangwu\"}; System.out.println(names); // [Ljava.lang.String;@641147d0 System.out.println(Arrays.toString(names)); //[zhangsan, lisi, wangwu]} 1234567891011121314/** * Arrays.deepToString()作用是：适合于将多维数组转换成字符串。 */@Testpublic void testDeepToString() { // 适合于二维数组以及多维数组的。 int[][] arr = { {12, 2, 3, 3}, {4, 45, 5, 5}, {1, 1, 1, 1, 1, 1} }; System.out.println(Arrays.toString(arr)); // [[I@641147d0, [I@6e38921c, [I@64d7f7e0] System.out.println(Arrays.deepToString(arr)); // [[12, 2, 3, 3], [4, 45, 5, 5], [1, 1, 1, 1, 1, 1]]} 12345678910@Testpublic void testEquals() { int[] arr1 = {1, 2, 3}; int[] arr2 = {2, 1, 3}; System.out.println(Arrays.equals(arr1, arr2)); String[] names1 = new String[]{\"abc\", \"def\", \"xyz\"}; String[] names2 = new String[]{\"abc\", \"def\", \"xyz\"}; System.out.println(Arrays.equals(names1, names2));} Equals方法 12345678910@Testpublic void testEquals() { int[] arr1 = {1, 2, 3}; int[] arr2 = {2, 1, 3}; System.out.println(Arrays.equals(arr1, arr2)); //false String[] names1 = new String[]{\"abc\", \"def\", \"xyz\"}; String[] names2 = new String[]{\"abc\", \"def\", \"xyz\"}; System.out.println(Arrays.equals(names1, names2)); //true} Sort方法 123456789101112131415161718192021222324252627@Testpublic void testSort() { int[] arr = {1, 3, 45, 5, 6, 7, 87, 8}; Arrays.sort(arr); System.out.println(Arrays.toString(arr));//[1, 3, 5, 6, 7, 8, 45, 87] String[] strs = {\"a\", \"ac\", \"ab\", \"b\"}; // 应该是根据字典的顺序排序的。 Arrays.sort(strs); System.out.println(Arrays.toString(strs));//[a, ab, ac, b] // 能不能对Person数组排序 Person p1 = new Person(20); Person p2 = new Person(22); Person p3 = new Person(19); Person p4 = new Person(18); /* java.lang.ClassCastException: class com.powernode.javase.Person cannot be cast to class java.lang.Comparable 猜测，底层一定有这样一行代码： Comparable c = (Comparable)p1; 为什么会报这样的错误呢？也进一步说明了我们的Person类不是可比较的。 Comparable字面意思：可比较的。 */ Person[] persons = {p1, p2, p3, p4}; // 排序 Arrays.sort(persons); System.out.println(Arrays.toString(persons));//[Person{age=18}, Person{age=19}, Person{age=20}, Person{age=22}]} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 凡是自定义的类型要做比较的话，这个自定义类型必须实现一个接口：Comparable接口，并且实现compareTo方法，在这个方法中编写比较规则。public class Person implements Comparable { private int age; private String name; public Person() { } public Person(int age) { this.age = age; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Person{\" + \"age=\" + age + '}'; } @Override public int compareTo(Object o) { // 编写比较规则。 // 根据年龄进行比较 // p1.compareTo(p2) p1和p2之间进行比较。 // this是p1 // o是p2 // 当前对象的年龄 //this.age; // 另一个对象的年龄 Person person = (Person) o; //person.age; // 按照年龄进行比较。 return this.age - person.age; //return person.age - this.age; // 按照字符串进行比较。 // 升序 //return this.name.compareTo(person.name); // 降序 //return person.name.compareTo(this.name); }} Copyof方法 1234567891011@Testpublic void testCopyOf() { // 数组拷贝 int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9}; int[] newArr = Arrays.copyOf(arr, 3); System.out.println(Arrays.toString(newArr));//[1, 2, 3] // to不包含 int[] newArr2 = Arrays.copyOfRange(arr, 2, 4); System.out.println(Arrays.toString(newArr2));//[3, 4]}","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaofanshutu.github.io/categories/Java/"}],"tags":[]},{"title":"Java面向对象","slug":"动力节点Java/Chapter3_面向对象","date":"2025-06-08T22:12:58.052Z","updated":"2025-06-16T13:03:17.002Z","comments":true,"path":"posts/5f8d3e42.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/5f8d3e42.html","excerpt":"面向对象概述软件开发方法：面向过程和面向对象 面向过程：关注点在实现功能的步骤上。 PO：Procedure Oriented。代表语言：C语言 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。 例如开汽车：启动、踩离合、挂挡、松离合、踩油门、车走了。 再例如装修房子：做水电、刷墙、贴地砖、做柜子和家具、入住。 对于简单的流程是适合使用面向过程的方式进行的。复杂的流程不适合使用面向过程的开发方式。 面向对象：关注点在实现功能需要哪些对象的参与。 OO：Object Oriented 面向对象。包括OOA,OOD,OOP。OOA：Object Oriented Analysis 面向对象分析。OOD：Object Oriented Design 面向对象设计。OOP：Object Oriented Programming 面向对象编程。代表语言：Java、C#、Python等。 人类是以面向对象的方式去认知世界的。所以采用面向对象的思想更加容易处理复杂的问题。 面向对象就是分析出解决这个问题都需要哪些对象的参加，然后让对象与对象之间协作起来形成一个系统。 例如开汽车：汽车对象、司机对象。司机对象有一个驾驶的行为。司机对象驾驶汽车对象。 再例如装修房子：水电工对象，油漆工对象，瓦工对象，木工对象。每个对象都有自己的行为动作。最终完成装修。 面向对象开发方式耦合度低，扩展能力强。例如采用面向过程生产一台电脑，不会分CPU、内存和硬盘，它会按照电脑的工作流程一次成型。采用面向对象生产一台电脑，CPU是一个对象，内存条是一个对象，硬盘是一个对象，如果觉得硬盘容量小，后期是很容易更换的，这就是扩展性。 面向对象三大特征 封装（Encapsulation） 继承（Inheritance） 多态（Polymorphism） 类与对象 类 现实世界中，事物与事物之间具有共同特征，例如：刘德华和梁朝伟都有姓名、身份证号、身高等状态，都有吃、跑、跳等行为。将这些共同的状态和行为提取出来，形成了一个模板，称为类。 类实际上是人类大脑思考总结的一个模板，类是一个抽象的概念。 状态在程序中对应属性。属性通常用变量来表示。 行为在程序中对应方法。用方法来描述行为动作。 类 = 属性 + 方法。 对象 实际存在的个体。 对象又称为实例（instance）。 通过类这个模板可以实例化n个对象。（通过类可以创造多个对象） 例如通过“明星类”可以创造出“刘德华对象”和“梁朝伟对象”。 明星类中有一个属性姓名：String name;“ 刘德华对象”和“梁朝伟对象”由于是通过明星类造出来的，所以这两个都有name属性，但是值是不同的。因此这种属性被称为实例变量。 对象的创建和使用","text":"面向对象概述软件开发方法：面向过程和面向对象 面向过程：关注点在实现功能的步骤上。 PO：Procedure Oriented。代表语言：C语言 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。 例如开汽车：启动、踩离合、挂挡、松离合、踩油门、车走了。 再例如装修房子：做水电、刷墙、贴地砖、做柜子和家具、入住。 对于简单的流程是适合使用面向过程的方式进行的。复杂的流程不适合使用面向过程的开发方式。 面向对象：关注点在实现功能需要哪些对象的参与。 OO：Object Oriented 面向对象。包括OOA,OOD,OOP。OOA：Object Oriented Analysis 面向对象分析。OOD：Object Oriented Design 面向对象设计。OOP：Object Oriented Programming 面向对象编程。代表语言：Java、C#、Python等。 人类是以面向对象的方式去认知世界的。所以采用面向对象的思想更加容易处理复杂的问题。 面向对象就是分析出解决这个问题都需要哪些对象的参加，然后让对象与对象之间协作起来形成一个系统。 例如开汽车：汽车对象、司机对象。司机对象有一个驾驶的行为。司机对象驾驶汽车对象。 再例如装修房子：水电工对象，油漆工对象，瓦工对象，木工对象。每个对象都有自己的行为动作。最终完成装修。 面向对象开发方式耦合度低，扩展能力强。例如采用面向过程生产一台电脑，不会分CPU、内存和硬盘，它会按照电脑的工作流程一次成型。采用面向对象生产一台电脑，CPU是一个对象，内存条是一个对象，硬盘是一个对象，如果觉得硬盘容量小，后期是很容易更换的，这就是扩展性。 面向对象三大特征 封装（Encapsulation） 继承（Inheritance） 多态（Polymorphism） 类与对象 类 现实世界中，事物与事物之间具有共同特征，例如：刘德华和梁朝伟都有姓名、身份证号、身高等状态，都有吃、跑、跳等行为。将这些共同的状态和行为提取出来，形成了一个模板，称为类。 类实际上是人类大脑思考总结的一个模板，类是一个抽象的概念。 状态在程序中对应属性。属性通常用变量来表示。 行为在程序中对应方法。用方法来描述行为动作。 类 = 属性 + 方法。 对象 实际存在的个体。 对象又称为实例（instance）。 通过类这个模板可以实例化n个对象。（通过类可以创造多个对象） 例如通过“明星类”可以创造出“刘德华对象”和“梁朝伟对象”。 明星类中有一个属性姓名：String name;“ 刘德华对象”和“梁朝伟对象”由于是通过明星类造出来的，所以这两个都有name属性，但是值是不同的。因此这种属性被称为实例变量。 对象的创建和使用 类的定义语法格式： [修饰符列表] class 类名 { ​ // 属性（描述状态） ​ // 方法（描述行为动作） } 12345678910public class Student { // 姓名 String name; // 实例变量 // 年龄 int age; // 性别 boolean gender; // 学习 public void study(){ System.out.println(“正在学习”); } // 实例方法（实例方法又叫对象方法）} 对象的创建 Student s = new Student(); 在Java中，使用class定义的类，属于引用数据类型。所以Student属于引用数据类型。类型名为：Student。 Student s; 表示定义一个变量。数据类型是Student。变量名是s。 对象的使用 读取属性值：s.name 修改属性值：s.name = “jackson”; 通过一个类可以实例化多个对象 Student s1 = new Student(); Student s2 = new Student(); 对象的内存分析（对象与引用） new运算符会在JVM的堆内存中分配空间用来存储实例变量。new分配的空间就是Java对象。 在JVM中对象创建后会有对应的内存地址，将内存地址赋值给一个变量，这个变量被称为引用。 Java中的GC主要针对的是JVM的堆内存。 空指针异常是如何发生的？ 程序计数器 虚拟机栈 堆 方法区 运行时常量池 本地方法区 方法调用时参数是如何传递的？将变量中保存的值复制一份传递过去。 初次认识this关键字：出现在实例方法中，代表当前对象。“this.”大部分情况下可以省略。this存储在实例方法栈帧的局部变量表的0号槽位上。任何一个实例方法，局部变量表0号槽位放的是this。 this.用来区分局部变量和实例变量的时候不能省略。 传递的是u变量保存的那个地址 面向对象的封装特性什么是封装？ ​ 封装是一种将数据和方法加以包装，使之成为一个独立的实体，并且把它与外部对象隔离开来的机制。具体来说，封装是将一个对象的所有“状态（属性）”以及“行为（方法）”统一封装到一个类中，从而隐藏了对象内部的具体实现细节，向外界提供了有限的访问接口，以实现对对象的保护和隔离。 实现封装的步骤： 第一步：属性私有化 第二步：对外提供getter setter方法 封装保证安全性，提高复用性 实例方法中调用实例方法 构造方法Constructor(构造器)的语法 构造方法有什么作用？ 构造方法的执行分为两个阶段：对象的创建和对象的初始化。这两个阶段不能颠倒，也不可分割。 在Java中，当我们使用关键字new时，就会在内存中创建一个新的对象，虽然对象已经被创建出来了，但还没有被初始化。而初始化则是在执行构造方法体时进行的。 构造方法如何定义？ [修饰符列表] 构造方法名(形参){} 构造方法如何调用？ new 构造方法名(实参); 关于无参数构造方法： 如果一个类没有显示的定义任何构造方法，系统会默认提供一个无参数构造方法，也被称为缺省构造器。一旦显示的定义了构造方法，则缺省构造器将不存在。为了方便对象的创建，建议将缺省构造器显示的定义出来。 构造方法支持重载机制。 关于构造代码块。对象的创建和初始化过程梳理： new的时候在堆内存中开辟空间，给所有属性赋默认值 执行构造代码块进行初始化 执行构造方法体进行初始化 构造方法执行结束，对象初始化完毕。 构造方法/Constructor/构造器 构造方法有什么作用？ 作用1：对象的创建（通过调用构造方法可以完成对象的创建） 作用2：对象的初始化（给对象的所有属性赋值就是对象的初始化） 怎么定义构造方法呢？ 123[修饰符列表] 构造方法名(形参列表){ 构造方法体;} 注意： 构造方法名必须和类名一致。 构造方法不需要提供返回值类型。 如果提供了返回值类型，那么这个方法就不是构造方法了，就变成普通方法了。 构造方法怎么调用呢？ 使用new运算符来调用。 语法：new 构造方法名(实参); 注意：构造方法最终执行结束之后，会自动将创建的对象的内存地址返回。但构造方法体中不需要提供“return 值;”这样的语句。 在java语言中，如果一个类没有显示的去定义构造方法，系统会默认提供一个无参数的构造方法。（通常把这个构造方法叫做缺省构造器。） 一个类中如果显示的定义了构造方法，系统则不再提供缺省构造器。所以，为了对象创建更加方便，建议把无参数构造方法手动的写出来。 在java中，一个类中可以定义多个构造方法，而且这些构造方法自动构成了方法的重载(overload)。 构造方法中给属性赋值了？为什么还需要单独定义set方法给属性赋值呢？ 在构造方法中赋值是对象第一次创建时属性赋的值。set方法可以在后期的时候调用，来完成属性值的修改。 时机不一样 set方法是出生之后想改内容，调用构造方法 构造方法里面设置属性内容是在创建对象的时候给属性赋值 构造方法执行原理？ 构造方法执行包括两个重要的阶段： 第一阶段：对象的创建 第二阶段：对象的初始化 对象在什么时候创建的？ new的时候，会直接在堆内存中开辟空间。然后给所有属性赋默认值，完成对象的创建。（这个过程是在构造方法体执行之前就完成了。） 对象初始化在什么时候完成的？ 构造方法体开始执行，标志着开始进行对象初始化。构造方法体执行完毕，表示对象初始化完毕。 构造代码块？ 1234//语法格式{ //构造代码块} 123{构造代码块：new一次就会执行一次这个，每次执行构造方法前会执行一次（构造代码块执行之前对象已经创建好了）} 构造代码块什么时候执行，执行几次？ 每一次在new的时候，都会先执行一次构造代码块。 构造代码块是在构造方法执行之前执行的。 构造代码块有什么用？ 如果所有的构造方法在最开始的时候有相同的一部分代码，不妨将这个公共的代码提取到构造代码块当中，这样代码可以得到复用。 this关键字 this是一个关键字 this出现在实例方法中，代表当前对象。语法是：this. this本质上是一个引用，该引用保存当前对象的内存地址。 通过“this.”可以访问实例变量，可以调用实例方法。 this存储在：栈帧的局部变量表的第0个槽位上。 this. 大部分情况下可以省略，用于区分局部变量和实例变量时不能省略。 this不能出现在静态方法中。 “this(实参)”语法： 只能出现在构造方法的第一行。 通过当前构造方法去调用本类中其他的构造方法。 作用是：代码复用。 1234this(实参)：1. 通过这种语法可以在构造方法中调用本类中其他的构造方法。2. 作用：代码复用。3. this(实参); 只能出现在构造方法第一行。 123456789101112131415161718192021public Date() { /* this.year = 1970; this.month = 1; this.day = 1; */ // 不要这么写，这样会导致再创建一个新的对象。 //new Date(1970,1,1); // 不会创建新对象。只是通过一个构造方法去调用另一个构造方法。 this(1970,1,1); System.out.println(\"日期创建成功！~\");}public Date(int year, int month, int day) { this.year = year; this.month = month; this.day = day;} static关键字 static是一个关键字，翻译为：静态的。 static修饰的变量叫做静态变量。当所有对象的某个属性的值是相同的，建议将该属性定义为静态变量，来节省内存的开销。 静态变量在类加载时初始化，存储在堆中。 static修饰的方法叫做静态方法。 所有静态变量和静态方法，统一使用“类名.”调用。虽然可以使用“引用.”来调用，但实际运行时和对象无关，所以不建议这样写，因为这样写会给其他人造成疑惑。 使用“引用.”访问静态相关的，即使引用为null，也不会出现空指针异常。 静态方法中不能使用this关键字。因此无法直接访问实例变量和调用实例方法。 静态代码块在类加载时执行，一个类中可以编写多个静态代码块，遵循自上而下的顺序依次执行。 静态代码块代表了类加载时刻，如果你有代码需要在此时刻执行，可以将该代码放到静态代码块中。 1234567891011121314/** * static关键字： * 1. static翻译为静态的 * 2. static修饰的变量：静态变量 * 3. static修饰的方法：静态方法 * 4. 所有static修饰的，访问的时候，直接采用“类名.”，不需要new对象。 * 5. 什么情况下把成员变量定义为静态成员变量？ * 当一个属性是对象级别的，这个属性通常定义为实例变量。（实例变量是一个对象一份。100个对象就应该有100个空间） * 当一个属性是类级别的（所有对象都有这个属性，并且这个属性的值是一样的），建议将其定义为静态变量，在内存空间上只有一份。节省内存开销。 * 这种类级别的属性，不需要new对象，直接通过类名访问。 * 6. 静态变量存储在哪里？静态变量在什么时候初始化？（什么时候开辟空间） * JDK8之后：静态变量存储在堆内存当中。 * 类加载时初始化。 */ 静态变量的内存图 类加载的时候会去检查类中有没有静态变量，有静态变量的话就将其放在类的静态变量中 类加载是在main方法执行之前执行的 空指针异常何时发生实例相关：实例变量 实例方法 静态代码块i可以访问，j不能访问 123456789101112131415161718/** * static关键字还可以定义静态代码块： * * 1.语法格式： * static { * * } * * 2. 静态代码块什么时候执行？执行几次？ * 静态代码块在类加载时执行，并且只执行一次。 * * 3. 静态代码块可以编写多个，并且遵循自上而下的顺序依次执行。 * * 4. 静态代码块什么时候使用？ * 本质上，静态代码块就是为程序员预留的一个特殊的时间点：类加载时刻 * 如果你需要再类加载时刻执行一段程序的话，这段代码就可以写到静态代码块当中。 * 例如，有这样一个需求：请在类加载时，记录日志。那么记录日志的代码就可以编写到静态代码块当中。 */ Java虚拟机规范JVM对应了一套规范（Java虚拟机规范），它可以有不同的实现JVM规范是一种抽象的概念，它可以有多种不同的实现。例如： HotSpot：HotSpot 由 Oracle 公司开发，是目前最常用的虚拟机实现，也是默认的 Java 虚拟机，默认包含在 Oracle JDK 和 OpenJDK 中 JRockit：JRockit 也是由 Oracle 公司开发。它是一款针对生产环境优化的 JVM 实现，能够提供高性能和可伸缩性 IBM JDK：IBM JDK 是 IBM 公司开发的 Java 环境，采用了与 HotSpot 不同的 J9 VM，能够提供更小的内存占用和更迅速的启动时间 Azul Zing：Azul Zing 是针对生产环境优化的虚拟机实现，能够提供高性能和实时处理能力，适合于高负载的企业应用和实时分析等场景 OpenJ9：OpenJ9 是由 IBM 开发的优化的 Java 虚拟机实现，支持高度轻量级、低时延的 GC、优化的 JIT 编译器和用于健康度测试的可观察性仪表板 Oracle官网上Java虚拟机规范的一部分 运行时数据区 The pc Register（程序计数器） 是一块较小的内存空间，此计数器记录的是正在执行的虚拟机字节码指令的地址； Java Virtual Machine Stacks（Java虚拟机栈） Java虚拟机栈用于存储栈帧。栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。 Heap（堆） 是Java虚拟机所管理的最大的一块内存。堆内存用于存放Java对象实例以及数组。堆是垃圾收集器收集垃圾的主要区域。 Method Area（方法区） 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 规范上静态变量在方法区，但是实际上在堆中 Run-Time Constant Pool（运行时常量池） 是方法区的一部分，用于存放编译期生成的各种字面量与符号引用。 符号引用：类名，方法名，属性名，字面量，都存在于运行时常量池 Native Method Stacks（本地方法栈） 在本地方法的执行过程中，会使用到本地方法栈。和 Java 虚拟机栈十分相似。 压栈是给本地方法栈压。 总结：这些运行时数据区虽然在功能上有所区别，但在整个 Java 虚拟机启动时都需要被创建，并且在虚拟机运行期间始终存在，直到虚拟机停止运行时被销毁。同时，不同的 JVM 实现对运行时数据区的分配和管理方式也可能不同，会对性能和功能产生影响。 JVM体系结构图（该图属于JVM规范，不是具体的实现） JVM规范的实现：HotSpot（Oracle JDK/Open JDK内部使用的JVM就是HotSpot）JDK6的HotSpot 年轻代：刚new出来的对象放在这里。 老年代：经过垃圾回收之后仍然存活的对象。 符号引用：类全名，字段全名，方法全名等。 这个时期的永久代和堆是相邻的，使用连续的物理内存，但是内存空间是隔离的。 永久代的垃圾收集是和老年代捆绑在一起的，因此无论谁满了，都会触发永久代和老年代的垃圾收集。 JDK7的HotSpot这是一个过渡的版本，该版本相对于JDK6来说，变化如下： 类的静态变量转移到堆中了 字符串常量池转移到堆中了 运行时常量池中的符号引用转移到本地内存了 JDK8及更高版本的HotSpot相对于JDK7来说发生了如下变化： 彻底删除永久代（为了避免OOM错误的发生） 将方法区的实现转移到本地内存 将符号引用重新放回运行时常量池 单例模式设计模式概述 什么是设计模式？ 设计模式（Design Pattern）是一套被广泛接受的、经过试验验证的、可反复使用的基于面向对象的软件设计经验总结，它是软件开发人员在软件设计中，对常见问题的解决方案的总结和抽象。设计模式是针对软件开发中常见问题和模式的通用解决方案 设计模式有哪些？ GoF设计模式：《Design Patterns: Elements of Reusable Object-Oriented Software》（即后述《设计模式》一书），由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著（Addison-Wesley，1995）。这几位作者常被称为四人组（Gang of Four）。 架构设计模式（Architectural Pattern）：主要用于软件系统的整体架构设计，包括多层架构、MVC架构、微服务架构、REST架构和大数据架构等。 企业级设计模式（Enterprise Pattern）：主要用于企业级应用程序设计，包括基于服务的架构（SOA）、企业集成模式（EIP）、业务流程建模（BPM）和企业规则引擎（BRE）等。 领域驱动设计模式（Domain Driven Design Pattern）：主要用于领域建模和开发，包括聚合、实体、值对象、领域事件和领域服务等。 并发设计模式（Concurrency Pattern）：主要用于处理并发性问题，包括互斥、线程池、管道、多线程算法和Actor模型等。 数据访问模式（Data Access Pattern）：主要用于处理数据访问层次结构，包括数据访问对象（DAO）、仓库模式和活动记录模式等。 GoF设计模式的分类？ 创建型：主要解决对象的创建问题 结构型：通过设计和构建对象之间的关系，以达到更好的重用性、扩展性和灵活性 行为型：主要用于处理对象之间的算法和责任分配 单例模式单例模式（GoF23种设计模式之一，最简单的设计模式：保证某种类型的对象只创建一个） 饿汉式:类加载时就创建对象。1234567public class Singleton { private static Singleton instance = new Singleton(); // 在类加载的时候就创建实例 private Singleton() {} // 将构造方法设为私有化 public static Singleton getInstance() { // 提供一个公有的静态方法，以获取实例 return instance; }} 懒汉式：第一次调用get方法时才会创建对象。12345678910public class Singleton { private static Singleton instance; // 声明一个静态的、私有的该类类型的变量，用于存储该类的实例 private Singleton() {} // 将构造方法设为私有化 public static Singleton getInstance() { // 提供一个公有的静态方法，以获取实例 if (instance == null) { // 第一次调用该方法时，才真正创建实例 instance = new Singleton(); // 创建实例 } return instance; }} 继承 面向对象三大特征之一：继承 继承作用？ 基本作用：代码复用 重要作用：有了继承，才有了方法覆盖和多态机制。 继承在java中如何实现？ [修饰符列表] class 类名 extends 父类名{} extends翻译为扩展。表示子类继承父类后，子类是对父类的扩展。 继承相关的术语：当B类继承A类时 A类称为：父类、超类、基类、superclass B类称为：子类、派生类、subclass Java只支持单继承，一个类只能直接继承一个类。 Java不支持多继承，但支持多重继承（多层继承）。 子类继承父类后，除私有的不支持继承、构造方法不支持继承。其它的全部会继承。 一个类没有显示继承任何类时，默认继承java.lang.Object类。 方法覆盖(override)/方法重写(overwrite) 什么情况下考虑使用方法覆盖？ 当从父类中继承过来的方法无法满足当前子类的业务需求时。 发生方法覆盖的条件？ 具有继承关系的父子类之间 相同的返回值类型，相同的方法名，相同的形式参数列表 访问权限不能变低，可以变高。 抛出异常不能变多，可以变少。 返回值类型可以是父类方法返回值类型的子类。 方法覆盖的小细节： @Override注解标注的方法会在编译阶段检查该方法是否重写了父类的方法。 私有方法不能继承，所以不能覆盖。 构造方法不能继承，所以不能覆盖。 静态方法不存在方法覆盖，方法覆盖针对的是实例方法。 方法覆盖说的实例方法，和实例变量无关。 多态多态的基础语法 什么是向上转型和向下转型？ java允许具有继承关系的父子类型之间的类型转换。 向上转型（upcasting）：子–&gt;父 子类型的对象可以赋值给一个父类型的引用。 向下转型（downcasting）：父–&gt;子 父类型的引用可以转换为子类型的引用。但是需要加强制类型转换符。 无论是向上转型还是向下转型，前提条件是：两种类型之间必须存在继承关系。这样编译器才能编译通过。 什么是多态？ 父类型引用指向子类对象。Animal a = new Cat(); a.move(); 程序分为编译阶段和运行阶段： 编译阶段：编译器只知道a是Animal类型，因此去Animal类中找move()方法，找到之后，绑定成功，编译通过。这个过程通常被称为静态绑定。 运行阶段：运行时和JVM堆内存中的真实Java对象有关，所以运行时会自动调用真实对象的move()方法。这个过程通常被称为动态绑定。 多态指的是：多种形态，编译阶段一种形态，运行阶段另一种形态，因此叫做多态。 向下转型我们需要注意什么？ 向下转型时，使用不当，容易发生类型转换异常：ClassCastException。 在向下转型时，一般建议使用instanceof运算符进行判断来避免ClassCastException的发生。 instanceof运算符的使用 语法格式：(引用 instanceof 类型) 执行结果是true或者false 例如：(a instanceof Cat) 如果结果是true：表示a引用指向的对象是Cat类型的。 如果结果是false：表示a引用指向的对象不是Cat类型的。 软件开发七大原则 软件开发原则旨在引导软件行业的从业者在代码设计和开发过程中，遵循一些基本原则，以达到高质量、易维护、易扩展、安全性强等目标。软件开发原则与具体的编程语言无关的，属于软件设计方面的知识。 软件开发七大原则？ 开闭原则 (Open-Closed Principle，OCP)：一个软件实体应该对扩展开放，对修改关闭。即在不修改原有代码的基础上，通过添加新的代码来扩展功能。（最基本的原则，其它原则都是为这个原则服务的。） 单一职责原则：一个类只负责单一的职责，也就是一个类只有一个引起它变化的原因。 里氏替换原则：子类对象可以替换其基类对象出现的任何地方，并且保证原有程序的正确性。 接口隔离原则：客户端不应该依赖它不需要的接口。 依赖倒置原则：高层模块不应该依赖底层模块，它们都应该依赖于抽象接口。换言之，面向接口编程。 迪米特法则：一个对象应该对其它对象保持最少的了解。即一个类应该对自己需要耦合或调用的类知道得最少。 合成复用原则：尽量使用对象组合和聚合，而不是继承来达到复用的目的。组合和聚合可以在获取外部对象的方法中被调用，是一种运行时关联，而继承则是一种编译时关联。 多态在开发中的作用 降低程序的耦合度，提高程序的扩展力。 尽量使用多态，面向抽象编程，不要面向具体编程。 super关键字 super关键字和this关键字对比来学习。this代表的是当前对象。super代表的是当前对象中的父类型特征。 super不能使用在静态上下文中。 “super.”大部分情况下是可以省略的。什么时候不能省略？ 当父类和子类中定义了相同的属性（实例变量）或者相同方法（实例方法）时，如果需要在子类中访问父类的属性或方法时，super.不能省略。 this可以单独输出，super不能单独输出。 super(实参); 通过子类的构造方法调用父类的构造方法，目的是为了完成父类型特征的初始化。当一个构造方法第一行没有显示的调用“super(实参);”，也没有显示的调用“this(实参)”，系统会自动调用super()。因此一个类中的无参数构造方法建议显示的定义出来。 super(实参); 这个语法只能出现在构造方法第一行。 在Java语言中只要new对象，Object的无参数构造方法一定会执行。 final关键字 final修饰的类不能被继承 final修饰的方法不能被覆盖 final修饰的变量，一旦赋值不能重新赋值 final修饰的实例变量必须在对象初始化时手动赋值 final修饰的实例变量一般和static联合使用：称为常量 final修饰的引用，一旦指向某个对象后，不能再指向其它对象。但指向的对象内部的数据是可以修改的。 抽象类 什么时候考虑将类定义为抽象类？ 如果类中有些方法无法实现或者没有意义，可以将方法定义为抽象方法，类定义为抽象类。这样在抽象类中只提供公共代码，具体的实现强行交给子类去做。 比如一个Person类有一个问候的方法greet()，但是不同国家的人问候的方式不同，因此greet()方法具体实现应该交给子类。再比如主人喂养宠物的例子中的宠物Pet，Pet中的eat()方法的方法体就是没有意义的。 抽象类如何定义？ abstract class 类名{} 抽象类有构造方法，但无法实例化。抽象类的构造方法是给子类使用的。 抽象方法如何定义？ abstract 方法返回值类型 方法名(形参); 抽象类中不一定有抽象方法，但如果有抽象方法那么类要求必须是抽象类。 一个非抽象的类继承抽象类，要求必须将抽象方法进行实现/重写。 abstract关键字不能和private，final，static关键字共存。 接口接口的基础语法 接口（interface）在Java中表示一种规范或契约，它定义了一组抽象方法和常量，用来描述一些实现这个接口的类应该具有哪些行为和属性。接口和类一样，也是一种引用数据类型。 接口怎么定义？[修饰符列表] interface 接口名{} 抽象类是半抽象的，接口是完全抽象的。接口没有构造方法，也无法实例化。 接口中只能定义：常量+抽象方法。接口中的常量的static final可以省略。接口中的抽象方法的abstract可以省略。接口中所有的方法和变量都是public修饰的。 接口和接口之间可以多继承。 类和接口的关系我们叫做实现（这里的实现也可以等同看做继承）。使用implements关键字进行接口的实现。 一个非抽象的类实现接口必须将接口中所有的抽象方法全部实现。 一个类可以实现多个接口。语法是：class 类 implements 接口A,接口B{} Java8之后，接口中允许出现默认方法和静态方法(JDK8新特性) 引入默认方式是为了解决接口演变问题：接口可以定义抽象方法，但是不能实现这些方法。所有实现接口的类都必须实现这些抽象方法。这会导致接口升级的问题：当我们向接口添加或删除一个抽象方法时，这会破坏该接口的所有实现，并且所有该接口的用户都必须修改其代码才能适应更改。这就是所谓的”接口演变”问题。 引入的静态方法只能使用本接口名来访问，无法使用实现类的类名访问。 JDK9之后允许接口中定义私有的实例方法（为默认方法服务的）和私有的静态方法（为静态方法服务的）。 所有的接口隐式的继承Object。因此接口也可以调用Object类的相关方法。 接口的作用 面向接口调用的称为：接口调用者 面向接口实现的称为：接口实现者 调用者和实现者通过接口达到了解耦合。也就是说调用者不需要关心具体的实现者，实现者也不需要关心具体的调用者，双方都遵循规范，面向接口进行开发。 面向抽象编程，面向接口编程，可以降低程序的耦合度，提高程序的扩展力。 定义一个Usb接口，提供read()和write()方法，通过read()方法读，通过write()方法写： 定义一个电脑类Computer，它是调用者，面向Usb接口来调用。 Usb接口的实现可以有很多，例如：打印机（Printer），硬盘（HardDrive）。 123456public class Computer{ public void conn(Usb usb){ usb.read(); usb.write(); }} 再想想，我们平时去饭店吃饭，这个场景中有没有接口呢？食谱菜单就是接口。顾客是调用者。厨师是实现者。 接口与抽象类如何选择 抽象类和接口虽然在代码角度都能达到同样的效果，但适用场景不同： 抽象类主要适用于公共代码的提取。当多个类中有共同的属性和方法时，为了达到代码的复用，建议为这几个类提取出来一个父类，在该父类中编写公共的代码。如果有一些方法无法在该类中实现，可以延迟到子类中实现。这样的类就应该使用抽象类。 接口主要用于功能的扩展。例如有很多类，一些类需要这个方法，另外一些类不需要这个方法时，可以将该方法定义到接口中。需要这个方法的类就去实现这个接口，不需要这个方法的就可以不实现这个接口。接口主要规定的是行为。 UML UML（Unified Modeling Language，统一建模语言）是一种用于面向对象软件开发的图形化的建模语言。它由Grady Booch、James Rumbaugh和Ivar Jacobson等三位著名的软件工程师所开发，并于1997年正式发布。UML提供了一套通用的图形化符号和规范，帮助开发人员以图形化的形式表达软件设计和编写的所有关键方面，从而更好地展示软件系统的设计和实现过程。 UML是一种图形化的语言，类似于现实生活中建筑工程师画的建筑图纸，图纸上有特定的符号代表特殊的含义。 UML不是专门为java语言准备的。只要是面向对象的编程语言，开发前的设计，都需要画UML图进行系统设计。（设计模式、软件开发七大原则等同样也不是只为java语言准备的。） UML图包括： 类图（Class Diagram）：描述软件系统中的类、接口、关系和其属性等； 用例图（Use Case Diagram）：描述系统的功能需求和用户与系统之间的关系； 序列图（Sequence Diagram）：描述对象之间的交互、消息传递和时序约束等； 状态图（Statechart Diagram）：描述类或对象的生命周期以及状态之间的转换； 对象图（Object Diagram）：表示特定时间的系统状态，并显示其包含的对象及其属性； 协作图（Collaboration Diagram）：描述对象之间的协作，表示对象之间相互合作来完成任务的关系； 活动图（Activity Diagram）：描述系统的动态行为和流程，包括控制流和对象流； 部署图（Deployment Diagram）：描述软件或系统在不同物理设备上部署的情况，包括计算机、网络、中间件、应用程序等。 常见的UML建模工具有：StarUML，Rational Rose等。 类之间的关系 泛化关系（is a） 实现关系（is like a） 关联关系（has a） 聚合关系 聚合关系指的是一个类包含、合成或者拥有另一个类的实例，而这个实例是可以独立存在的。 聚合关系是一种弱关联关系，表示整体与部分之间的关系。 例如一个教室有多个学生 组合关系（Composition） 组合关系是聚合关系的一种特殊情况，表示整体与部分之间的关系更加强烈。 组合关系指的是一个类包含、合成或者拥有另一个类的实例，而这个实例只能同时存在于一个整体对象中。如果整体对象被销毁，那么部分对象也会被销毁。 例如一个人对应四个肢体。 依赖关系（Dependency） 依赖关系是一种临时性的关系，当一个类使用另一个类的功能时，就会产生依赖关系。 如果一个类的改变会影响到另一个类的功能，那么这两个类之间就存在依赖关系。 依赖关系是一种较弱的关系，可以存在多个依赖于同一个类的对象。 例如A类中使用了B类，但是B类作为A类的方法参数或者局部变量等。 访问控制权限 private：私有的，只能在本类中访问。 缺省：默认的，同一个包下可以访问。 protected：受保护的，子类中可以访问。（受保护的通常就是给子孙用的。） public：公共的，在任何位置都可以访问。 a. 类中的属性和方法访问权限共有四种：private、缺省、protected和public。b. 类的访问权限只有两种：public和 缺省。 c. 访问权限控制符不能修饰局部变量。 Object类 java.lang.Object是所有类的超类。java中所有类都实现了这个类中的方法。 Object类是我们学习JDK类库的第一个类。通过这个类的学习要求掌握会查阅API帮助文档。 现阶段Object类中需要掌握的方法： toString：将java对象转换成字符串。 equals：判断两个对象是否相等。 现阶段Object类中需要了解的方法： hashCode：返回一个对象的哈希值，通常作为在哈希表中查找该对象的键值。Object类的默认实现是根据对象的内存地址生成一个哈希码（即将对象的内存地址转换为整数作为哈希值）。hashCode()方法是为了HashMap、Hashtable、HashSet等集合类进行优化而设置的，以便更快地查找和存储对象。 finalize：当java对象被回收时，由GC自动调用被回收对象的finalize方法，通常在该方法中完成销毁前的准备。 clone：对象的拷贝。（浅拷贝，深拷贝）protected修饰的只能在同一个包下或者子类中访问。只有实现了Cloneable接口的对象才能被克隆。 内部类 什么是内部类？ 定义在一个类中的类。 什么时候使用内部类？ 一个类用到了另外一个类，而这两个类的联系比较密切，但是如果把这两个类定义为独立的类，不但增加了类的数量，也不利于代码的阅读和维护。 内部类可以访问外部类的私有成员，这样可以将相关的类和接口隐藏在外部类的内部，从而提高封装性。 匿名内部类是指没有名字的内部类，通常用于定义一个只使用一次的类，比如在事件处理中。 内部类包括哪几种？ 静态内部类：和静态变量一个级别 静态内部类如何实例化：OuterClass.StaticInnerClass staticInnerClass = new OuterClass.StaticInnerClass(); 无法直接访问外部类中实例变量和实例方法。 实例内部类：和实例变量一个级别 实例内部类如何实例化：OuterClass.InnerClass innerClass = new OuterClass().new InnerClass(); 可以直接访问外部类中所有的实例变量，实例方法，静态变量，静态方法。 局部内部类：和局部变量一个级别 局部内部类方外类外部的局部变量时，局部变量需要被final修饰。 从JDK8开始，不需要手动添加final了，但JVM会自动添加。 匿名内部类：特殊的局部内部类，没有名字，只能用一次。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaofanshutu.github.io/categories/Java/"}],"tags":[]},{"title":"Java基础语法","slug":"动力节点Java/Chapter2_Java基础语法","date":"2025-06-08T22:12:37.686Z","updated":"2025-06-08T23:23:09.087Z","comments":true,"path":"posts/ea538f2a.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/ea538f2a.html","excerpt":"标识符什么是标识符 在Java中，程序员有权利自己取名的就是标识符。标识符是用来给变量、方法、类和包等命名的字符序列。 标识符的长度没有限制，但是建议使用有意义的、简洁的标识符，以提高代码的可读性和可维护性。 标识符可以标识什么 变量名 方法名 类名、接口名、枚举名、注解名 包名 常量名 其他…… 标识符命名规则 标识符可以由字母、数字、下划线(_)和美元符号($)组成，不能含有其他符号。（java支持全球所有语言，所以这里的 字母 指的是任何一个国家的文字都可以） 标识符不能以数字开头。 标识符不能是Java中的关键字，如public、class、void等。 标识符是区分大小写的，即Foo和foo是两个不同的标识符。 标识符的长度没有限制，但是Java建议使用有意义的、简短的标识符。 标识符命名规范","text":"标识符什么是标识符 在Java中，程序员有权利自己取名的就是标识符。标识符是用来给变量、方法、类和包等命名的字符序列。 标识符的长度没有限制，但是建议使用有意义的、简洁的标识符，以提高代码的可读性和可维护性。 标识符可以标识什么 变量名 方法名 类名、接口名、枚举名、注解名 包名 常量名 其他…… 标识符命名规则 标识符可以由字母、数字、下划线(_)和美元符号($)组成，不能含有其他符号。（java支持全球所有语言，所以这里的 字母 指的是任何一个国家的文字都可以） 标识符不能以数字开头。 标识符不能是Java中的关键字，如public、class、void等。 标识符是区分大小写的，即Foo和foo是两个不同的标识符。 标识符的长度没有限制，但是Java建议使用有意义的、简短的标识符。 标识符命名规范 见名知意 驼峰式命名方式 类名、接口名、枚举、注解：首字母大写，后面每个单词首字母大写。（StudentService，UserService） 变量名和方法名：首字母小写，后面每个单词首字母大写。（doSome，doOther） 常量名：全部大写，每个单词用下划线连接。（LOGIN_SUCCESS，SYSTEM_ERROR） 包名：全部小写 关键字什么是关键字 Java关键字是Java编程语言中预定义的具有特殊含义的单词，这些单词不能被用作标识符，而是在语法中有特定的用法和限制。 Java关键字都是小写的。 Java关键字有哪些 abstract, assert, boolean, break, byte, case, catch, char, class, continue, default, do, double, else, enum, extends, final, finally, float, for, if, implements, import, instanceof, int, interface, long, native, new, package, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, throws, transient, try, void, volatile, while 保留字：goto，const 字面量什么是字面量 字面量指的是在程序中直接使用的数据。 字面量是Java中最基本的表达式，不需要进行计算或转换，直接使用即可。 Java中有哪些字面量 整数型：10、-5、0、100 浮点型：3.14、-0.5、1.0 布尔型：true、false 字符型：’a’、’b’、’c’、’1’、’2’、’国’ 字符串型：”Hello”、”World”、”Java”、”你好呀” 加号运算符 + 作用1：求和（当加号两边都是数字时进行求和运算） 作用2：字符串拼接（当加号两边有任意一边是字符串类型时会进行字符串拼接，结果还是一个字符串） 变量什么是变量？ 变量是内存当中的一块空间。是计算机中存储数据最基本的单元。 变量三要素： 数据类型（决定空间大小）【int, double, String】 变量名（只要是合法的标识符即可） 变量值（变量中具体存储的数据） 变量的声明、赋值、访问 int i; // 声明一个整数型的变量，起名i i = 100; // 给变量i赋值100 System.out.println(i); // 访问i变量：读操作 i = 200; // 访问i变量：改操作【给变量i重新赋值200】 变量的作用 变量的存在会让程序更加便于维护。 变量的存在可以增强程序的可读性。 变量的小细节 变量必须先声明，再赋值，才能访问 方法体当中的代码遵循自上而下的顺序依次逐行执行，变量先访问，再声明肯定是不行的 一行代码上可以同时声明多个变量 在同一个作用域当中，变量名不能重名，可以重新赋值 变量值的数据类型必须和变量的数据类型一致，这样是不允许的：String name = 100; 变量的作用域 作用域就是变量的有效范围。变量的作用域是怎样的呢？用一句大白话就可以概括了：出了大括号就不认识了。 作用域的不同主要是因为声明在不同位置的变量具有不同的生命周期。所谓的生命周期是：从内存开辟到内存释放。 Java遵循就近原则 变量的分类 局部变量 成员变量 静态变量 实例变量 二进制123456//二进制字面量是以ob开始的System.out.println(0b10011011);//155//八进制字面量是以0开始的System.out.println(0123);//83//十六进制字面量是以0x开始的System.out.println(0x1A3F);//6719 二进制概述 计算机底层只能识别二进制。 计算机底层只识别二进制是因为计算机内部的电子元件只能识别两种状态，即开和关，或者高电平和低电平。二进制正好可以用两种状态来表示数字和字符，因此成为了计算机最基本的表示方法。 在计算机内部，所有的数据都被转化为二进制形式进行处理和存储。 虽然计算机可以通过不同的编程语言和程序来处理不同的数据类型和格式，但最终都需要将其转化为二进制形式才能被计算机底层识别和处理。 什么是二进制 十进制：满十进一 二进制：满二进一 十进制转换为二进制 将十进制数除以2，得到商和余数。 将余数记录下来，然后将商作为新的十进制数，重复步骤1，直到商为0为止。 将记录的余数从下往上排列，得到的就是对应的二进制数。 二进制转换为十进制 将二进制数每一位权值找出来，然后每个权值与对应二进制位相乘，最后将它们相加，即可得到十进制数。 什么是权值？ 在二进制中，权值指的是每个位所代表的数值大小，即二进制中每个位的位置所代表的数值大小。 例如，在二进制数1101中，最高位的权值为8，次高位的权值为4，第三位的权值为2，最低位的权值为1。 二进制数1101转换为十进制数的计算过程如下： 1×2³ + 1×2² + 0×2¹ + 1×2⁰ = 8 + 4 + 0 + 1 = 13 八进制与十六进制八进制是满8进1 十六进制是满十六进1 十进制转为八进制（或十六进制）与二进制相同。 八进制（或十六进制）转为十进制的原理与二进制相同。 二进制转为十六进制 将二进制数从右往左每四位一组，不足四位则在左侧补0，得到若干个四位二进制数。 将每个四位二进制数转换为对应的十六进制数 十六进制转为二进制 将十六进制中的每个数字转换成4个二进制位 原码反码补码byte与bit byte（字节）是计算机存储和处理数据的基本单位，通常由8个比特（bit）组成。每个比特（bit）是计算机中最小的存储单位，只能存储0或1两个状态。因此，一个字节（byte）可以存储8个比特（bit）的数据。 两者之间的关系是，1 byte = 8 bit，即8个比特（bit）组成一个字节（byte）。 在计算机中，数据通常以字节（byte）为单位进行存储和传输，而比特（bit）则是用来表示数据的最小单位。 1KB = 1024byte 1MB = 1024KB 1GB = 1024MB 1TB = 1024GB 原码反码补码 原码反码补码是计算机二进制的三种表示形式。 计算机在底层都是采用二进制补码形式表示的。 二进制位最高位称为符号位，0为正数，1为负数。 正数的原码反码补码 正数的原码反码补码是相同的。 127的原码反码补码分别是多少？都是0111 1111 负数的原码反码补码 负数的原码运算规则：将绝对值转换为二进制后，最高位改为1。 -5的原码：10000101 -5的反码：11111010（原则是：以原码作为参考，符号位不变，其他位取反。） -5的补码：11111011（原则是：以反码作为参考，符号位不变，加1） -20的原码反码补码是多少？ -128的原码反码补码是多少？ -128的原码和补码都是1000 0000 已知负数补码怎么得到原码 虽然计算机底层是采用补码的形式存储的，但最终显示给人类的时候是以原码的形式显示的。 将负数的补码形式除符号位外的所有位按位取反，再加1即可得到原码。 已知补码：10000001 它的原码是：11111111 结果是：-127 通过这个可以得出，对于一个字节来说，最大值127，最小值-128。 计算机底层为什么采用补码 可以简化电路设计：采用补码形式可以将加减法运算转化为相同的操作，从而简化电路设计。 解决了0的正负问题：在原码中，0有两个表示，+0和-0，这样会导致计算结果不唯一，而在补码中，0只有一种表示，即全0，可以避免这个问题。 解决了负数溢出问题：在原码中，负数的表示范围比正数少1，这样在进行减法运算时容易出现负数溢出的情况，而在补码中，负数的表示范围与正数相同，可以避免负数溢出的问题。 方便计算机进行运算：补码形式可以方便计算机进行加减法运算，而且可以使用相同的电路进行运算，从而提高了计算机的运算效率。 可以计算一下 -3 + 2，看看能不能理解。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaofanshutu.github.io/categories/Java/"}],"tags":[]},{"title":"Java开发环境搭建","slug":"动力节点Java/Chapter1_Java开发环境搭建","date":"2025-06-08T21:33:49.327Z","updated":"2025-06-08T23:23:09.086Z","comments":true,"path":"posts/77a3ba8f.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/77a3ba8f.html","excerpt":"常用的windows组合键 win + D 回到桌面 win + E 打开资源管理器 win + R 打开运行窗口 win + L 锁屏 alt + tab 应用之间的切换 常用的DOS命令 打开DOS命令窗口 win + R，输入cmd cmd是commond单词的缩写。 怎么在DOS命令窗口中完成复制和粘贴？ 鼠标左键选中要复制的内容，再点击鼠标右键 在任意空白处，鼠标右键，即可粘贴 什么是当前路径？ 假设进入DOS命令窗口时显示的是：C:\\Users\\Administrator&gt;。那么当前路径就是：C:\\Users\\Administrator 常用DOS命令： dir：列出当前路径下所有的文件以及目录。 cls：clear screen清屏。 exit：退出DOS命令窗口。 切换盘符：c: 或者 d: 或者e: del：删除一个文件或者多个文件。del Test.java del *.java ipconfig以及ipconfig /all：查看网卡的相关信息，例如ip地址，mac地址等。 ping命令：查看两台计算机之间是否可以正常通信 ping 192.168.137.101 ping 192.168.137.101 -t ping www.baidu.com ping www.baidu.com -t 终止DOS命令窗口中某个命令的执行：ctrl + c mkdir：创建目录 mkdir abc，表示在当前目录下新建一个目录：abc rd：删除目录 rd abc，表示删除当前路径下的abc目录 ren：重命名 ren abc xyz，表示将当前路径下的abc目录名修改为xyz cd命令： 作用是：切换目录。change directory cd命令的用法：cd 路径 路径包括： 相对路径：相对路径一定是相对于当前路径而言的，以当前路径为基准，从当前所在的位置开始找。 绝对路径：在windows当中，路径开始的时候，是以盘符开始的，都是绝对路径。例如：C:\\Users\\Administrator\\xyz\\abc\\def cd .. 回到上级目录 （在windows系统中两个点.. 代表的是一个上级目录。扩展：其实还有一个路径叫做一个点 . 一个点代表的是当前路径。） cd / 回到跟目录 注意：路径在windows当中自动补全：使用tab键。 定时关机： shutdown -s -t 3600 一小时之后自动关机。 批处理文件 my.bat文件 123cd C:\\Users\\Administrator\\xyz\\abc\\defc:del *.java 作用：切换到C:\\Users\\Administrator\\xyz\\abc\\def目录下，删除这个目录中所有的java文件。 通用的文本编辑快捷键ctrl+c 复制 ctrl+v 粘贴 ctrl+x 剪切 ctrl+s 保存","text":"常用的windows组合键 win + D 回到桌面 win + E 打开资源管理器 win + R 打开运行窗口 win + L 锁屏 alt + tab 应用之间的切换 常用的DOS命令 打开DOS命令窗口 win + R，输入cmd cmd是commond单词的缩写。 怎么在DOS命令窗口中完成复制和粘贴？ 鼠标左键选中要复制的内容，再点击鼠标右键 在任意空白处，鼠标右键，即可粘贴 什么是当前路径？ 假设进入DOS命令窗口时显示的是：C:\\Users\\Administrator&gt;。那么当前路径就是：C:\\Users\\Administrator 常用DOS命令： dir：列出当前路径下所有的文件以及目录。 cls：clear screen清屏。 exit：退出DOS命令窗口。 切换盘符：c: 或者 d: 或者e: del：删除一个文件或者多个文件。del Test.java del *.java ipconfig以及ipconfig /all：查看网卡的相关信息，例如ip地址，mac地址等。 ping命令：查看两台计算机之间是否可以正常通信 ping 192.168.137.101 ping 192.168.137.101 -t ping www.baidu.com ping www.baidu.com -t 终止DOS命令窗口中某个命令的执行：ctrl + c mkdir：创建目录 mkdir abc，表示在当前目录下新建一个目录：abc rd：删除目录 rd abc，表示删除当前路径下的abc目录 ren：重命名 ren abc xyz，表示将当前路径下的abc目录名修改为xyz cd命令： 作用是：切换目录。change directory cd命令的用法：cd 路径 路径包括： 相对路径：相对路径一定是相对于当前路径而言的，以当前路径为基准，从当前所在的位置开始找。 绝对路径：在windows当中，路径开始的时候，是以盘符开始的，都是绝对路径。例如：C:\\Users\\Administrator\\xyz\\abc\\def cd .. 回到上级目录 （在windows系统中两个点.. 代表的是一个上级目录。扩展：其实还有一个路径叫做一个点 . 一个点代表的是当前路径。） cd / 回到跟目录 注意：路径在windows当中自动补全：使用tab键。 定时关机： shutdown -s -t 3600 一小时之后自动关机。 批处理文件 my.bat文件 123cd C:\\Users\\Administrator\\xyz\\abc\\defc:del *.java 作用：切换到C:\\Users\\Administrator\\xyz\\abc\\def目录下，删除这个目录中所有的java文件。 通用的文本编辑快捷键ctrl+c 复制 ctrl+v 粘贴 ctrl+x 剪切 ctrl+s 保存 ctrl+z 撤销 ctrl+y 重做 ctrl+a 全选 home 光标回到行首 end 光标回到行尾 ctrl + home 光标回到文章开始 ctrl + end 光标回到文章末尾 shift + home 或 end 选中一行 鼠标双击 （选中一个单词） ctrl + shift + 右箭头或左箭头 （选中一个单词） ctrl + f 查找 Java语言概述Java SE（Java Standard Edition）是Java的标准版，它包含了Java语言的核心部分，包括基础类库、虚拟机和开发工具等。Java SE主要用于开发桌面应用程序、控制台程序和小型服务器端应用程序等。 Java EE（Java Enterprise Edition）是Java的企业版，它是在Java SE的基础上扩展而来，主要用于开发大型企业级应用程序，如电子商务系统、ERP系统和CRM系统等。Java EE包含了许多企业级技术，如Servlet、JSP、EJB、JMS、JTA等。 Java ME（Java Micro Edition）是Java的微型版，它主要用于嵌入式设备和移动设备上的应用程序开发，如手机、平板电脑、数码相机、路由器等。Java ME的特点是体积小、速度快、资源占用少，可以在较小的内存和处理能力的设备上运行。 Java语言特点简单易学：Java语言的语法和C语言很相似，但是它去掉了C中的复杂的指针和多重继承等特性，使得Java语言更加简单易学。 面向对象：Java语言是一种纯面向对象的编程语言，它支持对象的封装、继承和多态等面向对象的特性。 平台无关性&gt;（跨平台性：一次编译，到处运行）：Java语言的程序可以在不同的操作系统和硬件平台上运行，这是因为Java程序被编译成字节码，而不是机器码，字节码可以在任何支持Java虚拟机的平台上运行。 实现原理：不同的操作系统上安装属于自己的Java虚拟机，而Java虚拟机屏蔽了各个操作系统之间的差异，从而做到跨平台。 安全性：Java语言具有很高的安全性，它提供了一系列的安全措施来保护程序不受恶意攻击和病毒侵害。 高性能：Java语言具有很高的性能，它采用了一系列优化措施来提高程序的执行速度和内存使用效率。 多线程支持：Java语言具有很好的多线程支持，它提供了一系列的线程控制机制，使得程序可以更好地利用计算机的多核处理能力。 自动垃圾回收机制：Java语言采用的是垃圾回收机制（Garbage Collection，简称GC），也就是自动内存管理机制。在传统的编程语言中，程序员需要手动分配和释放内存，容易出现内存泄漏和悬挂指针等问题。而Java语言采用的垃圾回收机制可以自动分配和释放内存，避免了内存泄漏和悬挂指针等问题。 JDK的加载与执行原理 包含两个阶段：编译阶段和运行阶段。Java既是编译型语言，又是解释型语言 编译阶段和运行阶段可以在不同的操作系统上完成。 编译后删除java源程序，不会影响程序的执行。 生成的class文件如果是A.class，则类名为A。如果是Hello.class，则类名为Hello。 javac是负责编译的命令（检查语法规则），java是负责运行的命令。 class文件不是机器码，操作系统无法直接执行。只有JVM才能看懂。 JVM会把class字节码解释为机器码，这样操作系统才能看懂。 JDK(Java Development Kit)、JRE(Java Runtime Environment)、JVM(Java Virtual Machine)分别是什么？他们的关系是什么？ JDK包含JRE，JRE里面有JVM JVM其实就是一个规范 第一个Java程序JDK的下载与安装 环境变量PATH的配置 JDK的重点目录介绍 ​ bin：该目录主要存放命令 ​ lib：该目录主要存放JDK的类库 ​ lib/src.zip：JDK源码 第一个Java程序的编写 第一个Java程序的编译 ​ javac命令的使用：javac 后面可以跟相对路径或者绝对路径（有盘符就是绝对路径） 第一个Java程序的运行 ​ java命令的使用 理解环境变量CLASSPATH ​ 类加载器（ClassLoader） ​ CLASSPATH是给Java的类加载器指路的 PATH环境变量 path环境变量不是java的，隶属于windows操作系统 path环境变量的作用是什么？ 在path中有很多路径，路径和路径之间采用 分号（;） 隔开 在DOS命令窗口中输入一个DOS命令之后，windows会先从当前路径下找这个命令，如果找不到，则会去环境变量PATH的路径中查找该命令，找到则执行，找不到，则报错。 PATH环境变量实际上就是给windows操作系统指路的。 编写第一个Java程序在硬盘的任何位置，新建一个java源文件，起名：HelloWorld.java 12345public class HelloWorld { public static void main(String[] args){ System.out.println(\"Hello World!\"); }} 编译第一个java程序 使用javac命令来编译。首先确保javac命令能用。 javac命令怎么用，语法是什么？ javac java源文件的路径 javac java源文件的相对路径 javac java源文件的绝对路径 运行第一个Java程序 使用java命令来运行程序，首先确保java命令可以用。 java命令怎么用？语法格式是什么？ java 类名（比如：java HelloWorld） 切记切记切记~！！！！！！！！！ java命令后面跟的不是文件路径。java命令后面跟的是类名 什么是类名？ A.class，类名是A HelloWorld.class，类名是HelloWorld Test.class，类名是：Test 要使用java命令，首先DOS命令窗口中的当前路径必须切换到class文件所在的位置。 掌握环境变量CLASSPATH classpath环境变量是隶属于Java语言的。不是windows操作系统的。和PATH环境变量完全不同。 classpath环境变量是给classloader（类加载器）指路的。 java A。执行后。先启动JVM，JVM启动classloader，classloader去硬盘上通过classpath找A.class文件。找到则执行，找不到则报错。 如果classpath没有配置的话，默认从当前路径下找class字节码文件。 如果classpath配置了，例如配置到桌面上了：C:\\Users\\Administrator\\Desktop，那么classloader以后就只会去桌面上找字节码文件了，不再从当前路径下找了。 注意，如果classpath配置为：classpath=.;C:\\Users\\Administrator\\Desktop 是什么意思呢？ 先让类加载器从当前路径下找，如果找不到的话，去C:\\Users\\Administrator\\Desktop找。 关于编译时的乱码问题 当java源文件中有中文时，用EditPlus工具写代码，最后会出现中文乱码问题，为什么？ EditPlus默认是简体中文GBK。 java21的javac编译器采用的是UTF-8的编码方式进行编译。 编码不一致，所以乱码了。 怎么解决？ 第一种方案：编译的时候用特定字符集编译 javac -encoding GBK HelloWorld2.java 第二种方案： 将editplus的字符集修改为UTF-8 java中的三种注释123// 单行注释// 单行注释// 单行注释 1234/* 多行注释 多行注释*/ 123456/*** javadoc注释，可以给javadoc命令解析提取并生成帮助文档* @author qingya* @version 1.0* @since 1.0*/ 使用以下命令可以提取生成帮助文档： 1javadoc -d docs -author -version -encoding utf-8 HelloWorld.java public class与class的区别1234561. 一个Java源文件中可以定义多个class2. 编译之后，一个class就会对应生成一个class字节码文件3. 如果一个类是public的，类名必须和源文件名保持一致。4. public的类可以没有。如果有的话，也只能有一个。5. 每个类中都可以编写入口main方法。想执行X类的main方法怎么办？java X6. 在实际的开发中，对于一个软件来说，一般入口只有1个。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaofanshutu.github.io/categories/Java/"}],"tags":[]},{"title":"","slug":"《疯狂Java讲义》/《疯狂Java讲义》 第一章","date":"2025-05-09T00:22:18.937Z","updated":"2025-06-08T23:23:09.088Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/0.html","excerpt":"《疯狂Java讲义》 第一章 第一个HelloWorld程序 javac -d . HelloWorld.java(javac -d destdir srcdir) destdir是.的时候表示将字节码生成到java文件所在的路径下。 java是区分大小写的","text":"《疯狂Java讲义》 第一章 第一个HelloWorld程序 javac -d . HelloWorld.java(javac -d destdir srcdir) destdir是.的时候表示将字节码生成到java文件所在的路径下。 java是区分大小写的","categories":[],"tags":[]},{"title":"IDEA常用快捷键","slug":"动力节点Java/IDEA快捷键 - 副本","date":"2025-04-12T10:43:43.493Z","updated":"2025-04-10T00:10:05.718Z","comments":true,"path":"posts/566321e7.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/566321e7.html","excerpt":"IDEA常用快捷键 单行注释：ctrl + / 多行注释：ctrl + shift + / 查看源码：按ctrl别松手，鼠标移动到对应的类名下方，出现下划线，点击过去，可以查看类源码。 多行编辑：按alt别松手，鼠标拖动多行，完成多行编辑。 怎么快速生成创建对象语句：类名.new.var 怎么快速生成if语句：布尔类型值.if 怎么快速生成setter和getter方法：alt + insert，然后选择setter and getter生成。 怎么快速生成构造方法：alt + insert，然后选择Constructor。 在IDEA当中如何自动纠错：将光标移动到错误的位置，按atl + enter。会有提示，根据提示进行纠错。 移动代码到上一行：alt + shift + 上/下方向 怎么快速重写方法？alt + insert，选择Override…. 怎么快速重写方法？ctrl + o 快速向下转型，并同时生成变量名：变量名.castvar 快速查看方法的参数：ctrl + p 返回上一步：ctrl + alt + 左方向键。 下一步：ctrl + alt + 右方向键。 代码格式化：ctrl + alt + L 查看继承结构：ctrl + H 自动代码包裹：ctrl + alt + t 快速运行程序 ctrl + shift + F10","text":"IDEA常用快捷键 单行注释：ctrl + / 多行注释：ctrl + shift + / 查看源码：按ctrl别松手，鼠标移动到对应的类名下方，出现下划线，点击过去，可以查看类源码。 多行编辑：按alt别松手，鼠标拖动多行，完成多行编辑。 怎么快速生成创建对象语句：类名.new.var 怎么快速生成if语句：布尔类型值.if 怎么快速生成setter和getter方法：alt + insert，然后选择setter and getter生成。 怎么快速生成构造方法：alt + insert，然后选择Constructor。 在IDEA当中如何自动纠错：将光标移动到错误的位置，按atl + enter。会有提示，根据提示进行纠错。 移动代码到上一行：alt + shift + 上/下方向 怎么快速重写方法？alt + insert，选择Override…. 怎么快速重写方法？ctrl + o 快速向下转型，并同时生成变量名：变量名.castvar 快速查看方法的参数：ctrl + p 返回上一步：ctrl + alt + 左方向键。 下一步：ctrl + alt + 右方向键。 代码格式化：ctrl + alt + L 查看继承结构：ctrl + H 自动代码包裹：ctrl + alt + t 快速运行程序 ctrl + shift + F10","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaofanshutu.github.io/categories/Java/"}],"tags":[]},{"title":"集合","slug":"动力节点Java/Chapter7_集合","date":"2025-04-11T12:10:19.347Z","updated":"2025-04-29T14:08:56.210Z","comments":true,"path":"posts/d366874c.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/d366874c.html","excerpt":"集合概述 Java集合中存储的是引用，存的不是堆中的对象。堆中的对象的地址存储到了集合中。 默认情况下，如果不使用泛型，集合中可以存储任何类型的引用。（只要是Object类的子类都可以存储） Java集合框架相关的类都在java.util包下。 Java集合框架分为两部分： Collection结构：元素以单个形式存储。 Map结构：元素以键值对的映射关系存储。 Collection继承结构 上图6个蓝色的实现类中，只有HashSet是无序集合，其他都是有序集合。 有序集合：集合中存储的元素有下标 或者 集合中存储的元素是可排序的 无序集合： 集合中存储的元素没有下标 并且 集合中存储的元素也没有排序 每个集合实现类对应的数据结构： 集合类型 数据结构 描述 ArrayList 数组 一种可以动态增长和缩减的索引序列 LinkedList 双向链表（不是队列结构，但是可以用它模拟队列） 一种可以在任何位置进行高效插入和删除操作的有序序列 Vector 数组（线程安全） HashSet 哈希表 一种没有重复元素的无序集合 LinkedHashSet 双向链表+哈希表 一种可以记住元素插入次序的集 TreeSet 红黑树 一种有序集 List集合中存储的元素可以重复，Set集合中的元素不可重复。 Collection接口的常用方法 方法 描述 boolean add(E e); 向集合中添加元素 int size(); 获取集合中元素个数 boolean addAll(Collection c); 将参数集合中所有元素全部加入当前集合 boolean contains(Object o); 判断集合中是否包含对象o boolean remove(Object o); 从集合中删除对象o void clear(); 清空集合 boolean isEmpty(); 判断集合中元素个数是否为0 Object[] toArray(); 将集合转换成一维数组","text":"集合概述 Java集合中存储的是引用，存的不是堆中的对象。堆中的对象的地址存储到了集合中。 默认情况下，如果不使用泛型，集合中可以存储任何类型的引用。（只要是Object类的子类都可以存储） Java集合框架相关的类都在java.util包下。 Java集合框架分为两部分： Collection结构：元素以单个形式存储。 Map结构：元素以键值对的映射关系存储。 Collection继承结构 上图6个蓝色的实现类中，只有HashSet是无序集合，其他都是有序集合。 有序集合：集合中存储的元素有下标 或者 集合中存储的元素是可排序的 无序集合： 集合中存储的元素没有下标 并且 集合中存储的元素也没有排序 每个集合实现类对应的数据结构： 集合类型 数据结构 描述 ArrayList 数组 一种可以动态增长和缩减的索引序列 LinkedList 双向链表（不是队列结构，但是可以用它模拟队列） 一种可以在任何位置进行高效插入和删除操作的有序序列 Vector 数组（线程安全） HashSet 哈希表 一种没有重复元素的无序集合 LinkedHashSet 双向链表+哈希表 一种可以记住元素插入次序的集 TreeSet 红黑树 一种有序集 List集合中存储的元素可以重复，Set集合中的元素不可重复。 Collection接口的常用方法 方法 描述 boolean add(E e); 向集合中添加元素 int size(); 获取集合中元素个数 boolean addAll(Collection c); 将参数集合中所有元素全部加入当前集合 boolean contains(Object o); 判断集合中是否包含对象o boolean remove(Object o); 从集合中删除对象o void clear(); 清空集合 boolean isEmpty(); 判断集合中元素个数是否为0 Object[] toArray(); 将集合转换成一维数组 这里有疑问：为什么col.toArray()返回的是地址？？？ add(E e) &amp; size() &amp; toArray()12345678910Collection col = new ArrayList();//add(E e)col.add(\"zhangsan\");col.add(123);col.add(true);System.out.println(col); // [zhangsan, 123, true]System.out.println(col.toArray());// [Ljava.lang.Object;@1b6d3586//size()System.out.println(col.size());// 3 addAll(Collection c)123456//addAll(Collection c)Collection col2 = new ArrayList();col2.add(\"好好学习，天天向上\");col2.add(\"you are the best~\");col.addAll(col2); // 将col2中的元素添加到col中System.out.println(col); 遇到问题：控制台中文乱码 12345//addAll(Collection c)Collection col2 = new ArrayList();col2.add(\"hello~\");col.addAll(col2); // 将col2中的元素添加到col中System.out.println(col);// [zhangsan, 123, true, hello~] contains(Object o)123//contains(Object o)System.out.println(col.contains(\"zhangsan\")); // trueSystem.out.println(col.contains(new String(\"zhangsan\"))); // true remove(Object o)123System.out.println(col);//[zhangsan, 123, true, hello~]col.remove(\"zhangsan\"); // 删除元素System.out.println(col);//[123, true, hello~] clear() &amp; isEmpty()1234System.out.println(col);// [123, true, hello~]col.clear();System.out.println(col);// []System.out.println(col.isEmpty()); // true Collection集合的遍历第一步：获取当前集合依赖的迭代器对象 ​ Iterator it = collection.iterator(); 第二步：编写循环，循环条件：当前光标指向的位置是否存在元素。 ​ while(it.hasNext()){} 第三步：如果有，将光标指向的当前元素返回，并且将光标向下移动一位。 ​ Object obj = it.next(); 泛型 泛型是Java5的新特性，属于编译阶段的功能。 泛型可以让开发者在编写代码时指定集合中存储数据的数据类型。 泛型作用： 类型安全：指定类型后，编译期会在编译阶段进行类型检查。如果尝试将错误的类型加入集合中，则会在编译阶段报错。避免了在运行时出现类型错误的问题。 代码简洁：使用泛型后可以简化代码，避免了繁琐的类型转换操作。没有泛型的时候，需要使用Object类型来保存集合中的元素，在使用时需要强制类型转换成实际类型。 在集合中使用泛型 12Collection&lt;String&gt; strs = new ArrayList&lt;String&gt;();//这就表示该集合只能存储字符串，存储其它类型时编译器报错。并且以上代码使用泛型后，避免了繁琐的类型转换，集合中的元素可以直接调用String类特有的方法。 Java7的新特性：钻石表达式 1Collection&lt;String&gt; strs = new ArrayList&lt;&gt;(); 泛型擦除与补偿 泛型的出现提高了编译时的安全性，正因为编译时对添加的数据做了检查，则程序运行时才不会抛出类型转换异常。因此泛型本质上是编译时期的技术，是专门给编译器用的。加载类的时候，会将泛型擦除掉（擦除之后的类型为Object类型），这个称为泛型擦除。 为什么要有泛型擦除呢？其本质是为了让JDK1.4和JDK1.5能够兼容同一个类加载器。在JDK1.5版本中，程序编译时期会对集合添加的元素进行安全检查，如果检查完是安全的、没有错误的，那么就意味着添加的元素都属于同一种数据类型，则加载类时就可以把这个泛型擦除掉，将泛型擦除后的类型就是Object类，这样擦除之后的代码就与JDK1.4的代码一致。 由于加载类的时候，会默认将类中的泛型擦除为Object类型，所以添加的元素就被转化为Object类型，同时取出的元素也默认为Object类型。而我们获得集合中的元素时，按理说取出的元素应该是Object类型，为什么取出的元素却是实际添加的元素类型呢？ 这是因为这里又做了一个默认的操作，我们称之为泛型的补偿。在程序运行时，通过获取元素的实际类型进行强转，这就叫做泛型补偿（不必手动实现强制转换）。获得集合中的元素时，虚拟机会根据获得元素的实际类型进行向下转型，也就是会恢复获得元素的实际类型，因此我们就无需手动执行向下转型操作，从本质上避免了抛出类型转换异常。 泛型的使用在类上定义泛型123456789101112131415161718192021222324252627282930313233343536package com.powernode.javase.collection.Summer;public class MyAnimal&lt;String, Integer&gt; { private String name; private int age; public MyAnimal(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public java.lang.String toString() { return \"MyAnimal{\" + \"name=\" + name + \", age=\" + age + '}'; }} 1234567//这种可以直接调用String或者Integer类特有的方法（因为声明泛型的时候直接指定了泛型类型是String和Object）MyAnimal&lt;String, Integer&gt; myAnimal = new MyAnimal&lt;&gt;(\"dog\", 2);System.out.println(myAnimal.getName().charAt(1));//这种的不能直接调用String或者Integer类特有的方法MyAnimal&lt;Object, Object&gt; myAnimal1 = new MyAnimal&lt;&gt;(\"cat\", 0);//myAnimal1.getName().charAt(1); 调用不了这个方法 在静态方法上定义泛型 在类上定义的泛型，在静态方法中无法使用。 如果在静态方法中使用泛型，则需要在方法返回值类型前面进行泛型的声明。 语法格式：&lt;泛型1, 泛型2, 泛型3, …&gt; 返回值类型 方法名(形参列表) {} 12345678910111213141516171819public class A { private static &lt;T&gt; void print(T[] t) { for (T t1 : t) { System.out.println(t1); } } public static void main(String[] args) { String[] strs = {\"a\", \"b\", \"c\"}; Integer[] ints = {1, 2, 3}; Double[] doubles = {1.1, 2.2, 3.3}; A.print(strs); System.out.println(\"==========\"); A.print(ints); System.out.println(\"==========\"); A.print(doubles); }} 结果： 1234567891011abc==========123==========1.12.23.3 在接口上定义泛型语法格式：interface 接口名&lt;泛型1,泛型2,…&gt; {} 例如：public interface Flayable &lt;T&gt; {} 实现接口时，如果知道具体的类型，则：public class MyClass implements Flyable &lt;Bird&gt; {} 实现接口时，如果不知道具体的类型，则：public class MyClass &lt;T&gt; implements Flyable &lt;T&gt; {} 123456/* 定义一个泛型接口*/public interface MyFlyable&lt;T&gt; { void fly(T t);} 123456789/* B类实现接口时，指定具体类型为Bird*/public class B implements MyFlyable&lt;Bird&gt; { @Override public void fly(Bird bird) { System.out.println(\"Bird \" + bird.getName() + \" is flying.\"); }} ​ 123456789101112131415/* C类实现接口时，未指定具体类型*/class C&lt;T&gt; implements MyFlyable&lt;T&gt; { @Override public void fly(T t) { if (t instanceof Bird) { System.out.println(\"Bird \" + ((Bird) t).getName() + \" is flying.\"); } else if (t instanceof Dragon) { System.out.println(\"Dragon \" + ((Dragon) t).getName() + \" is flying.\"); } else { System.out.println(\"Unknown type is flying.\"); } }} 12345678910111213 public static void main(String[] args) { Bird bird = new Bird(\"xiaohuangli\"); Dragon dragon = new Dragon(\"xiaolongren\"); B b = new B(); b.fly(bird); //会报错,因为B类只接受Bird类型的参数// b.fly(dragon); C c = new C(); c.fly(dragon); c.fly(bird); } 结果： 123Bird xiaohuangli is flying.Dragon xiaolongren is flying.Bird xiaohuangli is flying. 泛型通配符(泛型的使用，不属于定义了) 无限定通配符，&lt;?&gt;，此处“？”可以为任意引用数据类型。 上限通配符，&lt;? extends Number&gt;，此处“？”必须为Number及其子类。 下限通配符，&lt;? super Number&gt;，此处“？”必须为Number及其父类。 123456789101112131415161718192021222324252627282930313233343536373839404142public class Test { public static void main(String[] args) { //什么类型都可以接收 print(new ArrayList&lt;String&gt;()); print(new ArrayList&lt;Object&gt;()); print(new ArrayList&lt;Integer&gt;()); //报错，这里需要的是BB或者BB的子类 //print2(new ArrayList&lt;AA&gt;()); print2(new ArrayList&lt;BB&gt;()); print2(new ArrayList&lt;CC&gt;()); print3(new ArrayList&lt;AA&gt;()); print3(new ArrayList&lt;BB&gt;()); //报错，这里需要的是BB或者BB的父类 //print3(new ArrayList&lt;CC&gt;()); } static void print(ArrayList&lt;?&gt; list){ System.out.println(list); } static void print2(ArrayList&lt;? extends BB&gt; list){ System.out.println(list); } static void print3(ArrayList&lt;? super BB&gt; list){ System.out.println(list); }}class AA{}class BB extends AA{}class CC extends BB{} 迭代时删除元素 迭代集合时删除元素 使用“集合对象.remove(元素)”：会出现ConcurrentModificationException异常。 使用“迭代器对象.remove()”：不会出现异常。 如何解决并发修改问题？答案：fail-fast机制 fail-fast机制又被称为“快速失败机制”。只要程序发现对集合进行了并发修改，就会立即让其失败，以防出错。 fail-fast机制是如何实现的？ 集合中设置了一个modCount属性，用来记录修改次数，使用集合对象执行增，删，改中任意一个操作时，modCount就会自动加1。 获取迭代器对象的时候，会给迭代器对象初始化一个expectedModCount属性。并且将expectedModCount初始化为modCount，即：int expectedModCount = modCount; 当使用集合对象删除元素时：modCount会加1。但是迭代器中的expectedModCount不会加1。而当迭代器对象的next()方法执行时，会检测expectedModCount和modCount是否相等，如果不相等，则抛出：ConcurrentModificationException异常。 当使用迭代器删除元素的时候：modCount会加1，并且expectedModCount也会加1。这样当迭代器对象的next()方法执行时，检测到的expectedModCount和modCount相等，则不会出现ConcurrentModificationException异常。 注意：虽然我们当前写的程序是单线程的程序，并没有使用多线程，但是通过迭代器去遍历的同时使用集合去删除元素，这个行为将被认定为并发修改。 结论：迭代集合时，删除元素要使用“迭代器对象.remove()”方法来删除，避免使用“集合对象.remove(元素)”。主要是为了避免ConcurrentModificationException异常的发生。注意：迭代器的remove()方法删除的是next()方法的返回的那个数据。remove()方法调用之前一定是先调用了next()方法，如果不是这样的，就会报错。 获取迭代器对象的时候，会给迭代器对象初始化一个expectedModCount属性。并且将expectedModCount初始化为modCount，即：int expectedModCount = modCount; ​ java.util.ArrayList#iterator 123456789101112131415161718public static void main(String[] args) { ArrayList&lt;Integer&gt; integers = new ArrayList&lt;&gt;(); integers.add(1); integers.add(2); integers.add(3); Iterator&lt;Integer&gt; iterator = integers.iterator(); while (iterator.hasNext()) { Integer integer = iterator.next(); if(integer == 2) { iterator.remove(); } } for (Integer integer : integers) { System.out.println(integer); }} 结果： 1213 123456789101112131415161718public static void main(String[] args) { ArrayList&lt;Integer&gt; integers = new ArrayList&lt;&gt;(); integers.add(1); integers.add(2); integers.add(3); Iterator&lt;Integer&gt; iterator = integers.iterator(); while (iterator.hasNext()) { Integer integer = iterator.next(); if(integer == 2) { integers.remove(integer);//没有异常，为什么 } } for (Integer integer : integers) { System.out.println(integer); }} List接口List接口常用方法 List集合存储的元素特点：有序可重复 List接口下的常见实现类： ArrayList：数组 Vector, Stack：数组（且线程安全） LinkedList：双向链表 List接口特有方法 序号 方法 描述 1 void add(int index, E element) 在指定索引处插入元素 2 E set(int index, E element) 修改索引处的元素 3 E get(int index) 根据索引获取元素（因为有这个方法，所以可以根据下标遍历List集合） 4 E remove(int index) 删除索引处的元素 5 int indexOf(Object o) 获取对象o在当前集合中第一次出现时的索引。 6 int lastIndexOf(Object o) 获取对象o在当前集合中最后一次出现时的索引。 7 List subList(int fromIndex, int toIndex) 截取子List集合生成一个新集合（对原集合无影响）。[fromIndex, toIndex) 8 static List of(E… elements) 静态方法，返回包含任意数量元素的不可修改列表。（获取的集合是只读的，不可修改的。） 测试1：在指定索引处添加元素 12345678910111213141516171819202122public class ListTest02 { public static void main(String[] args) { // 创建List集合对象 List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 添加元素 list.add(\"1\"); list.add(\"2\"); list.add(\"3\"); list.add(\"4\"); list.add(\"5\"); list.add(\"6\"); // 在指定位置添加元素 list.add(1, \"张三\"); Iterator&lt;String&gt; iterator = list.iterator(); while (iterator.hasNext()) { String next = iterator.next(); System.out.println(next); } }} 12345671张三23456 测试2和3 1234567891011121314151617181920212223public class ListTest02 { public static void main(String[] args) { // 创建List集合对象 List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 添加元素 list.add(\"1\"); list.add(\"2\"); list.add(\"3\"); list.add(\"4\"); list.add(\"5\"); list.add(\"6\"); //修改索引处的元素 list.set(1, \"李四\"); System.out.println(\"下标为2的元素是：\" + list.get(2)); Iterator&lt;String&gt; iterator = list.iterator(); while (iterator.hasNext()) { String next = iterator.next(); System.out.println(next); } }} 1234567下标为2的元素是：31李四3456 通过下标遍历List集合 12345678910111213public static void main(String[] args) { ArrayList&lt;String&gt; animals = new ArrayList&lt;&gt;(); animals.add(\"Dog\"); animals.add(\"Cat\"); animals.add(\"Bird\"); animals.add(\"Fish\"); animals.add(\"Lizard\"); for (int i = 0; i &lt; animals.size(); i++) { String animal = animals.get(i); System.out.println(animal); }} 结果： 12345DogCatBirdFishLizard 测试subList 12345678910111213141516public static void main(String[] args) { List&lt;String&gt; animals = new ArrayList&lt;&gt;(); animals.add(\"Dog\"); animals.add(\"Cat\"); animals.add(\"Bird\"); animals.add(\"Fish\"); animals.add(\"Lizard\"); List&lt;String&gt; newAnimals = new ArrayList&lt;&gt;(); newAnimals = animals.subList(2, 4); //实际获取到的是下标2和3的元素 ListIterator&lt;String&gt; listIterator = newAnimals.listIterator(); while (listIterator.hasNext()) { String next = listIterator.next(); System.out.println(next); }} 结果： 12BirdFish 测试of(E… elements) ❓疑问：这里为什么是? extends Serializable，这个代码是我的Idea自动生成的 1234List&lt;? extends Serializable&gt; hello = List.of(1, 3, 4, 5, \"hello\", true, 1.2f);for (Serializable s : hello) { System.out.println(s);} 结果： 12345671345hellotrue1.2 List接口特有迭代器 特有的迭代方式 方法 描述 ListIterator listIterator() 获取List集合特有的迭代器（该迭代器功能更加强大，但只适合于List集合使用） ListIterator listIterator(int index) 从列表中的指定位置开始，返回列表中元素的列表迭代器 ListIterator接口中常用方法 方法 描述 boolean hasNext() 判断光标当前指向的位置是否存在元素。 E next() 将当前光标指向的元素返回，然后将光标向下移动一位。 void remove() 删除上一次next()方法返回的那个数据(删除的是集合中的)。remove()方法调用的前提是：先调用next()方法。否则会报错。 void add(E e) 添加元素（将元素添加到光标指向的位置，然后光标向下移动一位。） boolean hasPrevious() 判断当前光标指向位置的上一个位置是否存在元素。 E previous() 获取上一个元素（将光标向上移动一位，然后将光标指向的元素返回） int nextIndex() 获取光标指向的那个位置的下标 int previousIndex() 获取光标指向的那个位置的上一个位置的下标 void set(E e) 修改的是上一次next()方法返回的那个数据（修改的是集合中的）。set()方法调用的前提是：先调用了next()方法。否则会报错。 hasNext()：判断光标当前指向的位置是否存在元素 12345678910111213List&lt;String&gt; animals = new ArrayList&lt;&gt;();animals.add(\"Dog\");animals.add(\"Cat\");animals.add(\"Bird\");animals.add(\"Fish\");animals.add(\"Lizard\");//测试hasNext()ListIterator&lt;String&gt; iterator = animals.listIterator();while (iterator.hasNext()) { String animal = iterator.next(); System.out.println(animal);} 结果： 12345DogCatBirdFishLizard nextIndex()：获取光标指向的那个位置的下标 previousIndex()：获取光标指向的那个位置的上一个位置的下标 12345678910111213List&lt;String&gt; animals = new ArrayList&lt;&gt;();animals.add(\"Dog\");animals.add(\"Cat\");animals.add(\"Bird\");animals.add(\"Fish\");animals.add(\"Lizard\");ListIterator&lt;String&gt; iterator = animals.listIterator();//测试nextIndex()System.out.println(\"Next index: \" + iterator.nextIndex());//0//测试previousIndex()System.out.println(\"Previous index: \" + iterator.previousIndex());//-1 remove()：删除上一次next()方法返回的那个数据(删除的是集合中的)。remove()方法调用的前提是：你先调用next()方法。不然会报错。 1234567891011List&lt;String&gt; animals = new ArrayList&lt;&gt;();animals.add(\"Dog\");animals.add(\"Cat\");animals.add(\"Bird\");animals.add(\"Fish\");animals.add(\"Lizard\");ListIterator&lt;String&gt; iterator = animals.listIterator();//测试remove()iterator.remove();//java.lang.IllegalStateException add(E e)：将元素添加到光标的位置，然后光标向下移动一位 12345678910111213141516List&lt;String&gt; animals = new ArrayList&lt;&gt;();animals.add(\"Dog\");animals.add(\"Cat\");animals.add(\"Bird\");animals.add(\"Fish\");animals.add(\"Lizard\");ListIterator&lt;String&gt; iterator = animals.listIterator();while (iterator.hasNext()) { String animal = iterator.next(); if(\"Bird\".equals(animal)){ iterator.remove(); }}System.out.println(animals);// [Dog, Cat, Bird, Butterfly, Fish, Lizard] set(E e)：修改的是上一次next()方法返回的那个数据（修改的是集合中的）。set()方法调用的前提是：你先调用了next()方法。不然会报错 1234567891011121314151617List&lt;String&gt; animals = new ArrayList&lt;&gt;();animals.add(\"Dog\");animals.add(\"Cat\");animals.add(\"Bird\");animals.add(\"Fish\");animals.add(\"Lizard\");ListIterator&lt;String&gt; iterator = animals.listIterator();while (iterator.hasNext()) { String animal = iterator.next(); if(\"Bird\".equals(animal)){ iterator.set(\"Butterfly\"); }}System.out.println(animals);// [Dog, Cat, Butterfly, Fish, Lizard] List接口使用Comparator排序数组中自定义类型是如何排序的让自定义类型实现java.lang.Comparable接口，接着重写compareTo方法。在compareTo方法中指定比较规则。 123456789101112131415161718192021222324252627public class User implements Comparable&lt;User&gt; { private String name; public User(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public int compareTo(User user) { return this.name.compareTo(user.name); } @Override public String toString() { return \"User{\" + \"name='\" + name + '\\'' + '}'; }} 1234567891011121314import java.util.Arrays;public class ArraySort { public static void main(String[] args) { User jack = new User(\"Jack\"); User tom = new User(\"Tom\"); User lucy = new User(\"Lucy\"); User[] users = new User[]{jack, tom, lucy}; Arrays.sort(users); for (User user : users) { System.out.println(user.getName()); } }} 结果： 123JackLucyTom List集合的排序对list集合排序可以调用 default void sort(Comparator&lt;? super E&gt; c) ​ sort方法参数：java.util.Comparator（我们把这个叫比较器，这是一个接口） 提供一个Comparator的实现类，重写compare方法 1234567891011121314151617181920212223242526public class ListSort { public static void main(String[] args) { Person zhangsan = new Person(\"zhangsan\", 20); Person lisi = new Person(\"lisi\", 25); Person wangwu = new Person(\"wangwu\", 30); Person zhaoliu = new Person(\"zhaoliu\", 35); ArrayList&lt;Person&gt; people = new ArrayList&lt;Person&gt;(); people.add(zhangsan); people.add(lisi); people.add(wangwu); people.add(zhaoliu); System.out.println(\"Before sorting:\"); for (Person person : people) { System.out.println(person.getName() + \" \" + person.getAge()); } // Sort the list using the custom comparator people.sort(new PersonComparator()); System.out.println(\"\\nAfter sorting by name:\"); for (Person person : people) { System.out.println(person.getName() + \" \" + person.getAge()); } }} ​ 123456789101112131415161718192021222324252627282930313233public class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; }} 结果： 1234567891011Before sorting:zhangsan 20lisi 25wangwu 30zhaoliu 35After sorting by name:lisi 25wangwu 30zhangsan 20zhaoliu 35 采用匿名内部类的方式提供Comparator的实现类 1234567891011121314151617181920212223242526272829303132333435import java.util.ArrayList;import java.util.Comparator;public class ListSort2 { public static void main(String[] args) { Person zhangsan = new Person(\"zhangsan\", 20); Person lisi = new Person(\"lisi\", 25); Person wangwu = new Person(\"wangwu\", 30); Person zhaoliu = new Person(\"zhaoliu\", 35); ArrayList&lt;Person&gt; people = new ArrayList&lt;Person&gt;(); people.add(zhangsan); people.add(lisi); people.add(wangwu); people.add(zhaoliu); System.out.println(\"Before sorting:\"); for (Person person : people) { System.out.println(person.getName() + \" \" + person.getAge()); } // Sort the list using an anonymous inner class people.sort(new Comparator&lt;Person&gt;() { @Override public int compare(Person o1, Person o2) { return o2.getName().compareTo(o1.getName()); } }); System.out.println(\"\\nAfter sorting by name:\"); for (Person person : people) { System.out.println(person.getName() + \" \" + person.getAge()); } }} ArrayList 底层采用了数组数据结构 优点：底层是数组，因此根据下标查找元素的时间复杂度是O(1)，检索效率高 缺点：随机增删元素效率低。注意：只要数组的容量没有满，对末尾元素进行增删时，效率不会受影响 适用场景：需要频繁检索元素，并且很少进行随机增删元素时建议使用ArrayList 默认初始化容量： 当调用无参构造方法时，初始化容量为0，当第一次调用add方法时，会将ArrayList容量初始化为10个长度 扩容策略 底层扩容会创建一个新数组，然后使用数组拷贝。扩容之后的新容量是原容量的1.5倍 1234567891011private Object[] grow(int minCapacity) { int oldCapacity = elementData.length; if (oldCapacity &gt; 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { int newCapacity = ArraysSupport.newLength(oldCapacity, minCapacity - oldCapacity, /* minimum growth */ oldCapacity &gt;&gt; 1 /* preferred growth */); return elementData = Arrays.copyOf(elementData, newCapacity); } else { return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)]; }} 12345678910111213public static int newLength(int oldLength, int minGrowth, int prefGrowth) { // preconditions not checked because of inlining // assert oldLength &gt;= 0 // assert minGrowth &gt; 0 int prefLength = oldLength + Math.max(minGrowth, prefGrowth); // might overflow if (0 &lt; prefLength &amp;&amp; prefLength &lt;= SOFT_MAX_ARRAY_LENGTH) { return prefLength; } else { // put code cold in a separate method return hugeLength(oldLength, minGrowth); }} 集合源码分析 属性分析 123456789//The array buffer into which the elements of the ArrayList are stored. transient Object[] elementData; // non-private to simplify nested class access/** * The size of the ArrayList (the number of elements it contains). * * @serial */private int size; 构造方法分析（使用ArrayList时，最好预测一下最大数量，给定初始化容量，减少扩容次数） 添加元素 看上面扩容策略处的代码 修改元素: 修改元素时会将修改前的值返回 1E set(int index, E element); 123456public E set(int index, E element) { Objects.checkIndex(index, size); E oldValue = elementData(index); elementData[index] = element; return oldValue;} 12345678910111213141516public class ListSort { public static void main(String[] args) { Person zhangsan = new Person(\"zhangsan\", 20); Person lisi = new Person(\"lisi\", 25); Person wangwu = new Person(\"wangwu\", 30); Person zhaoliu = new Person(\"zhaoliu\", 35); List&lt;Person&gt; people = new ArrayList&lt;&gt;(); people.add(zhangsan); people.add(lisi); people.add(wangwu); people.add(zhaoliu); System.out.println(people.set(2, zhaoliu)); //Person{name='wangwu', age=30} }} 插入元素 删除元素 Vector Vector底层也是数组，和ArrayList相同。 不同的是Vector几乎所有的方法都是同步的（被synchronized修饰：线程排队执行，不能并发），因此Vector是线程安全的，但是因为效率低，所以很少使用。控制线程安全有新的方式，所以这个很少用。 初始化容量：10 扩容策略：扩容之后的容量是原容量的2倍。 链表存储结构 单向链表 双向链表 环形链表 链表优点 因为链表节点在空间存储上，内存地址不是连续的。因此删除某个节点时不需要涉及到元素位移的问题。因此随机增删元素效率较高。时间复杂度O(1) 链表缺点 链表中元素在查找时，只能从某个节点开始顺序查找，因为链表节点的内存地址在空间上不是连续的。链表查找元素效率较低，时间复杂度O(n) 适用场景 ​ 需要频繁进行随机增删，但很少的查找的操作时。 LinkedList LinkedList是一个双向链表 源码分析 属性分析 1234567891011transient int size = 0;/** * Pointer to first node. */transient Node&lt;E&gt; first;/** * Pointer to last node. */transient Node&lt;E&gt; last; 构造方法分析 添加元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public void add(int index, E element) { checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index));}void linkLast(E e) { final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;}/** * Inserts element e before non-null Node succ. */void linkBefore(E e, Node&lt;E&gt; succ) { // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++;}Node&lt;E&gt; node(int index) { // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) { Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; } else { Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; }} 1234567public E set(int index, E element) { checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;} 修改元素 1234567public E set(int index, E element) { checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;} 插入元素 12345678public void add(int index, E element) { checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index));} 删除元素 123456789101112131415161718192021222324252627282930public E remove(int index) { checkElementIndex(index); return unlink(node(index));}E unlink(Node&lt;E&gt; x) { // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) { first = next; } else { prev.next = next; x.prev = null; } if (next == null) { last = prev; } else { next.prev = prev; x.next = null; } x.item = null; size--; modCount++; return element;} 手写单向链表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167/** * 自定义的单向链表 */public class MyLinked&lt;E&gt; { /** * 元素个数 */ private int size; /** * 单向链表的头结点 */ private Node&lt;E&gt; first; /** * 构建一个空链表 */ public MyLinked() { } /** * 获取集合中元素的个数 * * @return 个数 */ public int size() { return size; } /** * 向单向链表的末尾添加一个元素。 * * @param data 数据 */ public void add(E data) { //如果first是空，表示是一个空链表 if (first == null) { first = new Node&lt;&gt;(data, null); size++; return; } Node&lt;E&gt; last = findLast(); Node&lt;E&gt; newNode = new Node&lt;&gt;(data, null); last.next = newNode; size++; } /** * 找到单向链表的末尾结点 * * @return 末尾结点 */ private Node&lt;E&gt; findLast() { if (first == null) { //空链表 return null; } Node&lt;E&gt; last = first; while (last.next != null) { //把last.next看做是最后一个结点 last = last.next; } return last; } /** * 将元素添加到指定索引处 * * @param index 下标 * @param data 数据 */ public void add(int index, E data) { Node&lt;E&gt; oldNode = node(index); if (index == 0) { first = new Node&lt;&gt;(data, first); } else { Node&lt;E&gt; newNode = new Node&lt;&gt;(data, oldNode); Node&lt;E&gt; prev = node(index - 1); prev.next = newNode; } size++; } /** * 返回索引处的结点对象 * * @param index 索引 * @return 结点对象 */ private Node&lt;E&gt; node(int index) { //假设头结点是下一个结点 Node&lt;E&gt; next = first; for (int i = 0; i &lt; index; i++) { next = next.next; } return next; } /** * 删除指定索引处的元素 * * @param index 索引 */ public void remove(int index) { if (index == 0) { first = first.next; } else { Node&lt;E&gt; pre = node(index - 1); Node&lt;E&gt; cur = node(index); pre.next = cur.next; cur.next = null; cur.item = null; } size--; } /** * 修改指定索引处的数据 * * @param index 索引 * @param data 数据 */ public void set(int index, E data) { node(index).item = data; } /** * 根据下标获取数据 * * @param index 下标 * @return 数据 */ public E get(int index) { return node(index).item; } /** * 单向链表当中的结点（建议定义为静态内部类。） */ private static class Node&lt;E&gt; { /** * 数据 */ E item; /** * 下一个结点的内存地址 */ Node&lt;E&gt; next; /** * 构造一个结点对象 * * @param item 结点中的数据 * @param next 下一个结点的内存地址。 */ public Node(E item, Node&lt;E&gt; next) { this.item = item; this.next = next; } }} 12345678910111213141516171819202122232425262728293031323334353637383940package com.powernode.javase.collection.Summer;public class MyLinkedTest { public static void main(String[] args) { MyLinked&lt;String&gt; myLinked = new MyLinked&lt;&gt;(); myLinked.add(\"hello\"); myLinked.add(\"world\"); myLinked.add(\"java\"); //遍历 traverseCollection(myLinked); //删除 System.out.println(\"-----------------\"); myLinked.remove(1); traverseCollection(myLinked); //修改 System.out.println(\"-----------------\"); myLinked.set(0, \"hello~hello~\"); traverseCollection(myLinked); //新增 System.out.println(\"-----------------\"); myLinked.add(1, \"world~world~\"); traverseCollection(myLinked); //查询 System.out.println(\"-----------------\"); String s = myLinked.get(2); System.out.println(s); } private static void traverseCollection(MyLinked&lt;String&gt; myLinked) { for (int i = 0; i &lt; myLinked.size(); i++) { String s = myLinked.get(i); System.out.println(s); } }} 123456789101112131415helloworldjava-----------------hellojava-----------------hello~hello~java-----------------hello~hello~world~world~java-----------------java 栈数据结构 LIFO原则（Last In, First Out）：后进先出 可以用数组实现栈数据结构，也可以用双向链表来实现。 用数组实现栈数据结构的代表有：Stack、ArrayDeque Stack：Vetor的子类，实现了栈数据结构，除了具有Vetor的方法，还扩展了其它方法，完成了栈结构的模拟。不过在JDK1.6（Java6）之后就不建议使用了，因为它是线程安全的，太慢了。Stack中的方法如下： E push(E item)：压栈 E pop()：弹栈（将栈顶元素删除，并返回被删除的引用） int search(Object o)：查找栈中元素（返回值的意思是：以1为开始，从栈顶往下数第几个） E peek()：窥视栈顶元素（不会将栈顶元素删除，只是看看栈顶元素是什么。注意：如果栈为空时会报异常。） ArrayDeque E push(E item) E pop() 用链表实现的代表是：LinkedList E push(E item) E pop() 队列数据结构 概念 队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，队列是一种操作受限制的线性表。进行插入操作（入口）的端称为队尾，进行删除操作（出口）的端称为队头。 队列的插入操作只能在队尾操作，队列的删除操作只能在队头操作，因此队列是一种先进先出（First In First Out）的线性表，简称FIFO表。 Queue接口是一种基于FIFO（先进先出）的数据结构，而Deque接口则同时支持FIFO和LIFO（后进先出）两种操作。因此Deque接口也被称为“双端队列”。 Java集合框架中队列的实现： 链表实现方式：LinkedList 数组实现方式：ArrayDeque ![image-20250418214047976](https://raw.githubusercontent.com/growingbambi/typora/master/image-20250418214047976.png) LinkedList和ArrayDeque都实现了Queue、Deque接口，因此这两个类都具备队列和双端队列的特性。 LinkedList底层是基于双向链表实现的，因此它天然就是一个双端队列，既支持从队尾入队，从队头出队，也支持从队头入队，从队尾出队。用Deque的实现方式来说，就是它既实现了队列的offer()和poll()方法，也实现了双端队列的offerFirst()、offerLast()、pollFirst()和pollLast()方法等。 ArrayDeque底层是使用环形数组实现的，也是一个双端队列。它比LinkedList更加高效，因为在数组中随机访问元素的时间复杂度是O(1)，而链表中需要从头或尾部遍历链表寻找元素，时间复杂度是O(N)。循环数组：index = (start + i) % capacity Queue接口基于Collection扩展的方法 方法 描述 boolean offer(E e); 入队 E poll(); 出队，如果队列为空，返回null。 E remove(); 出队，如果队列为空，抛异常。 E peek(); 查看队头元素，如果为空则返回null。 E element(); 查看对头元素，如果为空则抛异常。 Deque接口基于Queen接口扩展的方法 可以模拟队列的方法 描述 boolean offerLast(E e); 从队尾入队 E pollFirst(); 从队头出队 可以模拟双端队列的方法 描述 boolean offerLast(E e); 从队尾入队 E pollFirst(); 从队头出队 boolean offerFirst(E e); 从队头入队 E pollLast(); 从队尾出队 另外offerLast+pollLast或者pollFirst+offerFirst可以模拟栈数据结构。或者也可以直接调用push/pop方法。 Map继承结构 Map集合以key和value的键值对形式存储。key和value存储的都是引用。 Map集合中key起主导作用。value是附属在key上的。 SequencedMap是Java21新增的。 LinkedHashMap和TreeMap都是有序集合。（key是有序的） HashMap，Hashtable，Properties都是无序集合。（key是无序的） Map集合的key都是不可重复的。key重复的话，value会覆盖。 HashSet集合底层是new了一个HashMap。往HashSet集合中存储元素实际上是将元素存储到HashMap集合的key部分。HashMap集合的key是无序不可重复的，因此HashSet集合就是无序不可重复的。HashMap集合底层是哈希表/散列表数据结构，因此HashSet底层也是哈希表/散列表。 TreeSet集合底层是new了一个TreeMap。往TreeSet集合中存储元素实际上是将元素存储到TreeMap集合的key部分。TreeMap集合的key是不可重复但可排序的，因此TreeSet集合就是不可重复但可排序的。TreeMap集合底层是红黑树，因此TreeSet底层也是红黑树。它们的排序通过java.lang.Comparable和java.util.Comparator均可实现。 LinkedHashSet集合底层是new了一个LinkedHashMap。LinkedHashMap集合只是为了保证元素的插入顺序，效率比HashSet低，底层采用的哈希表+双向链表实现。 根据源码可以看到向Set集合中add时，底层会向Map中put。value只是一个固定不变的常量，只是起到一个占位符的作用。主要是key。 Map接口的常用方法 方法 描述 V put(K key, V value); 添加键值对 void putAll(Map&lt;? extends K,? extends V&gt; m); 添加多个键值对 V get(Object key); 通过key获取value boolean containsKey(Object key); 是否包含某个key boolean containsValue(Object value); 是否包含某个value V remove(Object key); 通过key删除key-value void clear(); 清空Map int size(); 键值对个数 boolean isEmpty(); 判断是否为空Map Collection values(); 获取所有的value Set keySet(); 获取所有的key Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(); 获取所有键值对的Set视图 static &lt;K,V&gt; Map&lt;K,V&gt; of(K k1, V v1, K k2, V v2, K k3, V v3); 静态方法，使用key-value构造map HashMap","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaofanshutu.github.io/categories/Java/"}],"tags":[]},{"title":"常用类_String类","slug":"动力节点Java/Chapter6_常用类_String类","date":"2025-04-10T23:38:26.701Z","updated":"2025-04-11T12:11:43.308Z","comments":true,"path":"posts/6dd21eef.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/6dd21eef.html","excerpt":"String初识 java.lang.String Java中String属于引用数据类型，代表字符串。 Java在堆中为字符串准备了字符串常量池。（是一种缓存技术，提高程序执行效率） ​ 注：字符串字面量在编译的时候就已经确定了将其放到字符串常量池中。JVM启动时会立即将程序中带有双引号的字符串字面量全部放入字符串常量池。 Java8之后字符串常量池存放在堆中，Java8之前字符串常量池在永久代。 字符串一旦创建是不可变的。 12@Stable private final byte[] value; String的拼接 动态拼接后新的字符串不会自动放到字符串常量池。 12345String str1 = \"abc\"; //字符串常量池String str2 = \"def\"; //字符串常量池String str3 = \"abcdef\"; //字符串常量池String str4 = str1 + str2; //运行时才会创建对象, str4在堆内存中System.out.println(str3 == str4); //false 两个字符串字面量拼接会做编译阶段的优化，在编译阶段就会进行字符串的拼接。","text":"String初识 java.lang.String Java中String属于引用数据类型，代表字符串。 Java在堆中为字符串准备了字符串常量池。（是一种缓存技术，提高程序执行效率） ​ 注：字符串字面量在编译的时候就已经确定了将其放到字符串常量池中。JVM启动时会立即将程序中带有双引号的字符串字面量全部放入字符串常量池。 Java8之后字符串常量池存放在堆中，Java8之前字符串常量池在永久代。 字符串一旦创建是不可变的。 12@Stable private final byte[] value; String的拼接 动态拼接后新的字符串不会自动放到字符串常量池。 12345String str1 = \"abc\"; //字符串常量池String str2 = \"def\"; //字符串常量池String str3 = \"abcdef\"; //字符串常量池String str4 = str1 + str2; //运行时才会创建对象, str4在堆内存中System.out.println(str3 == str4); //false 两个字符串字面量拼接会做编译阶段的优化，在编译阶段就会进行字符串的拼接。 1234//在字符串常量池中只有一个abcdefString str3 = \"abcdef\"; //字符串常量池String str5 = \"abc\" + \"def\"; //字符串常量池System.out.println(str3 == str5); //true String类的常用构造方法 String(char[] value)： 根据字符数组创建一个新的字符串对象。 123char[] chars = new char[]{'a', 'b', 'c'};String s = new String(chars);System.out.println(s);//abc String(char[] value, int offset, int count)： 根据字符数组的指定部分创建一个新的字符串对象。 123char[] chars = new char[]{'a', 'b', 'c', 'd', 'e', 'f'};String s = new String(chars, 1, 3);System.out.println(s);//bcd String(byte[] bytes)： 根据字节数组创建一个新的字符串对象，默认使用平台默认的字符集进行解码。 String(byte[] bytes, int offset, int length)： 根据字节数组的指定部分创建一个新的字符串对象，默认使用平台默认的字符集进行解码。 123byte[] bytes = new byte[]{97, 98, 99, 100, 101, 102};String str = new String(chars, 2, 3);System.out.println(str);//cde String(byte[] bytes, Charset charset)：根据字节数组和指定的字符集创建一个新的字符串对象。 如果编码和解码用到的字符集不一致，则会出现乱码。 new String(bytes, Charset.defaultCharset()); 123byte[] bytesArr = new byte[]{97, 98, 99, 100, 101, 102};String s5 = new String(bytesArr, Charset.defaultCharset());System.out.println(s5);//abcdef 12345// 先将字符串转换成byte[]数组（这个过程是一个编码的过程）byte[] bytes1 = \"你好旧时光\".getBytes(StandardCharsets.UTF_8);// 将以上的byte[]数组转换成字符串（这个过程是一个解码的过程）String s6 = new String(bytes1, StandardCharsets.UTF_8);System.out.println(s6);//你好旧时光 12345678// 乱码的本质：在进行编码和解码的时候没有使用同一个字符编码方式。//如果编码和解码的字符集不一致，就会出现乱码。// 先将字符串转换成byte[]数组（这个过程是一个编码的过程）byte[] bytes1 = \"你好旧时光\".getBytes(StandardCharsets.UTF_8);// 将以上的byte[]数组转换成字符串（这个过程是一个解码的过程）String s6 = new String(bytes1, StandardCharsets.ISO_8859_1);System.out.println(s6); String(byte[] bytes, String charsetName)：根据字节数组和指定的字符集名称创建一个新的字符串对象。 12345// 编码byte[] bytes = \"淡然\".getBytes(\"GBK\");// 解码String s6 = new String(bytes, \"GBK\");System.out.println(s6);//淡然 String(String original)：通过复制现有字符串创建一个新的字符串对象。 这个方法被@IntrinsicCandidate标注，这个注解的作用是告诉编译器，该方法或构造函数是一个内在的候选方法,可以被优化和替换为更高效的代码。因此它是不建议使用的。 new String(“hello”); 这个代码会让常量池中有一个 “hello”，并且在堆中也有有一个String对象。 123456@IntrinsicCandidatepublic String(String original) { this.value = original.value; this.coder = original.coder; this.hash = original.hash;} 1String helloStr = new String(\"hello\"); String类的常用方法 byte[] getBytes(); 将字符串转换成字节数组。其实就是对字符串进行编码。默认按照系统默认字符集。 byte[] getBytes(String charsetName); 将字符串按照指定字符集的方式进行编码。 byte[] getBytes(Charset charset); char[] toCharArray(); 将字符串转换字符数组。 String toLowerCase(); 转小写 String toUpperCase(); 转大写 String concat(String str); 进行字符串的拼接操作。和 + 的区别？+ 既可以进行求和，也可以进行字符串的拼接，底层拼接时会创建StringBuilder对象进行拼接。+ 拼接null时不会出现空指针异常。 concat方法参数只能时字符串类型，拼接时不会创建StringBuilder对象，拼接完成后返回一个新的String对象。拼接null会出现空指针异常。 +使用较多。如果进行大量字符串拼接，这两个都不合适。 String substring(int beginIndex); 从指定下标beginIndex开始截取子字符串 String substring(int beginIndex, int endIndex); String trim(); 去除字符串前后空白（只能去除ASCII码中的空格和制表符） String strip(); 去除字符串前后空白（支持所有的编码形式的空白，可以将全角空格去除，\\u3000是全角空格，Java11新增） String stripLeading(); 去除前空白 String stripTrailing(); 去除后空白 String toString(); String intern(); 获取字符串常量池中的字符串，如果常量池中没有，则将字符串加入常量池并返回。 byte[] bytes = {97,98,99,100}; String s = new String(bytes); String s2 = s.intern(); // 将字符串 “abcd”放入字符串常量池并返回常量池中的字符串 “abcd” static String join(CharSequence d, CharSequence… elements); 将多个字符串以某个分隔符连接（Java8新增） static String join(CharSequence delimiter, Iterable&lt;? extends CharSequence&gt; elements); static String valueOf(boolean b); 以下所有的静态方法valueOf作用是将非字符串类型的数据转换为字符串形式。 static String valueOf(char c); static String valueOf(char[] data); static String valueOf(char[] data, int offset, int count); static String valueOf(double d); static String valueOf(float f); static String valueOf(int i); static String valueOf(long l); static String valueOf(Object obj); 正则表达式String类的面试题练习题","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaofanshutu.github.io/categories/Java/"}],"tags":[]},{"title":"IDEA常用","slug":"动力节点Java/IDEA快捷键","date":"2025-04-09T14:14:33.587Z","updated":"2025-06-08T23:04:47.582Z","comments":true,"path":"posts/566321e7.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/566321e7.html","excerpt":"IDEA常用快捷键 单行注释：ctrl + / 多行注释：ctrl + shift + / 查看源码：按ctrl别松手，鼠标移动到对应的类名下方，出现下划线，点击过去，可以查看类源码。 多行编辑：按alt别松手，鼠标拖动多行，完成多行编辑。 怎么快速生成创建对象语句：类名.new.var 怎么快速生成if语句：布尔类型值.if 怎么快速生成setter和getter方法：alt + insert，然后选择setter and getter生成。 怎么快速生成构造方法：alt + insert，然后选择Constructor。 在IDEA当中如何自动纠错：将光标移动到错误的位置，按atl + enter。会有提示，根据提示进行纠错。 移动代码到上一行：alt + shift + 上/下方向 怎么快速重写方法？alt + insert，选择Override…. 怎么快速重写方法？ctrl + o 快速向下转型，并同时生成变量名：变量名.castvar 快速查看方法的参数：ctrl + p 返回上一步：ctrl + alt + 左方向键。 下一步：ctrl + alt + 右方向键。 代码格式化：ctrl + alt + L 查看继承结构：ctrl + H（或者F4） 自动代码包裹：ctrl + alt + t 快速运行程序 ctrl + shift + F10 IDEA中文乱码 在 IntelliJ IDEA 中，可以通过以下步骤检查和设置文件编码：右键文件 -&gt; File Encoding -&gt; 选择 UTF-8。 设置 JVM 的字符编码：在运行配置中添加 JVM 参数，强制指定 UTF-8 编码：-Dfile.encoding=UTF-8在 IntelliJ IDEA 中：打开 Run/Debug Configurations。在 VM options 中添加上述参数。","text":"IDEA常用快捷键 单行注释：ctrl + / 多行注释：ctrl + shift + / 查看源码：按ctrl别松手，鼠标移动到对应的类名下方，出现下划线，点击过去，可以查看类源码。 多行编辑：按alt别松手，鼠标拖动多行，完成多行编辑。 怎么快速生成创建对象语句：类名.new.var 怎么快速生成if语句：布尔类型值.if 怎么快速生成setter和getter方法：alt + insert，然后选择setter and getter生成。 怎么快速生成构造方法：alt + insert，然后选择Constructor。 在IDEA当中如何自动纠错：将光标移动到错误的位置，按atl + enter。会有提示，根据提示进行纠错。 移动代码到上一行：alt + shift + 上/下方向 怎么快速重写方法？alt + insert，选择Override…. 怎么快速重写方法？ctrl + o 快速向下转型，并同时生成变量名：变量名.castvar 快速查看方法的参数：ctrl + p 返回上一步：ctrl + alt + 左方向键。 下一步：ctrl + alt + 右方向键。 代码格式化：ctrl + alt + L 查看继承结构：ctrl + H（或者F4） 自动代码包裹：ctrl + alt + t 快速运行程序 ctrl + shift + F10 IDEA中文乱码 在 IntelliJ IDEA 中，可以通过以下步骤检查和设置文件编码：右键文件 -&gt; File Encoding -&gt; 选择 UTF-8。 设置 JVM 的字符编码：在运行配置中添加 JVM 参数，强制指定 UTF-8 编码：-Dfile.encoding=UTF-8在 IntelliJ IDEA 中：打开 Run/Debug Configurations。在 VM options 中添加上述参数。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaofanshutu.github.io/categories/Java/"}],"tags":[]},{"title":"常用类_日期","slug":"动力节点Java/Chapter6_常用类_日期","date":"2025-04-09T13:56:08.600Z","updated":"2025-04-10T00:10:05.716Z","comments":true,"path":"posts/4f0359c2.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/4f0359c2.html","excerpt":"日期日期类 java.util.Date123public Date() { this(System.currentTimeMillis());} 123public Date(long date) { fastTime = date;} 日期格式化类 SimpleDateFormat日期转字符串字符串转日期日历类 java.util.Calendar获取当前时间的日历对象","text":"日期日期类 java.util.Date123public Date() { this(System.currentTimeMillis());} 123public Date(long date) { fastTime = date;} 日期格式化类 SimpleDateFormat日期转字符串字符串转日期日历类 java.util.Calendar获取当前时间的日历对象123//Gets a calendar using the default time zone and locale.Calendar instance = Calendar.getInstance();System.out.println(instance); 结果： 1java.util.GregorianCalendar[time=1744207975651,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"GMT+08:00\",offset=28800000,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2025,MONTH=3,WEEK_OF_YEAR=15,WEEK_OF_MONTH=2,DAY_OF_MONTH=9,DAY_OF_YEAR=99,DAY_OF_WEEK=4,DAY_OF_WEEK_IN_MONTH=2,AM_PM=1,HOUR=10,HOUR_OF_DAY=22,MINUTE=12,SECOND=55,MILLISECOND=651,ZONE_OFFSET=28800000,DST_OFFSET=0] 获取日历中某部分（年份/月份/星期等） 类型 描述 备注 Calendar.YEAR 获取年份 Calendar.MONTH 获取月份 0表示1月，1表示2月，…，11表示12月 Calendar.DAY_OF_MONTH 获取本月的第几天 Calendar.DAY_OF_YEAR 获取本年的第几天 Calendar.DAY_OF_WEEK 获取星期几 1表示星期日，…，7表示星期六 Calendar.HOUR_OF_DAY 小时，24小时制 Calendar.HOUR 小时，12小时制 Calendar.MINUTE 获取分钟 Calendar.SECOND 获取秒 Calendar.MILLISECOND 获取毫秒 12345678910111213Calendar instance = Calendar.getInstance();System.out.println(\"year: \" + instance.get(Calendar.YEAR));//2025System.out.println(\"month: \" + instance.get(Calendar.MONTH));//3: 四月System.out.println(\"the day of the month: \" + instance.get(Calendar.DAY_OF_MONTH));//9System.out.println(\"the day number within the current year: \" + instance.get(Calendar.DAY_OF_YEAR));//99System.out.println(\"the day of the week:\" + instance.get(Calendar.DAY_OF_WEEK));//4: 星期三//the hour of the day. HOUR_OF_DAY is used for the 24-hour clockSystem.out.println(\"the hour of the day. 24-hour clock: \" + instance.get(Calendar.HOUR_OF_DAY));//22//the hour of the morning or afternoon. HOUR is used for the 12-hour clock (0 - 11). Noon and midnight are represented by 0, not by 12.System.out.println(\"the hour of the day. 12-hour clock: \" + instance.get(Calendar.HOUR));//10System.out.println(\"minute: \" + instance.get(Calendar.MINUTE));//39System.out.println(\"second: \" + instance.get(Calendar.SECOND));//35System.out.println(\"millsecond: \" + instance.get(Calendar.MILLISECOND));//711 12//获取自1970年1月1日0时0分0秒到系统当前时间的总毫秒数。System.out.println(System.currentTimeMillis());//1744207198604 设置日历 set方法calendar.set(Calendar.YEAR, 2023)123Calendar calendar2 = Calendar.getInstance();calendar2.set(Calendar.YEAR, 2023);System.out.println(calendar2.get(Calendar.YEAR) + \"年\" + (calendar2.get(Calendar.MONTH) + 1) + \"月\" + calendar2.get(Calendar.DAY_OF_MONTH) + \"日\"); //2023年4月9日 calendar.set(2015, Calendar.SEPTEMBER,8)123Calendar calendar2 = Calendar.getInstance();calendar2.set(2015, Calendar.JULY, 26, 8, 30, 0);System.out.println(calendar2); 结果： 12015年7月26日 小点：最好用提供的常量 日历中各部分加减 add方法calendar.add(Calendar.YEAR, 1)123Calendar calendar2 = Calendar.getInstance();calendar2.add(Calendar.YEAR, 1);System.out.println(calendar2.get(Calendar.YEAR) + \"年\" + (calendar2.get(Calendar.MONTH) + 1) + \"月\" + calendar2.get(Calendar.DAY_OF_MONTH) + \"日\"); 结果： 12026年4月9日 让日历关联具体时间 setTime方法calendar.setTime(new Date())//年份偏移： Date 构造方法中的年份参数是基于 1900 的偏移量。例如，传入 2015 实际表示 1900 + 2015 = 3915 年。 1234Calendar calendar2 = Calendar.getInstance();calendar2.setTime(new Date(2015, Calendar.JULY, 15));System.out.println(calendar2.get(Calendar.YEAR) + \"年\" + (calendar2.get(Calendar.MONTH) + 1) + \"月\" + calendar2.get(Calendar.DAY_OF_MONTH) + \"日\"); //3915年7月15日 获取日历的具体时间 getTime方法Date time = calendar.getTime();IDEA小技巧： 自动提示忽略大小写，取消勾选Match Case checkbox","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaofanshutu.github.io/categories/Java/"}],"tags":[]},{"title":"Spring","slug":"Spring学习笔记","date":"2025-04-09T09:59:01.293Z","updated":"2025-04-09T10:24:39.383Z","comments":true,"path":"posts/6c92115f.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/6c92115f.html","excerpt":"通过如下代码，来分析几个开发原则（OCP开闭原则和DIP依赖倒置原则） 代码结构 1.Test类12345678910package com.xu.spring6.client;import com.xu.spring6.web.UserAction;public class Test { public static void main(String[] args) { UserAction userAction = new UserAction(); userAction.deleteUser(); }} 2.UserAction类123456789101112package com.xu.spring6.web;import com.xu.spring6.service.UserService;import com.xu.spring6.service.impl.UserServiceImpl;public class UserAction { private UserService userService = new UserServiceImpl(); public void deleteUser(){ userService.deleteUser(); }} 3.UserService接口和UserServiceImpl实现类12345package com.xu.spring6.service;public interface UserService { void deleteUser();}","text":"通过如下代码，来分析几个开发原则（OCP开闭原则和DIP依赖倒置原则） 代码结构 1.Test类12345678910package com.xu.spring6.client;import com.xu.spring6.web.UserAction;public class Test { public static void main(String[] args) { UserAction userAction = new UserAction(); userAction.deleteUser(); }} 2.UserAction类123456789101112package com.xu.spring6.web;import com.xu.spring6.service.UserService;import com.xu.spring6.service.impl.UserServiceImpl;public class UserAction { private UserService userService = new UserServiceImpl(); public void deleteUser(){ userService.deleteUser(); }} 3.UserService接口和UserServiceImpl实现类12345package com.xu.spring6.service;public interface UserService { void deleteUser();} 1234567891011121314package com.xu.spring6.service.impl;import com.xu.spring6.dao.UserDao;import com.xu.spring6.dao.impl.UserDaoImplForMySQL;import com.xu.spring6.service.UserService;public class UserServiceImpl implements UserService { private UserDao userDao = new UserDaoImplForMySQL(); @Override public void deleteUser() { userDao.deleteUser(); }} 4.UserDao接口和UserDaoImplForMySQL实现类12345package com.xu.spring6.dao;public interface UserDao { void deleteUser();} 1234567891011package com.xu.spring6.dao.impl;import com.xu.spring6.dao.UserDao;public class UserDaoImplForMySQL implements UserDao { @Override public void deleteUser() { System.out.println(\"正在删除用户信息~\"); }} 分析上述代码存在问题UserAction类中用到了private UserService userService = new UserServiceImpl(); UserServiceImpl实现类中用到了private UserDao userDao = new UserDaoImplForMySQL(); 如果现在，我想从MySQL（UserDaoImplForMySQL）切换到Oracle（UserDaoImplForOracle），那么我就必须修改UserServiceImpl类的代码，将声明成员变量userDao的代码改为如下： 1private UserDao userDao = new UserDaoImplForOracle(); 这个就违反了OCP开闭原则和DIP依赖倒置原则。 OCP开闭原则开闭原则(Open-Closed Principle)：简称OCP，在软件开发过程中应当对扩展开放，对修改关闭。也就是说，如果在进行功能扩展的时候，添加额外的类是没问题的，但因为功能扩展而修改之前运行正常的程序，这是不推荐的。因为一旦修改之前运行正常的程序，就会导致项目整体要进行全方位的重新测试。这是相当繁琐的过程。导致这个问题的主要原因是：代码和代码之间的耦合度太高。如下图所示： 上层是依赖下层的。UserAction依赖UserServiceImpl，而UserServiceImpl依赖UserDaoImplForMySQL，这样就会导致下面只要改动，上面必然会受牵连（跟着也会改），所谓牵一发而动全身。这个也同时违背了另一个开发原则：依赖倒置原则。 DIP依赖倒置原则依赖倒置原则(Dependence Inversion Principle)：简称DIP，主要倡导面向抽象编程，面向接口编程，不要面向具体编程，让上层不再依赖下层，下面改动了，上面的代码不会受到牵连。这样可以大大降低程序的耦合度，耦合度低了，扩展力就强了，同时代码复用性也会增强。（软件七大开发原则都是在为解耦合服务） 前面有问题的代码没有完全实现面向接口编程，因为代码中还是使用了接口的具体实现类。 下面这种才算是完全的面向接口编程","categories":[{"name":"Spring6","slug":"Spring6","permalink":"https://xiaofanshutu.github.io/categories/Spring6/"}],"tags":[]},{"title":"Injection","slug":"D4-注入","date":"2025-04-09T09:59:01.292Z","updated":"2025-04-09T10:24:39.383Z","comments":true,"path":"posts/13006ff7.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/13006ff7.html","excerpt":"1 IoC 控制反转 控制反转是一种思想。 控制反转，反转的是什么？ 将对象的创建权交出去，交给第三方容器负责。 将对象和对象之间关系的维护权交出去，交给第三方容器负责。 控制反转这种思想如何实现呢？ DI（Dependency Injection）：依赖注入 2 依赖注入 Spring是通过依赖注入的方式来完成Bean管理的。Bean管理指的是：Bean对象的创建，以及Bean对象中属性的赋值（或者叫做Bean对象之间关系的维护）。 依赖注入： 依赖指的是对象和对象之间的关联关系。 注入指的是一种数据传递行为，通过注入行为来让对象和对象产生关系。 依赖注入常见的实现方式包括两种： 第一种：set注入 第二种：构造注入 2.1 set注入","text":"1 IoC 控制反转 控制反转是一种思想。 控制反转，反转的是什么？ 将对象的创建权交出去，交给第三方容器负责。 将对象和对象之间关系的维护权交出去，交给第三方容器负责。 控制反转这种思想如何实现呢？ DI（Dependency Injection）：依赖注入 2 依赖注入 Spring是通过依赖注入的方式来完成Bean管理的。Bean管理指的是：Bean对象的创建，以及Bean对象中属性的赋值（或者叫做Bean对象之间关系的维护）。 依赖注入： 依赖指的是对象和对象之间的关联关系。 注入指的是一种数据传递行为，通过注入行为来让对象和对象产生关系。 依赖注入常见的实现方式包括两种： 第一种：set注入 第二种：构造注入 2.1 set注入set注入是基于set方法实现的，底层会通过反射机制调用属性对应的set方法然后给属性赋值。这种方式要求必须对外提供属性的set方法。 通过一个例子来学习set注入pom.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.xu&lt;/groupId&gt; &lt;artifactId&gt;spring6-002-dependency-injection&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--log4j2的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.20.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt; &lt;version&gt;2.20.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; UserService 1234567891011121314151617181920212223package com.xu.service;import com.xu.dao.UserDao;import com.xu.dao.VipDao;public class UserService { private UserDao userDao; private VipDao vipDao; public void save() { userDao.save(); vipDao.save(); } public void setUserDao(UserDao userDao) { this.userDao = userDao; } public void setVipDao(VipDao vipDao) { this.vipDao = vipDao; }} UserDao 123456789101112package com.xu.dao;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class UserDao { private static Logger LOGGER = LoggerFactory.getLogger(UserDao.class); public void save() { LOGGER.info(\"UserDao正在保存用户信息\"); }} VipDao 123456789101112package com.xu.dao;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class VipDao { private Logger LOGGER = LoggerFactory.getLogger(VipDao.class); public void save() { LOGGER.info(\"VipDao正在保存用户信息\"); }} log4j2.xml 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;loggers&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"log\"/&gt; &lt;/root&gt; &lt;/loggers&gt; &lt;appenders&gt; &lt;console name=\"log\" target=\"SYSTEM_OUT\"&gt; &lt;PatternLayout pattern=\"%d{yyyy-MM-dd HH:mm:ss SSS} [%t] %-3level %logger{1024} - %msg%n\"/&gt; &lt;/console&gt; &lt;/appenders&gt;&lt;/configuration&gt; spring.xml 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"userDao\" class=\"com.xu.dao.UserDao\"/&gt; &lt;bean id=\"vipDao\" class=\"com.xu.dao.VipDao\"/&gt; &lt;bean id=\"userService\" class=\"com.xu.service.UserService\"&gt; &lt;property name=\"userDao\" ref=\"userDao\"/&gt; &lt;property name=\"vipDao\" ref=\"vipDao\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类 123456789101112131415package com.xu.test;import com.xu.service.UserService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class SpringTest { @Test public void testIoC() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring.xml\"); UserService userService = applicationContext.getBean(\"userService\", UserService.class); userService.save(); }} 运行结果： 原理是什么？set注入的核心实现原理：通过反射机制调用set方法来给属性赋值，让两个对象之间产生关系。 举例验证： 1.将成员属性的属性名改为userhaha和viphaha，然后保持set方法的方法名不变，测试这种情况下，程序应该可以正常运行。不会报错。 12345678910111213141516171819202122package com.xu.service;import com.xu.dao.UserDao;import com.xu.dao.VipDao;public class UserService { private UserDao userhaha; private VipDao viphaha; public void save() { userhaha.save(); viphaha.save(); } public void setUserDao(UserDao userDao) { this.userhaha = userDao; } public void setVipDao(VipDao vipDao) { this.viphaha = vipDao; }} 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"userDao\" class=\"com.xu.dao.UserDao\"/&gt; &lt;bean id=\"vipDao\" class=\"com.xu.dao.VipDao\"/&gt; &lt;bean id=\"userService\" class=\"com.xu.service.UserService\"&gt; &lt;property name=\"userDao\" ref=\"userDao\"/&gt; &lt;property name=\"vipDao\" ref=\"vipDao\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 运行结果：成功 2.保持成员属性的属性名不变，将set方法的方法名改为setUserDaoHaHa和setVipDaoHaHa，测试这种情况下，程序应该会报错。 12345678910111213141516171819202122package com.xu.service;import com.xu.dao.UserDao;import com.xu.dao.VipDao;public class UserService { private UserDao userDao; private VipDao vipDao; public void save() { userDao.save(); vipDao.save(); } public void setUserDaoHaHa(UserDao userDao) { this.userDao = userDao; } public void setVipDaoHaHa(VipDao vipDao) { this.vipDao = vipDao; }} 如果property的name还是传的userDao和vipDao就会报错 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"userDao\" class=\"com.xu.dao.UserDao\"/&gt; &lt;bean id=\"vipDao\" class=\"com.xu.dao.VipDao\"/&gt; &lt;bean id=\"userService\" class=\"com.xu.service.UserService\"&gt; &lt;property name=\"userDao\" ref=\"userDao\"/&gt; &lt;property name=\"vipDao\" ref=\"vipDao\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 将property的name改为userDaoHaHa和vipDaoHaHa就成功了 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"userDao\" class=\"com.xu.dao.UserDao\"/&gt; &lt;bean id=\"vipDao\" class=\"com.xu.dao.VipDao\"/&gt; &lt;bean id=\"userService\" class=\"com.xu.service.UserService\"&gt; &lt;property name=\"userDaoHaHa\" ref=\"userDao\"/&gt; &lt;property name=\"vipDaoHaHa\" ref=\"vipDao\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 2.2 构造注入原理：通过调用构造方法来给属性赋值。 使用下标注入123456789101112package com.xu.dao;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class OrderDao { private static Logger LOGGER = LoggerFactory.getLogger(OrderDao.class); public void orderService() { LOGGER.info(\"服务已预约~\"); }} 123456789101112131415package com.xu.service;import com.xu.dao.OrderDao;public class OrderService { private OrderDao orderDao; public OrderService(OrderDao orderDao) { this.orderDao = orderDao; } public void order() { orderDao.orderService(); }} 12345678&lt;bean id=\"orderDao\" class=\"com.xu.dao.OrderDao\" /&gt;&lt;bean id=\"orderService\" class=\"com.xu.service.OrderService\"&gt; &lt;!--index=\"0\"表示构造方法的第一个参数，将orderDao对象传递给构造方法的第一个参数。--&gt; &lt;constructor-arg index=\"0\" ref=\"orderDao\"/&gt; &lt;!-- 如果有多个构造方法参数，则继续加index=\"1\" --&gt; &lt;!-- &lt;constructor-arg index=\"1\" ref=\"orderDao\"/&gt;--&gt;&lt;/bean&gt; 123456@Testpublic void testConstructorDI() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring.xml\"); OrderService orderService = applicationContext.getBean(\"orderService\", OrderService.class); orderService.order();} 运行结果如下： 使用构造方法参数名注入12345678910111213141516171819package com.xu.service;import com.xu.dao.UserDao;import com.xu.dao.VipDao;public class UserService2 { private UserDao userDao; private VipDao vipDao; public UserService2(UserDao userDao, VipDao vipDao) { this.userDao = userDao; this.vipDao = vipDao; } public void save() { userDao.save(); vipDao.save(); }} 123456@Testpublic void testConstructorDIByName() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); UserService2 userService2 = applicationContext.getBean(\"userService\", UserService2.class); userService2.save();} 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"userDao\" class=\"com.xu.dao.UserDao\"/&gt; &lt;bean id=\"vipDao\" class=\"com.xu.dao.VipDao\"/&gt; &lt;bean id=\"userService\" class=\"com.xu.service.UserService2\"&gt; &lt;constructor-arg name=\"userDao\" ref=\"userDao\"/&gt; &lt;constructor-arg name=\"vipDao\" ref=\"vipDao\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 即不指定下标，也不指定参数名，让Spring自行判断1234&lt;bean id=\"userServiceBean\" class=\"com.xu.service.UserService2\"&gt; &lt;constructor-arg ref=\"userDao\"/&gt; &lt;constructor-arg ref=\"vipDao\"/&gt;&lt;/bean&gt; 123456@Testpublic void testConstructorDIWithNothing() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); UserService2 userService = applicationContext.getBean(\"userServiceBean\", UserService2.class); userService.save();} 3 set注入专题3.1 注入外部Bean123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"userDaoBean\" class=\"com.powernode.spring6.dao.UserDao\"/&gt; &lt;bean id=\"userServiceBean\" class=\"com.powernode.spring6.service.UserService\"&gt; &lt;property name=\"userDao\" ref=\"userDaoBean\"/&gt; &lt;!-- 这个就叫做注入外部bean --&gt; &lt;/bean&gt;&lt;/beans&gt; 外部Bean的特点：bean定义在外面，在property标签中使用ref属性进行注入。这种方式比较常用。 3.2 注入内部Bean内部Bean的方式：在bean标签中嵌套bean标签。 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"userServiceBean\" class=\"com.powernode.spring6.service.UserService\"&gt; &lt;property name=\"userDao\"&gt; &lt;bean class=\"com.powernode.spring6.dao.UserDao\"/&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 3.3 注入简单类型12345678910111213141516171819202122package com.xu.entity;public class User { private String name; private int age; public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"User{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; }} 第二步：编写spring配置文件：spring-simple-di.xml 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"user\" class=\"com.xu.entity.User\"&gt; &lt;property name=\"name\" value=\"xu\"/&gt; &lt;property name=\"age\" value=\"22\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 第三步：编写测试程序 123456@Testpublic void testSimpleValue() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-simple-di.xml\"); User user = applicationContext.getBean(\"user\", User.class); System.out.println(user);} 第四步：运行测试程序 3.4 注入数组当数组中的元素是简单类型： 123456789101112131415161718package com.hilda;import java.util.Arrays;public class Person { private String[] favariteFoods; public void setFavariteFoods(String[] favariteFoods) { this.favariteFoods = favariteFoods; } @Override public String toString() { return \"Person{\" + \"favariteFoods=\" + Arrays.toString(favariteFoods) + '}'; }} 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"person\" class=\"com.hilda.Person\"&gt; &lt;property name=\"favariteFoods\"&gt; &lt;array&gt; &lt;value&gt;酸菜鱼&lt;/value&gt; &lt;value&gt;凉皮&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 123456@Testpublic void testArraySimple() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring.xml\"); Person person = applicationContext.getBean(\"person\", Person.class); System.out.println(person);} 1Person{favariteFoods=[酸菜鱼, 凉皮]} 当数组中的元素是非简单类型：一个订单中包含多个商品。 123456789101112131415161718192021222324252627package com.hilda;public class Goods { private String name; public Goods() { } public Goods(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"Goods{\" + \"name='\" + name + '\\'' + '}'; }} 12345678910111213141516171819202122232425package com.hilda;import java.util.Arrays;public class Order { private Goods[] goods; public Order() { } public Order(Goods[] goods) { this.goods = goods; } public void setGoods(Goods[] goods) { this.goods = goods; } @Override public String toString() { return \"Order{\" + \"goods=\" + Arrays.toString(goods) + '}'; }} 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"goods1\" class=\"com.hilda.Goods\"&gt; &lt;property name=\"name\" value=\"西瓜\"/&gt; &lt;/bean&gt; &lt;bean id=\"goods2\" class=\"com.hilda.Goods\"&gt; &lt;property name=\"name\" value=\"苹果\"/&gt; &lt;/bean&gt; &lt;bean id=\"order\" class=\"com.hilda.Order\"&gt; &lt;property name=\"goods\"&gt; &lt;array&gt; &lt;!--元素是非简单类型，使用ref标签--&gt; &lt;ref bean=\"goods1\"/&gt; &lt;ref bean=\"goods2\"/&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试程序： 123456@Testpublic void testArray(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring2.xml\"); Order order = applicationContext.getBean(\"order\", Order.class); System.out.println(order);} 1Order{goods=[Goods{name='西瓜'}, Goods{name='苹果'}]} 要点： 如果数组中是简单类型，使用value标签。 如果数组中是非简单类型，使用ref标签。 3.5 注入List集合List集合：有序可重复 123456789101112131415161718package com.hilda;import java.util.List;public class People { private List&lt;String&gt; names; public void setNames(List&lt;String&gt; names) { this.names = names; } @Override public String toString() { return \"People{\" + \"names=\" + names + '}'; }} 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"peopleBean\" class=\"com.hilda.People\"&gt; &lt;property name=\"names\"&gt; &lt;list&gt; &lt;value&gt;xu&lt;/value&gt; &lt;value&gt;hilda&lt;/value&gt; &lt;value&gt;halla&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 123456@Testpublic void testCollection(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-list.xml\"); People peopleBean = applicationContext.getBean(\"peopleBean\", People.class); System.out.println(peopleBean);} 1People{names=[xu, hilda, halla]} 注意：注入List集合的时候使用list标签，如果List集合中是简单类型使用value标签，反之使用ref标签。 3.7 注入Set集合Set集合：无序不可重复 1234567891011121314151617181920212223242526package com.hilda;import java.util.List;import java.util.Set;public class People { private List&lt;String&gt; names; private Set&lt;String&gt; phones; public void setPhones(Set&lt;String&gt; phones) { this.phones = phones; } public void setNames(List&lt;String&gt; names) { this.names = names; } @Override public String toString() { return \"People{\" + \"names=\" + names + \", phones=\" + phones + '}'; }} 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"peopleBean\" class=\"com.hilda.People\"&gt; &lt;property name=\"names\"&gt; &lt;list&gt; &lt;value&gt;xu&lt;/value&gt; &lt;value&gt;hilda&lt;/value&gt; &lt;value&gt;halla&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"phones\"&gt; &lt;set&gt; &lt;!--非简单类型可以使用ref，简单类型使用value--&gt; &lt;value&gt;1319336***1&lt;/value&gt; &lt;value&gt;1319336***2&lt;/value&gt; &lt;value&gt;1319336***3&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 123456@Testpublic void testSet(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-set.xml\"); People peopleBean = applicationContext.getBean(\"peopleBean\", People.class); System.out.println(peopleBean);} 执行结果： 1People{names=[xu, hilda, halla], phones=[1319336***1, 1319336***2, 1319336***3]} 要点： 使用标签 set集合中元素是简单类型的使用value标签，反之使用ref标签。 3.8 注入Map集合12345678910111213141516171819202122232425262728293031323334package com.hilda;import java.util.List;import java.util.Map;import java.util.Set;public class People { private List&lt;String&gt; names; private Set&lt;String&gt; phones; private Map&lt;Integer, String&gt; addrs; public void setAddrs(Map&lt;Integer, String&gt; addrs) { this.addrs = addrs; } public void setPhones(Set&lt;String&gt; phones) { this.phones = phones; } public void setNames(List&lt;String&gt; names) { this.names = names; } @Override public String toString() { return \"People{\" + \"names=\" + names + \", phones=\" + phones + \", addrs=\" + addrs + '}'; }} 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"peopleBean\" class=\"com.hilda.People\"&gt; &lt;property name=\"names\"&gt; &lt;list&gt; &lt;value&gt;xu&lt;/value&gt; &lt;value&gt;hilda&lt;/value&gt; &lt;value&gt;halla&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"phones\"&gt; &lt;set&gt; &lt;!--非简单类型可以使用ref，简单类型使用value--&gt; &lt;value&gt;1319336***1&lt;/value&gt; &lt;value&gt;1319336***2&lt;/value&gt; &lt;value&gt;1319336***3&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=\"addrs\"&gt; &lt;map&gt; &lt;!--如果key不是简单类型，使用 key-ref 属性--&gt; &lt;!--如果value不是简单类型，使用 value-ref 属性--&gt; &lt;entry key=\"1\" value=\"北京大兴区\"/&gt; &lt;entry key=\"2\" value=\"上海浦东区\"/&gt; &lt;entry key=\"3\" value=\"深圳宝安区\"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 123456@Testpublic void testMap(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-map.xml\"); People peopleBean = applicationContext.getBean(\"peopleBean\", People.class); System.out.println(peopleBean);} 执行结果： 1People{names=[xu, hilda, halla], phones=[1319336***1, 1319336***2, 1319336***3], addrs={1=北京大兴区, 2=上海浦东区, 3=深圳宝安区}} 要点： 使用标签 如果key是简单类型，使用 key 属性，反之使用 key-ref 属性。 如果value是简单类型，使用 value 属性，反之使用 value-ref 属性。 3.9 注入Propertiesjava.util.Properties继承java.util.Hashtable，所以Properties也是一个Map集合。 123456789101112131415161718192021222324252627282930313233343536373839404142package com.hilda;import java.util.List;import java.util.Map;import java.util.Properties;import java.util.Set;public class People { private List&lt;String&gt; names; private Set&lt;String&gt; phones; private Map&lt;Integer, String&gt; addrs; private Properties properties; public void setProperties(Properties properties) { this.properties = properties; } public void setAddrs(Map&lt;Integer, String&gt; addrs) { this.addrs = addrs; } public void setPhones(Set&lt;String&gt; phones) { this.phones = phones; } public void setNames(List&lt;String&gt; names) { this.names = names; } @Override public String toString() { return \"People{\" + \"names=\" + names + \", phones=\" + phones + \", addrs=\" + addrs + \", properties=\" + properties + '}'; }} 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"peopleBean\" class=\"com.hilda.People\"&gt; &lt;property name=\"names\"&gt; &lt;list&gt; &lt;value&gt;xu&lt;/value&gt; &lt;value&gt;hilda&lt;/value&gt; &lt;value&gt;halla&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"phones\"&gt; &lt;set&gt; &lt;!--非简单类型可以使用ref，简单类型使用value--&gt; &lt;value&gt;1319336***1&lt;/value&gt; &lt;value&gt;1319336***2&lt;/value&gt; &lt;value&gt;1319336***3&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=\"addrs\"&gt; &lt;map&gt; &lt;!--如果key不是简单类型，使用 key-ref 属性--&gt; &lt;!--如果value不是简单类型，使用 value-ref 属性--&gt; &lt;entry key=\"1\" value=\"北京大兴区\"/&gt; &lt;entry key=\"2\" value=\"上海浦东区\"/&gt; &lt;entry key=\"3\" value=\"深圳宝安区\"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=\"properties\"&gt; &lt;props&gt; &lt;prop key=\"driver\"&gt;com.mysql.cj.jdbc.Driver&lt;/prop&gt; &lt;prop key=\"url\"&gt;jdbc:mysql://localhost:3306/spring&lt;/prop&gt; &lt;prop key=\"username\"&gt;root&lt;/prop&gt; &lt;prop key=\"password\"&gt;123456&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 123456@Testpublic void testProperties(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-properties.xml\"); People peopleBean = applicationContext.getBean(\"peopleBean\", People.class); System.out.println(peopleBean);} 执行结果： 1People{names=[xu, hilda, halla], phones=[1319336***1, 1319336***2, 1319336***3], addrs={1=北京大兴区, 2=上海浦东区, 3=深圳宝安区}, properties={password=123456, driver=com.mysql.cj.jdbc.Driver, url=jdbc:mysql://localhost:3306/spring, username=root}} 要点： 使用标签嵌套标签完成。 3.10 注入null和空字符串注入空字符串使用： 或者 value=””注入null使用： 或者 不为该属性赋值 我们先来看一下，怎么注入空字符串。 12345678910111213141516package com.hilda;public class Vip { private String email; public void setEmail(String email) { this.email = email; } @Override public String toString() { return \"Vip{\" + \"email='\" + email + '\\'' + '}'; }} 12345678&lt;bean id=\"vipBean\" class=\"com.hilda.Vip\"&gt; &lt;!--空串的第一种方式--&gt; &lt;!--&lt;property name=\"email\" value=\"\"/&gt;--&gt; &lt;!--空串的第二种方式--&gt; &lt;property name=\"email\"&gt; &lt;value/&gt; &lt;/property&gt;&lt;/bean&gt; 123456@Testpublic void testNull(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring.xml\"); Vip vipBean = applicationContext.getBean(\"vipBean\", Vip.class); System.out.println(vipBean);} 执行结果： 怎么注入null呢？ 第一种方式：不给属性赋值 1&lt;bean id=\"vipBean\" class=\"com.hilda.Vip\"/&gt; 执行结果： 第二种方式：使用 12345&lt;bean id=\"vipBean\" class=\"com.hilda.Vip\"&gt; &lt;property name=\"email\"&gt; &lt;null/&gt; &lt;/property&gt;&lt;/bean&gt; 执行结果： 3.11 注入的值中含有特殊符号XML中有5个特殊字符，分别是：&lt;、&gt;、’、”、&amp;以上5个特殊符号在XML中会被特殊对待，会被当做XML语法的一部分进行解析，如果这些特殊符号直接出现在注入的字符串当中，会报错。 解决方案包括两种： 第一种：特殊符号使用转义字符代替。 第二种：将含有特殊符号的字符串放到： 当中。因为放在CDATA区中的数据不会被XML文件解析器解析。 5个特殊字符对应的转义字符分别是： 特殊字符 转义字符 &gt; &gt; &lt; &lt; ‘ ' “ \" &amp; &amp; 先使用转义字符来代替： 12345678910111213141516package com.hilda;public class Math { private String result; public void setResult(String result) { this.result = result; } @Override public String toString() { return \"Math{\" + \"result='\" + result + '\\'' + '}'; }} 123&lt;bean id=\"mathBean\" class=\"com.hilda.Math\"&gt; &lt;property name=\"result\" value=\"2 &amp;lt; 3\"/&gt;&lt;/bean&gt; 123456@Testpublic void testSpecial(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring.xml\"); com.hilda.Math mathBean = applicationContext.getBean(\"mathBean\", Math.class); System.out.println(mathBean);} 执行结果： 我们再来使用CDATA方式： 1234567&lt;bean id=\"mathBean\" class=\"com.hilda.Math\"&gt; &lt;!--&lt;property name=\"result\" value=\"2 &amp;lt; 3\"/&gt;--&gt; &lt;property name=\"result\"&gt; &lt;!--只能使用value标签--&gt; &lt;value&gt;&lt;![CDATA[3 &lt; 6]]&gt;&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; 注意：使用CDATA时，不能使用value属性，只能使用value标签。执行结果： 4 p命名空间注入目的：简化配置。使用p命名空间注入的前提条件包括两个： 第一：在XML头部信息中添加p命名空间的配置信息： 1xmlns:p=\"http://www.springframework.org/schema/p\" 第二：p命名空间注入是基于setter方法的，所以需要对应的属性提供setter方法。 12345678910111213141516171819202122package com.hilda;public class Customer { private String name; private int age; public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Customer{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; }} 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"customerBean\" class=\"com.hilda.Customer\" p:name=\"zhangsan\" p:age=\"20\"/&gt;&lt;/beans&gt; 123456@Testpublic void testP(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring.xml\"); Customer customerBean = applicationContext.getBean(\"customerBean\", Customer.class); System.out.println(customerBean);} 执行结果：把setter方法去掉：所以p命名空间实际上是对set注入的简化。 如果不引入p命名空间的话，会报错 4.1 c命名空间注入c命名空间是简化构造方法注入的。使用c命名空间的两个前提条件：第一：需要在xml配置文件头部添加信息： 1xmlns:c=\"http://www.springframework.org/schema/c\" 第二：需要提供构造方法。 12345678910111213141516171819202122package com.hilda;public class MyTime { private int year; private int month; private int day; public MyTime(int year, int month, int day) { this.year = year; this.month = month; this.day = day; } @Override public String toString() { return \"MyTime{\" + \"year=\" + year + \", month=\" + month + \", day=\" + day + '}'; }} 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:c=\"http://www.springframework.org/schema/c\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--两种方式都可以--&gt; &lt;!-- &lt;bean id=\"myTimeBean\" class=\"com.hilda.MyTime\" c:year=\"1909\" c:month=\"1\" c:day=\"13\"/&gt;--&gt; &lt;bean id=\"myTimeBean\" class=\"com.hilda.MyTime\" c:_0=\"2008\" c:_1=\"8\" c:_2=\"8\"/&gt;&lt;/beans&gt; 123456@Testpublic void testC(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-c.xml\"); MyTime myTimeBean = applicationContext.getBean(\"myTimeBean\", MyTime.class); System.out.println(myTimeBean);} 执行结果： 把构造方法注释掉： 所以，c命名空间是依靠构造方法的。注意：不管是p命名空间还是c命名空间，注入的时候都可以注入简单类型以及非简单类型。 4.2 util命名空间使用util命名空间可以让配置复用。使用util命名空间的前提是：在spring配置文件头部添加配置信息。如下： 123456789101112131415161718package com.hilda;import java.util.Properties;public class MyDataSource1 { private Properties properties; public void setProperties(Properties properties) { this.properties = properties; } @Override public String toString() { return \"MyDataSource1{\" + \"properties=\" + properties + '}'; }} 123456789101112131415161718package com.hilda;import java.util.Properties;public class MyDataSource2 { private Properties properties; public void setProperties(Properties properties) { this.properties = properties; } @Override public String toString() { return \"MyDataSource2{\" + \"properties=\" + properties + '}'; }} 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:util=\"http://www.springframework.org/schema/util\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\"&gt; &lt;util:properties id=\"prop\"&gt; &lt;prop key=\"driver\"&gt;com.mysql.cj.jdbc.Driver&lt;/prop&gt; &lt;prop key=\"url\"&gt;jdbc:mysql://localhost:3306/spring&lt;/prop&gt; &lt;prop key=\"username\"&gt;root&lt;/prop&gt; &lt;prop key=\"password\"&gt;123456&lt;/prop&gt; &lt;/util:properties&gt; &lt;bean id=\"dataSource1\" class=\"com.hilda.MyDataSource1\"&gt; &lt;property name=\"properties\" ref=\"prop\"/&gt; &lt;/bean&gt; &lt;bean id=\"dataSource2\" class=\"com.hilda.MyDataSource2\"&gt; &lt;property name=\"properties\" ref=\"prop\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 12345678910@Testpublic void testUtil(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-util.xml\"); MyDataSource1 dataSource1 = applicationContext.getBean(\"dataSource1\", MyDataSource1.class); System.out.println(dataSource1); MyDataSource2 dataSource2 = applicationContext.getBean(\"dataSource2\", MyDataSource2.class); System.out.println(dataSource2);} 执行结果： 4.3 基于XML的自动装配Spring还可以完成自动化的注入，自动化注入又被称为自动装配。它可以根据名字进行自动装配，也可以根据类型进行自动装配。 4.3.1 根据名称自动装配123456789101112131415package com.powernode.spring6.dao;/** * @author 动力节点 * @version 1.0 * @className UserDao * @since 1.0 **/public class UserDao { public void insert(){ System.out.println(\"正在保存用户数据。\"); }} 123456789101112131415161718192021222324package com.powernode.spring6.service;import com.powernode.spring6.dao.UserDao;/** * @author 动力节点 * @version 1.0 * @className UserService * @since 1.0 **/public class UserService { private UserDao aaa; // 这个set方法非常关键 public void setAaa(UserDao aaa) { this.aaa = aaa; } public void save(){ aaa.insert(); }} Spring的配置文件这样配置： 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"userService\" class=\"com.powernode.spring6.service.UserService\" autowire=\"byName\"/&gt; &lt;bean id=\"aaa\" class=\"com.powernode.spring6.dao.UserDao\"/&gt;&lt;/beans&gt; 这个配置起到关键作用： UserService Bean中需要添加autowire=”byName”，表示通过名称进行装配。 UserService类中有一个UserDao属性，而UserDao属性的名字是aaa，**对应的set方法是setAaa()**，正好和UserDao Bean的id是一样的。这就是根据名称自动装配。 123456@Testpublic void testAutowireByName(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-autowire.xml\"); UserService userService = applicationContext.getBean(\"userService\", UserService.class); userService.save();} 执行结果：我们来测试一下，byName装配是和属性名有关还是和set方法名有关系： 12345678910111213141516171819202122232425262728package com.powernode.spring6.service;import com.powernode.spring6.dao.UserDao;/** * @author 动力节点 * @version 1.0 * @className UserService * @since 1.0 **/public class UserService { // 这里没修改 private UserDao aaa; /*public void setAaa(UserDao aaa) { this.aaa = aaa; }*/ // set方法名变化了 public void setDao(UserDao aaa){ this.aaa = aaa; } public void save(){ aaa.insert(); }} 在执行测试程序：通过测试得知，aaa属性并没有赋值成功。也就是并没有装配成功。我们将spring配置文件修改以下： 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"userService\" class=\"com.powernode.spring6.service.UserService\" autowire=\"byName\"/&gt; &lt;!--这个id修改了--&gt; &lt;bean id=\"dao\" class=\"com.powernode.spring6.dao.UserDao\"/&gt; &lt;/beans&gt; 执行测试程序：这说明，如果根据名称装配(byName)，底层会调用set方法进行注入。例如：setAge() 对应的名字是age，setPassword()对应的名字是password，setEmail()对应的名字是email。 4.3.2 根据类型自动装配1234567891011121314package com.powernode.spring6.dao;/** * @author 动力节点 * @version 1.0 * @className AccountDao * @since 1.0 **/public class AccountDao { public void insert(){ System.out.println(\"正在保存账户信息\"); }} 12345678910111213141516171819202122package com.powernode.spring6.service;import com.powernode.spring6.dao.AccountDao;/** * @author 动力节点 * @version 1.0 * @className AccountService * @since 1.0 **/public class AccountService { private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) { this.accountDao = accountDao; } public void save(){ accountDao.insert(); }} 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--byType表示根据类型自动装配--&gt; &lt;bean id=\"accountService\" class=\"com.powernode.spring6.service.AccountService\" autowire=\"byType\"/&gt; &lt;bean class=\"com.powernode.spring6.dao.AccountDao\"/&gt;&lt;/beans&gt; 123456@Testpublic void testAutowireByType(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-autowire.xml\"); AccountService accountService = applicationContext.getBean(\"accountService\", AccountService.class); accountService.save();} 执行结果：我们把UserService中的set方法注释掉，再执行： 丹丹 todo： 这里是AccountService，不是UserService 可以看到无论是byName还是byType，在装配的时候都是基于set方法的。所以set方法是必须要提供的。提供构造方法是不行的，大家可以测试一下。这里就不再赘述。如果byType，根据类型装配时，如果配置文件中有两个类型一样的bean会出现什么问题呢？ 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"accountService\" class=\"com.powernode.spring6.service.AccountService\" autowire=\"byType\"/&gt; &lt;bean id=\"x\" class=\"com.powernode.spring6.dao.AccountDao\"/&gt; &lt;bean id=\"y\" class=\"com.powernode.spring6.dao.AccountDao\"/&gt;&lt;/beans&gt; 执行测试程序：测试结果说明了，当byType进行自动装配的时候，配置文件中某种类型的Bean必须是唯一的，不能出现多个。 4.4 Spring引入外部属性配置文件我们都知道编写数据源的时候是需要连接数据库的信息的，例如：driver url username password等信息。这些信息可以单独写到一个属性配置文件中吗，这样用户修改起来会更加的方便。当然可以。第一步：写一个数据源类，提供相关属性。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.powernode.spring6.beans;import javax.sql.DataSource;import java.io.PrintWriter;import java.sql.Connection;import java.sql.SQLException;import java.sql.SQLFeatureNotSupportedException;import java.util.logging.Logger;/** * @author 动力节点 * @version 1.0 * @className MyDataSource * @since 1.0 **/public class MyDataSource implements DataSource { @Override public String toString() { return \"MyDataSource{\" + \"driver='\" + driver + '\\'' + \", url='\" + url + '\\'' + \", username='\" + username + '\\'' + \", password='\" + password + '\\'' + '}'; } private String driver; private String url; private String username; private String password; public void setDriver(String driver) { this.driver = driver; } public void setUrl(String url) { this.url = url; } public void setUsername(String username) { this.username = username; } public void setPassword(String password) { this.password = password; } //......} 第二步：在类路径下新建jdbc.properties文件，并配置信息。 1234driver=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/springusername=rootpassword=root123 第三步：在spring配置文件中引入context命名空间。 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt;&lt;/beans&gt; 第四步：在spring中配置使用jdbc.properties文件。 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:property-placeholder location=\"jdbc.properties\"/&gt; &lt;bean id=\"dataSource\" class=\"com.powernode.spring6.beans.MyDataSource\"&gt; &lt;property name=\"driver\" value=\"${driver}\"/&gt; &lt;property name=\"url\" value=\"${url}\"/&gt; &lt;property name=\"username\" value=\"${username}\"/&gt; &lt;property name=\"password\" value=\"${password}\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试程序： 123456@Testpublic void testProperties(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-properties.xml\"); MyDataSource dataSource = applicationContext.getBean(\"dataSource\", MyDataSource.class); System.out.println(dataSource);} 执行结果： 丹丹 todo： 把properties里面的 参数名统一都改为jdbc.url, jdbc.username, jdbc.password等 上面这个图片usernamme是Administrator，因为 它 是取的windows变量","categories":[{"name":"Spring6","slug":"Spring6","permalink":"https://xiaofanshutu.github.io/categories/Spring6/"}],"tags":[]},{"title":"First Project","slug":"D3-first project","date":"2025-04-09T09:59:01.289Z","updated":"2025-04-09T10:24:39.383Z","comments":true,"path":"posts/358c4d47.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/358c4d47.html","excerpt":"项目结构 创建Empty Project 修改工程JDK创建完spring6的空工程之后，将这里改为JDK17。否则创建的module默认不是JDK17，就会报各种错误。 在空工程里面创建一个Module","text":"项目结构 创建Empty Project 修改工程JDK创建完spring6的空工程之后，将这里改为JDK17。否则创建的module默认不是JDK17，就会报各种错误。 在空工程里面创建一个Module 详细代码User类1234package com.xu.entity;public class User {} beans.xml配置文件注意： bean的id不能重复， 这个id就相当于是bean的身份证号。 123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"user\" class=\"com.xu.entity.User\"/&gt;&lt;/beans&gt; FirstTest测试类123456789101112131415package com.xu.test;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class FirstTest { @Test public void testFirst() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); Object user = applicationContext.getBean(\"user\"); System.out.println(user); //运行结果：com.xu.entity.User@7f0eb4b4 //说明Spring容器帮我们成功创建出来了User对象 }} 代码细节剖析1. 底层是如何创建的User对象?是通过反射机制调用的无参构造函数吗? 答:是 如何通过反射机制获取对象? 1234567package com.xu.entity;public class User { public User() { System.out.println(\"User类的无参构造方法执行了~\"); }} 123456789@Testpublic void testReflect() { try { Class&lt;?&gt; aClass = Class.forName(\"com.xu.entity.User\"); System.out.println(aClass.newInstance()); } catch (Exception e) { throw new RuntimeException(e); }} 运行结果： Spring beans.xml里面的class可以配置抽象类吗? 答:不可以 如何理解下面这句代码中的abstract=”true” 1&lt;bean id=\"abstractClass\" class=\"com.xu.entity.AbstractClass\" abstract=\"true\"/&gt; 在Spring的beans.xml配置文件中，标签的abstract属性用于定义一个抽象的bean。将abstract属性设置为true表示该bean是抽象的，不能直接实例化。具体含义如下:抽象的bean无法被直接实例化，它只作为其他非抽象bean的父类或模板，它可以提供一些通用的配置或方法，供子类或其他具体的bean继承和使用,抽象bean可以包含一些通用的属性或方法，但它们没有具体的实现，需要子类或具体的bean来提供实现。抽象bean可以被其他非抽象的bean继承，继承后的子类bean可以继承父类bean的属性和方法，并可以覆盖或补充父类的实现。通过定义抽象bean，可以实现代码的重用和封转通用逻辑的目的。它提供了一种模板化的方式，允许其他具体的bean来继承和扩展。在配置文件中，抽象bean的定义通常用于作为其他具体bean的基类或模板，而不能直接实例化为一个独立的bean。因此，抽象bean的abstract属性被设置为true，以标识它是一个抽象的概念, 而不是一个具体的可实例化的bean。 代码3.1中，getBean()方法返同的类型是Object。这个时候，如果我想要访问子类的特有属性和方法时，还需要向下转型，有其它办法可以优化这个问题吗? 代码3.1： 123456@Testpublic void testFirst() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); Object user = applicationContext.getBean(\"user\"); System.out.println(user);} 答：有，可以调用getBean的另外一种实现方式。请看代码3.2 代码3.2： UserDaoImplForMySQL类中有一个特有的方法getUserList 12345public class UserDaoImplForMySQL { public void getUserList(){ System.out.println(\"获取用户列表方法执行了~\"); }} 通过下面这种方式可以直接获取到UserDaoImplForMySQL类型的对象userDao 通过userDao可以直接访问UserDaoImplForMySQL类的特有方法getUserList 123456@Testpublic void test2() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); UserDaoImplForMySQL userDao = applicationContext.getBean(\"userDaoBean\", UserDaoImplForMySQL.class); userDao.getUserList();} 可以一次性读取多个bean的xml文件吗？ 答：可以 在beans.xml中声明一个id为user的bean，在spring.xml中声明一个id为vip的bean。通过如下代码同时读取两个配置文件。 1234567@Testpublic void test3(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\", \"spring.xml\"); User user = applicationContext.getBean(\"user\", User.class); Vip vip = applicationContext.getBean(\"vip\", Vip.class);} ClassPathXmlApplicationContext是从类路径中加载配置文件，如果配置文件不在类路径当中，又应该如何加载配置文件呢？ 12345@Testpublic void test4(){ ApplicationContext applicationContext = new FileSystemXmlApplicationContext(\"D:\\\\3_study\\\\1.coding\\\\external.xml\"); Object userDaoBean = applicationContext.getBean(\"userDaoBean\", UserDaoImplForMySQL.class);} ApplicationContext的超级父接口BeanFactory。 可以直接用BeanFactory来定义对象 123456@Testpublic void test5() { BeanFactory beanFactory = new ClassPathXmlApplicationContext(\"beans.xml\"); Object user = beanFactory.getBean(\"user\"); System.out.println(user); //com.xu.entity.User@5c33f1a9} 启用Log4j2日志框架引入Log4j2依赖1234567891011&lt;!--log4j2的依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt;&lt;/dependency&gt; 新建log4j2.xml文件（文件必须放到根路径下，名字固定为log4j2.xml）123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;loggers&gt; &lt;!-- level指定日志级别，从低到高的优先级： ALL &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF --&gt; &lt;root level=\"DEBUG\"&gt; &lt;appender-ref ref=\"spring6log\"/&gt; &lt;/root&gt; &lt;/loggers&gt; &lt;appenders&gt; &lt;!--输出日志信息到控制台--&gt; &lt;console name=\"spring6log\" target=\"SYSTEM_OUT\"&gt; &lt;!--控制日志输出的格式--&gt; &lt;PatternLayout pattern=\"%d{yyyy-MM-dd HH:mm:ss SSS} [%t] %-3level %logger{1024} - %msg%n\"/&gt; &lt;/console&gt; &lt;/appenders&gt;&lt;/configuration&gt; 使用日志框架1234567public class UserDaoImplForMySQL { Logger logger = LoggerFactory.getLogger(UserDaoImplForMySQL.class); public UserDaoImplForMySQL() { logger.info(\"UserDaoImplForMySQL类的无参构造方法执行了~~~\"); }}","categories":[{"name":"Spring6","slug":"Spring6","permalink":"https://xiaofanshutu.github.io/categories/Spring6/"}],"tags":[]},{"title":"控制反转","slug":"D2-引入控制反转思想","date":"2025-04-09T09:59:01.288Z","updated":"2025-04-09T10:24:39.383Z","comments":true,"path":"posts/424232bd.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/424232bd.html","excerpt":"引入控制反转概念将对象的创建权/管理权交出去了，不再使用硬编码的方式了。同时也把对象关系的管理权交出去了，也不再使用硬编码的方式了。像这种把对象的创建权交出去，把对象关系的管理权交出去，被称为控制反转。 控制反转IoC控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计思想，可以用来降低代码之间的耦合度，符合依赖倒置原则。IoC可以认为是一种全新的设计模式，但是理论和时间成熟相对较晚，并没有包含在GoF中。（GoF指的是23种设计模式）。Spring框架就是一个实现了IoC思想的框架。 控制反转思想的核心是：将对象的创建权交出去，将对象和对象之间关系的管理权交出去，由第三方容器来负责创建与维护。 控制反转常见的实现方式：依赖注入（Dependency Injection，简称DI）。通常，依赖注入的实现又包括两种方式： set方法注入 构造方法注入 Spring概述","text":"引入控制反转概念将对象的创建权/管理权交出去了，不再使用硬编码的方式了。同时也把对象关系的管理权交出去了，也不再使用硬编码的方式了。像这种把对象的创建权交出去，把对象关系的管理权交出去，被称为控制反转。 控制反转IoC控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计思想，可以用来降低代码之间的耦合度，符合依赖倒置原则。IoC可以认为是一种全新的设计模式，但是理论和时间成熟相对较晚，并没有包含在GoF中。（GoF指的是23种设计模式）。Spring框架就是一个实现了IoC思想的框架。 控制反转思想的核心是：将对象的创建权交出去，将对象和对象之间关系的管理权交出去，由第三方容器来负责创建与维护。 控制反转常见的实现方式：依赖注入（Dependency Injection，简称DI）。通常，依赖注入的实现又包括两种方式： set方法注入 构造方法注入 Spring概述Spring简介 Spring框架是一个开源的Java应用程序框架，它由Rod Johnson创建。它提供了一系列的模块来简化Java应用程序的开发。Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。Spring最初的出现是为了解决EJB臃肿的设计，以及难以测试等问题。Spring为简化开发而生，让程序员只需关注核心业务的实现，尽可能的不再关注非业务逻辑代码（事务控制，安全日志等）。 Spring常用模块注：在Spring5中新增了Webflux模块。 Spring Core: 这是Spring框架的核心模块，提供了IoC(Inversion of Control)容器的实现。loC容器负责管理和组织应用程序中的对象，通过依赖注入来管理对象之间的依赖关系。 Spring MVC 这是Spring框架的Web开发模块，提供了一个基于MVC(Model-View-Controller)架构的Web应用程序开发框架。它通过DispatcherServlet将请求分发给合适的处理器，并将处理结果返回给客户端。 Spring AOP 这是Spring框架的面向切面编程模块，提供了一种在应用程序中实现模切关注点的方式。通过AOP，可以将与业务逻辑无关的功能(如日志记录、性能监测、事务管理等)模块化并集中管理。（扩展1： Spring AOP通俗解释） Spring Web Spring Web模块提供了基于Servlet技术的Web应用程序开发支持。它包含了Spring MVC框架，用于构建基于MVC架构的Web应用程序。SpringMVC通过DispatcherServlet将请求分发给合适的处理器，并将处理结果返回给客户端。它还提供了一些注解和工具，用于处理URL映射、请求参数绑定、视图解析等。 Spring ORM 它可以与Hiberate、MyBatis等ORM框架集成，简化了数据访问层的开发。Spring ORM提供了一些模板类和注解，用于简化数据库操作、事务管理等操作。 Spring Context Spring Context模块是Spring框架的核心模块之一，提供了1oC容器的实现。loC容器负责管理和组织应用程序中的对象，通过依赖注入来管理对象之间的依赖关系。Spring Context模块还提供了一些高级特性，如面向切面编程(AOP)、事件传播、国际化支持等。 Spring DAO Spring DAO模块是Spring框架中的数据访问对象(DAO)支持模块。它提供了一种简化和统一的方式来访问和操作各种数据存储，如关系型数据库、NoSQL数据库、缓存等。Spring DAO模块可以与 ORM框架(如Hibernate.MyBatis)集成，也可以直接使用JDBC进行数据库操作。它提供了一些模板类和注解，用于简化数据库操作、事务管理等。 Spring Webflux Spring Webflux是Spring框架的响应式编程支持模块。它基于Reactive Streams规范，提供了一种非阻塞的、异步的编程模型，SpringWebflux可以用于构建响应式的Web应用程序和服务。它提供了一些注解和函数式编程的API，用于处理HTTP请求，处理数据流、处理异步操作等。与传统的Servlet容器相比，Spring Webflux可以处理更高的并发请求和更高的吞吐量。 还有其他几个常用模块，未在上图列出： Spring Data 这是Spring框架的数据访问模块，提供了对各种数据访问技术的集成支持。它简化了数据访问层的开发，提供了一种统一的API来访问和操作各种数据存储(如关系型数据库、NoSQL数据库、缓存等)。 Spring Security 这是Spring框架的安全模块，提供了身份验证和授权的支持。它可以集成到Spring应用程序中，为应用程序提供安全性保护，如用户认证、授权、密码加密等。 Spring特点 轻量 从大小与开销两方面而言Spring都是轻量的。完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布。并且Spring所需的处理开销也是微不足道的。 Spring是非侵入式的：Spring应用中的对象不依赖于Spring的特定类。（扩展2：非侵入式编程） 控制反转 Spring通过一种称作控制反转（IoC）的技术促进了松耦合。当应用了IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。你可以认为IoC与JNDI相反—不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。（扩展3：loC和JNDI的区别） 面向切面 Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。 容器 Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。然而，Spring不应该被混同于传统的重量级的EJB容器，它们经常是庞大与笨重的，难以使用。 框架 Spring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。Spring也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。 所有Spring的这些特征使你能够编写更干净、更可管理、并且更易于测试的代码。它们也为Spring中的各种模块提供了基础支持。 扩展1： Spring AOP通俗解释想象一下你正在画一幅画，画中有很多不同的元素，如人物、树、花等。画画时，你可能会有一些特别的需求，比如想要给画中的每个元素都添加一些相同的颜色或纹理。但是，你不想挨个给每个添加，因为那样会很麻烦。 这时，Spring AOP就像一个魔法笔，它可以帮助你在画画的过程中自动添加你想要的颜色或纹理，而无需手动去做。你只需要告诉魔法笔你想要添加的颜色或纹理，然后它会自动帮你完成。在编程中，我们经常需要在一些特定的地方(例如方法调用或特定的代码段)执行一些相同的操作，比如日志记录、性能监测或事务管理。Spring AOP就像这个魔法笔，它可以自动帮助我们在这些特定的地方添加这些通用操作，而无需手动去每个地方都编写相同的代码。所以，Spring AOP可以让我们更方便地在代码中添加一些通用的功能，而无需重复编写相同的代码。它是一种在编程中帮助我们实现代码重用和维护的魔法笔。 扩展2：非侵入式编程非侵入式编程是一种编程范式，它强调在开发应用程序时，不需要对现有代码进行修改或依赖于特定的框架或库。具体来说，非侵入式编程具有以下几个特点: 低依赖性:Spring框架的核心容器是一个轻量级的loC容器，它本身的依赖性非常低。这意味着您可以选择性地使用 Spring框架的各个模块，而不需要将整个应用程序都依赖于Spring。您可以根据需要选择性地引入Spring的功能，而不会对应用程序的其他部分产生强耦合。 面向接口编程:Spring框架鼓励使用接口进行编程，通过依赖注入将具体实现类与接口解耦。这种面向接口的编程方式使得应用程序的各个组件之间的耦合度降低，增加了代码的可维护性和可扩展性。 配置灵活性:Spring框架使用XML、注解和Java配置等方式来进行配置。这种灵活的配置方式使得您可以根据需要对应用程序进行灵活的配置和调整，而不需要修改应用程序的源代码。这种配置的灵活性使得您可以将Spring框架集成到现有的应用程序中，而不需要对原有代码进行大量的修改。 面向切面编程:Spring框架提供了面向切面编程(AOP)的支持，可以将与核心业务逻辑无关的横切关注点(如日志、事务管理)模块化并集中管理。这样可以将这些横切关注点与业务逻辑进行解耦，使得应用程序的代码更加清晰和可维护。 综上所述，Spring框架是非侵入式的，因为它可以与现有的应用程序进行集成，而不需要对应用程序进行大量的修改。它通过依赖注入、面向接口编程和配置的灵活性，使得应用程序的各个组件之间的耦合度降低，增加了代码的可维护性和可扩展性。 扩展3：loC和JNDI的区别loC(Inversion of Control)和JNDI(Java Naming and Directory Interface)是两个不同的概念，它们在思想上有以下区别: 控制反转(loC): loC是一种设计模式，也称为依赖注入(Dependency Injection)，它是一种通过外部容器来管理对象的创建和组装的方式。在loC中，应用程序不再负责创建和管理对象的依赖关系，而是将这些责任交给了一个外部的容器。容器根据配置文件或注解的定义，将对象之间的依赖关系注入到相应的对象中。这种方式将控制权反转给了容器，使得应用程序更加灵活、可扩展和易于维护。 loC是将对象的控制权交给框架，框架主动为用户提供对象，而不需要用户主动去申请。通过配置文件或注解，用户可以告诉框架需要哪些对象以及它们的依赖关系，然后框架负责创建和管理这些对象，并在需要的时候将它们注入到用户代码中。 JNDI 是Java平台提供的一种用于访问命名和目录服务的API。它提供了一种统一的方式来访问各种命名和目录服务，如LDAP(Lightweight DirectoryAccess Protocol)、DNS(Domain Name System)等。通过JNDI,应用程序可以在运行时动态地查找和获取命名和目录服务中的对象。JNDI的主要目的是为了实现应用程序与命名和目录服务的解耦，提供一种统一的访问方式。 JNDI是用户主动去获取对象的一种方式。用户通过JNDI API来访问命名和目录服务，根据对象的名称或其他标识符来查找和获取相应的对象。这种方式需要用户自己编写代码来处理对象的获取和使用。 综上所述，loC和JNDI在对象获取的方式上存在明显的差异。loC框架通过自动创建和管理对象来实现控制反转，而JNDI则需要用户自己编写代码来主动获取对象。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://xiaofanshutu.github.io/categories/Spring/"}],"tags":[]},{"title":"HTML5","slug":"HTML - 副本","date":"2024-01-17T22:55:32.103Z","updated":"2024-01-17T23:39:08.350Z","comments":true,"path":"posts/98f3a6d9.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/98f3a6d9.html","excerpt":"","text":"什么是HTMLHTML Hyper Text Markup Language(超文本标记语言) HTML的全称为超文本标记语言，是一种标记语言。它包括一系列标签．通过这些标签可以将网络上的文档格式统一，使分散的Internet资源连接为一个逻辑整体。HTML文本是由HTML命令组成的描述性文本，HTML命令可以说明文字，图形、动画、声音、表格、链接等。 W3C World Wide Web Consortium(万维网联盟) 万维网联盟创建于1994年，是Web技术领域最具权威和影响力的国际中立性技术标准机构。W3C已发布了200多项影响深远的Web技术标准及实施指南，如广为业界采用的超文本标记语言HTML（标准通用标记语言下的一个应用）、可扩展标记语言XML（标准通用标记语言下的一个子集）以及帮助残障人士有效获得Web信息的无障碍指南（WCAG）等，有效促进了Web技术的互相兼容，对互联网技术的发展和应用起到了基础性和根本性的支撑作用。 网页基本信息1234567891011121314151617&lt;!-- DOCTYPE: 告诉浏览器，我们要使用什么规范 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;!-- head: 代表网页头部 --&gt;&lt;head&gt; &lt;!-- meta: 描述性标签，用来描述我们网站的一些信息 --&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;!-- title: 网页标题 --&gt; &lt;title&gt;我的第一个HTML网页&lt;/title&gt;&lt;/head&gt;&lt;!-- body: 代表网页主体 --&gt;&lt;body&gt;你好，bambi&lt;/body&gt;&lt;/html&gt; 网页基本标签12345678910111213141516171819202122232425262728293031&lt;body&gt;&lt;!--标题标签--&gt;&lt;h1&gt;h1标题&lt;/h1&gt;&lt;h2&gt;h2标题&lt;/h2&gt;&lt;h3&gt;h2标题&lt;/h3&gt;&lt;h4&gt;h2标题&lt;/h4&gt;&lt;h5&gt;h2标题&lt;/h5&gt;&lt;h6&gt;h2标题&lt;/h6&gt;&lt;!--段落标签--&gt;&lt;p&gt; 这是一个段落标签&lt;/p&gt;&lt;!--换行标签--&gt;这是一个换行&lt;br&gt;标签&lt;!--水平线标签--&gt;&lt;hr&gt;&lt;!--字体样式标签-粗体--&gt;&lt;strong&gt;hope to see you on the top&lt;/strong&gt;&lt;!--字体样式标签-斜体--&gt;&lt;em&gt;boun prem&lt;/em&gt;&lt;!--特殊符号-空格--&gt;你&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;好&lt;!--特殊符号-大于--&gt;&amp;gt;&lt;!--特殊符号-小于--&gt;&amp;lt;&lt;!--特殊符号-版权所有--&gt;&amp;copy;&lt;/body&gt; 图像标签 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;HTML学习&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=\"resources/image/5.png\" title=\"海绵宝宝\" width=\"300\" height=\"300\" /&gt;&lt;/body&gt;&lt;/html&gt; 超链接标签及其应用文本超链接123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;HTML学习&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--href: 必填，表示要跳转到哪一个页面--&gt;&lt;!--target: 表示窗口在哪里打开--&gt;&lt;a href=\"test01.html\" target=\"_blank\"&gt;文本超链接&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 图像超链接12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;HTML学习&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"test01.html\" target=\"_blank\"&gt;&lt;img src=\"resources/image/5.png\" title=\"图片超链接\" width=\"300\" height=\"300\" /&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 锚链接123&lt;a id=\"bottom\"&gt;&lt;/a&gt;&lt;!--锚链接--&gt;&lt;a href=\"test01.html#bottom\"&gt;跳转到底部&lt;/a&gt; 功能性链接邮件链接12&lt;!--邮件链接--&gt;&lt;a href=\"mailto:15191434031@163.com\"&gt;邮件链接&lt;/a&gt; 块元素和行内元素 块元素 无论内容多少，该元素独占一行 (p, h1-h6) 行内元素 内容撑开宽度，左右都是行内元素的可以排在一行 (a, strong, em) 列表标签无序列表1234&lt;!--无序列表--&gt;&lt;ul&gt;a&lt;/ul&gt;&lt;ul&gt;b&lt;/ul&gt;&lt;ul&gt;c&lt;/ul&gt; 有序列表123456&lt;!--有序列表--&gt;&lt;ol&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;草莓&lt;/li&gt;&lt;/ol&gt; 自定义列表123456789&lt;!--自定义列表: 自定义列表一般用在网站底部--&gt;&lt;dl&gt; &lt;dt&gt;我的爱好 &lt;dd&gt;游泳&lt;/dd&gt; &lt;dd&gt;看书&lt;/dd&gt; &lt;dd&gt;听音乐&lt;/dd&gt; &lt;dd&gt;跑步&lt;/dd&gt; &lt;/dt&gt;&lt;/dl&gt; 表格标签1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;表格标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- tr:行 td:列 跨行:rowspan 跨列:colspan--&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td rowspan=\"3\"&gt;11&lt;/td&gt; &lt;td&gt;12&lt;/td&gt; &lt;td&gt;13&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;22&lt;/td&gt; &lt;td&gt;23&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt;33&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 媒体元素视频文件1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;媒体元素&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--controls:控制条autoplay:自动播放--&gt;&lt;video src=\"resources/video/02.mp4\" controls autoplay&gt;测试视频&lt;/video&gt;&lt;/body&gt;&lt;/html&gt; 视频能成功加载并且会自动播放 音频文件1&lt;audio src=\"resources/video/02.mp4\" controls autoplay&gt;&lt;/audio&gt; 页面结构分析 元素名 描述 header 标记头部区域的内容（用于页面或页面中的一块区域） footer 标记脚部区域的内容（用于整个页面或者页面的一块区域） section Web页面中的一块独立区域 article 独立的文章内容 aside 相关内容或应用（常用于侧边栏） nav 导航类辅助内容 iframe内联框架12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;内联框架&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;iframe src=\"test03.html\" name=\"mainFrame\"&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt; 初识表单post和get提交123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;提交表单&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"test01.html\" method=\"get\"&gt; &lt;p&gt;用户名：&lt;input type=\"text\"/&gt;&lt;/p&gt; &lt;p&gt;密 码：&lt;input type=\"password\"/&gt;&lt;/p&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;input type=\"reset\" value=\"重置\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 文本框和单选框 123456789101112131415161718&lt;!--文本输入框--&gt;文本输入框&lt;p&gt; &lt;input type=\"text\" name=\"name\"&gt;&lt;/p&gt;&lt;!--密码框--&gt;密码框&lt;p&gt; &lt;input type=\"password\"&gt;&lt;/p&gt;&lt;!--单选框，默认选中男checked--&gt;性别&lt;p&gt; &lt;input type=\"radio\" name=\"sex\" value=\"男\" checked&gt;男 &lt;input type=\"radio\" name=\"sex\" value=\"女\"&gt;女&lt;/p&gt; 按钮和多选框12345678910&lt;p&gt; &lt;input type=\"checkbox\" value=\"reading\" name=\"hobby\"&gt;阅读 &lt;input type=\"checkbox\" value=\"running\" name=\"hobby\" checked&gt;跑步 &lt;input type=\"checkbox\" value=\"yoga\" name=\"hobby\"&gt;瑜伽&lt;/p&gt;&lt;p&gt; &lt;input type=\"button\" value=\"按钮显示的文字\" name=\"btn1\"&gt; &lt;input type=\"image\" src=\"resources/image/5.png\" width=\"200\"&gt;&lt;/p&gt; 列表框文本域和文件域12345678910111213141516171819202122&lt;p&gt;下拉框 &lt;select name=\"水果天堂\"&gt; &lt;option value=\"banana\"&gt;香蕉&lt;/option&gt; &lt;option value=\"apple\" selected&gt;苹果&lt;/option&gt;&lt;!-- 苹果默认会是选中的 --&gt; &lt;option value=\"strawberry\"&gt;草莓&lt;/option&gt; &lt;/select&gt;&lt;/p&gt;&lt;p&gt;文本域 &lt;textarea name=\"remark\" cols=\"60\" rows=\"10\"&gt; 在这里写入备注内容 &lt;/textarea&gt;&lt;/p&gt;&lt;p&gt;文件域 &lt;input type=\"file\" name=\"file\"&gt; &lt;input type=\"button\" value=\"上传文件\" name=\"upload\"&gt;&lt;/p&gt; 搜索框滑块和简单验证123456789101112131415161718&lt;form&gt;&lt;p&gt;邮箱： &lt;input type=\"email\" name=\"email\"&gt;&lt;/p&gt;&lt;p&gt;URL： &lt;input type=\"url\" name=\"url\"&gt;&lt;/p&gt;&lt;p&gt;滑块： &lt;input type=\"range\" min=\"0\" max=\"100\" name=\"voice\" step=\"2\"&gt;&lt;/p&gt;&lt;p&gt;搜索： &lt;input type=\"search\" name=\"search\"&gt;&lt;/p&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 表单的应用 隐藏域hidden 只读readonly 禁用disable 表单初级验证 placeholder：提示信息 required：非空判断 pattern：正则表达式 123&lt;p&gt; 用户名：&lt;input type=\"text\" name=\"name\" required placeholder=\"请输入用户名\"&gt;&lt;/p&gt;","categories":[{"name":"HTML5","slug":"HTML5","permalink":"https://xiaofanshutu.github.io/categories/HTML5/"}],"tags":[],"author":"cutiebambi"},{"title":"Java","slug":"老韩Java","date":"2023-10-07T12:03:24.722Z","updated":"2024-01-17T23:38:15.521Z","comments":true,"path":"posts/df2849ec.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/df2849ec.html","excerpt":"","text":"Java概述如何快速学习一个知识点 转义字符1234567// 在控制台，输入 tab 键，可以实现命令补全 \\t ：一个制表位，实现对齐的功能\\n ：换行符\\\\ ：一个\\\\\" :一个\"\\' ：一个' \\r :一个回车 12345678910111213141516171819202122232425262728//转义字符练习public class App { //编写一个 main 方法 public static void main(String[] args) { //\\t ：一个制表位，实现对齐的功能 System.out.println(\"北京\\t天津\\t上海\"); // \\n ：换行符 System.out.println(\"jack\\nsmith\\nmary\"); // \\\\ ：一个\\ System.out.println(\"C:\\\\Windows\\\\System32\\\\cmd.exe\"); // \\\" :一个\" System.out.println(\"你好呀，\\\"bambi\\\"\"); // \\' ：一个' System.out.println(\"你好呀，\\'bambi\\'\"); // \\r :一个回车 System.out.println(\"你好呀\\r明天\"); // 解读 // 1. 输出 你好呀 // 2. \\r 表示回车 System.out.println(\"你好呀\\r明天\"); }} 12345678910d:\\desktop&gt;java App北京 天津 上海jacksmithmaryC:\\Windows\\System32\\cmd.exe你好呀，\"bambi\"你好呀，'bambi'明天呀明天呀 Java代码规范_行尾风格 DOS（Disk Operating System 磁盘操作系统）命令DOS介绍 相对路径 &amp; 绝对路径 常用DOC命令1234567891011121314151.查看当前目录是有什么内容 dir dir dir d:\\abc2\\test2002.切换到其他盘下：盘符号 cd : change directory 案例演示： 切换到 c 盘 cd /D c: 3.切换到当前盘的其他目录下 (使用相对路径和绝对路径演示), ..\\表示上一级目录 案例演示： cd d:\\abc2\\test200 cd ..\\..\\abc2\\test200 4.切换到上一级： 案例演示： cd .. 5.切换到根目录：cd \\ 案例演示：cd \\6.查看指定的目录下所有的子级目录 tree7.清屏 cls8.退出 DOS exit 变量变量使用注意事项1.变量表示内存中一块存储区域，不同类型占用的空间不同。 2.该区域有自己的名称 [变量名] 和类型 [数据类型] 3.变量三要素，变量=变量名 + 变量值 + 数据类型 程序中+号的使用1.加号左右两边如果都是数字，做加法运算。 2.加号左右两边有一方为字符串，做拼接运算。 3.运算顺序，从左到右。 1System.out.println(\"hello\" + 100 + 3);//hello1003 数据类型 整数类型整数类型的分类 整数类型使用注意细节1.Java的整型默认为int类型，可以加小写l或者大写L将数字变为long类型。 2.bit，计算机中的最小存储单位。 ​ byte，计算机中的基本存储单元。 ​ 1byte = 8bit 浮点类型浮点型的分类 说明： 1.浮点数都是近似值，尾数可能丢失，造成精度损失。 2.浮点数 = 符号位 + 指数位 + 尾数位 浮点数类型使用注意细节 浮点数常量默认类型为double类型，尾部加f或者F可以变为float。 浮点型常量有两种表现形式： 十进制形式：1.23, 521.0f, .369 科学计数法形式：5.21e2$$5.21 * 10^2$$1.23e-2$$1.23/10^2$$ 通常情况下，应该使用double类型，因为double更精确。 12345678public class App { public static void main(String[] args) { double n1 = 3.123456789; float n2 = 3.123456789F; System.out.println(n1); System.out.println(n2); }} 123.1234567893.1234567 浮点数使用陷阱 2.7 和 8.1 / 3 的比较 1234567891011121314public class App { public static void main(String[] args) { double n1 = 2.7; double n2 = 8.1 / 3; System.out.println(n1 == n2);// false System.out.println(n1); System.out.println(n2); //通过Math.abs判断浮点数类型是否相等 if(Math.abs(n1 - n2) &lt; 0.00001){ System.out.println(\"这两个double类型的数据相等~\"); } }} 1234false2.72.6999999999999997这两个double类型的数据相等~ Java API文档API: Application Programming Interface应用程序编程接口 字符类型（char）案例演示123456789101112public class App { public static void main(String[] args) { char c1 = 'a'; char c2 = '\\t'; char c3 = '许'; char c4 = 97; System.out.println(c1); System.out.println(c2); System.out.println(c3); System.out.println(c4); }} 字符型使用细节 在Java中，char的本质是一个整数，默认输出Unicode码对应的字符。https://tool.chinaz.com/tools/unicode.aspx 可以直接给char赋一个整数，输出的时候，会按照对应的Unicode字符输出。（97 ==》 a） char支持运算，它相当于一个整数，因为它都有对应的Unicode码。思考：System.out.println(‘a’ + “a”); 程序运行后，会输出什么？ 123456789101112131415161718192021222324252627public class App { public static void main(String[] args) { // 在 java中，char的本质是一个整数，在默认输出时，是 unicode 码对应的字符 // 要输出对应的数字，可以(int)字符 char c1 = 97; System.out.println(c1); // a char c2 = 'a'; //输出'a' 对应的数字 System.out.println((int)c2);//97 char c3 = '许'; System.out.println((int)c3);//35768 char c4 = 35768; System.out.println(c4);//许 // char类型是可以进行运算的，相当于一个整数，因为它都对应有 Unicode 码. System.out.println('a' + 10);//107 // 课堂小测试 char c5 = 'b' + 1; System.out.println((int)c5);//99 System.out.println(c5);//c System.out.println('a' + \"a\");//aa System.out.println('a' + 1);//98 }} 字符存储细节字符型存储到计算机里面，会将字符对应的码值（整数）找出来。比如： 存储’a’ =&gt; 码值97 =&gt; 二进制（0110 0001） =&gt;存储 字符编码表 ASCII编码，一个字节表示，一共128个字符。实际上一个字节可以表示256个字符，它没有用完，只用了128个。 Unicode编码，固定大小的编码，字母和汉字统一都是占用2个字节，浪费空间。 UTF-8编码，大小可变的编码表，字母占1个字节，汉字占用3个字节。 GBK编码，可以表示汉字，而且范围比较广，字母1个字节，汉字2个字节。 GB2312编码，可以表示汉字。（GB2312 &lt; GBK） BIG5码，繁体中文，台湾，香港。 布尔类型（boolean）布尔类型也叫boolean类型，只允许取值true或者false，没有null。 在Java中，不可以使用非0或者0代替true或false。 基本数据类型转换自动类型转换 自动类型转换细节 多种类型的数据混合运算时，系统会首先自动将所有的数据转换为容量最大的那种数据类型，然后再进行计算。int + double ==&gt; 会转成double （byte，short）和char之间没有类型转换 123//当把一个具体的值赋给byte时，会先判断该值是否在byte范围内，如果在，就okbyte b1 = 10; //不报错char c1 = b1; //报错，因为byte不能转换为char byte，short，char三者运算时，会在计算时转换为int类型 自动提升原则：表达式结果的类型自动提升为操作数中最大的类型。 强制类型转换自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。有可能会造成精度损失或数据溢出。 强制类型转换细节 强制符号只针对最近的操作数，可以使用小括号来提升优先级。 12int x = (int)(3 * 3.5 + 6 * 1.5);System.out.println(x); char类型可以保存int的常量值，但是不能保存int的变量值，需要强转。 12345char c1 = 100;int i1 = 100;//char c2 = i1;//错误char c2 = (char)i1;System.out.println(c2);//100对应的字符d byte和short，char类型在进行运算时，会被当做int类型处理。 基本数据类型和String类型的转换1、基本数据类型转String类型 基本数据类型的值 + “ “ 2、String类型转基本数据类型 基本类型包装类.parse**() 3、字符串转为字符。str.charAt(0); 12345678910111213public class App { public static void main(String[] args) { String s = \"123\"; int i = Integer.parseInt(s); System.out.println(i);//123 double v = Double.parseDouble(s); System.out.println(v); byte b = Byte.parseByte(s); System.out.println(b); }} 123123123.0123 本章作业 程序阅读题，看看输出什么？ 12308 使用char类型，分别保存\\n \\t \\r \\ 1等字符，并且打印输出 123456789101112131415public class App { public static void main(String[] args) { //分别保存\\n \\t \\r \\\\ 1 等字符 char c1 = '\\n'; char c2 = '\\t'; char c3 = '\\r'; char c4 = '\\\\'; char c5 = '1'; System.out.println(c1); System.out.println(c2); System.out.println(c3); System.out.println(c4); System.out.println(c5); }} 保存两本书名，用+拼接，看效果。 保存两个性别，用+拼接，看效果。 保存两本书价格，用+拼接，看效果。 123456789101112131415public class App { public static void main(String[] args) { String s1 = \"向前一步\"; String s2 = \"你当像鸟飞往你的山\"; System.out.println(s1 + s2); char c1 = '男'; char c2 = '女'; System.out.println(c1 + c2); double d1 = 32.2; double d2 = 31.1; System.out.println(d1 + d2); }} 123向前一步你当像鸟飞往你的山5290663.300000000000004 编程实现如下效果 123456789101112public class App { public static void main(String[] args) { String name = \"bambi\"; int age = 13; char gender = '女'; int score = 99; String hobby = \"climbing\"; System.out.println(\"姓名\" + \"\\t\" + \"年龄\" + \"\\t\" + \"性别\" + \"\\t\" + \"成绩\" + \"\\t\" + \"爱好\" + \"\\n\" + name + \"\\t\" + age + \"\\t\" + gender + \"\\t\" + score + \"\\t\" + hobby); }} 用IDEA执行代码输出结果为： 用CMD执行代码输出结果为： 运算符运算符介绍 算术运算符算术运算符一览 细节说明*对一个数取模，等价于a%b = a-a/bb。** 练习题假如还有 59 天放假，问：合 xx 个星期零 xx 天12345678public class App { public static void main(String[] args) { int days = 258; int weeks = days/7; int leftDays = days%7; System.out.println(days + \"天,\" + \"合\" + weeks + \"星期零\" + leftDays + \"天\"); }} 1258天,合36星期零6天 定义一个变量保存华氏温度，华氏温度转换摄氏温度的公式为：5/9*(华氏温度-100),请求出华氏温度对应的摄氏温度。[234.5]12345678public class App { public static void main(String[] args) {// 定义一个变量保存华氏温度，华氏温度转换摄氏温度的公式为：5/9*(华氏温度-100),请求出华氏温度对应的摄氏温度。[234.5] double fahrenheit = 60.8; double centigrade = 5.0 / 9 * (fahrenheit - 100); System.out.println(centigrade); }} 1-21.77777777777778 关系运算符介绍 关系运算符的结果都是布尔（boolean）类型，要么是true，要么是false。 关系运算符组成的表达式称为关系表达式。 关系运算符一览 程序控制结构程序流程控制介绍顺序控制分支控制 if-else双分支嵌套分支switch 分支结构for 循环控制(!!!)while 循环控制do..while 循环控制多重循环控制(难点! 重点!)跳转控制语句-break跳转控制语句-continue跳转控制语句-return本章作业 12345678910111213141516package chapter5.homework;public class Homework03 { public void test(int year) { if ((year % 4 == 0) &amp;&amp; (year % 100 != 0) || year % 400 == 0) { System.out.println(year + \"年是闰年\"); } else { System.out.println(year + \"年不是闰年\"); } } public static void main(String[] args) { Homework03 homework03 = new Homework03(); homework03.test(2005); }} 123456789101112131415161718192021package chapter5.homework;public class Homework06 { public void test() { int count = 0; for (int i = 1; i &lt;= 100; i++) { if (i % 5 != 0) { count++; System.out.print(i + \"\\t\"); if (count % 5 == 0) { System.out.print(\"\\n\"); } } } } public static void main(String[] args) { Homework06 homework06 = new Homework06(); homework06.test(); }} 123456789101112131415161718package chapter5.homework;public class Homework07 { public void test() { for (char i = 'a'; i &lt;= 'z'; i++) { System.out.print(i + \" \"); } System.out.println(); for (char i = 'Z'; i &gt;= 'A'; i--) { System.out.print(i + \" \"); } } public static void main(String[] args) { Homework07 homework = new Homework07(); homework.test(); }} 1234567891011121314151617181920package chapter5.homework;public class Homework08 { public void test() { double sum = 0; for (int i = 1; i &lt;= 100; i++) { if (i % 2 == 0) { sum -= 1.0 / i; } else { sum += 1.0 / i; } } System.out.println(\"结果为: \" + sum); } public static void main(String[] args) { Homework08 homework = new Homework08(); homework.test(); }} 123456789101112131415161718package chapter5.homework;public class Homework09 { public void test() { int sum = 0; for (int i = 1; i &lt;= 100; i++) { for (int j = 1; j &lt;= i; j++) { sum += j; } } System.out.println(\"总和为：\" + sum); } public static void main(String[] args) { Homework09 homework = new Homework09(); homework.test(); }} 数组、排序和查找为什么需要数组 数组介绍数组可以存放多个同一类型的数据。数组也是一种数据类型，为引用类型。 即：数组就是一组数据 数组快速入门用数组来解决上面的问题。 数组的使用动态初始化使用方式1：动态初始化 定义数据类型[] 数组名 = new 数据类型[大小]； int [] arr=new int[5]; 使用数组名[下标] arr[2] 代表要访问arr数组的第三个元素。（数组下标是从0开始的） 快速入门案例循环输入5个成绩，保存到double数组并输出。 12345678910111213141516import java.util.Scanner;public class Array02 { public static void main(String[] args) { double[] scores = new double[5]; Scanner scanner = new Scanner(System.in); for (int i = 0; i &lt; 5; i++) { System.out.println(\"请输入第\" + (i + 1) + \"个成绩\"); scores[i] = scanner.nextDouble(); } for (int i = 0; i &lt; scores.length; i++) { System.out.print(scores[i] + \"\\t\"); } System.out.println(); }} 1234567891011请输入第1个成绩90请输入第2个成绩89请输入第3个成绩30请输入第4个成绩100请输入第5个成绩8590.0 89.0 30.0 100.0 85.0 静态初始化数组使用注意事项和细节 数组是多个相同类型数据的组合，实现对这些数据的统一管理 数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用。 数组创建后，如果没有赋值，有默认值int 0，short 0, byte 0, long 0, float 0.0,double 0.0，char \\u0000，boolean false，String null 使用数组的步骤1. 声明数组并开辟空间2. 给数组各个元素赋值3. 使用数组 数组的下标是从0 开始的。 数组下标必须在指定范围内使用，否则报：下标越界异常，比如： int [] arr=new int[5]; 则有效下标为0-4 数组属引用类型，数组型数据是对象(object) 数组应用案例创建一个char 类型的26 个元素的数组，分别放置’A’-‘Z’。使用for 循环访问所有元素并打印出来。提示：char 类型数据运算’A’+2 -&gt; ‘C’ 1234567891011121314151617181920public class Test01 { public static void main(String[] args) { char[] arr = new char[26]; for (int i = 0; i &lt; arr.length; i++) { arr[i] = (char) ('A' + i); } System.out.println(\"正序输出====&gt;\"); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + \" \"); } System.out.println(); System.out.println(\"倒序输出====&gt;\"); for (int i = arr.length - 1; i &gt;= 0; i--) { System.out.print(arr[i] + \" \"); } System.out.println(); }} 1234正序输出====&gt;A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 倒序输出====&gt;Z Y X W V U T S R Q P O N M L K J I H G F E D C B A 请求出一个数组int[]的最大值{4,-1,9, 10,23}，并得到对应的下标 1234567891011121314public class Test01 { public static void main(String[] args) { int[] arr = {4, -1, 9, 10, 23}; int maxValue = arr[0]; int maxIndex = 0; for (int i = 0; i &lt; arr.length; i++) { if (arr[i] &gt; maxValue) { maxValue = arr[i]; maxIndex = i; } } System.out.println(\"最大值：\" + maxValue + \"，对应的下标为：\" + maxIndex); }} 1最大值：23，对应的下标为：4 数组赋值机制基本数据类型赋值，这个值就使具体的数据。且互不影响。 12int n1=1;int n2=n1; 数组是引用传递，赋的值是地址。 数组拷贝将int[] arr1 = {10,20,30}; 拷贝到arr2 数组, 要求数据空间是独立的. 12345678910111213141516171819public class Test01 { public static void main(String[] args) { int[] arr1 = {10, 20, 30}; int[] arr2 = new int[arr1.length]; for (int i = 0; i &lt; arr1.length; i++) { arr2[i] = arr1[i]; } System.out.println(\"arr1数组为：\"); for (int i = 0; i &lt; arr1.length; i++) { System.out.print(arr1[i] + \"\\t\"); } System.out.println(); System.out.println(\"arr2数组为：\"); for (int i = 0; i &lt; arr2.length; i++) { System.out.print(arr2[i] + \"\\t\"); } }} 1234arr1数组为：10 20 30 arr2数组为：10 20 30 数组反转要求：把数组{11,22,33,44,55,66}的元素内容反转{66, 55,44,33,22,11}。 12345678910111213141516171819public class Test01 { public static void main(String[] args) { int[] arr = {11, 22, 33, 44, 55, 66}; int[] arrNew = new int[arr.length]; for (int i = 0, j = arrNew.length - 1; i &lt; arr.length; i++, j--) { arrNew[j] = arr[i]; } System.out.println(\"原数组为：\"); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + \"\\t\"); } System.out.println(); System.out.println(\"反转之后的数组为：\"); for (int i = 0; i &lt; arrNew.length; i++) { System.out.print(arrNew[i] + \"\\t\"); } }} 1234原数组为：11 22 33 44 55 66 反转之后的数组为：66 55 44 33 22 11 数组添加/扩容要求：实现动态的给数组添加元素效果，实现对数组扩容。 原始数组使用静态分配int[] arr = {1,2,3} 用户可以决定是否继续添加，添加成功，是否继续？y/n 12345678910111213141516171819202122232425262728293031public class Test01 { public static void main(String[] args) { int[] arr = {1, 2, 3}; int[] arrNew; int number; Scanner scanner = new Scanner(System.in); while (true) { System.out.println(\"请输入是否需要插入元素，y/n\"); char c = scanner.next().charAt(0); if (c == 'y') { arrNew = new int[arr.length + 1]; System.out.println(\"请输入要插入的元素：\"); number = scanner.nextInt(); for (int i = 0; i &lt; arr.length; i++) { arrNew[i] = arr[i]; } arrNew[arrNew.length - 1] = number; arr = arrNew; } else { System.out.println(\"用户主动选择退出~\"); break; } } System.out.println(\"最终的数组结果为：\"); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + \"\\t\"); } System.out.println(); }} 123456789101112请输入是否需要插入元素，y/ny请输入要插入的元素：4请输入是否需要插入元素，y/ny请输入要插入的元素：5请输入是否需要插入元素，y/nn用户主动选择退出~1 2 3 4 5 有一个数组{1， 2， 3， 4， 5}， 可以将该数组进行缩减，提示用户是否继续缩减，每次缩减最后那个元素。当只剩下最后一个元素，提示，不能再缩减。 123456789101112131415161718192021222324252627282930313233343536public class Test01 { public static void main(String[] args) { int[] arr = {1, 2, 3, 4, 5}; int[] arrNew; Scanner scanner = new Scanner(System.in); while (true) { System.out.println(\"请输入是否需要删除元素，y/n\"); char c = scanner.next().charAt(0); if (arr.length == 1) { System.out.println(\"当前数组只剩余一个元素，不能再操作，直接退出~\"); showArray(arr); break; } if (c == 'y') { arrNew = new int[arr.length - 1]; for (int i = 0; i &lt; arrNew.length; i++) { arrNew[i] = arr[i]; } arr = arrNew; showArray(arr); } else { System.out.println(\"用户主动选择退出~\"); showArray(arr); break; } } } private static void showArray(int[] arr) { System.out.println(\"当前数组结果为：\"); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + \"\\t\"); } System.out.println(); }} 123456789101112131415161718192021请输入是否需要删除元素，y/ny当前数组结果为：1 2 3 4 请输入是否需要删除元素，y/ny当前数组结果为：1 2 3 请输入是否需要删除元素，y/ny当前数组结果为：1 2 请输入是否需要删除元素，y/ny当前数组结果为：1 请输入是否需要删除元素，y/ny当前数组只剩余一个元素，不能再操作，直接退出~当前数组结果为：1 排序的介绍排序是将多个数据，依指定的顺序进行排列的过程。 内部排序指将需要处理的所有数据都加载到内部存储器中进行排序。包括(交换式排序法、选择式排序法和插入式排序法)； 外部排序数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。包括(合并排序法和直接合并排序法)。 冒泡排序法冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从后向前（从下标较大的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。 下面我们举一个具体的案例来说明冒泡法。我们将五个无序：24,69,80,57,13 使用冒泡排序法将其排成一个从小到大的有序数列。 1234567891011121314151617181920212223242526public class Test01 { public static void main(String[] args) { int[] arr = {24, 69, 80, 57, 13}; System.out.println(\"原数组为：\"); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + \"\\t\"); } System.out.println(); int temp; for (int i = 0; i &lt; arr.length - 1; i++) { for (int j = 0; j &lt; arr.length - 1 - i; j++) { if (arr[j] &gt; arr[j + 1]) { temp = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = temp; } } } System.out.println(\"冒泡排序输出的结果为：\"); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + \"\\t\"); } System.out.println(); }} 1234原数组为：24 69 80 57 13 冒泡排序输出的结果为：13 24 57 69 80 查找介绍在java 中，我们常用的查找有两种: 顺序查找SeqSearch.java 二分查找【二分法，我们放在算法讲解】 案例有一个数列：白眉鹰王、金毛狮王、紫衫龙王、青翼蝠王猜数游戏：从键盘中任意输入一个名称，判断数列中是否包含此名称【顺序查找】要求: 如果找到了，就提示找到，并给出下标值。 12345678910111213141516171819202122import java.util.Scanner;public class Test01 { public static void main(String[] args) { String[] arr = {\"白眉鹰王\", \"金毛狮王\", \"紫衫龙王\", \"青翼蝠王\"}; Scanner scanner = new Scanner(System.in); System.out.println(\"请输入你要查找的名字：\"); String findName = scanner.next(); int index = -1; for (int i = 0; i &lt; arr.length; i++) { if (arr[i].equals(findName)) { index = i; break; } } if (index == -1) { System.out.println(\"没有找到你要查找的名字。\"); } else { System.out.println(\"你要查找的名字：\" + findName + \"，已找到，其对应的数组下标为： \" + index); } }} 123请输入你要查找的名字：金毛狮王你要查找的名字：金毛狮王，已找到，其对应的数组下标为： 1 多维数组-二维数组二维数组的使用快速入门案例二维数组的每个元素是一维数组。 使用方式1：动态初始化12语法：类型[][] 数组名 = new 类型[大小][大小];例子：int[][] arr = new int[2][3]; 二维数组的内存存在形式 使用方式2：动态初始化123先声明：类型数组名[][]; TwoDimensionalArray02.java再定义(开辟空间) 数组名= new 类型[大小][大小]赋值(有默认值，比如int 类型的就是0) 使用方式3：动态初始化（列数不确定） 使用方式4：静态初始化123456定义: 类型 数组名[][] = { {值1,值2..}, {值1,值2..}, {值1,值2..} }例子: int[][] arr = {{1,1,1}, {8,8,9}, {100}};解读： 定义了一个二维数组arr arr 有三个元素(每个元素都是一维数组) 第一个一维数组有3 个元素, 第二个一维数组有3 个元素, 第三个一维数组有1 个元素 二维数组应用案例使用二维数组打印一个10 行杨辉三角。 12345678910111213141516171819202122public class Test01 { public static void main(String[] args) { int[][] arr = new int[10][]; for (int i = 0; i &lt; arr.length; i++) { arr[i] = new int[i + 1]; for (int j = 0; j &lt; arr[i].length; j++) { if (j == 0 || j == arr[i].length - 1) { arr[i][j] = 1; } else { arr[i][j] = arr[i - 1][j] + arr[i - 1][j - 1]; } } } for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; arr[i].length; j++) { System.out.print(arr[i][j] + \" \"); } System.out.println(); } }} 123456789101 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1 1 7 21 35 35 21 7 1 1 8 28 56 70 56 28 8 1 1 9 36 84 126 126 84 36 9 1 二维数组使用细节和注意事项1234567891) 一维数组的声明方式有:int[] x 或者int x[] 2) 二维数组的声明方式有:int[][] y 或者int[] y[] 或者int y[][] 3) 二维数组实际上是由多个一维数组组成的，它的各个一维数组的长度可以相同，也可以不相同。比如： map[][] 是一个二维数组。int map [][] = {{1,2},{3,4,5}}由map[0] 是一个含有两个元素的一维数组，map[1] 是一个含有三个元素的一维数组构成，我们也称为列数不等的二维数组 二维数组课堂练习本章作业已知有一个升序数组，要求插入一个元素之后，该数组仍然为升序。 1234567891011121314151617181920212223242526272829public class Test01 { public static void main(String[] args) { int[] arr = {10, 12, 45, 90}; int[] arrNew = new int[arr.length + 1]; int num = 23; int index = -1; for (int i = 0; i &lt; arr.length; i++) { if (arr[i] &gt;= num) { index = i; break; } } if (index == -1) {//说明数据应该插入最后一位 index = arr.length; } for (int i = 0, j = 0; i &lt; arrNew.length; i++) { if (index == i) { arrNew[i] = num; } else { arrNew[i] = arr[j]; j++; } } for (int i = 0; i &lt; arrNew.length; i++) { System.out.print(arrNew[i] + \" \"); } System.out.println(); }} 110 12 23 45 90 随机生成10个整数（1-100）范围内，保存到数组中。 12345678910111213141516import java.util.Random;public class Test01 { public static void main(String[] args) { int[] arr = new int[10]; Random random = new Random(); for (int i = 0; i &lt; arr.length; i++) { int num = random.nextInt(100) + 1; arr[i] = num; } for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + \" \"); } System.out.println(); }} 184 53 23 19 43 98 68 26 79 3 面向对象编程（基础部分）类与对象养猫猫问题张老太养了两只猫猫:一只名字叫小白,今年 3 岁,白色。还有一只叫小花,今年 100 岁,花色。请编写一个程序，当用户输入小猫的名字时，就显示该猫的名字，年龄，颜色。如果用户输入的小猫名错误，则显示张老太没有这只猫猫。 使用现有技术解决上述问题 单独定义变量解决 123456789//第 1 只猫信息String cat1Name = \"小白\";int cat1Age = 3;String cat1Color = \"白色\";//第 2 只猫信息String cat2Name = \"小花\";int cat2Age = 100;String cat2Color = \"花色\"; 使用数组 12345//1.数据类型体现不出来//2.只能通过[下标]获取信息，造成变量名字和内容的对应关系不明确//3.不能体现猫的行为String[] cat1 = {\"小白\", \"3\", \"白色\"};String[] cat2 = {\"小花\", \"100\", \"花色\"}; 现有技术缺点分析 不利于数据管理 效率低下 引入类与对象（OOP）1234567891011Cat cat1 = new Cat();cat1.name = \"小白\";cat1.age = 3;cat1.color = \"白色\";cat1.weight = 10;Cat cat2 = new Cat();cat2.name = \"小花\";cat2.age = 100;cat2.color = \"花色\";cat2.weight = 20; 类和对象的内存分配机制（重点！！！）Java内存结构分析 栈：基本数据类型 堆：存放对象（Cat cat，数组等） 方法区：常量池（常量，字符串），类加载信息 练习题分析下列代码的内存结构： 重载介绍同一个类里面，可以有多个同名的方法。但是方法的形参列表不能一样。 可变参数使用可以通过可变参数，将同一个类中同方法名，同功能但是不同参数的方法封装成一个方法。 语法格式修饰符 返回值类型 方法名(参数类型… 形参名) { } 例子求2个整数，3个整数，5个整数的和。 使用传统技术解决问题 12345678public class App { public static void main(String[] args) { SumNum sumNum = new SumNum(); System.out.println(sumNum.sum2(1, 2)); System.out.println(sumNum.sum3(1, 2, 3)); System.out.println(sumNum.sum5(1, 2, 3, 4, 5)); }} 1234567891011public class SumNum { public int sum2(int n1, int n2){ return n1 + n2; } public int sum3(int n1, int n2, int n3){ return n1 + n2 + n3; } public int sum5(int n1, int n2, int n3, int n4, int n5){ return n1 + n2 + n3 + n4 + n5; }} 结果 1233615 使用可变参数解决问题 12345678public class App { public static void main(String[] args) { SumNum sumNum = new SumNum(); System.out.println(sumNum.sums(1, 2)); System.out.println(sumNum.sums(1, 2, 3)); System.out.println(sumNum.sums(1, 2, 3, 4, 5)); }} 123456789public class SumNum { public int sums(int... n){ int total = 0; for (int i = 0; i &lt; n.length; i++) { total += n[i]; } return total; }} 结果 1233615 对象创建流程分析（包含构造器）1Person p = new Person(5, \"闹闹\"); 123456789public class Person { int age = 10; String name; public Person(int age, String name) { this.age = age; this.name = name; }} 成员方法基本介绍在某些情况下，我们要需要定义成员方法(简称方法)。比如人类:除了有一些属性外( 年龄，姓名..),我们人类还有一些行为比如:可以说话、跑步..,通过学习，还可以做算术题。这时就要用成员方法才能完成。 成员方法快速入门笔记本28页图片 方法的调用机制原理笔记本29页图片 为什么需要成员方法笔记本29页图片 成员方法的好处提高代码的复用性 可以将实现的细节封装起来，然后供其他用户来调用即可 成员方法的定义笔记本30页 注意事项和使用细节访问修饰符(作用是控制方法使用的范围)如果不写默认访问，[有四种: public, protected, 默认, private], 具体在后面说 返回数据类型 一个方法最多有一个返回值[思考，如何返回多个结果返回数组] 返回类型可以为任意类型，包含基本类型或引用类型(数组，对象) 如果方法要求有返回数据类型，则方法体中最后的执行语句必须为return 值; 而且要求返回值类型必须和return 的 值类型一致或兼容 如果方法是void，则方法体中可以没有return 语句，或者只写return ; 方法名遵循驼峰命名法，最好见名知义，表达出该功能的意思即可, 比如得到两个数的和getSum, 开发中按照规范 形参列表 类定义的完善 课堂练习题1.编写类AA ，有一个方法：判断一个数是奇数odd 还是偶数, 返回boolean 1234567891011121314151617public class Test01 { public static void main(String[] args) { AA aa = new AA(); int num = 4; if (aa.isOdd(num)) { System.out.println(\"数字\" + num + \"是奇数\"); } else { System.out.println(\"数字\" + num + \"是偶数\"); } }}class AA { public boolean isOdd(int num) { return num % 2 == 0 ? false : true; }} 1数字4是偶数 1数字9是奇数 2.根据行、列、字符打印对应行数和列数的字符，比如：行：3，列：2，字符 #, 则打印相应的效果 12345678910111213141516public class Test02 { public static void main(String[] args) { String[][] arr = new String[3][2]; for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; arr[i].length; j++) { arr[i][j] = \"#\"; } } for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; arr[i].length; j++) { System.out.print(arr[i][j] + \"\\t\"); } System.out.println(); } }} 123# # # # # # 成员方法传参机制(非常非常重要)基本数据类型的传参机制基本数据类型，传递的是值（值拷贝），形参的任何改变不影响实参。 引用数据类型的传参机制引用类型可以通过形参来影响实参。 成员方法返回类型是引用类型应用实例 方法递归调用(非常非常重要，比较难)基本介绍递归就是方法自己调用自己。 递归能解决什么问题? 递归举例打印问题 123456789101112131415public class Recursion01 { public static void main(String[] args) { T t = new T(); t.test(4);//调用方法后输出结果是？ }}class T { public void test(int n) { if (n &gt; 2) { test(n - 1); } System.out.println(\"n=\" + n); }} 123n=2n=3n=4 阶乘问题 123456789101112131415161718192021222324252627282930313233343536373839404142```### 递归重要规则![image-20230920060433456](https://raw.githubusercontent.com/xiaofanshutu/typora2022/main/image-20230920060433456.png)### 课堂练习![image-20230920052744709](https://raw.githubusercontent.com/xiaofanshutu/typora2022/main/image-20230920052744709.png)请使用递归的方式求出斐波那契数1,1,2,3,5,8,13...给你一个整数n，求出它的斐波那契值是多少。```javapublic class RecursionExercise01 { public static void main(String[] args) { T t = new T(); int n = 7; int fibonacciNum = t.fibonacci(n); if (fibonacciNum != -1) { System.out.println(\"数字 \" + n + \" 的斐波那契值为 \" + fibonacciNum); } else { System.out.println(\"数据不合法\"); } }}class T { public int fibonacci(int n) { if (n &gt; 0) { if (n == 1 || n == 2) { return 1; } else { return fibonacci(n - 1) + fibonacci(n - 2); } } else { System.out.println(\"数据不合法，输入的n为：\" + n); return -1; } }} 1数字 7 的斐波那契值为 13 猴子吃桃子问题：有一堆桃子，猴子第一天吃了其中的一半，并再多吃了一个！以后每天猴子都吃其中的一半，然后再多吃一个。当到第10 天时，想再吃时（即还没吃），发现只有1个桃子了。问题：最初共多少个桃子？ 123456789101112131415161718192021package chapter07;public class RecursionExercise01 { public static void main(String[] args) { T t = new T(); int peach = t.peach(1); System.out.println(peach); }}class T { public int peach(int day) { if (day == 10) { return 1; } else if (day &gt;= 1 &amp;&amp; day &lt;= 9) { return (peach(day + 1) + 1) * 2; } else { return -1; } }} 递归调用应用实例-迷宫问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class MiGong { public static void main(String[] args) { MiGongTest miGongTest = new MiGongTest(); int[][] map = new int[8][7]; for (int i = 0; i &lt; map.length; i++) { for (int j = 0; j &lt; map[i].length; j++) { map[i][j] = 0; } } for (int i = 0; i &lt; map.length; i++) { map[i][0] = 1; map[i][6] = 1; } for (int j = 0; j &lt; 7; j++) { map[0][j] = 1; map[7][j] = 1; } map[3][1] = 1; map[3][2] = 1; miGongTest.findWay(map, 1, 1); for (int i = 0; i &lt; map.length; i++) { for (int j = 0; j &lt; map[i].length; j++) { System.out.print(map[i][j] + \" \"); } System.out.println(); } }}class MiGongTest { public boolean findWay(int[][] map, int i, int j) { if (map[6][5] == 2) { return true; } else { if (map[i][j] == 0) { map[i][j] = 2; if (findWay(map, i + 1, j)) {//下 return true; } else if (findWay(map, i, j + 1)) {//右 return true; } else if (findWay(map, i - 1, j)) {//上 return true; } else if (findWay(map, i, j - 1)) {//左 return true; } else { map[i][j] = 3; return false; } } else { return false; } } }} 123456781 1 1 1 1 1 1 1 2 0 0 0 0 1 1 2 2 2 0 0 1 1 1 1 2 0 0 1 1 0 0 2 0 0 1 1 0 0 2 0 0 1 1 0 0 2 2 2 1 1 1 1 1 1 1 1 测试回溯法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class MiGong { public static void main(String[] args) { MiGongTest miGongTest = new MiGongTest(); int[][] map = new int[8][7]; for (int i = 0; i &lt; map.length; i++) { for (int j = 0; j &lt; map[i].length; j++) { map[i][j] = 0; } } for (int i = 0; i &lt; map.length; i++) { map[i][0] = 1; map[i][6] = 1; } for (int j = 0; j &lt; 7; j++) { map[0][j] = 1; map[7][j] = 1; } map[3][1] = 1; map[3][2] = 1; map[2][2] = 1;//测试回溯法 miGongTest.findWay(map, 1, 1); for (int i = 0; i &lt; map.length; i++) { for (int j = 0; j &lt; map[i].length; j++) { System.out.print(map[i][j] + \" \"); } System.out.println(); } }}class MiGongTest { public boolean findWay(int[][] map, int i, int j) { if (map[6][5] == 2) { return true; } else { if (map[i][j] == 0) { map[i][j] = 2; if (findWay(map, i + 1, j)) {//下 return true; } else if (findWay(map, i, j + 1)) {//右 return true; } else if (findWay(map, i - 1, j)) {//上 return true; } else if (findWay(map, i, j - 1)) {//左 return true; } else { map[i][j] = 3; return false; } } else { return false; } } }} 123456781 1 1 1 1 1 1 1 2 2 2 0 0 1 1 3 1 2 0 0 1 1 1 1 2 0 0 1 1 0 0 2 0 0 1 1 0 0 2 0 0 1 1 0 0 2 2 2 1 1 1 1 1 1 1 1 递归调用应用实例-汉诺塔递归调用应用实例-八皇后问题[同学们先尝试做，后面老师评讲.]方法重载(OverLoad)基本介绍同一个类中，拥有相同方法名，且形参列表不一样。（返回类型无要求） 重载的好处减轻了起名和记名的麻烦。 快速入门案例 注意事项和使用细节课堂练习题this关键字深入理解this什么是this？Java虚拟机给每个对象都分配了一个this，代表当前对象。 this本质 this小结1234dog1.info();public void info(){ System.out.println(this.hashCode());//此时，输出的就是dog1的hashCode值。哪个对象调用，this就是哪个对象。} this的注意事项和使用细节 本章作业 定义方法max，实现求某个double数组的最大值，并返回 123456789package com.bambi;public class Homework01 { public static void main(String[] args) { A01 a01 = new A01(); double[] array = {10.01, 80.25, 20.15, 30.71, 12.56}; System.out.println(a01.max(array)); }} 1234567891011121314151617181920package com.bambi;public class A01 { public double max(double[] array) { double ans = 0.0; for (int i = 0; i &lt; array.length; i++) { if (i == 0) { ans = array[i]; } else { if (ans &lt; array[i]) { ans = array[i]; } } } return ans; }} 定义方法find，实现查找某字符串是否在字符串数组中，并返回索引，如果找不到，则返回-1 123456789package com.bambi;public class Homework02 { public static void main(String[] args) { A02 a02 = new A02(); String[] array = {\"bambi\", \"eazin\", \"stefen\"}; System.out.println(a02.find(\"summer\", array)); }} 123456789101112package com.bambi;public class A02 { public int find(String s, String[] array) { for (int i = 0; i &lt; array.length; i++) { if (s.equals(array[i])) { return i; } } return -1; }} 1-1 编写类Book，定义方法updatePrice，实现更改某本书的价格，具体：如果价格大于150，则更改为150；如果价格大于100，则更改为100；否则不变。 12345678public class A03 { public static void main(String[] args) { Book book = new Book(); System.out.println(book.updatePrice(200.55)); System.out.println(book.updatePrice(130.91)); System.out.println(book.updatePrice(50.21)); }} 1234567891011public class Book { //编写类Book，定义方法updatePrice，实现更改某本书的价格，具体：如果价格大于150，则更改为150；如果价格大于100，则更改为100；否则不变。 public double updatePrice(double price){ if(price &gt; 150){ price = 150; } else if (price &gt; 100) { price = 100; } return price; }} 123150.0100.050.21 编写类，实现数组的复制功能copyArr，输入旧数组，返回新数组。 12345678910111213141516171819202122public class A03 { public static void main(String[] args) { A04 a04 = new A04(); int[] ints = {1, 2}; int[] afterArr = a04.copyArr(ints); for (int num : afterArr) { System.out.println(num); } }}public class A04 { //定义一个类，实现数组的复制功能copyArr。输入旧数组，返回一个新数组 public int[] copyArr(int[] array) { int[] newArr = new int[array.length]; for (int i = 0; i &lt; array.length; i++) { newArr[i] = array[i]; } return newArr; }} 面向对象编程（中级部分）IDEA常用快捷键 删除当前行, 默认是ctrl + d 复制当前行, 自己配置 ctrl + alt + 向下光标 补全代码 alt + / 添加注释和取消注释 ctrl + / 【第一次是添加注释，第二次是取消注释】 导入该行需要的类 先配置 auto import , 然后使用 alt+enter 即可 快速格式化代码 ctrl + alt + L 快速运行程序 自己定义 alt + R 生成构造器等 alt + insert [提高开发效率] 查看一个类的层级关系F4 将光标放在一个方法上，输入 ctrl + B , 可以定位到方法 [学继承后，非常有用] —–这个在我电脑上不生效，再试试 自动的分配变量名 , 通过 在后面假 .var [老师最喜欢的] 包","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://xiaofanshutu.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"cutiebambi"},{"title":"面向对象编程（基础部分）","slug":"面向对象编程（基础部分）_韩顺平","date":"2023-10-07T12:03:21.888Z","updated":"2024-01-17T23:38:29.143Z","comments":true,"path":"posts/dfc0bd6b.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/dfc0bd6b.html","excerpt":"","text":"类与对象养猫猫问题张老太养了两只猫猫:一只名字叫小白,今年 3 岁,白色。还有一只叫小花,今年 100 岁,花色。请编写一个程序，当用户输入小猫的名字时，就显示该猫的名字，年龄，颜色。如果用户输入的小猫名错误，则显示张老太没有这只猫猫。 使用现有技术解决上述问题 单独定义变量解决 123456789//第 1 只猫信息String cat1Name = \"小白\";int cat1Age = 3;String cat1Color = \"白色\";//第 2 只猫信息String cat2Name = \"小花\";int cat2Age = 100;String cat2Color = \"花色\"; 使用数组 12345//1.数据类型体现不出来//2.只能通过[下标]获取信息，造成变量名字和内容的对应关系不明确//3.不能体现猫的行为String[] cat1 = {\"小白\", \"3\", \"白色\"};String[] cat2 = {\"小花\", \"100\", \"花色\"}; 现有技术缺点分析 不利于数据管理 效率低下 引入类与对象（OOP）1234567891011Cat cat1 = new Cat();cat1.name = \"小白\";cat1.age = 3;cat1.color = \"白色\";cat1.weight = 10;Cat cat2 = new Cat();cat2.name = \"小花\";cat2.age = 100;cat2.color = \"花色\";cat2.weight = 20; 类和对象的内存分配机制（重点！！！）Java内存结构分析 栈：基本数据类型 堆：存放对象（Cat cat，数组等） 方法区：常量池（常量，字符串），类加载信息 练习题分析下列代码的内存结构： 重载介绍同一个类里面，可以有多个同名的方法。但是方法的形参列表不能一样。 可变参数使用可以通过可变参数，将同一个类中同方法名，同功能但是不同参数的方法封装成一个方法。 语法格式修饰符 返回值类型 方法名(参数类型… 形参名) { } 例子求2个整数，3个整数，5个整数的和。 使用传统技术解决问题 12345678public class App { public static void main(String[] args) { SumNum sumNum = new SumNum(); System.out.println(sumNum.sum2(1, 2)); System.out.println(sumNum.sum3(1, 2, 3)); System.out.println(sumNum.sum5(1, 2, 3, 4, 5)); }} 1234567891011public class SumNum { public int sum2(int n1, int n2){ return n1 + n2; } public int sum3(int n1, int n2, int n3){ return n1 + n2 + n3; } public int sum5(int n1, int n2, int n3, int n4, int n5){ return n1 + n2 + n3 + n4 + n5; }} 结果 1233615 使用可变参数解决问题 12345678public class App { public static void main(String[] args) { SumNum sumNum = new SumNum(); System.out.println(sumNum.sums(1, 2)); System.out.println(sumNum.sums(1, 2, 3)); System.out.println(sumNum.sums(1, 2, 3, 4, 5)); }} 123456789public class SumNum { public int sums(int... n){ int total = 0; for (int i = 0; i &lt; n.length; i++) { total += n[i]; } return total; }} 结果 1233615 对象创建流程分析（包含构造器）1Person p = new Person(5, \"闹闹\"); 123456789public class Person { int age = 10; String name; public Person(int age, String name) { this.age = age; this.name = name; }} 成员方法基本介绍在某些情况下，我们要需要定义成员方法(简称方法)。比如人类:除了有一些属性外( 年龄，姓名..),我们人类还有一些行为比如:可以说话、跑步..,通过学习，还可以做算术题。这时就要用成员方法才能完成。 成员方法快速入门笔记本28页图片 方法的调用机制原理笔记本29页图片 为什么需要成员方法笔记本29页图片 成员方法的好处提高代码的复用性 可以将实现的细节封装起来，然后供其他用户来调用即可 成员方法的定义笔记本30页 注意事项和使用细节访问修饰符(作用是控制方法使用的范围)如果不写默认访问，[有四种: public, protected, 默认, private], 具体在后面说 返回数据类型 一个方法最多有一个返回值[思考，如何返回多个结果返回数组] 返回类型可以为任意类型，包含基本类型或引用类型(数组，对象) 如果方法要求有返回数据类型，则方法体中最后的执行语句必须为return 值; 而且要求返回值类型必须和return 的 值类型一致或兼容 如果方法是void，则方法体中可以没有return 语句，或者只写return ; 方法名遵循驼峰命名法，最好见名知义，表达出该功能的意思即可, 比如得到两个数的和getSum, 开发中按照规范 形参列表 类定义的完善 课堂练习题1.编写类AA ，有一个方法：判断一个数是奇数odd 还是偶数, 返回boolean 1234567891011121314151617public class Test01 { public static void main(String[] args) { AA aa = new AA(); int num = 4; if (aa.isOdd(num)) { System.out.println(\"数字\" + num + \"是奇数\"); } else { System.out.println(\"数字\" + num + \"是偶数\"); } }}class AA { public boolean isOdd(int num) { return num % 2 == 0 ? false : true; }} 1数字4是偶数 1数字9是奇数 2.根据行、列、字符打印对应行数和列数的字符，比如：行：3，列：2，字符 #, 则打印相应的效果 12345678910111213141516public class Test02 { public static void main(String[] args) { String[][] arr = new String[3][2]; for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; arr[i].length; j++) { arr[i][j] = \"#\"; } } for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; arr[i].length; j++) { System.out.print(arr[i][j] + \"\\t\"); } System.out.println(); } }} 123# # # # # # 成员方法传参机制(非常非常重要)基本数据类型的传参机制基本数据类型，传递的是值（值拷贝），形参的任何改变不影响实参。 引用数据类型的传参机制引用类型可以通过形参来影响实参。 成员方法返回类型是引用类型应用实例 方法递归调用(非常非常重要，比较难)基本介绍递归就是方法自己调用自己。 递归能解决什么问题? 递归举例打印问题 123456789101112131415public class Recursion01 { public static void main(String[] args) { T t = new T(); t.test(4);//调用方法后输出结果是？ }}class T { public void test(int n) { if (n &gt; 2) { test(n - 1); } System.out.println(\"n=\" + n); }} 123n=2n=3n=4 阶乘问题 123456789101112131415161718192021222324252627282930313233343536373839404142```### 递归重要规则![image-20230920060433456](https://raw.githubusercontent.com/xiaofanshutu/typora2022/main/image-20230920060433456.png)### 课堂练习![image-20230920052744709](https://raw.githubusercontent.com/xiaofanshutu/typora2022/main/image-20230920052744709.png)请使用递归的方式求出斐波那契数1,1,2,3,5,8,13...给你一个整数n，求出它的斐波那契值是多少。```javapublic class RecursionExercise01 { public static void main(String[] args) { T t = new T(); int n = 7; int fibonacciNum = t.fibonacci(n); if (fibonacciNum != -1) { System.out.println(\"数字 \" + n + \" 的斐波那契值为 \" + fibonacciNum); } else { System.out.println(\"数据不合法\"); } }}class T { public int fibonacci(int n) { if (n &gt; 0) { if (n == 1 || n == 2) { return 1; } else { return fibonacci(n - 1) + fibonacci(n - 2); } } else { System.out.println(\"数据不合法，输入的n为：\" + n); return -1; } }} 1数字 7 的斐波那契值为 13 猴子吃桃子问题：有一堆桃子，猴子第一天吃了其中的一半，并再多吃了一个！以后每天猴子都吃其中的一半，然后再多吃一个。当到第10 天时，想再吃时（即还没吃），发现只有1个桃子了。问题：最初共多少个桃子？ 123456789101112131415161718192021package chapter07;public class RecursionExercise01 { public static void main(String[] args) { T t = new T(); int peach = t.peach(1); System.out.println(peach); }}class T { public int peach(int day) { if (day == 10) { return 1; } else if (day &gt;= 1 &amp;&amp; day &lt;= 9) { return (peach(day + 1) + 1) * 2; } else { return -1; } }} 递归调用应用实例-迷宫问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class MiGong { public static void main(String[] args) { MiGongTest miGongTest = new MiGongTest(); int[][] map = new int[8][7]; for (int i = 0; i &lt; map.length; i++) { for (int j = 0; j &lt; map[i].length; j++) { map[i][j] = 0; } } for (int i = 0; i &lt; map.length; i++) { map[i][0] = 1; map[i][6] = 1; } for (int j = 0; j &lt; 7; j++) { map[0][j] = 1; map[7][j] = 1; } map[3][1] = 1; map[3][2] = 1; miGongTest.findWay(map, 1, 1); for (int i = 0; i &lt; map.length; i++) { for (int j = 0; j &lt; map[i].length; j++) { System.out.print(map[i][j] + \" \"); } System.out.println(); } }}class MiGongTest { public boolean findWay(int[][] map, int i, int j) { if (map[6][5] == 2) { return true; } else { if (map[i][j] == 0) { map[i][j] = 2; if (findWay(map, i + 1, j)) {//下 return true; } else if (findWay(map, i, j + 1)) {//右 return true; } else if (findWay(map, i - 1, j)) {//上 return true; } else if (findWay(map, i, j - 1)) {//左 return true; } else { map[i][j] = 3; return false; } } else { return false; } } }} 123456781 1 1 1 1 1 1 1 2 0 0 0 0 1 1 2 2 2 0 0 1 1 1 1 2 0 0 1 1 0 0 2 0 0 1 1 0 0 2 0 0 1 1 0 0 2 2 2 1 1 1 1 1 1 1 1 测试回溯法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class MiGong { public static void main(String[] args) { MiGongTest miGongTest = new MiGongTest(); int[][] map = new int[8][7]; for (int i = 0; i &lt; map.length; i++) { for (int j = 0; j &lt; map[i].length; j++) { map[i][j] = 0; } } for (int i = 0; i &lt; map.length; i++) { map[i][0] = 1; map[i][6] = 1; } for (int j = 0; j &lt; 7; j++) { map[0][j] = 1; map[7][j] = 1; } map[3][1] = 1; map[3][2] = 1; map[2][2] = 1;//测试回溯法 miGongTest.findWay(map, 1, 1); for (int i = 0; i &lt; map.length; i++) { for (int j = 0; j &lt; map[i].length; j++) { System.out.print(map[i][j] + \" \"); } System.out.println(); } }}class MiGongTest { public boolean findWay(int[][] map, int i, int j) { if (map[6][5] == 2) { return true; } else { if (map[i][j] == 0) { map[i][j] = 2; if (findWay(map, i + 1, j)) {//下 return true; } else if (findWay(map, i, j + 1)) {//右 return true; } else if (findWay(map, i - 1, j)) {//上 return true; } else if (findWay(map, i, j - 1)) {//左 return true; } else { map[i][j] = 3; return false; } } else { return false; } } }} 123456781 1 1 1 1 1 1 1 2 2 2 0 0 1 1 3 1 2 0 0 1 1 1 1 2 0 0 1 1 0 0 2 0 0 1 1 0 0 2 0 0 1 1 0 0 2 2 2 1 1 1 1 1 1 1 1 递归调用应用实例-汉诺塔递归调用应用实例-八皇后问题[同学们先尝试做，后面老师评讲.]方法重载(OverLoad)基本介绍同一个类中，拥有相同方法名，且形参列表不一样。（返回类型无要求） 重载的好处减轻了起名和记名的麻烦。 快速入门案例 注意事项和使用细节课堂练习题this关键字深入理解this什么是this？Java虚拟机给每个对象都分配了一个this，代表当前对象。 this本质 this小结1234dog1.info();public void info(){ System.out.println(this.hashCode());//此时，输出的就是dog1的hashCode值。哪个对象调用，this就是哪个对象。} this的注意事项和使用细节 本章作业 定义方法max，实现求某个double数组的最大值，并返回 123456789package com.bambi;public class Homework01 { public static void main(String[] args) { A01 a01 = new A01(); double[] array = {10.01, 80.25, 20.15, 30.71, 12.56}; System.out.println(a01.max(array)); }} 1234567891011121314151617181920package com.bambi;public class A01 { public double max(double[] array) { double ans = 0.0; for (int i = 0; i &lt; array.length; i++) { if (i == 0) { ans = array[i]; } else { if (ans &lt; array[i]) { ans = array[i]; } } } return ans; }} 定义方法find，实现查找某字符串是否在字符串数组中，并返回索引，如果找不到，则返回-1 123456789package com.bambi;public class Homework02 { public static void main(String[] args) { A02 a02 = new A02(); String[] array = {\"bambi\", \"eazin\", \"stefen\"}; System.out.println(a02.find(\"summer\", array)); }} 123456789101112package com.bambi;public class A02 { public int find(String s, String[] array) { for (int i = 0; i &lt; array.length; i++) { if (s.equals(array[i])) { return i; } } return -1; }} 1-1 编写类Book，定义方法updatePrice，实现更改某本书的价格，具体：如果价格大于150，则更改为150；如果价格大于100，则更改为100；否则不变。 12345678public class A03 { public static void main(String[] args) { Book book = new Book(); System.out.println(book.updatePrice(200.55)); System.out.println(book.updatePrice(130.91)); System.out.println(book.updatePrice(50.21)); }} 1234567891011public class Book { //编写类Book，定义方法updatePrice，实现更改某本书的价格，具体：如果价格大于150，则更改为150；如果价格大于100，则更改为100；否则不变。 public double updatePrice(double price){ if(price &gt; 150){ price = 150; } else if (price &gt; 100) { price = 100; } return price; }} 123150.0100.050.21 编写类，实现数组的复制功能copyArr，输入旧数组，返回新数组。 12345678910111213141516171819202122public class A03 { public static void main(String[] args) { A04 a04 = new A04(); int[] ints = {1, 2}; int[] afterArr = a04.copyArr(ints); for (int num : afterArr) { System.out.println(num); } }}public class A04 { //定义一个类，实现数组的复制功能copyArr。输入旧数组，返回一个新数组 public int[] copyArr(int[] array) { int[] newArr = new int[array.length]; for (int i = 0; i &lt; array.length; i++) { newArr[i] = array[i]; } return newArr; }}","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://xiaofanshutu.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"cutiebambi"},{"title":"数组、排序和查找","slug":"数组、排序和查找_韩顺平","date":"2023-10-07T12:03:21.472Z","updated":"2024-01-17T23:38:33.535Z","comments":true,"path":"posts/c2bc67b6.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/c2bc67b6.html","excerpt":"","text":"为什么需要数组 数组介绍数组可以存放多个同一类型的数据。数组也是一种数据类型，为引用类型。 即：数组就是一组数据 数组快速入门用数组来解决上面的问题。 数组的使用动态初始化使用方式1：动态初始化 定义数据类型[] 数组名 = new 数据类型[大小]； int [] arr=new int[5]; 使用数组名[下标] arr[2] 代表要访问arr数组的第三个元素。（数组下标是从0开始的） 快速入门案例循环输入5个成绩，保存到double数组并输出。 12345678910111213141516import java.util.Scanner;public class Array02 { public static void main(String[] args) { double[] scores = new double[5]; Scanner scanner = new Scanner(System.in); for (int i = 0; i &lt; 5; i++) { System.out.println(\"请输入第\" + (i + 1) + \"个成绩\"); scores[i] = scanner.nextDouble(); } for (int i = 0; i &lt; scores.length; i++) { System.out.print(scores[i] + \"\\t\"); } System.out.println(); }} 1234567891011请输入第1个成绩90请输入第2个成绩89请输入第3个成绩30请输入第4个成绩100请输入第5个成绩8590.0 89.0 30.0 100.0 85.0 静态初始化数组使用注意事项和细节 数组是多个相同类型数据的组合，实现对这些数据的统一管理 数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用。 数组创建后，如果没有赋值，有默认值int 0，short 0, byte 0, long 0, float 0.0,double 0.0，char \\u0000，boolean false，String null 使用数组的步骤1. 声明数组并开辟空间2. 给数组各个元素赋值3. 使用数组 数组的下标是从0 开始的。 数组下标必须在指定范围内使用，否则报：下标越界异常，比如： int [] arr=new int[5]; 则有效下标为0-4 数组属引用类型，数组型数据是对象(object) 数组应用案例创建一个char 类型的26 个元素的数组，分别放置’A’-‘Z’。使用for 循环访问所有元素并打印出来。提示：char 类型数据运算’A’+2 -&gt; ‘C’ 1234567891011121314151617181920public class Test01 { public static void main(String[] args) { char[] arr = new char[26]; for (int i = 0; i &lt; arr.length; i++) { arr[i] = (char) ('A' + i); } System.out.println(\"正序输出====&gt;\"); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + \" \"); } System.out.println(); System.out.println(\"倒序输出====&gt;\"); for (int i = arr.length - 1; i &gt;= 0; i--) { System.out.print(arr[i] + \" \"); } System.out.println(); }} 1234正序输出====&gt;A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 倒序输出====&gt;Z Y X W V U T S R Q P O N M L K J I H G F E D C B A 请求出一个数组int[]的最大值{4,-1,9, 10,23}，并得到对应的下标 1234567891011121314public class Test01 { public static void main(String[] args) { int[] arr = {4, -1, 9, 10, 23}; int maxValue = arr[0]; int maxIndex = 0; for (int i = 0; i &lt; arr.length; i++) { if (arr[i] &gt; maxValue) { maxValue = arr[i]; maxIndex = i; } } System.out.println(\"最大值：\" + maxValue + \"，对应的下标为：\" + maxIndex); }} 1最大值：23，对应的下标为：4 数组赋值机制基本数据类型赋值，这个值就使具体的数据。且互不影响。 12int n1=1;int n2=n1; 数组是引用传递，赋的值是地址。 数组拷贝将int[] arr1 = {10,20,30}; 拷贝到arr2 数组, 要求数据空间是独立的. 12345678910111213141516171819public class Test01 { public static void main(String[] args) { int[] arr1 = {10, 20, 30}; int[] arr2 = new int[arr1.length]; for (int i = 0; i &lt; arr1.length; i++) { arr2[i] = arr1[i]; } System.out.println(\"arr1数组为：\"); for (int i = 0; i &lt; arr1.length; i++) { System.out.print(arr1[i] + \"\\t\"); } System.out.println(); System.out.println(\"arr2数组为：\"); for (int i = 0; i &lt; arr2.length; i++) { System.out.print(arr2[i] + \"\\t\"); } }} 1234arr1数组为：10 20 30 arr2数组为：10 20 30 数组反转要求：把数组{11,22,33,44,55,66}的元素内容反转{66, 55,44,33,22,11}。 12345678910111213141516171819public class Test01 { public static void main(String[] args) { int[] arr = {11, 22, 33, 44, 55, 66}; int[] arrNew = new int[arr.length]; for (int i = 0, j = arrNew.length - 1; i &lt; arr.length; i++, j--) { arrNew[j] = arr[i]; } System.out.println(\"原数组为：\"); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + \"\\t\"); } System.out.println(); System.out.println(\"反转之后的数组为：\"); for (int i = 0; i &lt; arrNew.length; i++) { System.out.print(arrNew[i] + \"\\t\"); } }} 1234原数组为：11 22 33 44 55 66 反转之后的数组为：66 55 44 33 22 11 数组添加/扩容要求：实现动态的给数组添加元素效果，实现对数组扩容。 原始数组使用静态分配int[] arr = {1,2,3} 用户可以决定是否继续添加，添加成功，是否继续？y/n 12345678910111213141516171819202122232425262728293031public class Test01 { public static void main(String[] args) { int[] arr = {1, 2, 3}; int[] arrNew; int number; Scanner scanner = new Scanner(System.in); while (true) { System.out.println(\"请输入是否需要插入元素，y/n\"); char c = scanner.next().charAt(0); if (c == 'y') { arrNew = new int[arr.length + 1]; System.out.println(\"请输入要插入的元素：\"); number = scanner.nextInt(); for (int i = 0; i &lt; arr.length; i++) { arrNew[i] = arr[i]; } arrNew[arrNew.length - 1] = number; arr = arrNew; } else { System.out.println(\"用户主动选择退出~\"); break; } } System.out.println(\"最终的数组结果为：\"); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + \"\\t\"); } System.out.println(); }} 123456789101112请输入是否需要插入元素，y/ny请输入要插入的元素：4请输入是否需要插入元素，y/ny请输入要插入的元素：5请输入是否需要插入元素，y/nn用户主动选择退出~1 2 3 4 5 有一个数组{1， 2， 3， 4， 5}， 可以将该数组进行缩减，提示用户是否继续缩减，每次缩减最后那个元素。当只剩下最后一个元素，提示，不能再缩减。 123456789101112131415161718192021222324252627282930313233343536public class Test01 { public static void main(String[] args) { int[] arr = {1, 2, 3, 4, 5}; int[] arrNew; Scanner scanner = new Scanner(System.in); while (true) { System.out.println(\"请输入是否需要删除元素，y/n\"); char c = scanner.next().charAt(0); if (arr.length == 1) { System.out.println(\"当前数组只剩余一个元素，不能再操作，直接退出~\"); showArray(arr); break; } if (c == 'y') { arrNew = new int[arr.length - 1]; for (int i = 0; i &lt; arrNew.length; i++) { arrNew[i] = arr[i]; } arr = arrNew; showArray(arr); } else { System.out.println(\"用户主动选择退出~\"); showArray(arr); break; } } } private static void showArray(int[] arr) { System.out.println(\"当前数组结果为：\"); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + \"\\t\"); } System.out.println(); }} 123456789101112131415161718192021请输入是否需要删除元素，y/ny当前数组结果为：1 2 3 4 请输入是否需要删除元素，y/ny当前数组结果为：1 2 3 请输入是否需要删除元素，y/ny当前数组结果为：1 2 请输入是否需要删除元素，y/ny当前数组结果为：1 请输入是否需要删除元素，y/ny当前数组只剩余一个元素，不能再操作，直接退出~当前数组结果为：1 排序的介绍排序是将多个数据，依指定的顺序进行排列的过程。 内部排序指将需要处理的所有数据都加载到内部存储器中进行排序。包括(交换式排序法、选择式排序法和插入式排序法)； 外部排序数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。包括(合并排序法和直接合并排序法)。 冒泡排序法冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从后向前（从下标较大的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。 下面我们举一个具体的案例来说明冒泡法。我们将五个无序：24,69,80,57,13 使用冒泡排序法将其排成一个从小到大的有序数列。 1234567891011121314151617181920212223242526public class Test01 { public static void main(String[] args) { int[] arr = {24, 69, 80, 57, 13}; System.out.println(\"原数组为：\"); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + \"\\t\"); } System.out.println(); int temp; for (int i = 0; i &lt; arr.length - 1; i++) { for (int j = 0; j &lt; arr.length - 1 - i; j++) { if (arr[j] &gt; arr[j + 1]) { temp = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = temp; } } } System.out.println(\"冒泡排序输出的结果为：\"); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + \"\\t\"); } System.out.println(); }} 1234原数组为：24 69 80 57 13 冒泡排序输出的结果为：13 24 57 69 80 查找介绍在java 中，我们常用的查找有两种: 顺序查找SeqSearch.java 二分查找【二分法，我们放在算法讲解】 案例有一个数列：白眉鹰王、金毛狮王、紫衫龙王、青翼蝠王猜数游戏：从键盘中任意输入一个名称，判断数列中是否包含此名称【顺序查找】要求: 如果找到了，就提示找到，并给出下标值。 12345678910111213141516171819202122import java.util.Scanner;public class Test01 { public static void main(String[] args) { String[] arr = {\"白眉鹰王\", \"金毛狮王\", \"紫衫龙王\", \"青翼蝠王\"}; Scanner scanner = new Scanner(System.in); System.out.println(\"请输入你要查找的名字：\"); String findName = scanner.next(); int index = -1; for (int i = 0; i &lt; arr.length; i++) { if (arr[i].equals(findName)) { index = i; break; } } if (index == -1) { System.out.println(\"没有找到你要查找的名字。\"); } else { System.out.println(\"你要查找的名字：\" + findName + \"，已找到，其对应的数组下标为： \" + index); } }} 123请输入你要查找的名字：金毛狮王你要查找的名字：金毛狮王，已找到，其对应的数组下标为： 1 多维数组-二维数组二维数组的使用快速入门案例二维数组的每个元素是一维数组。 使用方式1：动态初始化12语法：类型[][] 数组名 = new 类型[大小][大小];例子：int[][] arr = new int[2][3]; 二维数组的内存存在形式 使用方式2：动态初始化123先声明：类型数组名[][]; TwoDimensionalArray02.java再定义(开辟空间) 数组名= new 类型[大小][大小]赋值(有默认值，比如int 类型的就是0) 使用方式3：动态初始化（列数不确定） 使用方式4：静态初始化123456定义: 类型 数组名[][] = { {值1,值2..}, {值1,值2..}, {值1,值2..} }例子: int[][] arr = {{1,1,1}, {8,8,9}, {100}};解读： 定义了一个二维数组arr arr 有三个元素(每个元素都是一维数组) 第一个一维数组有3 个元素, 第二个一维数组有3 个元素, 第三个一维数组有1 个元素 二维数组应用案例使用二维数组打印一个10 行杨辉三角。 12345678910111213141516171819202122public class Test01 { public static void main(String[] args) { int[][] arr = new int[10][]; for (int i = 0; i &lt; arr.length; i++) { arr[i] = new int[i + 1]; for (int j = 0; j &lt; arr[i].length; j++) { if (j == 0 || j == arr[i].length - 1) { arr[i][j] = 1; } else { arr[i][j] = arr[i - 1][j] + arr[i - 1][j - 1]; } } } for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; arr[i].length; j++) { System.out.print(arr[i][j] + \" \"); } System.out.println(); } }} 123456789101 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1 1 7 21 35 35 21 7 1 1 8 28 56 70 56 28 8 1 1 9 36 84 126 126 84 36 9 1 二维数组使用细节和注意事项1234567891) 一维数组的声明方式有:int[] x 或者int x[] 2) 二维数组的声明方式有:int[][] y 或者int[] y[] 或者int y[][] 3) 二维数组实际上是由多个一维数组组成的，它的各个一维数组的长度可以相同，也可以不相同。比如： map[][] 是一个二维数组。int map [][] = {{1,2},{3,4,5}}由map[0] 是一个含有两个元素的一维数组，map[1] 是一个含有三个元素的一维数组构成，我们也称为列数不等的二维数组 二维数组课堂练习本章作业已知有一个升序数组，要求插入一个元素之后，该数组仍然为升序。 1234567891011121314151617181920212223242526272829public class Test01 { public static void main(String[] args) { int[] arr = {10, 12, 45, 90}; int[] arrNew = new int[arr.length + 1]; int num = 23; int index = -1; for (int i = 0; i &lt; arr.length; i++) { if (arr[i] &gt;= num) { index = i; break; } } if (index == -1) {//说明数据应该插入最后一位 index = arr.length; } for (int i = 0, j = 0; i &lt; arrNew.length; i++) { if (index == i) { arrNew[i] = num; } else { arrNew[i] = arr[j]; j++; } } for (int i = 0; i &lt; arrNew.length; i++) { System.out.print(arrNew[i] + \" \"); } System.out.println(); }} 110 12 23 45 90 随机生成10个整数（1-100）范围内，保存到数组中。 12345678910111213141516import java.util.Random;public class Test01 { public static void main(String[] args) { int[] arr = new int[10]; Random random = new Random(); for (int i = 0; i &lt; arr.length; i++) { int num = random.nextInt(100) + 1; arr[i] = num; } for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + \" \"); } System.out.println(); }} 184 53 23 19 43 98 68 26 79 3","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://xiaofanshutu.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"cutiebambi"},{"title":"程序控制结构","slug":"程序控制结构_韩顺平","date":"2023-10-07T12:03:21.120Z","updated":"2024-01-17T23:38:10.765Z","comments":true,"path":"posts/e88088a3.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/e88088a3.html","excerpt":"","text":"程序流程控制介绍顺序控制分支控制 if-else双分支嵌套分支switch 分支结构for 循环控制(!!!)while 循环控制do..while 循环控制多重循环控制(难点! 重点!)跳转控制语句-break跳转控制语句-continue跳转控制语句-return本章作业 12345678910111213141516package chapter5.homework;public class Homework03 { public void test(int year) { if ((year % 4 == 0) &amp;&amp; (year % 100 != 0) || year % 400 == 0) { System.out.println(year + \"年是闰年\"); } else { System.out.println(year + \"年不是闰年\"); } } public static void main(String[] args) { Homework03 homework03 = new Homework03(); homework03.test(2005); }} 123456789101112131415161718192021package chapter5.homework;public class Homework06 { public void test() { int count = 0; for (int i = 1; i &lt;= 100; i++) { if (i % 5 != 0) { count++; System.out.print(i + \"\\t\"); if (count % 5 == 0) { System.out.print(\"\\n\"); } } } } public static void main(String[] args) { Homework06 homework06 = new Homework06(); homework06.test(); }} 123456789101112131415161718package chapter5.homework;public class Homework07 { public void test() { for (char i = 'a'; i &lt;= 'z'; i++) { System.out.print(i + \" \"); } System.out.println(); for (char i = 'Z'; i &gt;= 'A'; i--) { System.out.print(i + \" \"); } } public static void main(String[] args) { Homework07 homework = new Homework07(); homework.test(); }} 1234567891011121314151617181920package chapter5.homework;public class Homework08 { public void test() { double sum = 0; for (int i = 1; i &lt;= 100; i++) { if (i % 2 == 0) { sum -= 1.0 / i; } else { sum += 1.0 / i; } } System.out.println(\"结果为: \" + sum); } public static void main(String[] args) { Homework08 homework = new Homework08(); homework.test(); }} 123456789101112131415161718package chapter5.homework;public class Homework09 { public void test() { int sum = 0; for (int i = 1; i &lt;= 100; i++) { for (int j = 1; j &lt;= i; j++) { sum += j; } } System.out.println(\"总和为：\" + sum); } public static void main(String[] args) { Homework09 homework = new Homework09(); homework.test(); }}","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://xiaofanshutu.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"cutiebambi"},{"title":"运算符","slug":"运算符_韩顺平","date":"2023-10-07T12:03:20.688Z","updated":"2024-01-17T23:38:37.276Z","comments":true,"path":"posts/f29265a7.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/f29265a7.html","excerpt":"","text":"运算符介绍 算术运算符算术运算符一览 细节说明*对一个数取模，等价于a%b = a-a/bb。** 练习题假如还有 59 天放假，问：合 xx 个星期零 xx 天12345678public class App { public static void main(String[] args) { int days = 258; int weeks = days/7; int leftDays = days%7; System.out.println(days + \"天,\" + \"合\" + weeks + \"星期零\" + leftDays + \"天\"); }} 1258天,合36星期零6天 定义一个变量保存华氏温度，华氏温度转换摄氏温度的公式为：5/9*(华氏温度-100),请求出华氏温度对应的摄氏温度。[234.5]12345678public class App { public static void main(String[] args) {// 定义一个变量保存华氏温度，华氏温度转换摄氏温度的公式为：5/9*(华氏温度-100),请求出华氏温度对应的摄氏温度。[234.5] double fahrenheit = 60.8; double centigrade = 5.0 / 9 * (fahrenheit - 100); System.out.println(centigrade); }} 1-21.77777777777778 关系运算符介绍 关系运算符的结果都是布尔（boolean）类型，要么是true，要么是false。 关系运算符组成的表达式称为关系表达式。 关系运算符一览","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://xiaofanshutu.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"cutiebambi"},{"title":"变量","slug":"变量_韩顺平","date":"2023-10-07T12:03:20.216Z","updated":"2024-01-17T23:38:02.944Z","comments":true,"path":"posts/13ffbe88.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/13ffbe88.html","excerpt":"","text":"变量使用注意事项1.变量表示内存中一块存储区域，不同类型占用的空间不同。 2.该区域有自己的名称 [变量名] 和类型 [数据类型] 3.变量三要素，变量=变量名 + 变量值 + 数据类型 程序中+号的使用1.加号左右两边如果都是数字，做加法运算。 2.加号左右两边有一方为字符串，做拼接运算。 3.运算顺序，从左到右。 1System.out.println(\"hello\" + 100 + 3);//hello1003 数据类型 整数类型整数类型的分类 整数类型使用注意细节1.Java的整型默认为int类型，可以加小写l或者大写L将数字变为long类型。 2.bit，计算机中的最小存储单位。 ​ byte，计算机中的基本存储单元。 ​ 1byte = 8bit 浮点类型浮点型的分类 说明： 1.浮点数都是近似值，尾数可能丢失，造成精度损失。 2.浮点数 = 符号位 + 指数位 + 尾数位 浮点数类型使用注意细节 浮点数常量默认类型为double类型，尾部加f或者F可以变为float。 浮点型常量有两种表现形式： 十进制形式：1.23, 521.0f, .369 科学计数法形式：5.21e2$$5.21 * 10^2$$1.23e-2$$1.23/10^2$$ 通常情况下，应该使用double类型，因为double更精确。 12345678public class App { public static void main(String[] args) { double n1 = 3.123456789; float n2 = 3.123456789F; System.out.println(n1); System.out.println(n2); }} 123.1234567893.1234567 浮点数使用陷阱 2.7 和 8.1 / 3 的比较 1234567891011121314public class App { public static void main(String[] args) { double n1 = 2.7; double n2 = 8.1 / 3; System.out.println(n1 == n2);// false System.out.println(n1); System.out.println(n2); //通过Math.abs判断浮点数类型是否相等 if(Math.abs(n1 - n2) &lt; 0.00001){ System.out.println(\"这两个double类型的数据相等~\"); } }} 1234false2.72.6999999999999997这两个double类型的数据相等~ Java API文档API: Application Programming Interface应用程序编程接口 字符类型（char）案例演示123456789101112public class App { public static void main(String[] args) { char c1 = 'a'; char c2 = '\\t'; char c3 = '许'; char c4 = 97; System.out.println(c1); System.out.println(c2); System.out.println(c3); System.out.println(c4); }} 字符型使用细节 在Java中，char的本质是一个整数，默认输出Unicode码对应的字符。https://tool.chinaz.com/tools/unicode.aspx 可以直接给char赋一个整数，输出的时候，会按照对应的Unicode字符输出。（97 ==》 a） char支持运算，它相当于一个整数，因为它都有对应的Unicode码。思考：System.out.println(‘a’ + “a”); 程序运行后，会输出什么？ 123456789101112131415161718192021222324252627public class App { public static void main(String[] args) { // 在 java中，char的本质是一个整数，在默认输出时，是 unicode 码对应的字符 // 要输出对应的数字，可以(int)字符 char c1 = 97; System.out.println(c1); // a char c2 = 'a'; //输出'a' 对应的数字 System.out.println((int)c2);//97 char c3 = '许'; System.out.println((int)c3);//35768 char c4 = 35768; System.out.println(c4);//许 // char类型是可以进行运算的，相当于一个整数，因为它都对应有 Unicode 码. System.out.println('a' + 10);//107 // 课堂小测试 char c5 = 'b' + 1; System.out.println((int)c5);//99 System.out.println(c5);//c System.out.println('a' + \"a\");//aa System.out.println('a' + 1);//98 }} 字符存储细节字符型存储到计算机里面，会将字符对应的码值（整数）找出来。比如： 存储’a’ =&gt; 码值97 =&gt; 二进制（0110 0001） =&gt;存储 字符编码表 ASCII编码，一个字节表示，一共128个字符。实际上一个字节可以表示256个字符，它没有用完，只用了128个。 Unicode编码，固定大小的编码，字母和汉字统一都是占用2个字节，浪费空间。 UTF-8编码，大小可变的编码表，字母占1个字节，汉字占用3个字节。 GBK编码，可以表示汉字，而且范围比较广，字母1个字节，汉字2个字节。 GB2312编码，可以表示汉字。（GB2312 &lt; GBK） BIG5码，繁体中文，台湾，香港。 布尔类型（boolean）布尔类型也叫boolean类型，只允许取值true或者false，没有null。 在Java中，不可以使用非0或者0代替true或false。 基本数据类型转换自动类型转换 自动类型转换细节 多种类型的数据混合运算时，系统会首先自动将所有的数据转换为容量最大的那种数据类型，然后再进行计算。int + double ==&gt; 会转成double （byte，short）和char之间没有类型转换 123//当把一个具体的值赋给byte时，会先判断该值是否在byte范围内，如果在，就okbyte b1 = 10; //不报错char c1 = b1; //报错，因为byte不能转换为char byte，short，char三者运算时，会在计算时转换为int类型 自动提升原则：表达式结果的类型自动提升为操作数中最大的类型。 强制类型转换自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。有可能会造成精度损失或数据溢出。 强制类型转换细节 强制符号只针对最近的操作数，可以使用小括号来提升优先级。 12int x = (int)(3 * 3.5 + 6 * 1.5);System.out.println(x); char类型可以保存int的常量值，但是不能保存int的变量值，需要强转。 12345char c1 = 100;int i1 = 100;//char c2 = i1;//错误char c2 = (char)i1;System.out.println(c2);//100对应的字符d byte和short，char类型在进行运算时，会被当做int类型处理。 基本数据类型和String类型的转换1、基本数据类型转String类型 基本数据类型的值 + “ “ 2、String类型转基本数据类型 基本类型包装类.parse**() 3、字符串转为字符。str.charAt(0); 12345678910111213public class App { public static void main(String[] args) { String s = \"123\"; int i = Integer.parseInt(s); System.out.println(i);//123 double v = Double.parseDouble(s); System.out.println(v); byte b = Byte.parseByte(s); System.out.println(b); }} 123123123.0123 本章作业 程序阅读题，看看输出什么？ 12308 使用char类型，分别保存\\n \\t \\r \\ 1等字符，并且打印输出 123456789101112131415public class App { public static void main(String[] args) { //分别保存\\n \\t \\r \\\\ 1 等字符 char c1 = '\\n'; char c2 = '\\t'; char c3 = '\\r'; char c4 = '\\\\'; char c5 = '1'; System.out.println(c1); System.out.println(c2); System.out.println(c3); System.out.println(c4); System.out.println(c5); }} 保存两本书名，用+拼接，看效果。 保存两个性别，用+拼接，看效果。 保存两本书价格，用+拼接，看效果。 123456789101112131415public class App { public static void main(String[] args) { String s1 = \"向前一步\"; String s2 = \"你当像鸟飞往你的山\"; System.out.println(s1 + s2); char c1 = '男'; char c2 = '女'; System.out.println(c1 + c2); double d1 = 32.2; double d2 = 31.1; System.out.println(d1 + d2); }} 123向前一步你当像鸟飞往你的山5290663.300000000000004 编程实现如下效果 123456789101112public class App { public static void main(String[] args) { String name = \"bambi\"; int age = 13; char gender = '女'; int score = 99; String hobby = \"climbing\"; System.out.println(\"姓名\" + \"\\t\" + \"年龄\" + \"\\t\" + \"性别\" + \"\\t\" + \"成绩\" + \"\\t\" + \"爱好\" + \"\\n\" + name + \"\\t\" + age + \"\\t\" + gender + \"\\t\" + score + \"\\t\" + hobby); }} 用IDEA执行代码输出结果为： 用CMD执行代码输出结果为：","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://xiaofanshutu.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"cutiebambi"},{"title":"FreeMarker","slug":"Freemarker笔记","date":"2023-07-26T13:15:01.077Z","updated":"2024-01-17T23:39:03.576Z","comments":true,"path":"posts/db5fbd34.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/db5fbd34.html","excerpt":"","text":"代码：https://gitee.com/hhgs_admin/freemarkerdemo 主要内容 概述FreeMarker概念：FreeMarker是一个模板引擎，一个基于模板生成文本输出的通用工具，使用纯Java编写。 FreeMarker被设计用来生成HTML Web页面，特别是基于MVC模式的应用程序 虽然FreeMarker具有一些编程的能力，但通常由Java程序准备要显示的数据，由FreeMarker生成页面，通过模板显示准备的数据： FreeMarker不是一个Web应用框架，而适合作为Web应用框架一个组件。 FreeMarker与容器无关，因为它并不知道HTTP或Servlet；FreeMarker同样可以应用于非Web应用程序环境。 FreeMarker更适合作为Model2框架（如Struts）的视图组件，你也可以在模板中使用JSP标记库。 FreeMarker是免费的。 FreeMarker特性通用目标能够生成各种文本：HTML、XML、RTF、Java源代码等等 易于嵌入到你的产品中：轻量级；不需要Servlet环境 插件式模板载入器：可以从任何源载入模板，如本地文件、数据库等等 你可以按你所需生成文本：保存到本地文件；作为Email发送；从Web应用程序发送它返回给Web浏览器 强大的模板语言所有常用的指令：include、if/elseif/else、循环结构 在模板中创建和改变变量 几乎在任何地方都可以使用复杂表达式来指定值 命名的宏，可以具有位置参数和嵌套内容 名字空间有助于建立和维护可重用的宏库，或者将一个大工程分成模块，而不必担心名字冲突 输出转换块：在嵌套模板片段生成输出时，转换HTML转义、压缩、语法高亮等等；你可以定义自己的转换 通用数据模型FreeMarker不是直接反射到Java对象，Java对象通过插件式对象封装，以变量方式在模板中显示 你可以使用抽象（接口）方式表示对象（JavaBean、XML文档、SQL查询结果集等等），告诉模板开发者使用方法，使其不受技术细节的打扰 为Web准备在模板语言中内建处理典型Web相关任务（如HTML转义）的结构 能够集成到Model2 Web应用框架中作为JSP的替代 支持JSP标记库 为MVC模式设计：分离可视化设计和应用程序逻辑；分离页面设计员和程序员 智能的国际化和本地化字符集智能化（内部使用UNICODE） 数字格式本地化敏感 日期和时间格式本地化敏感 非US字符集可以用作标识（如变量名） 多种不同语言的相同模板 强大的XML处理能力&lt;#recurse&gt; 和&lt;#visit&gt;指令（2.3版本）用于递归遍历XML树。在模板中清楚和直觉的访问XML对象模型。开源论坛 JForum 就是使用了 FreeMarker 做为页面模板。 FreeMarker环境搭建新建Maven Web项目 配置坐标依赖和部署插件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;freemarkerdemo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;freemarkerdemo Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- freemarker 的坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.23&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet-api 的依赖--&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;freemarkerdemo&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;!-- 配置Tomcat插件 ,用于启动项目 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;!--如果不设置，则默认为猫的自定义端口，项目路径为http://localhost:默认端口/项目名 --&gt; &lt;configuration&gt; &lt;!--如果端口号改为8081：那么访问的时候路径的端口就要写成8081，否则404 --&gt; &lt;port&gt;8080&lt;/port&gt; &lt;!-- 如果设置为/，则项目了路径为http://localhost:端口号 /--&gt; &lt;!-- 如果设置为/123，则项目了路径为http://localhost:端口号/123 --&gt; &lt;path&gt;/123&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; 修改配置文君web.xml1234567891011121314151617181920212223242526272829&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;freemarker&lt;/servlet-name&gt; &lt;servlet-class&gt;freemarker.ext.servlet.FreemarkerServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!-- 模板路径--&gt; &lt;param-name&gt;TemplatePath&lt;/param-name&gt; &lt;!-- 默认在webapp 目录下查找对应的模板文件--&gt; &lt;param-value&gt;/&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;!-- 模板默认的编码--&gt; &lt;param-name&gt;default_encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;!-- 处理所有的以.ftl结尾的文件；ftl是freemarker默认的文件后缀--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;freemarker&lt;/servlet-name&gt; &lt;url-pattern&gt;*.ftl&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 编写Servlet文件 123456789101112131415161718192021package org.example.controller;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/f01\")public class FreeMarker01 extends HttpServlet { @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {// 给模板的数据 req.setAttribute(\"msg\",\"hello word\");// 请求转发到指定的页面， req.getRequestDispatcher(\"template/f01.ftl\").forward(req,resp); }} 新建模板文件ftl12345678910111213&lt;!--html注释 在浏览器中可以看到的注释--&gt;&lt;#--freemarker注释 在浏览器中不能看到的注释freemarker的语法 1，html所有的标签都适用 2，js与css的使用，与html中语法一致--&gt;&lt;#-- 获取数据--&gt;${msg} 启动项目 访问项目 FreeMarker数据类型 布尔类型1.在Servlet中设置布尔类型的数据 12//布尔类型request.setAttribute(\"flag\",true); 2.获取数据 123456789&lt;#-- 数据类型：布尔类型 在freemarker中布尔类型不能直接输出；如果输出要先转成字符串 方式一：?c 方式二：?string 或 ?string(\"true时的文本\",\"false时的文本\")--&gt;&lt;h5&gt;布尔类型&lt;/h5&gt;${flag?c} &lt;br/&gt;${flag?string} &lt;br/&gt;${flag?string(\"yes\",\"no\")} &lt;br/&gt; 日期类型1.在Servlet中设置日期类型的数据 12//日期类型request.setAttribute(\"createDate\",new Date()); 2.获取数据 12345678910111213141516171819&lt;#-- 数据类型：日期类型 在freemarker中日期类型不能直接输出；如果输出要先转成日期型或字符串 1，年月日 ?date 2,时分秒 ?time 3,年月日时分秒 ?datetime 4,制定格式 ?string(\"自定义格式\") y:年 M:月 d:日 H:时 m:分 s:秒 --&gt;&lt;h5&gt;日期类型&lt;/h5&gt;&lt;#--输出日期格式 --&gt;${createDate?date} &lt;br/&gt;&lt;#--输出时间格式 --&gt;${createDate?time} &lt;br/&gt;&lt;#--输出日期时间格式 --&gt;${createDate?datetime} &lt;br/&gt;&lt;#--输出格式化日期格式 --&gt;${createDate?string(\"yyyy年MM月dd日 HH:mm:ss\")} &lt;br/&gt; 数值类型1.在Servlet中设置数值类型的数据 1234//数值类型request.setAttribute(\"age\",18);//数值类型request.setAttribute(\"salary\",100000);//数值类型request.setAttribute(\"avg\",0.545);//浮点类型 2.获取数据 123456789101112131415161718192021&lt;#-- 数据类型：数值类型 在freemarker中数值类型可以直接输出； 1，转字符串 普通字符串 ?c 货币字符串 ?string.currency 百分比型字符串 ?string.percent 2，保留浮点型数值指定小数位（#表示一个小数位） ?string[\"0.##\"]--&gt;&lt;#-- 直接输出数值类型--&gt;${age}&lt;br/&gt;${salary}&lt;br/&gt;&lt;#-- 将数值转换成字符串输出--&gt;${salary?c}&lt;br/&gt;&lt;#--将数值转换成货币类型的字符串输出 --&gt;${salary?string.currency}&lt;br&gt;&lt;#--将数值转换为百分比的字符串--&gt;${avg?string.percent}&lt;br&gt;&lt;#--将浮点型数值保留指定小数位输出（##表示保留两位小数）--&gt;${avg?string[\"0.##\"]} &lt;br/&gt; 字符串类型1.在Servlet中设置字符串类型的数据 123//字符串类型request.setAttribute(\"msg\",\"hello\");request.setAttribute(\"msg2\",\"freemarker \"); 2.获取数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;hr&gt;&lt;#-- 数据类型：字符串类型 在freemarker中字符串类型可以直接输出； 1，截取字符串（坐闭右开） ?substring(start,end) 2,首字母小写输出 ?uncap_first 3，首字母大写输出 ?cap_first 4，字母转小写输出 ?lower_case 5，字母转大写输出 ?upper_case 6，获取字符串长度 ?length 7，是否以指定字符串开头(boolean类型) ?starts_with(\"xx\")?string 8，是否以指定字符结尾(boolean类型) ?ends_with(\"xx\")?string 9，获取指定字符的索引 ?index_of(\"xx\") 10，去除字符串前后空格 ?trim 11，替换指定字符串 ?replace(\"xx\",\"xx\")--&gt;&lt;h5&gt;字符串类型&lt;/h5&gt;${msg}--------${msg2}&lt;br&gt;${msg?string}--------${msg2?string}&lt;br&gt;&lt;#-- 1.截取字符串（坐闭右开） ?substring(start,end) --&gt;${msg?substring(0,2)} &lt;br&gt;&lt;#-- 2,首字母小写输出 ?uncap_first --&gt;${msg?uncap_first} &lt;br&gt;&lt;#--3，首字母大写输出 ?cap_first --&gt;${msg?cap_first} &lt;br&gt;&lt;#--4，字母转小写输出 ?lower_case --&gt;${msg?lower_case} &lt;br&gt;&lt;#--5，字母转大写输出 ?upper_case --&gt;${msg?upper_case} &lt;br&gt;&lt;#--6，获取字符串长度 ?length --&gt;${msg?length} &lt;br&gt;&lt;#--7，是否以指定字符串开头(boolean类型) ?starts_with(\"xx\")?string --&gt;${msg?starts_with(\"a\")?string} &lt;br&gt;&lt;#--8，是否以指定字符结尾(boolean类型) ?ends_with(\"xx\")?string --&gt;${msg?ends_with(\"o\")?string} &lt;br&gt;&lt;#--9，获取指定字符的索引 ?index_of(\"xx\") --&gt;${msg2?index_of(\"m\")} &lt;br&gt;&lt;#--10，去除字符串前后空格 ?trim --&gt;${msg2?trim} &lt;br&gt;&lt;#--11，替换指定字符串 ?replace(\"xx\",\"xx\") --&gt;${msg?replace(\"he\",\"we\")} &lt;br&gt; 字符串空值清空处理 ​ FreeMarker的变量必须赋值，否则就会抛出异常。而对FreeMarker来说，null值和不存在的变量是完全一样的，因为FreeMarker无法理解null值。 ​ FreeMarker提供两个运算符来避免空值： ​ 1 !：指定确实变量的默认值 ​ ${value！}：如果value值为空，则默认值是空字符串 ​ ${value! “默认值”}： 如果value值为空，则默认值是字符串“默认值” 2 ??： 判断变量是否存在 ​ 如果变量存在，返回true，否则返回false ​ ${(value??)?string} 1234//空数据request.setAttribute(\"str1\",null);request.setAttribute(\"str2\",\"\"); 12345678910111213141516171819&lt;hr&gt;&lt;#-- 如果值不存在，直接输出就会报错--&gt;&lt;#--${a}--&gt;&lt;#--值为null的数据也直接报错--&gt;&lt;#--${str1}--&gt;&lt;#--值为空字符串的不会报错--&gt;&lt;h5&gt;空值处理&lt;/h5&gt;空字符串：${str2}&lt;br/&gt;&lt;#-- 使用!,当值不存在时，默认显示空字符串 --&gt;感叹号：${str1!}&lt;br/&gt;&lt;#-- 使用!\"xx\",当值不存在时，默认显示指定字符串--&gt;${str1! \"str1的数不存在\"}&lt;br/&gt;&lt;#-- 使用??,判断字符串是否为空；返回布尔类型。如果想要输出，需要将布尔类型转换成字符串--&gt;${(str1??)?c}&lt;br/&gt;${(str1??)?string}&lt;br/&gt; sequence类型1.在Servlet中设置序列类型的数据 12345678910111213// 序列类型 （数组、List、Set）// 数组操作String[] stars = new String[]{\"周杰伦\",\"林俊杰\",\"陈奕迅\",\"五月天\"};request.setAttribute(\"stars\",stars);// List操作List&lt;String&gt; citys = Arrays.asList(\"上海\",\"北京\",\"杭州\",\"深圳\");request.setAttribute(\"cityList\",citys);// JavaBean集合List&lt;User&gt; userList = new ArrayList&lt;&gt;();userList.add(new User(1,\"zhangsan\",22));userList.add(new User(2,\"lisi\",18));userList.add(new User(3,\"wangwu\",20));request.setAttribute(\"userList\",userList); 2.获取数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;#-- FreeMarker 数据类型 序列类型（数组、List、Set） 通过list指令输出序列 &lt;#list 序列名 as 元素名&gt; ${元素名} &lt;/#list&gt; 获取序列的长度 ${序列名?size} 获取序列元素的下标 ${元素名?index} 获取第一个元素 ${序列名?first} 获取最后一个元素 ${序列名?last} 倒序输出 序列名?reverse 升序输出 序列名?sort 降序输出 序列名?sort?reverse 指定字段名排序 序列名?sort_by(\"字段名\") 注：一般是JavaBean集合，对应的字段名需要提供get方法--&gt;&lt;#-- 数组操作 --&gt;&lt;#list stars as star&gt; 下标：${star?index} - 姓名：${star} &lt;br&gt;&lt;/#list&gt;获取序列的长度：${stars?size} &lt;br&gt;获取第一个元素：${stars?first} &lt;br&gt;获取最后一个元素： ${stars?last} &lt;br&gt;&lt;hr&gt;&lt;#-- List操作 --&gt;&lt;#list cityList as city&gt; ${city}&lt;/#list&gt;&lt;br&gt;&lt;#--倒序输出 序列名?reverse--&gt;&lt;#list cityList?reverse as city&gt; ${city}&lt;/#list&gt;&lt;br&gt;&lt;#--升序输出 序列名?sort--&gt;&lt;#list cityList?sort as city&gt; ${city}&lt;/#list&gt;&lt;br&gt;&lt;#--降序输出 序列名?sort?reverse--&gt;&lt;#list cityList?sort?reverse as city&gt; ${city}&lt;/#list&gt;&lt;br&gt;&lt;hr&gt;&lt;#list userList as user &gt; 编号：${user.userId} &nbsp; 姓名：${user.uname} &nbsp; ${user.uage} &lt;br&gt;&lt;/#list&gt;&lt;br&gt;&lt;#list userList?sort_by(\"uage\") as user &gt;编号：${user.userId} &nbsp; 姓名：${user.uname} &nbsp; ${user.uage} &lt;br&gt;&lt;/#list&gt;&lt;br&gt;&lt;hr&gt; hash类型1.在Servlet中设置hash类型的数据 123456// Map操作Map&lt;String,String&gt; cityMap = new HashMap&lt;&gt;();cityMap.put(\"sh\",\"上海\");cityMap.put(\"bj\",\"北京\");cityMap.put(\"sz\",\"深圳\");request.setAttribute(\"cityMap\",cityMap); 2.获取数据 12345678910111213141516171819&lt;#-- &nbsp; &nbsp;数据类型：hash类型 &nbsp; &nbsp; &nbsp; &nbsp; key遍历输出 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;#list hash?keys as key&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ${key} -- ${hash[key]} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;/#list&gt; &nbsp; &nbsp; &nbsp; &nbsp; value遍历输出 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;#list hash?values as value&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ${value} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;/#list&gt;--&gt;&lt;#-- key遍历输出 --&gt;&lt;#list cityMap?keys as key&gt; &nbsp; ${key} -- ${cityMap[key]} &lt;br&gt; &lt;/#list&gt; &lt;#-- value遍历输出 --&gt;&lt;#list cityMap?values as value&gt; &nbsp; ${value} | &lt;/#list&gt; FreeMarker常见指令assign 自定义变量指令使用 assign 指令你可以创建一个新的变量， 或者替换一个已经存在的变量。 12345678910&lt;#-- assign 自定义变量指令 语法： &lt;#assign 变量名=值&gt; &lt;#assign 变量名=值 变量名=值&gt; （定义多个变量）--&gt;&lt;#assign str=\"hello\"&gt;${str} &lt;br&gt; &lt;#assign num=1 names=[\"zhangsan\",\"lisi\",\"wangwu\"] &gt;${num} -- ${names?join(\",\")} if elseif else 逻辑判断指令可以使用 if ， elseif 和 else 指令来条件判断是否满足某些条件。 123456789101112131415161718192021222324&lt;h5&gt; 2. if, else, elseif 逻辑判断指令&lt;/h5&gt;&lt;#assign score = 60&gt;&lt;#if score lt 60 &gt; &lt;h6&gt;你个小渣渣！&lt;/h6&gt; &lt;#elseif score == 80&gt; &lt;h6&gt;分不在高，及格就行！&lt;/h6&gt; &lt;#elseif score gt 60 &amp;&amp; score lt 80 &gt; &lt;h6&gt;革命尚未成功，同志仍需努力！&lt;/h6&gt; &lt;#else &gt; &lt;h6&gt;哎哟不错哦！&lt;/h6&gt;&lt;/#if&gt;&lt;#--判断数据是否存在--&gt;&lt;#assign list=\"\"&gt;&lt;#if list??&gt; 数据存在 &lt;#else &gt; 数据不存在&lt;/#if&gt;&lt;br&gt;&lt;#if list2??&gt; 数据存在&lt;#else &gt; 数据不存在&lt;/#if&gt; list 遍历指令可以使用 list 指令来对序列进行遍历。 1234567891011121314151617181920&lt;h5&gt;3. list指令&lt;/h5&gt;&lt;#assign users = [\"张三\",\"李四\",\"王五\"]&gt;&lt;#list users as user&gt; ${user} |&lt;/#list&gt;&lt;br&gt;&lt;#--判断数据不为空，再执行遍历 （如果序列不存在，直接遍历会报错）--&gt;&lt;#if users2??&gt; &lt;#list users2 as user&gt; ${user} &lt;/#list&gt;&lt;/#if&gt;&lt;br&gt;&lt;#-- 当序列没有数据项时，使用默认信息 --&gt;&lt;#assign users3 = []&gt;&lt;#list users3 as user&gt; ${user} | &lt;#else &gt; 用户数据不存在！&lt;/#list&gt; macro 自定义指令可以使用 macro 指令来自定义一些自定义指令。 123456789101112131415161718192021222324252627282930313233343536373839&lt;#-- macro 自定义指令 （宏） 1. 基本使用 格式： &lt;#macro 指令名&gt; 指令内容 &lt;/#macro&gt; 使用： &lt;@指令名&gt;&lt;/@指令名&gt; 2. 有参数的自定义指令 格式： &lt;#macro 指令名 参数名1 参数名2&gt; 指令内容 &lt;/#macro&gt; 使用： &lt;@指令名 参数名1=参数值1 参数名2=参数值2&gt;&lt;/@指令名&gt; 注： 1. 指令可以被多次使用。 2. 自定义指令中可以包含字符串，也可包含内置指令--&gt;&lt;#-- 定义基本的自定义指令 --&gt;&lt;#macro address&gt; © 1999–2015 The FreeMarker Project. All rights reserved. &lt;/#macro&gt; &lt;#-- 使用指令 --&gt;&lt;@address&gt;&lt;/@address&gt; &lt;br&gt; &lt;@address&gt;&lt;/@address&gt; &lt;hr&gt; &lt;#-- 定义有参数的自定义指令 --&gt;&lt;#macro queryUserByName uname&gt; 通过用户名查询用户信息 - ${uname} &lt;/#macro&gt; &lt;#-- 使用指令，并传递参数 --&gt;&lt;@queryUserByName uname=\"admin\"&gt;&lt;/@queryUserByName&gt; &lt;br&gt; &lt;#-- 定义有多个参数的自定义指令 --&gt;&lt;#macro queryUserByParams uname uage&gt; 通过多个餐宿查询用户信息 - ${uname} - ${uage} &lt;/#macro&gt; &lt;#-- 使用指令，并传递多个参数 --&gt;&lt;@queryUserByParams uname=\"admin\" uage=18&gt;&lt;/@queryUserByParams&gt; &lt;br&gt; &lt;hr&gt; 123456789101112131415161718192021&lt;#-- 自定义指令中包含内置指令 --&gt;&lt;#macro cfb&gt; &lt;#list 1..9 as i&gt; &lt;#list 1..i as j&gt; ${j}*${i}=${j*i}&amp;nbsp; &lt;/#list&gt; &lt;br&gt; &lt;/#list&gt; &lt;/#macro&gt; &lt;@cfb&gt;&lt;/@cfb&gt; &lt;@cfb&gt;&lt;/@cfb&gt; &lt;#-- 动态数据 --&gt;&lt;#macro cfb2 num&gt; &lt;#list 1..num as i&gt; &lt;#list 1..i as j&gt; ${j}*${i}=${j*i}&amp;nbsp; &lt;/#list&gt; &lt;br&gt; &lt;/#list&gt; &lt;/#macro&gt; &lt;@cfb2 num=5&gt;&lt;/@cfb2&gt; nested 占位指令nested 指令执行自定义指令开始和结束标签中间的模板片段。嵌套的片段可以包含模板中任意合法的内容。 1234567891011&lt;#-- nested 占位指令 nested 相当于占位符,一般结合macro指令一起使用。 可以将自定义指令中的内容通过nested指令占位，当使用自定义指令时，会将占位内容显示。--&gt;&lt;#macro test&gt; 这是一段文本！ &lt;#nested&gt; &lt;#nested&gt; &lt;/#macro&gt; &lt;@test&gt;&lt;h4&gt;这是文本后面的内容！&lt;/h4&gt;&lt;/@test&gt; import 导入指令import 指令可以引入一个库。也就是说，它创建一个新的命名空间， 然后在那个命名空间中执行给定路径的模 板。可以使用引入的空间中的指令。 创建commons.ftl文件12345678&lt;#macro cfb&gt; &lt;#list 1..9 as i&gt; &lt;#list 1..i as j&gt; ${j}*${i}=${j*i}&amp;nbsp; &lt;/#list&gt; &lt;br&gt; &lt;/#list&gt; &lt;/#macro&gt; 在其他ftl页面中通过import导入commons.ftl的命名空间，使用该命名空间中的指令 创建test.ftl文件1234&lt;#-- 导入命名空间 --&gt;&lt;#import \"commons.ftl\" as common&gt; &lt;#-- 使用命名空间中的指令 --&gt;&lt;@common.cfb&gt;&lt;/@common.cfb&gt; 创建Controller1234567891011121314151617181920212223242526package org.example.controller;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @author liyonghui * @description Freemarker常用指令 * @date 2022/12/20 14:05 */@WebServlet(\"/f04\")public class FreeMarker04 extends HttpServlet { @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {// 请求转发到指定的页面， req.getRequestDispatcher(\"template/test.ftl\").forward(req, resp); }} include 包含指令可以使用 include 指令在你的模板中插入另外一个 FreeMarker 模板文件 。 被包含模板的输出格式是在 include 标签出现的位置插入的。 被包含的文件和包含它的模板共享变量，就像是被复制粘贴进去的一样。 1234567&lt;#--包含指令(引入其他页面文件) include--&gt;&lt;#--html文件--&gt;&lt;#include \"test.html\"&gt; &lt;#--freemarker文件--&gt;&lt;#include \"test.ftl\"&gt; &lt;#--text文件--&gt;&lt;#include \"test.txt\"&gt; FreeMarker页面静态化通过上述介绍可知 Freemarker 是一种基于模板的、用来生成输出文本的通用工具,所以 我们必须要定制符合自己业务的模板，然后生成自己的 html 页面。Freemarker 是通过 freemarker.template.Confifiguration 这个对象对模板进行加载的（它也处理创建和缓存预 解析模板的工作），然后我们通过 getTemplate 方法获得你想要的模板，有一点要记住 freemarker.template.Confifiguration 在你整个应用必须保证唯一实例。 定义模板创建news.ftl模板文件 1234567891011121314151617181920&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;#-- freemaeker模板中设置编码格式，否则中文可能乱码 --&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html;charset=UTF-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;#-- 新闻标题 --&gt; &lt;h2 align=\"center\"&gt;${title}&lt;/h2&gt; &lt;#-- 新闻来源 和 发布时间 --&gt; &lt;p align=\"center\"&gt; 新闻来源：${source} &amp;nbsp;&amp;nbsp; 发布时间：${pubTime} &lt;/p&gt; &lt;#-- 新闻内容 --&gt; &lt;p style=\"text-indent: 2em\"&gt; ${content} &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 加载模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.xxxx.servlet;import freemarker.template.Configuration;import freemarker.template.Template;import freemarker.template.TemplateException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.FileWriter;import java.io.IOException;import java.util.HashMap;import java.util.Map;@WebServlet(\"/news\")public class NewsServlet extends HttpServlet { @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 实例化模板对象 Configuration configuration = new Configuration(); // 设置加载模板的上下文 以及加载模板的路径 （模板存放路径） configuration.setServletContextForTemplateLoading(getServletContext(),\"/template\"); // 设置模板的编码格式 configuration.setDefaultEncoding(\"UTF-8\"); // 加载模板文件 获取模板对象 Template template = configuration.getTemplate(\"news.ftl\"); // 设置数据模型 Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"title\",\"【战“疫”说理】良好的公民素养和国民心态是“硬核”力量\"); map.put(\"source\",\"经济日报-中国经济网\"); map.put(\"pubTime\",\"2020年03月16日 10:00\"); map.put(\"content\",\"公共性的社会大事件，是检验和透视公民素养和国民心态的一个重要窗口。\" + \"在突袭而至的新冠肺炎疫情面前，一方面，抗击疫情的过程就是淬炼公民素养和国民心态的熔炉；另一方面，良好的公民素养和国民心态也是疫情防控的“硬核”力量，更是推动战“疫”积极向好态势不断拓展的精神之盾。\\n\" + \"\\n疫情防控，既是大战，也是大考。涵养良好的公民素养和国民心态，是疫情期间摆在我们面前的考题，同时也是提升国家治理能力过程中需要面对的课题。\\n\" + \"\\n着眼三个方面 提升科学素养\\n\\n疫情面前，每个人都是防控链条中的重要一环。做好自我保护，既是对自己、家人负责，也是对社会负责。有效做好科学防控，每个人都应具备必要的科学素养。\"); // 获取项目的根目录 String basePath = req.getServletContext().getRealPath(\"/\"); // 设置html的存放路径 File htmlFile = new File(basePath + \"/html\"); // 判断文件（目录）是否存在 if (!htmlFile.exists()) { // 如果文件目录不存在，则新建文件目录 htmlFile.mkdir(); } // 得到生成的文件名 （生成随机不重复的文件名） String fileName = System.currentTimeMillis() + \".html\"; // 创建html文件 File file = new File(htmlFile,fileName); // 获取文件输出流 FileWriter writer = new FileWriter(file); // 生成html （将数据模型填充到模板中） try { template.process(map,writer); } catch (TemplateException e) { e.printStackTrace(); } finally { // 关闭资源 writer.flush(); writer.close(); } }} 生成对应的html文件浏览器地址栏输入： http://localhost:8989/news 生成的文件存放在当前项目的webapp目录下的html目录中。 FreeMarker运算符算术运算符123456789101112&lt;!-- 算术运算 +、-、*、/、%--&gt;&lt;#assign a1 = 8 a2 = 2 &gt;${a1} + ${a2} = ${a1 + a2} &lt;br/&gt;${a1} - ${a2} = ${a1 - a2} &lt;br/&gt;${a1} * ${a2} = ${a1 * a2} &lt;br/&gt;${a1} / ${a2} = ${a1 / a2} &lt;br/&gt;${a1} % ${a2} = ${a1 % a2} &lt;br/&gt;&lt;!--字符串运算--&gt;${\"hello\" + \",\" + \"freemarker\"} 逻辑运算符1234&lt;#-- 逻辑运算符 &amp;&amp;、||、!--&gt; 比较运算符123456789&lt;#-- 比较运算符 &gt; (gt): 大于号，推荐使用 gt &lt; (lt)： 小于号，推荐使用 lt &gt;= (gte): 大于等于， 推荐是用 gte &lt;= (lte): 小于等于，推荐使用 lte == ： 等于 != : 不等于--&gt; 空值运算符1234567891011&lt;#-- 空值运算符 1. ??:判断是否为空，返回布尔类型 如果不为空返回 false， 如果为空返回 true，不能直接输出 ${(name??)?string} 2. !: 设置默认值，如果为空，则设置默认值 1. 设置默认为空字符串： ${name!} 2. 设置指定默认值 ${name!'zhangsan'}--&gt;","categories":[{"name":"新技术FreeMarker","slug":"新技术FreeMarker","permalink":"https://xiaofanshutu.github.io/categories/%E6%96%B0%E6%8A%80%E6%9C%AFFreeMarker/"}],"tags":[],"author":"cutiebambi"},{"title":"Java概述","slug":"Java概述_韩顺平","date":"2023-04-29T01:07:41.762Z","updated":"2024-01-17T23:39:26.828Z","comments":true,"path":"posts/1113d944.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/1113d944.html","excerpt":"","text":"如何快速学习一个知识点 转义字符1234567// 在控制台，输入 tab 键，可以实现命令补全 \\t ：一个制表位，实现对齐的功能\\n ：换行符\\\\ ：一个\\\\\" :一个\"\\' ：一个' \\r :一个回车 12345678910111213141516171819202122232425262728//转义字符练习public class App { //编写一个 main 方法 public static void main(String[] args) { //\\t ：一个制表位，实现对齐的功能 System.out.println(\"北京\\t天津\\t上海\"); // \\n ：换行符 System.out.println(\"jack\\nsmith\\nmary\"); // \\\\ ：一个\\ System.out.println(\"C:\\\\Windows\\\\System32\\\\cmd.exe\"); // \\\" :一个\" System.out.println(\"你好呀，\\\"bambi\\\"\"); // \\' ：一个' System.out.println(\"你好呀，\\'bambi\\'\"); // \\r :一个回车 System.out.println(\"你好呀\\r明天\"); // 解读 // 1. 输出 你好呀 // 2. \\r 表示回车 System.out.println(\"你好呀\\r明天\"); }} 12345678910d:\\desktop&gt;java App北京 天津 上海jacksmithmaryC:\\Windows\\System32\\cmd.exe你好呀，\"bambi\"你好呀，'bambi'明天呀明天呀 Java代码规范_行尾风格 DOS（Disk Operating System 磁盘操作系统）命令DOS介绍 相对路径 &amp; 绝对路径 常用DOC命令1234567891011121314151.查看当前目录是有什么内容 dir dir dir d:\\abc2\\test2002.切换到其他盘下：盘符号 cd : change directory 案例演示： 切换到 c 盘 cd /D c: 3.切换到当前盘的其他目录下 (使用相对路径和绝对路径演示), ..\\表示上一级目录 案例演示： cd d:\\abc2\\test200 cd ..\\..\\abc2\\test200 4.切换到上一级： 案例演示： cd .. 5.切换到根目录：cd \\ 案例演示：cd \\6.查看指定的目录下所有的子级目录 tree7.清屏 cls8.退出 DOS exit","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaofanshutu.github.io/categories/Java/"}],"tags":[],"author":"cutiebambi"},{"title":"重要信息记录","slug":"重要信息记录","date":"2023-04-29T01:07:41.762Z","updated":"2024-01-17T23:38:41.448Z","comments":true,"path":"posts/e179e6d6.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/e179e6d6.html","excerpt":"","text":"重要学习网站https://pdai.tech/md/about/me/about-me.html 需要学习的知识 Javascript Java Spring Boot HTML 数据库 集合 并发","categories":[{"name":"日常","slug":"日常","permalink":"https://xiaofanshutu.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[],"author":"cutiebambi"},{"title":"面试题总结","slug":"面试","date":"2023-04-29T01:07:41.762Z","updated":"2024-01-17T23:38:25.743Z","comments":true,"path":"posts/5c3dbcbd.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/5c3dbcbd.html","excerpt":"","text":"Java基础语法基础String、StringBuffer与StringBuilder的区别？Stringfinal修饰的，不可变，每次操作都会产生一个新的String对象。 12public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence StringBuffer线程安全的 123public final class StringBuffer extends AbstractStringBuilder implements java.io.Serializable, CharSequence 12345678910111213141516171819@Overridepublic synchronized StringBuffer append(Object obj) { toStringCache = null; super.append(String.valueOf(obj)); return this;}@Overridepublic synchronized StringBuffer append(String str) { toStringCache = null; super.append(str); return this;}public synchronized StringBuffer append(StringBuffer sb) { toStringCache = null; super.append(sb); return this;} StringBuilder线程不安全的 123public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence 总结性能：StringBuilder &gt; StringBuffer &gt; String 如果经常需要改变字符串的内容，需要使用除String之外的两个类。 平时工作中，优先使用StringBuilder，如果是多线程环境，并且这个变量是共享变量时，使用StringBuffer。 开发框架和中间件Spring什么是Spring框架？列举一些重要的Spring模块？什么是IOC? 如何实现的？什么是AOP? 有哪些AOP的概念？AOP 有哪些应用场景？有哪些AOP Advice通知的类型？AOP 有哪些实现方式？谈谈你对CGLib的理解？Spring AOP和AspectJ AOP有什么区别？Spring中的bean的作用域有哪些？Spring中的单例bean的线程安全问题了解吗？Spring中的bean生命周期？说说自己对于Spring MVC的了解？Spring MVC的工作原理了解嘛？Spring框架中用到了哪些设计模式？@Component和@Bean的区别是什么？将一个类声明为Spring的bean的注解有哪些？Spring事务管理的方式有几种？Spring事务中的隔离级别有哪几种？Spring事务中有哪几种事务传播行为？Bean Factory和ApplicationContext有什么区别？如何定义bean的范围？可以通过多少种方式完成依赖注入？Spring Boot什么是SpringBoot？为什么使用SpringBoot？Spring、Spring MVC和SpringBoot有什么区别？SpringBoot自动配置的原理?Spring Boot的核心注解是哪些？他主由哪几个注解组成的？SpringBoot的核心配置文件有哪几个？他们的区别是什么？什么是Spring Boot Starter？有哪些常用的？spring-boot-starter-parent有什么作用？如何自定义Spring Boot Starter？为什么需要spring-boot-maven-plugin？SpringBoot 打成jar和普通的jar有什么区别？如何使用Spring Boot实现异常处理？SpringBoot 实现热部署有哪几种方式？Spring Boot中的监视器是什么？Spring Boot 可以兼容老 Spring 项目吗？Spring SecurityMyBatisJPA日志框架Tomcat","categories":[{"name":"八股文","slug":"八股文","permalink":"https://xiaofanshutu.github.io/categories/%E5%85%AB%E8%82%A1%E6%96%87/"}],"tags":[],"author":"cutiebambi"},{"title":"马士兵","slug":"马士兵","date":"2023-04-29T01:07:41.762Z","updated":"2024-01-17T23:38:21.012Z","comments":true,"path":"posts/fc27ae96.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/fc27ae96.html","excerpt":"","text":"Java基础Java是什么类型的语言？简单说说Java中对象如何拷贝？伪代码快速实现深拷贝？什么是Object？有哪些常用的方法？怎么创建对象？notify方法为什么唤醒线程的方法是在object里面？不是应该在线程Thread里面吗？ 多态，面向接口编程?聊聊你的认知 制定标准 提高可扩展性 让你设计一个接口，你会考虑到什么点？ 最小隔离 接口和抽象类的区别？ 什么是内部类，说说你的理解以及实战场景HashMap里面有大量的内部类，匿名内部类，局部内部类等等，下来自己看一下 说说static和final在Java中的意义static不能修饰局部变量，static字段和static代码块谁先加载 如果子类里面有static，那么先加载子类还是先加载父类 Java中的基本数据类型占多少个字节，不同的操作系统一样吗？这个是JVM来决定的。不同操作系统占的字节一样，只不过占的空间不一样 int和Integer有什么关联？为什么需要Integer？装箱拆箱为什么需要8种包装类型？因为java是面向对象的语言 String, StringBuffer,StringBuilder的区别，以及String的常用方法？什么是序列化，反序列化，说说运用场景？反序列化的不安全问题如何解决？ 应用场景： dubbo RTC手写自己的rpc框架里面 数组有length()方法吗？构造器是否可以被重写？构造器不可以 char是否可以存储一个汉字可以 字符集和字符编码，解决乱码必学 集合原理系列ArrayList LinkedList： queue Deque 为什么现在舍弃Vector？ HashSet TreeSet HashMap TreeMap LinkedMap（有序） queue 阻塞队列 add remove element offer poll peek take Enumeration接口和Iterator接口的区别有哪些？Enumeration速度是迭代器的两倍，但是遍历的时候不能改里面的东西 异常异常是用来干嘛的？也是一种代码分支的实现方式 什么是事务？为什么需要事务？如何实现事务？事务隔离级别？java事务类型有几种？ jdbc事务 jta事务 容器事务 java修饰符以及各自的作用范围public protect 缺省 private linux什么是linux？如何安装使用linux 说说你常用的linux查看文件和文件夹的命令 如何递归删除文件夹和所有文件 如何拷贝，移动一个文件 如何查找一个文件 你还使用过哪些常用的linux命令 grep是什么命令？man是什么命令？ chmod是什么命令？如何使用？r,w,x/u,g,o/+,-/1,2,4各自代表什么含义？？ VI，VIM是什么？说说你常用的VI命令和按键 netstat命令的作用？如何使用？ kill命令如何使用？ ps和grep各自作用是什么？如何使用？ 如何部署自己的项目到linux服务器？ 什么是编辑视图，预览视图？ Java Web","categories":[{"name":"八股文","slug":"八股文","permalink":"https://xiaofanshutu.github.io/categories/%E5%85%AB%E8%82%A1%E6%96%87/"}],"tags":[],"author":"cutiebambi"},{"title":"Java网络编程","slug":"Java网络编程","date":"2023-04-29T01:07:41.747Z","updated":"2024-01-17T23:40:13.558Z","comments":true,"path":"posts/81e7b834.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/81e7b834.html","excerpt":"","text":"网络编程概述 计算机网络：计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。 网络编程的目的：传播交流信息，数据交换 想要实现网络编程需要什么？：IP和端口号 网络编程C/S 最新类的机器人 Java WebB/S 网络通信的要素 如何实现网络通信？ 地址 IP 端口号 规则：网络通信的协议 小结： 网络编程中的两个主要问题 如何准确定位到网络上的一台或者多台主机 找到主机之后如何进行通信 网络编程中的要素： IP和端口号 网络通信协议UDP/TCP 万物皆对象 IP 唯一定位一台网络上的计算机 127.0.0.1： 本机localhost ip地址的分类 IPV4/IPV6 IPV4：127.0.0.1，4个字节组成，每一个字节0~255，全球总共42亿个，30亿在北美，亚洲只有4亿。2011年用尽了。 IPV6：128位，8个无符号整数 公网（互联网）/ 私网（局域网） ABCD类地址 域名 练习：测试InetAddress的常用方法端口端口表示计算机上的一个程序的进程 不同的进程有不同的端口号，用来区分软件 0~65535 TCP/UDP: 65535*2。tcp:80 udp:80 单个协议下，端口号不能冲突 分类 公有端口： 0~1023 HTTP: 80 HTTPS: 443 FTP: 21 Telent: 23 程序注册端口：1024~49151，分配用户或者程序 Tomcat: 8080 MySQL: 3306 Oracle: 1521 动态/私有：49152~65535 小技巧 12345678910#查看所有的端口netstat -ano#查看指定端口netstat -ano|findStr \"7890\"#查看指定端口的进程tasklist|findStr \"3972\"#打开任务管理器的快捷键 Ctrl + Shift + Esc 端口映射 练习：学习InetSocketAddress常用方法通信协议协议就是一种约定 TCP/IP协议簇重要： TCP：用户传输协议 UDP：用户数据报协议 有名的协议： TCP： IP：网络互连协议 TCP/IP参考模型 TCP/UDP对比 TCP：打电话 连接，稳定 三次握手，四次挥手 123456789最少需要三次，保证稳定连接A:你瞅啥？B:瞅你咋地？A:干一场A:我要走了B:你真的要走了吗？B:你真的真的要走了吗？A:我真的要走了 客户端，服务端 传输完成，释放连接，效率低 UDP：发短信 不连接，不稳定 客户端，服务端：没有明确的界限 不管有没有准备好，都可以发给你 导弹 DDOS：洪水攻击（饱和攻击）","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://xiaofanshutu.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"cutiebambi"},{"title":"注解和反射","slug":"注解和反射","date":"2023-04-29T01:07:41.747Z","updated":"2024-01-17T23:38:48.912Z","comments":true,"path":"posts/a974f5b0.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/a974f5b0.html","excerpt":"","text":"注解入门什么是注解？ Annotation是从JDK5.0开始引入的新技术。 Annotation的作用 不是程序本身，可以对程序作出解释（这一点和注释没有什么区别） 可以被其他程序（比如：编译器）读取 Annotation的格式 “@注释名”，还可以有一些参数。例如@SuppressWarnings(value = “all”) Annotation可以在哪些地方使用？1@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE}) 内置注解@Override这个只适用于修饰方法，表示一个方法打算重写超类中的另一个方法 1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override {} @Deprecated这个可以用于修饰构造函数，方法，属性，包等，表示不推荐使用 12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})public @interface Deprecated {} @SuppressWarnings12345@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings { String[] value();} 元注解 元注解的作用就是负责注解其他注解，Java定义了4个标准的meta-annotation。可以在java.lang.annotation包中找到它们。 @Target 用于描述注解的使用范围（即：被描述的注解可以用在什么地方） 123456789101112@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target { /** * Returns an array of the kinds of elements an annotation type * can be applied to. * @return an array of the kinds of elements an annotation type * can be applied to */ ElementType[] value();} @Retention 表示需要在什么级别保存该注释信息，用于描述注解的生命周期 12345678910@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Retention { /** * Returns the retention policy. * @return the retention policy */ RetentionPolicy value();} @Documented 说明该注解将被包含在Javadoc中，Source &lt; Class &lt; Runtime 12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Documented {} @Inherited 说明子类可以继承父类中的该注解 12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Inherited {} 自定义注解使用@interface自定义注解的时候，会自动继承java.lang.Annotation接口 12345678910111213141516171819202122package com.cutiebambi.annotation;public class Test01 { @myAnnotation(value = {\"你好\",\"明天\"}) public static void main(String[] args) { }}//格式：public @interface 注解名 {自定义内容}@interface myAnnotation{ //每一个方法实际上是声明了一个配置参数。 //方法的名称就是参数的名称。 //返回值类型就是参数的类型（返回值只能是基本类型，Class，String， Enum） //如果只有一个参数成员，一般会将参数名命名为value String[] value(); //可以通过default来声明参数的默认值 //常使用空字符串，0作为默认值 int age() default 0; String name() default \"\";} Java反射机制概述动态语言 vs 静态语言动态语言 是一类在运行时可以改变其结构的语言：例如新的函数，对象，甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说：就是在运行时代码可以根据某些条件改变自身结构。 主要的动态语言：Object-C, C#, JavaScript, PHP, Python 静态语言 运行时结构不可以改变的语言。Java， C，C++ Java不是动态语言，但是Java可以称为“准动态语言”。即Java具有一定的动态性，可以利用反射机制获得类似动态语言的特性。 Java Reflection1Class c = Class.forName(\"java.lang.String\") 加载完类之后，在堆内存的方法区就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。 Java反射机制提供的功能 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时获取泛型信息 在运行时调用任意一个对象的成员变量和方法 处理注解 生成动态代理 Java反射的优点和缺点优点 可以动态创建对象和编译，体现出很大的灵活性 缺点 对性能有影响。使用反射基本上是一个解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。 理解Class类并获取Class实例Class类在Object类中定义了以下方法，此方法将被所有子类继承。此方法的返回值的类型是一个Class类，此类是Java反射的源头，实际上所谓反射：从程序的运行结果来看也很好理解，即：可以通过对象反射求出类的名称。 1public final native Class&lt;?&gt; getClass(); Class类是Reflection的根源，针对任何你想动态加载，运行的类，唯有先获取相应的Class对象。 获取Class类的实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.cutiebambi.annotation;public class Test02 { public static void main(String[] args) throws ClassNotFoundException { Person person = new Student(\"嘻嘻\",1); //获取Class类的几种方式 //1.通过对象获取 Class c1 = person.getClass(); System.out.println(c1.hashCode()); //2.通过forName获取 Class&lt;?&gt; c2 = Class.forName(\"com.cutiebambi.annotation.Student\"); System.out.println(c2.hashCode()); //3.通过类名.class获取 Class&lt;Student&gt; c3 = Student.class; System.out.println(c3.hashCode()); //4.基本内置类型的包装类都有一个TYPE属性，可以用来获取对应的Class类 Class&lt;Integer&gt; c4 = Integer.TYPE; //5.获取父类类型 c1.getSuperClass Class c5 = c1.getSuperclass(); System.out.println(c5.hashCode()); }}class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }}class Student extends Person{ public Student(String name, int age) { super(name, age); System.out.println(\"学生\"); }}class Teacher extends Person{ public Teacher(String name, int age) { super(name, age); System.out.println(\"老师\"); }} 哪些类型可以有Class对象 Key Info class 外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类 interface 接口 [] 数组 enum 枚举 annotation 注解@interface primitive type 基本数据类型 void 123456789101112131415161718192021222324252627282930package com.cutiebambi.annotation;import java.util.Map;//所有类型的classpublic class Test03 { public static void main(String[] args) { Class c1 = Object.class; Class c2 = Class.class; Class c3 = ArrayIndexOutOfBoundsException.class; Class c4 = Map.class; Class c5 = int[].class; Class c6 = int[][].class; Class c7 = Enum.class; Class c8 = Override.class; Class c9 = double.class; Class c10 = void.class; System.out.println(\"c1===&gt;\" + c1); System.out.println(\"c2===&gt;\" + c2); System.out.println(\"c3===&gt;\" + c3); System.out.println(\"c4===&gt;\" + c4); System.out.println(\"c5===&gt;\" + c5); System.out.println(\"c6===&gt;\" + c6); System.out.println(\"c7===&gt;\" + c7); System.out.println(\"c8===&gt;\" + c8); System.out.println(\"c9===&gt;\" + c9); System.out.println(\"c10==&gt;\" + c10); }} 12345678910c1===&gt;class java.lang.Objectc2===&gt;class java.lang.Classc3===&gt;class java.lang.ArrayIndexOutOfBoundsExceptionc4===&gt;interface java.util.Mapc5===&gt;class [Ic6===&gt;class [[Ic7===&gt;class java.lang.Enumc8===&gt;interface java.lang.Overridec9===&gt;doublec10==&gt;void 测试类什么时候会初始化主动引用（一定会发生类的初始化） new一个类的对象 使用java.lang.reflect包的方法对类进行反射调用 调用类的静态成员（除了final方法）和静态方法 当虚拟机启动，先初始化main方法所在的类 当初始化一个类，如果其父类没有初始化，则先会初始化它的父类 被动引用（不会发生类的初始化） 当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化 通过数组定义类引用，不会触发此类的初始化 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.cutiebambi.annotation;public class Test04 { static{ //当虚拟机启动，先初始化main方法所在的类 System.out.println(\"Main方法所在的类初始化\"); } public static void main(String[] args) throws ClassNotFoundException { //主动引用1：new一个类的对象 //Cat cat = new Cat(); //主动引用2：使用java.lang.reflect包的方法对类进行反射调用 //Class.forName(\"com.cutiebambi.annotation.Cat\"); //主动引用3：调用类的静态成员（除了final方法）和静态方法 //String boun = Cat.BOUN; //被动引用1：当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化 //String prem = Cat.PREM; //被动引用2：通过数组定义类引用，不会触发此类的初始化 //Cat[] cats = new Cat[10]; //被动引用3：引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了） String finalstr = Cat.FINALSTR; }}class Animal{ public static String PREM = \"prem\"; private String name; private int age; static{ //当初始化一个类，如果其父类没有初始化，则先会初始化它的父类 System.out.println(\"Animal类初始化\"); }}class Cat extends Animal{ public static String BOUN = \"boun\"; public final static String FINALSTR = \"eazin\"; static{ System.out.println(\"Cat类初始化\"); }} 1234567891011121314//主动引用1：new一个类的对象//主动引用2：使用java.lang.reflect包的方法对类进行反射调用//主动引用3：调用类的静态成员（除了final方法）和静态方法Main方法所在的类初始化Animal类初始化Cat类初始化//被动引用1：当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化Main方法所在的类初始化Animal类初始化//被动引用2：通过数组定义类引用，不会触发此类的初始化//被动引用3：引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）Main方法所在的类初始化 类的加载与ClassLoader类加载器的作用类加载的作用：将class文件字节码内容加载到内存，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象。 类加载器分为哪几种类型？ 12345678910111213141516171819202122232425262728293031package com.cutiebambi.annotation;public class Test05 { public static void main(String[] args) throws ClassNotFoundException { //获取系统类的加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); System.out.println(systemClassLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2 //获取系统类的父类加载器-扩展类加载器 ClassLoader parent = systemClassLoader.getParent(); System.out.println(parent);//sun.misc.Launcher$ExtClassLoader@85ede7b //获取扩展类加载器的父类加载器-根加载器 ClassLoader parent1 = parent.getParent(); System.out.println(parent1);//null //测试当前类是由哪个类加载器加载的 Class aClass = Class.forName(\"com.cutiebambi.annotation.Test05\"); ClassLoader classLoader = aClass.getClassLoader(); System.out.println(classLoader); //测试JDK内部类是由哪个类加载器加载的 Class&lt;?&gt; aClass1 = Class.forName(\"java.lang.Object\"); ClassLoader classLoader1 = aClass1.getClassLoader(); System.out.println(classLoader1); //如何获取系统类加载器可以加载的路径信息 String property = System.getProperty(\"java.class.path\"); System.out.println(property); }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869sun.misc.Launcher$AppClassLoader@18b4aac2sun.misc.Launcher$ExtClassLoader@85ede7bnullsun.misc.Launcher$AppClassLoader@18b4aac2nullD:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\charsets.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\deploy.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\ext\\access-bridge-64.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\ext\\cldrdata.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\ext\\dnsns.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\ext\\jaccess.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\ext\\jfxrt.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\ext\\localedata.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\ext\\nashorn.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\ext\\sunec.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\ext\\sunjce_provider.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\ext\\sunmscapi.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\ext\\sunpkcs11.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\ext\\zipfs.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\javaws.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\jce.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\jfr.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\jfxswt.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\jsse.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\management-agent.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\plugin.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\resources.jar;D:\\Tools\\Java\\jdk\\jdk1.8\\jre\\lib\\rt.jar;D:\\xudan\\summergoon\\202209_springboot\\springboot-03-web\\target\\classes;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\boot\\spring-boot-starter-web\\2.7.4\\spring-boot-starter-web-2.7.4.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\boot\\spring-boot-starter\\2.7.4\\spring-boot-starter-2.7.4.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\boot\\spring-boot\\2.7.4\\spring-boot-2.7.4.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\boot\\spring-boot-autoconfigure\\2.7.4\\spring-boot-autoconfigure-2.7.4.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\boot\\spring-boot-starter-logging\\2.7.4\\spring-boot-starter-logging-2.7.4.jar;C:\\Users\\cutiebambi\\.m2\\repository\\ch\\qos\\logback\\logback-classic\\1.2.11\\logback-classic-1.2.11.jar;C:\\Users\\cutiebambi\\.m2\\repository\\ch\\qos\\logback\\logback-core\\1.2.11\\logback-core-1.2.11.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\apache\\logging\\log4j\\log4j-to-slf4j\\2.17.2\\log4j-to-slf4j-2.17.2.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\apache\\logging\\log4j\\log4j-api\\2.17.2\\log4j-api-2.17.2.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\slf4j\\jul-to-slf4j\\1.7.36\\jul-to-slf4j-1.7.36.jar;C:\\Users\\cutiebambi\\.m2\\repository\\jakarta\\annotation\\jakarta.annotation-api\\1.3.5\\jakarta.annotation-api-1.3.5.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\yaml\\snakeyaml\\1.30\\snakeyaml-1.30.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\boot\\spring-boot-starter-json\\2.7.4\\spring-boot-starter-json-2.7.4.jar;C:\\Users\\cutiebambi\\.m2\\repository\\com\\fasterxml\\jackson\\core\\jackson-databind\\2.13.4\\jackson-databind-2.13.4.jar;C:\\Users\\cutiebambi\\.m2\\repository\\com\\fasterxml\\jackson\\core\\jackson-annotations\\2.13.4\\jackson-annotations-2.13.4.jar;C:\\Users\\cutiebambi\\.m2\\repository\\com\\fasterxml\\jackson\\core\\jackson-core\\2.13.4\\jackson-core-2.13.4.jar;C:\\Users\\cutiebambi\\.m2\\repository\\com\\fasterxml\\jackson\\datatype\\jackson-datatype-jdk8\\2.13.4\\jackson-datatype-jdk8-2.13.4.jar;C:\\Users\\cutiebambi\\.m2\\repository\\com\\fasterxml\\jackson\\datatype\\jackson-datatype-jsr310\\2.13.4\\jackson-datatype-jsr310-2.13.4.jar;C:\\Users\\cutiebambi\\.m2\\repository\\com\\fasterxml\\jackson\\module\\jackson-module-parameter-names\\2.13.4\\jackson-module-parameter-names-2.13.4.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\boot\\spring-boot-starter-tomcat\\2.7.4\\spring-boot-starter-tomcat-2.7.4.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\apache\\tomcat\\embed\\tomcat-embed-core\\9.0.65\\tomcat-embed-core-9.0.65.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\apache\\tomcat\\embed\\tomcat-embed-el\\9.0.65\\tomcat-embed-el-9.0.65.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\apache\\tomcat\\embed\\tomcat-embed-websocket\\9.0.65\\tomcat-embed-websocket-9.0.65.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\spring-web\\5.3.23\\spring-web-5.3.23.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\spring-beans\\5.3.23\\spring-beans-5.3.23.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\spring-webmvc\\5.3.23\\spring-webmvc-5.3.23.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\spring-aop\\5.3.23\\spring-aop-5.3.23.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\spring-context\\5.3.23\\spring-context-5.3.23.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\spring-expression\\5.3.23\\spring-expression-5.3.23.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\boot\\spring-boot-starter-thymeleaf\\2.7.4\\spring-boot-starter-thymeleaf-2.7.4.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\thymeleaf\\thymeleaf-spring5\\3.0.15.RELEASE\\thymeleaf-spring5-3.0.15.RELEASE.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\thymeleaf\\thymeleaf\\3.0.15.RELEASE\\thymeleaf-3.0.15.RELEASE.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\attoparser\\attoparser\\2.0.5.RELEASE\\attoparser-2.0.5.RELEASE.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\unbescape\\unbescape\\1.1.6.RELEASE\\unbescape-1.1.6.RELEASE.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\slf4j\\slf4j-api\\1.7.36\\slf4j-api-1.7.36.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\thymeleaf\\extras\\thymeleaf-extras-java8time\\3.0.4.RELEASE\\thymeleaf-extras-java8time-3.0.4.RELEASE.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\projectlombok\\lombok\\1.18.24\\lombok-1.18.24.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\spring-core\\5.3.23\\spring-core-5.3.23.jar;C:\\Users\\cutiebambi\\.m2\\repository\\org\\springframework\\spring-jcl\\5.3.23\\spring-jcl-5.3.23.jar;D:\\Tools\\IntelliJ IDEA 2022.1\\lib\\idea_rt.jar 创建运行时类的对象获取运行时类的完整结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.cutiebambi.annotation;import com.cutiebambi.pojo.Department;import org.springframework.util.StringUtils;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;public class Test06 { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException { //获取类的信息 //获取类的名字 Class c1 = Class.forName(\"com.cutiebambi.pojo.Employee\"); System.out.println(c1.getName());//包名+类名 System.out.println(c1.getSimpleName());//类名 //获取类的属性 Field[] fields = c1.getFields();//获取类的公共属性 for (Field field: fields) { System.out.println(\"c1.getFields()====&gt;\" + field); } fields = c1.getDeclaredFields();//获取类的所有属性 for (Field field: fields) { System.out.println(\"c1.getDeclaredFields()====&gt;\" + field); } //获取指定名字的属性的值 //System.out.println(c1.getField(\"lastName\"));//获取public属性 System.out.println(c1.getDeclaredField(\"lastName\"));//获取指定的公共属性 //获取类的方法 Method[] methods = c1.getMethods();//获取本类和父类的public方法 for (Method method: methods) { System.out.println(\"c1.getMethods()====&gt;\" + method); } methods = c1.getDeclaredMethods();//获取本类的所有方法 for (Method method: methods) { System.out.println(\"c1.getDeclaredMethods()====&gt;\" + method); } //获取指定方法 System.out.println(c1.getMethod(\"getLastName\")); //获取构造器 Constructor[] constructors = c1.getConstructors(); for (Constructor constructor: constructors) { System.out.println(\"c1.getConstructors()====&gt;\" + constructor); } constructors = c1.getDeclaredConstructors(); for (Constructor constructor: constructors) { System.out.println(\"c1.getDeclaredConstructors()====&gt;\" + constructor); } //获取指定构造器 System.out.println(c1.getConstructor(Integer.class,String.class, String.class, Integer.class, Department.class)); }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748com.cutiebambi.pojo.EmployeeEmployeec1.getDeclaredFields()====&gt;private java.lang.Integer com.cutiebambi.pojo.Employee.idc1.getDeclaredFields()====&gt;private java.lang.String com.cutiebambi.pojo.Employee.lastNamec1.getDeclaredFields()====&gt;private java.lang.String com.cutiebambi.pojo.Employee.emailc1.getDeclaredFields()====&gt;private java.lang.Integer com.cutiebambi.pojo.Employee.genderc1.getDeclaredFields()====&gt;private com.cutiebambi.pojo.Department com.cutiebambi.pojo.Employee.departmentc1.getDeclaredFields()====&gt;private java.util.Date com.cutiebambi.pojo.Employee.birthprivate java.lang.String com.cutiebambi.pojo.Employee.lastNamec1.getMethods()====&gt;public java.lang.Integer com.cutiebambi.pojo.Employee.getId()c1.getMethods()====&gt;public void com.cutiebambi.pojo.Employee.setId(java.lang.Integer)c1.getMethods()====&gt;public void com.cutiebambi.pojo.Employee.setLastName(java.lang.String)c1.getMethods()====&gt;public java.lang.String com.cutiebambi.pojo.Employee.getLastName()c1.getMethods()====&gt;public java.lang.String com.cutiebambi.pojo.Employee.getEmail()c1.getMethods()====&gt;public void com.cutiebambi.pojo.Employee.setGender(java.lang.Integer)c1.getMethods()====&gt;public void com.cutiebambi.pojo.Employee.setDepartment(com.cutiebambi.pojo.Department)c1.getMethods()====&gt;public java.lang.Integer com.cutiebambi.pojo.Employee.getGender()c1.getMethods()====&gt;public void com.cutiebambi.pojo.Employee.setBirth(java.util.Date)c1.getMethods()====&gt;public void com.cutiebambi.pojo.Employee.setEmail(java.lang.String)c1.getMethods()====&gt;public java.util.Date com.cutiebambi.pojo.Employee.getBirth()c1.getMethods()====&gt;public com.cutiebambi.pojo.Department com.cutiebambi.pojo.Employee.getDepartment()c1.getMethods()====&gt;public final void java.lang.Object.wait() throws java.lang.InterruptedExceptionc1.getMethods()====&gt;public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedExceptionc1.getMethods()====&gt;public final native void java.lang.Object.wait(long) throws java.lang.InterruptedExceptionc1.getMethods()====&gt;public boolean java.lang.Object.equals(java.lang.Object)c1.getMethods()====&gt;public java.lang.String java.lang.Object.toString()c1.getMethods()====&gt;public native int java.lang.Object.hashCode()c1.getMethods()====&gt;public final native java.lang.Class java.lang.Object.getClass()c1.getMethods()====&gt;public final native void java.lang.Object.notify()c1.getMethods()====&gt;public final native void java.lang.Object.notifyAll()c1.getDeclaredMethods()====&gt;public java.lang.Integer com.cutiebambi.pojo.Employee.getId()c1.getDeclaredMethods()====&gt;public void com.cutiebambi.pojo.Employee.setId(java.lang.Integer)c1.getDeclaredMethods()====&gt;public void com.cutiebambi.pojo.Employee.setLastName(java.lang.String)c1.getDeclaredMethods()====&gt;public java.lang.String com.cutiebambi.pojo.Employee.getLastName()c1.getDeclaredMethods()====&gt;public java.lang.String com.cutiebambi.pojo.Employee.getEmail()c1.getDeclaredMethods()====&gt;public void com.cutiebambi.pojo.Employee.setGender(java.lang.Integer)c1.getDeclaredMethods()====&gt;public void com.cutiebambi.pojo.Employee.setDepartment(com.cutiebambi.pojo.Department)c1.getDeclaredMethods()====&gt;public java.lang.Integer com.cutiebambi.pojo.Employee.getGender()c1.getDeclaredMethods()====&gt;public void com.cutiebambi.pojo.Employee.setBirth(java.util.Date)c1.getDeclaredMethods()====&gt;public void com.cutiebambi.pojo.Employee.setEmail(java.lang.String)c1.getDeclaredMethods()====&gt;public java.util.Date com.cutiebambi.pojo.Employee.getBirth()c1.getDeclaredMethods()====&gt;public com.cutiebambi.pojo.Department com.cutiebambi.pojo.Employee.getDepartment()public java.lang.String com.cutiebambi.pojo.Employee.getLastName()c1.getConstructors()====&gt;public com.cutiebambi.pojo.Employee()c1.getConstructors()====&gt;public com.cutiebambi.pojo.Employee(java.lang.Integer,java.lang.String,java.lang.String,java.lang.Integer,com.cutiebambi.pojo.Department)c1.getDeclaredConstructors()====&gt;public com.cutiebambi.pojo.Employee()c1.getDeclaredConstructors()====&gt;public com.cutiebambi.pojo.Employee(java.lang.Integer,java.lang.String,java.lang.String,java.lang.Integer,com.cutiebambi.pojo.Department)public com.cutiebambi.pojo.Employee(java.lang.Integer,java.lang.String,java.lang.String,java.lang.Integer,com.cutiebambi.pojo.Department) 调用运行时类的指定结构动态创建对象执行方法12345678910111213141516171819202122232425262728293031323334353637package com.cutiebambi.reflection;import com.cutiebambi.pojo.Department;import com.cutiebambi.pojo.Employee;import com.cutiebambi.pojo.User;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class Test07 { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException { //通过反射获取Class对象，然后再生成一个对象 Class c1 = Class.forName(\"com.cutiebambi.pojo.User\"); Object o = c1.newInstance(); System.out.println(o.toString()); //通过构造器创建对象 Constructor declaredConstructor = c1.getDeclaredConstructor(int.class, int.class, String.class); Object o1 = declaredConstructor.newInstance(1001, 18, \"bambi\"); System.out.println(o1.toString()); //通过反射调用普通方法 User user = (User)c1.newInstance(); Method setName = c1.getDeclaredMethod(\"setName\", String.class); setName.invoke(user, \"boun\");//invoke(对象, 传入的参数值) 激活某个对象的方法，并且传入对应的参数值 System.out.println(user.getName()); //通过反射操作普通属性 Field name = c1.getDeclaredField(\"name\"); //关闭安全检测 name.setAccessible(true); name.set(user, \"prem\"); System.out.println(user.getName()); }} 1234User{id=0, age=0, name='null'}User{id=1001, age=18, name='bambi'}bounprem 性能问题分析1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.cutiebambi.reflection;import com.cutiebambi.pojo.User;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.sql.Timestamp;public class Test08 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException { //性能问题分析 Class c1 = Class.forName(\"com.cutiebambi.pojo.User\"); //普通方式调用方法 User user = new User(); long start = System.currentTimeMillis(); for (int i = 0; i &lt; 1000000000; i++) { user.getName(); } long end = System.currentTimeMillis(); System.out.println(\"普通方式调用方法： \" + (end-start) + \"ms\"); //反射方式调用方法 user = (User)c1.newInstance(); Method getName = c1.getDeclaredMethod(\"getName\"); start = System.currentTimeMillis(); for (int i = 0; i &lt; 1000000000; i++) { getName.invoke(user, null); } end = System.currentTimeMillis(); System.out.println(\"反射方式调用方法： \" + (end-start) + \"ms\"); //关闭检测后的反射方式调用方法 user = (User)c1.newInstance(); getName = c1.getDeclaredMethod(\"getName\"); getName.setAccessible(true); start = System.currentTimeMillis(); for (int i = 0; i &lt; 1000000000; i++) { getName.invoke(user, null); } end = System.currentTimeMillis(); System.out.println(\"关闭检测后的反射方式调用方法： \" + (end-start) + \"ms\"); }} 123普通方式调用方法： 3ms反射方式调用方法： 1605ms关闭检测后的反射方式调用方法： 1575ms 获取泛型信息1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.cutiebambi.reflection;import com.cutiebambi.pojo.User;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.List;import java.util.Map;public class Test09 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException { Class c1 = Class.forName(\"com.cutiebambi.reflection.Test09\"); Type[] types = c1.getDeclaredMethod(\"method1\", Map.class, List.class).getGenericParameterTypes(); for (Type type : types) { if(type instanceof ParameterizedType){ Type[] actualTypeArguments = ((ParameterizedType) type).getActualTypeArguments(); for (Type actualTypeArgument : actualTypeArguments) { System.out.println(actualTypeArgument); } } } System.out.println(\"========================\"); Type returnType = c1.getDeclaredMethod(\"method2\").getGenericReturnType(); if(returnType instanceof ParameterizedType){ Type[] actualTypeArguments = ((ParameterizedType) returnType).getActualTypeArguments(); for (Type actualTypeArgument : actualTypeArguments) { System.out.println(actualTypeArgument); } } } //泛型作为参数类型 public static void method1(Map&lt;String, Object&gt; map, List&lt;User&gt; user){ } //泛型作为返回值类型 public static Map&lt;String, Object&gt; method2(){ return null; }} 123456class java.lang.Stringclass java.lang.Objectclass com.cutiebambi.pojo.User========================class java.lang.Stringclass java.lang.Object 获取注解信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.cutiebambi.reflection;import java.lang.annotation.*;import java.lang.reflect.Field;public class Test10 { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException { //获取注解信息 Class c1 = Class.forName(\"com.cutiebambi.reflection.User\"); Annotation[] annotations = c1.getAnnotations(); for (Annotation annotation : annotations) { System.out.println(annotation);//@com.cutiebambi.reflection.TableBambi(value=db_user) TableBambi tableAnno = (TableBambi)c1.getAnnotation(TableBambi.class); System.out.println(tableAnno.value());//db_user } //获取类指定的注解 Field name = c1.getDeclaredField(\"age\"); FieldBambi fieldBambi = name.getAnnotation(FieldBambi.class); System.out.println(fieldBambi.columnName()); System.out.println(fieldBambi.type()); System.out.println(fieldBambi.length()); }}@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface TableBambi { String value();}@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@interface FieldBambi { String columnName(); String type(); int length();}@TableBambi(\"db_user\")class User { @FieldBambi(columnName = \"db_id\", type = \"int\", length = 5) private int id; @FieldBambi(columnName = \"db_age\", type = \"int\", length = 3) private int age; @FieldBambi(columnName = \"db_name\", type = \"varchar\", length = 4) private String name; public User() { } public User(int id, int age, String name) { this.id = id; this.age = age; this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"User{\" + \"id=\" + id + \", age=\" + age + \", name='\" + name + '\\'' + '}'; }} 12345@com.cutiebambi.reflection.TableBambi(value=db_user)db_userdb_ageint3","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://xiaofanshutu.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"cutiebambi"},{"title":"Spring Boot","slug":"Spring Boot","date":"2023-04-29T01:07:41.747Z","updated":"2024-01-17T23:40:27.670Z","comments":true,"path":"posts/a541262a.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/a541262a.html","excerpt":"","text":"Spring Boot简介回顾什么是SpringSpring是一个开源框架，解决企业级应用开发的复杂性而创建的，简化开发。 Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。 Spring是如何简化Java开发的为了降低Java开发的复杂性，Spring采用了以下4种关键策略： 1、基于POJO的轻量级和最小侵入性编程，所有东西都是bean； 2、通过IOC，依赖注入（DI）和面向接口实现松耦合； 3、基于切面（AOP）和惯例进行声明式编程； 4、通过切面和模版减少样式代码，RedisTemplate，xxxTemplate； 什么是Spring Boot学过Java Web的同学就知道，开发一个web应用，从最初开始接触Servlet结合Tomcat, 跑出一个Hello Wolrld程序，是要经历特别多的步骤；后来就用了框架Struts，再后来是Spring MVC，到了现在的Spring Boot，过一两年又会有其他web框架出现；你们有经历过框架不断的演进，然后自己开发项目所有的技术也在不断的变化、改造吗？建议都可以去经历一遍； 言归正传，什么是Spring Boot呢，就是一个javaweb的开发框架，和Spring MVC类似，对比其他Java Web框架的好处，官方说是简化开发，约定大于配置（越是简化的东西，越是需要严格的规定）， you can “just run”，能迅速的开发web应用，几行代码开发一个http接口。 所有的技术框架的发展似乎都遵循了一条主线规律：从一个复杂应用场景 衍生 一种规范框架，人们只需要进行各种配置而不需要自己去实现它，这时候强大的配置功能成了优点；发展到一定程度之后，人们根据实际生产应用情况，选取其中实用功能和设计精华，重构出一些轻量级的框架；之后为了提高开发效率，嫌弃原先的各类配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案。 是的，这就是Java企业级应用-&gt;J2EE-&gt;Spring-&gt;Spring Boot的过程。 随着Spring不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用Spring 、更容易的集成各种常用的中间件、开源软件； Spring Boot 基于Spring开发，Spirng Boot 本身并不提供Spring框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于Spring框架的应用程序。也就是说，它并不是用来替代Spring的解决方案，而是和Spring框架紧密结合用于提升Spring开发者体验的工具。Spring Boot 以约定大于配置的核心思想，默认帮我们进行了很多设置，多数Spring Boot应用只需要很少的Spring配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、JPA、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。 简单来说就是Spring Boot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，Spring Boot整合了所有的框架 。 Spring Boot 出生名门，从一开始就站在一个比较高的起点，又经过这几年的发展，生态足够完善，Spring Boot已经当之无愧成为Java领域最热门的技术。 Spring Boot的主要优点： 为所有Spring开发者更快的入门 开箱即用，提供各种默认配置来简化项目配置 内嵌式容器简化Web项目 没有冗余代码生成和XML配置的要求 微服务什么是微服务 微服务是一种架构风格，它要求我们在开发一个应用的时候，这个应用必须构建成一系列小服务的组合;可以通过http的方式进行互通。要说微服务架构，先得说说过去我们的单体应用架构。 单体应用架构 所谓单体应用架构(all in one)是指，我们将一个应用的中的所有应用服务都封装在一个应用中。 无论是ERP、CRM或是其他什么系统，你都把数据库访问，web访问, 等等各个功能放到一个war包内。（目前我们写的项目就是如此，将一个系统整体打包成war包） 这样做的好处是，易于开发和测试；也十分方便部署；当需要扩展时，只需要将war复制多份，然后放到多个服务器上，再做个负载均衡就可以了。 单体应用架构的缺点是，哪怕我要修改一个非常小的地方，我都需要停掉整个服务，重新打包、部署这个应用war包。特别是对于一个大型应用，我们不可能把所有内容都放在一个应用里面，我们如何维护、如何分工合作都是问题。 微服务架构 all in one的架构方式，我们把所有的功能单元放在一个应用里面。然后我们把整个应用部署到服务器上。如果负载能力不行，我们将整个应用进行水平复制，进行扩展，然后在负载均衡。 所谓微服务架构，就是打破之前all in one的架构方式，把每个功能元素独立出来。把独立出来的功能元素的动态组合，需要的功能元素才去拿来组合，需要多一些时，可以整合多个功能元素。所以微服务架构是对功能元素进行复制，而没有对整个应用进行复制。 这样做的好处是: 节省了调用资源。 每个功能元素的服务都是一个可替换的、可独立升级的软件代码。 Martin Flower于2014年3月25日写的《Microservices》 ，详细的阐述了什么是微服务。 原文地址: http://martinfowler.com/articles/microservices.html 翻译: https://www.cnblogs.com/liuning8023/p/4493156.html 如何构建微服务 一个大型系统的微服务架构，就像一个复杂交织的神经网络，每-个神经元就是一个功能元素， 它们各自完成自己的功能，然后通过http相互请求调用。比如一个电商系统，查缓存、连数据库、浏览页面、结账、支付等服务都是一个个独立的功能服务,都被微化了，它们作为一个个微服务共同构建了一个庞大的系统。如果修改其中的一个功能，只需要更新升级其中一个功能服务单元即可。 但是这种庞大的系统架构给部署和运维带来很大的难度。于是，spring为我们带来了构建大型分布式微服务的全套、全程产品: 构建一个个功能独立的微服务应用单元，可以使用springboot, 可以帮我们快速构建一个应用； 大型分布式网络服务的调用，这部分由spring cloud来完成，实现分布式； 在分布式中间,进行流式数据计算、批处理，我们有spring cloud data flow。 spring为我们想清楚了整个从开始构建应用到大型分布式应用全流程方案。 第一个SpringBoot程序准备工作我们将学习如何快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。 我的环境准备： java version 1.8 Maven-3.6.1 SpringBoot 2.x 最新版 开发工具： IDEA 创建基础项目说明Spring官方提供了非常方便的工具让我们快速构建应用（提供了一个快速生成的网站） Spring Initializer：https://start.spring.io/ 项目创建方式一： 使用Spring Initializer 的 Web页面创建项目 1、打开 https://start.spring.io/ 2、填写项目信息 3、点击”Generate Project“按钮生成项目；下载此项目 4、解压项目包，并用IDEA以Maven项目导入，一路下一步即可，直到项目导入完毕。 5、如果是第一次使用，可能速度会比较慢，包比较多、需要耐心等待一切就绪。 项目创建方式二： 使用 IDEA 直接创建项目（idea继承了上面说的那个网站） 1、创建一个新项目 2、选择spring initalizr ， 可以看到默认就是去官网的快速构建工具那里实现 3、填写项目信息 4、选择初始化的组件（初学勾选 Web 即可） 5、填写项目路径 6、等待项目构建成功 项目结构分析： 通过上面步骤完成了基础项目的创建。就会自动生成以下文件。 1、程序的主启动类 2、一个 application.properties 配置文件 3、一个 测试类 4、一个 pom.xml pom.xml 分析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 有一个父项目 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.4&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;!-- gav坐标 --&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;hellospringboot&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;hellospringboot&lt;/name&gt; &lt;description&gt;hellospringboot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- web依赖：集成tomcat, dispatcherServlet, xml...... --&gt; &lt;!-- spring boot所有的依赖都是以spring-boot-starter为前缀的 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;!-- 打jar包插件 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 如上所示，pom文件主要有四个部分: 项目元数据信息：创建时候输入的Project Metadata部分，也就是Maven项目的基本元素，包括: groupld、 artifactld、 version、 name、 description等 parent：继承spring- boot -starter-parent的依赖管理，控制版本与打包等内容 dependencies： 项目具体依赖，这里包含了spring-boot-starter -web用于实现HTTP接口(该依赖中包含了Spring MVC)，官网对它的描述是:使用Spring MVC构建Web (包括RESTful)应用程序的入门者，使用Tomcat作为默认嵌入式容器。spring-boot-starter-test用于编写单元测试的依赖包。更多功能模块的使用我们将在后面逐步展开。 build: 构建配置部分。默认使用了spring-boot-maven-plugin,配合spring-boot-starter-parent就可以把Spring Boot应用打包成JAR来直接运行。 编写一个http接口 在主程序的同级目录下，新建一个controller包，一定要在同级目录下，否则识别不到。 在包中新建一个HelloController类。 123456789101112package com.cutiebambi;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController { @RequestMapping(\"/hello\") public String hello(){ return \"hello bambi\"; }} 编写完毕后，从主程序启动项目，浏览器发起请求，看页面返回； 点击 maven的 package, 将项目打成jar包 如果打包成功，则会在target目录下生成一个 jar 包 打成了jar包后，就可以在任何地方运行了。 小技巧 更改tomcat端口号 ( resources 目录下的application.properties 文件) 12#更改项目端口号server.port=8089 更改启动时显示的字符拼成的字母：到项目下的 resources 目录下新建一个banner.txt 即可，将图案放在这个文件即可。 SpringBoo原理初探【重点】pom.xml文件父依赖1234567&lt;!-- 有一个父项目 --&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.4&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; 点进spring-boot-starter-parent，它还有一个parent spring-boot-dependencies这个是核心依赖 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.7.4&lt;/version&gt;&lt;/parent&gt; 以后我们导入依赖默认是不需要写版本（因为有这些版本仓库）；但是如果导入的包没有在依赖中管理着就需要手动配置版本了； 启动器 spring-boot-starter1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; springboot-boot-starter-xxx：就是spring-boot的场景启动器 spring-boot-starter-web：帮我们导入了web模块正常运行所依赖的组件； SpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），如果我们想要使用什么样的功能，只需要在项目中引入相关的（启动器）starter即可，所有相关的依赖都会导入进来 ， 我们未来也可以自己自定义 starter； 主启动类 （看注解）12345678910111213package com.cutiebambi;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;//自动装配：启动类本身就是Spring的一个组件。//SpringBootApplication标注这个类是一个spring boot的应用。启动类下的所有的资源被导入：EnableAutoConfiguration@SpringBootApplicationpublic class HellospringbootApplication { public static void main(String[] args) { SpringApplication.run(HellospringbootApplication.class, args); }} @SpringBootApplication: 说明这个类是Spring Boot的主配置类。 @SpringBootConfiguration: Spring Boot的配置类​ @Configuration: 配置类，对应的是Spring 的xml文件。 ​ @Component @EnableAutoConfiguration: 开启自动配置功能​ @AutoConfigurationPackage: 自动配置包 ​ @Import(AutoConfigurationPackages.Registrar.class): 自动配置包注册 ​ @Import：Spring底层注解，给容器中导入一个组件。 ​ Registrar.class: 将主启动类所在包及包下面所有子包里面的所有组件扫描到Spring容器。 ​ @Import(AutoConfigurationImportSelector.class): 给容器中导入组件 ​ AutoConfigurationImportSelector: 自动配置导入选择器 123456protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { List&lt;String&gt; configurations = new ArrayList(SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader())); ImportCandidates.load(AutoConfiguration.class, this.getBeanClassLoader()).forEach(configurations::add); Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories nor in META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. If you are using a custom packaging, make sure that file is correct.\"); return configurations;} 上面的方法会调用下面这个方法 123456789public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader) { ClassLoader classLoaderToUse = classLoader; if (classLoader ** null) { classLoaderToUse = SpringFactoriesLoader.class.getClassLoader(); } String factoryTypeName = factoryType.getName(); return (List)loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());} 接着这个方法又会调用下面这个方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(ClassLoader classLoader) { Map&lt;String, List&lt;String&gt;&gt; result = (Map)cache.get(classLoader); if (result != null) { return result; } else { Map&lt;String, List&lt;String&gt;&gt; result = new HashMap(); try { //spring.factories这个是自动配置的核心文件 //自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。小结：SpringBoot所有自动配置都是在启动的时候扫描并加载：spring.factories配置文件 ，所有的自动配置类都在这里面，但是不一定生效，要判断条件是否成立，而所谓的条件就是只要导入了对应的strater，就有对应的启动器了，有了启动器，条件成立，自动配置就生效，然后就配置成功！ Enumeration&lt;URL&gt; urls = classLoader.getResources(\"META-INF/spring.factories\"); while(urls.hasMoreElements()) { URL url = (URL)urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); Iterator var6 = properties.entrySet().iterator(); while(var6.hasNext()) { Map.Entry&lt;?, ?&gt; entry = (Map.Entry)var6.next(); String factoryTypeName = ((String)entry.getKey()).trim(); String[] factoryImplementationNames = StringUtils.commaDelimitedListToStringArray((String)entry.getValue()); String[] var10 = factoryImplementationNames; int var11 = factoryImplementationNames.length; for(int var12 = 0; var12 &lt; var11; ++var12) { String factoryImplementationName = var10[var12]; ((List)result.computeIfAbsent(factoryTypeName, (key) -&gt; { return new ArrayList(); })).add(factoryImplementationName.trim()); } } } result.replaceAll((factoryType, implementations) -&gt; { return (List)implementations.stream().distinct().collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)); }); cache.put(classLoader, result); return result; } catch (IOException var14) { throw new IllegalArgumentException(\"Unable to load factories from location [META-INF/spring.factories]\", var14); } }} 总结SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值将这些值作为自动配置类导入容器 ， 自动配置类就生效 ，以前我们需要自己配置的东西，现在SpringBoot 帮我们进行自动配置工作；整个J2EE的整体解决方案和自动配置都在spring-boot-autoconfigure的jar包中，他会把所有需要导入的组件，以类名（全限定名）的方式返回，这些类名对应的组件就会被添加到容器里；容器中有很多的xxxAutoConfiguration的文件（@Bean）, 就是这些类给容器中导入这个场景需要的所有组件 ， 并自动配置，@Configuration ；有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作； yaml语法学习Spring Boot的全局配置文件SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的。 可以是application.properties 语法结构：key=value 也可以是application.yaml（官方推荐使用这个） 语法结构: key: value（key和value之间的空格必须存在） 配置文件的作用：修改Spring Boot自动配置的默认值。 yaml概述YAML是 “YAML Ain’t a Markup Language” 这种语言以数据作为中心，而不是以标记语言为重点！ 以前的配置文件，大多数都是使用xml来配置；比如一个简单的端口配置，我们来对比下yaml和xml 传统xml配置： 123&lt;server&gt; &lt;port&gt;8081&lt;port&gt;&lt;/server&gt; yaml配置： 12server: prot: 8080 yaml基础语法 说明：语法要求严格！ 空格不能省略 以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。 属性和值的大小写都是十分敏感的。 字面量：普通的值 [ 数字，布尔值，字符串 ] 字面量直接写在后面就可以 ， 字符串默认不用加上双引号或者单引号； 12#yaml格式（注意空格）k: v 注意： “ ” 双引号，不会转义字符串里面的特殊字符 ， 特殊字符会作为本身想表示的意思；比如 ：name: “kuang \\n shen” 输出 ：kuang 换行 shen’ ’ 单引号，会转义特殊字符 ， 特殊字符最终会变成和普通字符一样输出比如 ：name: ‘kuang \\n shen’ 输出 ：kuang \\n shen 对象、Map（键值对)1234#对象、Map格式k: v1: v2: 在下一行来写对象的属性和值得关系，注意缩进；比如： 123student: name: qinjiang age: 3 行内写法 1student: {name: qinjiang,age: 3} 数组（ List、set ） 用 - 值表示数组中的一个元素,比如： 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 总结123456789101112131415161718192021#yaml文件可以存储的东西，重点对于空格的要求很严格# 普通的键值对name: mengyuanshishabi# 对象student: name: mengyuan age: 3#行内表示user: {name: mengyuan,age: 3}# 数组pets: - cat - pig - dog# 行内表示pet: [cat,dog,pig]# 而properties只能存键值对 key=value# yaml格式文件的另一个强大之处，在于可以注入到我们的配置类中，下面会说。 注入配置文件yaml注入配置文件 在springboot项目中的resources目录下新建一个文件 application.yaml 编写一个实体类 Dog； 12345678910111213141516171819202122232425262728293031323334package com.cutiebambi;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Component //添加到spring 的组件里，注解生成&lt;bean&gt; ,在之前的开发中，也用注解来注入属性值public class Dog { private String name; private Integer age; public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public String toString() { return \"Dog{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; }} 思考，我们原来是如何给bean注入属性值的！@Value，给狗狗类测试一下： 123456public class Dog { @Value(\"旺财\") private String name; @Value(\"3\") private Integer age;} 在SpringBoot的测试类下注入狗狗输出一下； 我们在编写一个复杂一点的实体类：Person 类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.cutiebambi;import org.springframework.stereotype.Component;import java.util.Date;import java.util.List;import java.util.Map;@Componentpublic class Person { private String name; private Integer age; private Boolean happy; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public Boolean getHappy() { return happy; } public void setHappy(Boolean happy) { this.happy = happy; } public Date getBirth() { return birth; } public void setBirth(Date birth) { this.birth = birth; } public Map&lt;String, Object&gt; getMaps() { return maps; } public void setMaps(Map&lt;String, Object&gt; maps) { this.maps = maps; } public List&lt;Object&gt; getLists() { return lists; } public void setLists(List&lt;Object&gt; lists) { this.lists = lists; } public Dog getDog() { return dog; } public void setDog(Dog dog) { this.dog = dog; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + \", happy=\" + happy + \", birth=\" + birth + \", maps=\" + maps + \", lists=\" + lists + \", dog=\" + dog + '}'; }} 我们来使用yaml配置的方式进行注入，大家写的时候注意区别和优势，我们编写一个yaml配置！ 12345678910111213person: name: bambi age: 9 happy: false birth: 2022/02/12 maps: {key1: value1, key2: value2} lists: - music - climbing - swimming dog: name: 旺财 age: 3 我们刚才已经把person这个对象的所有值都写好了，我们现在来注入到我们的类中！ 1234567891011121314151617/*@ConfigurationProperties作用：将配置文件中配置的每一个属性的值，映射到这个组件中；告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定参数 prefix = “person” : 将配置文件中的person下面的所有属性和组件一一对应*/@Component //注册bean@ConfigurationProperties(prefix = \"person\")public class Person { private String name; private Integer age; private Boolean happy; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;} IDEA 提示，springboot配置注解处理器没有找到，让我们看文档，我们可以查看文档，找到一个依赖！ 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 确认以上配置都OK之后，我们去测试类中测试一下： 结果：所有值全部注入成功！ 加载指定的配置文件@PropertySource ： 加载指定的配置文件； @configurationProperties：默认从全局配置文件中获取值； 1、我们去在resources目录下新建一个person.properties文件 1name=bambi 2、然后在我们的代码中指定加载teacher.properties文件properties 123456789101112131415161718192021222324252627package com.cutiebambi;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;@Component@PropertySource(value = \"classpath:teacher.properties\")public class Teacher { @Value(\"${name}\") private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"Teacher{\" + \"name='\" + name + '\\'' + '}'; }} 3、再次输出测试一下：指定配置文件绑定成功！ 配置文件占位符12345678910111213person: name: bambi${random.uuid} # 随机uuid age: ${random.int} # 随机int happy: false birth: 2022/02/12 maps: {key1: value1, key2: value2} lists: - music - climbing - swimming dog: name: 旺财 age: 3 对比小结配置yaml和配置properties都可以获取到值 ， 强烈推荐 yaml； 如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下 @value； 如果说，我们专门编写了一个JavaBean来和配置文件进行一一映射，就直接@configurationProperties，不要犹豫！ JSR303校验12345678910111213/*@ConfigurationProperties作用：将配置文件中配置的每一个属性的值，映射到这个组件中；告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定参数 prefix = “person” : 将配置文件中的person下面的所有属性一一对应*/@Component //注册bean@ConfigurationProperties(prefix = \"person\")@Validated //数据校验public class Person { @NotNull private String name;} 多环境切换 profile是Spring对不同环境提供不同配置功能的支持，可以通过激活不同的环境版本，实现快速切换环境； 多配置文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yaml , 用来指定多个环境版本； 例如： application-test.properties 代表测试环境配置 application-dev.properties 代表开发环境配置 但是Springboot并不会直接启动这些配置文件，它默认使用application.properties主配置文件； 123#比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试；#我们启动SpringBoot，就可以看到已经切换到dev下的配置了；spring.profiles.active=dev yaml的多文档块和properties配置文件中一样，但是使用yaml去实现不需要创建多个配置文件，更加方便了 ! 1234567891011121314151617server: port: 8081#选择要激活那个环境块spring: profiles: active: prod---server: port: 8083spring: profiles: dev #配置环境的名称---server: port: 8084spring: profiles: prod #配置环境的名称 注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用properties配置文件的！ 配置文件加载位置官方文档说明： https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.external-config.files Spring Boot will automatically find and load application.properties and application.yaml files from the following locations when your application starts: From the classpath（类路径就是src/main/resource或者src/main/java，一般会把配置文件放在resource下。） The classpath root 优先级最低 The classpath /config package From the current directory The current directory The config/ subdirectory in the current directory Immediate child directories of the config/ subdirectory 优先级最高 拓展，运维小技巧指定位置加载配置文件 我们还可以通过spring.config.location来改变默认的配置文件位置 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；这种情况，一般是后期运维做的多，相同配置，外部指定的配置文件优先级最高 1java -jar spring-boot-config.jar --spring.config.location=F:/application.properties 自动配置原理【重点】 配置文件到底能写什么？怎么写？这个和spring.factories有什么关联？ SpringBoot官方文档中有大量的配置，我们无法全部记住 分析自动配置原理从spring.factories中选择一个类进入，我们以HttpEncodingAutoConfiguration（Http编码自动配置） 为例解释自动配置原理； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.cutiebambi;import org.springframework.boot.autoconfigure.AutoConfiguration;import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication.Type;import org.springframework.boot.autoconfigure.web.ServerProperties;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.boot.web.server.WebServerFactoryCustomizer;import org.springframework.boot.web.servlet.filter.OrderedCharacterEncodingFilter;import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;import org.springframework.boot.web.servlet.server.Encoding;import org.springframework.context.annotation.Bean;import org.springframework.core.Ordered;import org.springframework.web.filter.CharacterEncodingFilter;//表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件；@AutoConfiguration//进入这个ServerProperties查看，将配置文件中对应的值和ServerProperties绑定起来；//并把ServerProperties加入到IOC容器中//自动配置属性: 装配好之后，ServerProperties里面的属性就是我们要在配置文件中写的key了。@EnableConfigurationProperties({ServerProperties.class})//Spring的底层注解：根据不同条件，来判断当前配置或者类是否生效。如果满足指定的条件，整个配置类里面的配置就会生效；//这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnWebApplication( type = Type.SERVLET)//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnClass({CharacterEncodingFilter.class})//判断配置文件中是否存在某个配置：server.servlet.encoding.enabled；//如果不存在，判断也是成立的//即使我们配置文件中不配置server.servlet.encoding.enabled=true，也是默认生效的；@ConditionalOnProperty( prefix = \"server.servlet.encoding\", value = {\"enabled\"}, matchIfMissing = true)public class HttpEncodingAutoConfiguration { //他已经和SpringBoot的配置文件映射了 private final Encoding properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(ServerProperties properties) { this.properties = properties.getServlet().getEncoding(); } //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @Bean @ConditionalOnMissingBean //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() { CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.RESPONSE)); return filter; } @Bean public org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration.LocaleCharsetMappingsCustomizer localeCharsetMappingsCustomizer() { return new org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration.LocaleCharsetMappingsCustomizer(this.properties); } static class LocaleCharsetMappingsCustomizer implements WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt;, Ordered { private final Encoding properties; LocaleCharsetMappingsCustomizer(Encoding properties) { this.properties = properties; } public void customize(ConfigurableServletWebServerFactory factory) { if (this.properties.getMapping() != null) { factory.setLocaleCharsetMappings(this.properties.getMapping()); } } public int getOrder() { return 0; } }} 一句话总结 ：根据当前不同的条件判断，决定这个配置类是否生效！ 一但这个配置类生效；这个配置类就会给容器中添加各种组件； 这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件（application.yaml）绑定的； 所有在配置文件中能配置的属性都是在xxxxProperties类中封装着； 配置文件能配置什么就可以参照某个功能对应的这个属性类 1234567891011121314151617181920212223242526@ConfigurationProperties( prefix = \"server\", ignoreUnknownFields = true)public class ServerProperties { private Integer port; private InetAddress address; @NestedConfigurationProperty private final ErrorProperties error = new ErrorProperties(); private ForwardHeadersStrategy forwardHeadersStrategy; private String serverHeader; private DataSize maxHttpHeaderSize = DataSize.ofKilobytes(8L); private Shutdown shutdown; @NestedConfigurationProperty private Ssl ssl; @NestedConfigurationProperty private final Compression compression; @NestedConfigurationProperty private final Http2 http2; private final Servlet servlet; private final Reactive reactive; private final Tomcat tomcat; private final Jetty jetty; private final Netty netty; private final Undertow undertow;} 1234567891011121314#在配置文件中能够配置的东西，都存在一个固有的规律# ***AutoConfiguration: 它们是容器中的一个个组件，最后都会加入到容器中。它们会帮我们自动装配东西，自动装配的东西有默认值，它会从***Properties里面去取默认值。# ***Properties又和配置文件绑定，我们就可以使用自定义的配置了server: port: 9090 address: test ssl: certificate: test enabled: false enabled-protocols: test trust-store-type: dsf tomcat: accept-count: 10 这个就是自动装配的原理！！! 精髓1、SpringBoot启动会加载大量的自动配置类（xxxxAutoConfigurartion），每一个自动配置类中都有对应的 xxxxProperties，这些xxxxProperties中有着相关的属性与默认值，这些属性又是和配置文件（application.yaml）绑定的，所以我们可以通过配置文件来修改SpringBoot自动配置的默认值； 2、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中； 3、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在在其中，我们就不需要再手动配置了） 4、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件（application.yaml）中指定这些属性的值即可； xxxxAutoConfigurartion： 给容器中添加组件 **xxxxProperties:自动配置类，封装配置文件中相关属性； ** 了解：@Conditional了解完自动装配的原理后，我们来关注一个细节问题，自动配置类必须在一定的条件下才能生效； @Conditional派生注解（Spring注解版原生的@Conditional作用） 作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； @Conditional扩展注解 作用（【判断是否满足当前条件） @ConditionalOnBean 容器中是否存在指定bean @ConditionalOnClass 系统中有指定的类 @ConditionalOnExpression 满足SpEL表达式 @ConditionalOnJava 系统的Java版本是否符合要求 @ConditionalOnJndi JNDI存在指定项 @ConditionalOnMissingBean 容器中不存在指定bean @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 那么多的自动配置类，必须在一定的条件下才能生效；也就是说，我们加载了这么多的配置类，但不是所有的都生效了。 我们怎么知道哪些自动配置类生效？ 我们可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效； 12#开启springboot的调试类debug=true 输出的日志中大致分为一下几类： Positive matches:（自动配置类启用的：正匹配） 已经启用了，并且生效的 Negative matches:（没有启动，没有匹配成功的自动配置类：负匹配） Unconditional classes: （没有条件的类） 12345678910111213141516171819Positive matches:----------------- AopAutoConfiguration matched: - @ConditionalOnProperty (spring.aop.auto=true) matched (OnPropertyCondition) Negative matches:----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required class 'javax.jms.ConnectionFactory' (OnClassCondition)Unconditional classes:---------------------- org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration SpringBoot Web 开发前准备 我们要解决的问题： 导入静态资源，怎么样处理静态资源 首页index.jsp/index.html Jsp,模板引擎Thymeleaf 装配扩展SpringMVC 增删改查 拦截器 国际化 处理静态资源创建一个空的web工程 创建一个空web工程之后，先写一个测试controller验证有没有问题，没有问题的话再进行下一步。 123456789101112package com.cutiebambi;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController { @RequestMapping(\"/hello\") public String hello(){ return \"hello bambi\"; }} WebMvcAutoConfiguration.java 源码中关于静态资源的说明： 123456789101112131415161718public void addResourceHandlers(ResourceHandlerRegistry registry) { //1.如果我们在配置文件中自己定义了路径，下面默认的就会失效 if (!this.resourceProperties.isAddMappings()) { logger.debug(\"Default resource handling disabled\"); } else { //2.导入一些静态jar包，如jquery，这些jar包的目录结构要求，如果我们访问http://localhost:8080/webjars/... 就可以访问到/webjars下面的资源 this.addResourceHandler(registry, \"/webjars/**\", \"classpath:/META-INF/resources/webjars/\"); //3.源码中：staticPathPattern = \"/**\"，然后去查看WebProperties的Resources，private static final String[] CLASSPATH_RESOURCE_LOCATIONS = new String[]{\"classpath:/META-INF/resources/\", \"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\"}; this.addResourceHandler(registry, this.mvcProperties.getStaticPathPattern(), (registration) -&gt; { registration.addResourceLocations(this.resourceProperties.getStaticLocations()); if (this.servletContext != null) { ServletContextResource resource = new ServletContextResource(this.servletContext, \"/\"); registration.addResourceLocations(new Resource[]{resource}); } }); }} 总结： 在SpringBoot中，我们可以使用以下几种方式处理静态资源 webjars [^浏览器访问的路径]: localhost:8080/webjars/ public，static，/**, resources [^浏览器访问的路径]: localhost:8080/ 优先级: resources &gt; static(默认) &gt; public 如果我们在配置文件（application.properties）中自己定义了路径，SpringBoot默认的路径就会失效，一般不建议这样做，因为它会直接return，代码不会往下走。 http://localhost:8080/webjars/… 这个路径可以访问到/webjars下面的资源，一般会用于导入的依赖jar包的访问（这些依赖要去 webjars的官方网站：https://www.webjars.org 去找），要求这些jar包的目录结构要求如下： 12345&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;bootstrap&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt; ​ 在浏览器中访问通过webjars导入的静态资源： 那我们项目中要是使用自己的静态资源该怎么导入呢？我们去找staticPathPattern发现第二种映射规则 ：staticPathPattern = “/**” , 访问当前的项目任意资源，它会去找 WebProperties这个类 ,这个类在里面Resources定义了这些目录private static final String[] CLASSPATH_RESOURCE_LOCATIONS = new String[]{“classpath:/META-INF/resources/“, “classpath:/resources/“, “classpath:/static/“, “classpath:/public/“};所以平常我们访问 http://localhost:8080/… ，它就会匹配到上述的目录，去这些目录下寻找资源。 创建三个js文件去验证这三个目录的优先级。 访问localhost:8080/1.js，可以看到返回的是resources下面的js内容，可以得知：resources下面的静态资源优先级最高。 接着把resources目录下的js删掉，继续访问localhost:8080/1.js。这一次返回的是static目录下的js内容。 因此可以得出，优先级由高到低为：resources &gt; static &gt; public, 我们通常就把静态资源放在这三个目录下，至于怎样放，看个人习惯，很少使用/webjars。 首页如何定制123456789101112131415161718192021222324252627282930313233343536373839404142434445@Beanpublic WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) { WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping(new TemplateAvailabilityProviders(applicationContext), applicationContext, this.getWelcomePage(), this.mvcProperties.getStaticPathPattern()); welcomePageHandlerMapping.setInterceptors(this.getInterceptors(mvcConversionService, mvcResourceUrlProvider)); welcomePageHandlerMapping.setCorsConfigurations(this.getCorsConfigurations()); return welcomePageHandlerMapping;}private Resource getWelcomePage() { String[] var1 = this.resourceProperties.getStaticLocations(); int var2 = var1.length; for(int var3 = 0; var3 &lt; var2; ++var3) { String location = var1[var3]; Resource indexHtml = this.getIndexHtml(location); if (indexHtml != null) { return indexHtml; } } ServletContext servletContext = this.getServletContext(); if (servletContext != null) { return this.getIndexHtml((Resource)(new ServletContextResource(servletContext, \"/\"))); } else { return null; }}private Resource getIndexHtml(String location) { return this.getIndexHtml(this.resourceLoader.getResource(location));}private Resource getIndexHtml(Resource location) { try { Resource resource = location.createRelative(\"index.html\"); if (resource.exists() &amp;&amp; resource.getURL() != null) { return resource; } } catch (Exception var3) { } return null;} Thymeleaf模板引擎模板引擎 前端交给我们的页面，是html页面。如果是我们以前开发，我们需要把他们转成jsp页面，jsp好处就是当我们查出一些数据转发到JSP页面以后，我们可以用jsp轻松实现数据的显示，及交互等。 jsp支持非常强大的功能，包括能写Java代码，但是呢，我们现在的这种情况，SpringBoot这个项目首先是以jar的方式，不是war，第二，我们用的还是嵌入式的Tomcat，所以呢，他现在默认是不支持jsp的。 那不支持jsp，如果我们直接用纯静态页面的方式，那给我们开发会带来非常大的麻烦，那怎么办呢？ SpringBoot推荐你可以来使用模板引擎： 模板引擎，我们其实大家听到很多，其实jsp就是一个模板引擎，还有用的比较多的freemarker，包括SpringBoot给我们推荐的Thymeleaf，模板引擎有非常多，但再多的模板引擎，他们的思想都是一样的，什么样一个思想呢我们来看一下这张图： 模板引擎的作用就是我们来写一个页面模板，比如有些值呢，是动态的，我们写一些表达式。而这些值，从哪来呢，就是我们在后台封装一些数据。然后把这个模板和这个数据交给我们模板引擎，模板引擎按照我们这个数据帮你把这表达式解析、填充到我们指定的位置，然后把这个数据最终生成一个我们想要的内容给我们写出去，这就是我们这个模板引擎，不管是jsp还是其他模板引擎，都是这个思想。只不过呢，就是说不同模板引擎之间，他们可能这个语法有点不一样。其他的我就不介绍了，我主要来介绍一下SpringBoot给我们推荐的Thymeleaf模板引擎，这模板引擎呢，是一个高级语言的模板引擎，他的这个语法更简单。而且呢，功能更强大。我们呢，就来看一下这个模板引擎，那既然要看这个模板引擎。首先，我们来看SpringBoot里边怎么用。 引入Thymeleaf 怎么引入呢，对于springboot来说，什么事情不都是一个start的事情嘛，我们去在项目中引入一下。给大家三个网址： Thymeleaf 官网：https://www.thymeleaf.org/ Thymeleaf 在Github 的主页：https://github.com/thymeleaf/thymeleaf Spring官方文档：找到我们对应的版本https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter 找到对应的pom依赖：可以适当点进源码看下本来的包！ 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; Maven会自动下载jar包，我们可以去看下下载的东西； Thymeleaf分析 前面呢，我们已经引入了Thymeleaf，那这个要怎么使用呢？ 我们首先得按照SpringBoot的自动配置原理看一下我们这个Thymeleaf的自动配置规则，再按照那个规则，我们进行使用。我们去找一下Thymeleaf的自动配置类：ThymeleafProperties 1234567891011121314151617181920212223@ConfigurationProperties( prefix = \"spring.thymeleaf\")public class ThymeleafProperties { private static final Charset DEFAULT_ENCODING; public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; private boolean checkTemplate = true; private boolean checkTemplateLocation = true; private String prefix = \"classpath:/templates/\"; private String suffix = \".html\"; private String mode = \"HTML\"; private Charset encoding; private boolean cache; private Integer templateResolverOrder; private String[] viewNames; private String[] excludedViewNames; private boolean enableSpringElCompiler; private boolean renderHiddenMarkersBeforeCheckboxes; private boolean enabled; private final Servlet servlet; private final Reactive reactive;} 我们可以在其中看到默认的前缀和后缀！ 我们只需要把我们的html页面放在类路径下的templates下，thymeleaf就可以帮我们自动渲染了。 使用thymeleaf什么都不需要配置，只需要将他放在指定的文件夹下即可！ 测试 编写一个IndexController 1234567891011121314package com.cutiebambi;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;//在templates目录下的所有页面，只能通过controller来跳转。//这个需要模板引擎的支持！thymeleaf@Controllerpublic class IndexController { @RequestMapping(\"/helloindex\") public String index(){ return \"index\"; }} 编写一个测试页面 index.html 放在 templates 目录下12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Hello Bambi&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 明天更好~~&lt;/body&gt;&lt;/html&gt; 启动项目请求测试 Thymeleaf 语法学习 要学习语法，还是参考官网文档最为准确，我们找到对应的版本看一下； Thymeleaf 官网：https://www.thymeleaf.org/ ， 简单看一下官网！我们去下载Thymeleaf的官方文档！ 我们做个最简单的练习 ：我们需要查出一些数据，在页面中展示 修改测试请求，增加数据传输。 1234567891011121314package com.cutiebambi;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class TestController { @RequestMapping(\"/test\") public String test(Model model){ model.addAttribute(\"msg\", \"你好呀，bambi！\"); return \"test\"; }} 我们要使用thymeleaf，需要在html文件中导入命名空间的约束，方便提示。我们可以去官方文档查一下然后把命名空间写进来。 1&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt; 我们去编写下前端页面。 123456789101112&lt;!DOCTYPE html&gt;&lt;!--命名空间的约束--&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--所有的html元素都可以被thymeleaf替换接管， th:元素名称 --&gt; &lt;div th:text=\"${msg}\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 启动项目进行测试。 SpringMVC自动配置原理官网阅读 在进行项目编写前，我们还需要知道一个东西，就是SpringBoot对我们的SpringMVC还做了哪些配置，包括如何扩展，如何定制。 只有把这些都搞清楚了，我们在之后使用才会更加得心应手。途径一：源码分析；途径二：官方文档！ 地址 ：https://docs.spring.io/spring-boot/docs/2.7.4/reference/htmlsingle/#web.servlet.spring-mvc.auto-configuration 1234567891011121314151617181920212223242526//Spring MVC自动配置Spring MVC Auto-configuration//Spring Boot为Spring MVC提供了自动配置，在大多数应用程序中都能很好地工作。Spring Boot provides auto-configuration for Spring MVC that works well with most applications.//自动配置在Spring默认配置的基础上添加了以下特性:The auto-configuration adds the following features on top of Spring’s defaults://包含ContentNegotiatingViewResolver和BeanNameViewResolver bean。Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.//对提供静态资源的支持，包括对webjar的支持(在本文档后面介绍)。Support for serving static resources, including support for WebJars (covered later in this document).//自动注册Converter、GenericConverter和Formatter bean。Automatic registration of Converter, GenericConverter, and Formatter beans.//对HttpMessageConverters的支持(在本文档后面介绍)。Support for HttpMessageConverters (covered later in this document).//MessageCodesResolver的自动注册(在本文档后面介绍)。Automatic registration of MessageCodesResolver (covered later in this document).//静态index . html的支持。Static index.html support.//自动使用ConfigurableWebBindingInitializer bean(在本文档后面介绍)。Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document).//如果你想保留那些Spring Boot MVC定制，并做更多的MVC定制(拦截器、格式化器、视图控制器和其他功能)，你可以添加你自己的WebMvcConfigurer类型的@Configuration类，但不需要@EnableWebMvc。If you want to keep those Spring Boot MVC customizations and make more MVC customizations (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc.//如果你想提供RequestMappingHandlerMapping, RequestMappingHandlerAdapter，或ExceptionHandlerExceptionResolver的自定义实例，并且仍然保持Spring引导MVC的自定义，你可以声明一个WebMvcRegistrations类型的bean，并使用它来提供这些组件的自定义实例。If you want to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, and still keep the Spring Boot MVC customizations, you can declare a bean of type WebMvcRegistrations and use it to provide custom instances of those components.//如果你想完全控制Spring MVC，你可以添加你自己的@Configuration，带有@EnableWebMvc注解，或者添加你自己的@Configuration注解的DelegatingWebMvcConfiguration，就像@EnableWebMvc的Javadoc中描述的那样。If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc, or alternatively add your own @Configuration-annotated DelegatingWebMvcConfiguration as described in the Javadoc of @EnableWebMvc. 我们来仔细对照，看一下它怎么实现的，它告诉我们SpringBoot已经帮我们自动配置好了SpringMVC，然后自动配置了哪些东西呢？ ContentNegotiatingViewResolver 内容协商视图解析器自动配置了ViewResolver，就是我们之前学习的SpringMVC的视图解析器； 即根据方法的返回值取得视图对象（View），然后由视图对象决定如何渲染（转发，重定向）。 我们去看看这里的源码：我们找到 WebMvcAutoConfiguration ， 然后搜索ContentNegotiatingViewResolver。找到如下方法！ 123456789101112@Bean@ConditionalOnBean({ViewResolver.class})@ConditionalOnMissingBean( name = {\"viewResolver\"}, value = {ContentNegotiatingViewResolver.class})public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) { ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver(); resolver.setContentNegotiationManager((ContentNegotiationManager)beanFactory.getBean(ContentNegotiationManager.class)); resolver.setOrder(Integer.MIN_VALUE); return resolver;} 我们可以点进ContentNegotiatingViewResolver类看看！找到对应的解析视图的代码； 12345678910111213141516171819202122232425262728//注解说明：@Nullable 即参数可为null@Nullablepublic View resolveViewName(String viewName, Locale locale) throws Exception { RequestAttributes attrs = RequestContextHolder.getRequestAttributes(); Assert.state(attrs instanceof ServletRequestAttributes, \"No current ServletRequestAttributes\"); List&lt;MediaType&gt; requestedMediaTypes = this.getMediaTypes(((ServletRequestAttributes)attrs).getRequest()); if (requestedMediaTypes != null) { //获取候选的视图对象 List&lt;View&gt; candidateViews = this.getCandidateViews(viewName, locale, requestedMediaTypes); //选择一个最适合的视图对象，然后把这个对象返回 View bestView = this.getBestView(candidateViews, requestedMediaTypes, attrs); if (bestView != null) { return bestView; } } String mediaTypeInfo = this.logger.isDebugEnabled() &amp;&amp; requestedMediaTypes != null ? \" given \" + requestedMediaTypes.toString() : \"\"; if (this.useNotAcceptableStatusCode) { if (this.logger.isDebugEnabled()) { this.logger.debug(\"Using 406 NOT_ACCEPTABLE\" + mediaTypeInfo); } return NOT_ACCEPTABLE_VIEW; } else { this.logger.debug(\"View remains unresolved\" + mediaTypeInfo); return null; }} 我们继续点进去看，他是怎么获得候选的视图的呢？ getCandidateViews中看到他是把所有的视图解析器拿来，进行while循环，挨个解析！ 12345678910111213141516private List&lt;View&gt; getCandidateViews(String viewName, Locale locale, List&lt;MediaType&gt; requestedMediaTypes) throws Exception { List&lt;View&gt; candidateViews = new ArrayList(); if (this.viewResolvers != null) { Assert.state(this.contentNegotiationManager != null, \"No ContentNegotiationManager set\"); //遍历所有的视图解析器 Iterator var5 = this.viewResolvers.iterator(); while(var5.hasNext()) { ViewResolver viewResolver = (ViewResolver)var5.next(); View view = viewResolver.resolveViewName(viewName, locale); if (view != null) { candidateViews.add(view); } } }} 所以得出结论：ContentNegotiatingViewResolver 这个视图解析器就是用来组合所有的视图解析器的 我们再去研究下他的组合逻辑，看到有个属性viewResolvers，看看它是在哪里进行赋值的！ 12345678910111213141516171819202122232425262728protected void initServletContext(ServletContext servletContext) { Collection&lt;ViewResolver&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(this.obtainApplicationContext(), ViewResolver.class).values(); ViewResolver viewResolver; if (this.viewResolvers == null) { //这里它是从beanFactory工具中获取容器中的所有视图解析器 //ViewRescolver.class 把所有的视图解析器来组合的 this.viewResolvers = new ArrayList(matchingBeans.size()); Iterator var3 = matchingBeans.iterator(); while(var3.hasNext()) { viewResolver = (ViewResolver)var3.next(); if (this != viewResolver) { this.viewResolvers.add(viewResolver); } } } else { for(int i = 0; i &lt; this.viewResolvers.size(); ++i) { viewResolver = (ViewResolver)this.viewResolvers.get(i); if (!matchingBeans.contains(viewResolver)) { String name = viewResolver.getClass().getName() + i; this.obtainApplicationContext().getAutowireCapableBeanFactory().initializeBean(viewResolver, name); } } } AnnotationAwareOrderComparator.sort(this.viewResolvers); this.cnmFactoryBean.setServletContext(servletContext);} 既然它是在容器中去找视图解析器，我们是否可以猜想，我们就可以去实现一个视图解析器了呢？ 我们可以自己给容器中去添加一个视图解析器；这个类就会帮我们自动的将它组合进来；我们去实现一下 我们在我们的主程序中去写一个视图解析器来试试；123456789101112131415161718192021222324package com.cutiebambi.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.View;import org.springframework.web.servlet.ViewResolver;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import java.util.Locale;@Configurationpublic class MyMvcConfig implements WebMvcConfigurer { @Bean public ViewResolver MyViewResolver(){ return MyViewResolver(); } public static class MyViewResolver implements ViewResolver { @Override public View resolveViewName(String viewName, Locale locale) throws Exception { return null; } }} 怎么看我们自己写的视图解析器有没有起作用呢？我们给 DispatcherServlet 中的 doDispatch方法 加个断点进行调试一下，因为所有的请求都会走到这个方法中。 我们启动我们的项目，然后随便访问一个页面，看一下Debug信息； 刚开始这样写之后，我本地debug还没进到doDispatch的断点，项目就报错了。 1org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'MyViewResolver' defined in class path resource [com/cutiebambi/config/MyMvcConfig.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.web.servlet.ViewResolver]: Factory method 'MyViewResolver' threw exception; nested exception is java.lang.StackOverflowError 后来经过琢磨，把MyMvcConfig改成下面这样之后，程序就可以正常启动了。 12345678910111213141516171819//如果你想diy一些定制化的功能，只要写这个组件，然后将它交给springboot, springboot就会帮我们自动装配。//这个注解表明这是扩展的SpringMVC@Configurationpublic class MyMvcConfig implements WebMvcConfigurer { //ViewResolver 实现了视图解析器接口的类，我们就可以把它看作是视图解析器 @Bean public ViewResolver MyViewResolver(){ return new MyViewResolver(); }}//自定义一个自己的视图解析器，MyViewResolver//把这个从上面挪下来class MyViewResolver implements ViewResolver { @Override public View resolveViewName(String viewName, Locale locale) throws Exception { return null; }} 找到this 找到视图解析器viewResolvers，我们看到我们自己定义的视图解析器也在这里了^-^ 所以说，我们如果想要使用自己定制化的东西，我们只需要给容器中添加这个组件就好了！剩下的事情SpringBoot就会帮我们做了！ 转换器和格式化器 在WebMvcAutoConfiguration.java中找到格式化转换器： 12345678@Beanpublic FormattingConversionService mvcConversionService() { WebMvcProperties.Format format = this.mvcProperties.getFormat(); //拿到配置文件中的格式化规则 WebConversionService conversionService = new WebConversionService((new DateTimeFormatters()).dateFormat(format.getDate()).timeFormat(format.getTime()).dateTimeFormat(format.getDateTime())); this.addFormatters(conversionService); return conversionService;} 点进去： 1234567891011public DateTimeFormatters dateFormat(String pattern) { if (isIso(pattern)) { this.dateFormatter = DateTimeFormatter.ISO_LOCAL_DATE; this.datePattern = \"yyyy-MM-dd\"; } else { this.dateFormatter = formatter(pattern); this.datePattern = pattern; } return this;} 可以看到在我们的Properties文件中，我们可以进行自动配置它！ 如果配置了自己的格式化方式，就会注册到Bean中生效，我们可以在配置文件中配置日期格式化的规则： 修改SpringBoot的默认配置方式一：这么多的自动配置，原理都是一样的，通过这个WebMVC的自动配置原理分析，我们要学会一种学习方式，通过源码探究，得出结论；这个结论一定是属于自己的，而且一通百通。 SpringBoot的底层，大量用到了这些设计细节思想，所以，没事需要多阅读源码！得出结论； SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（如果用户自己配置@bean），如果有就用用户配置的，如果没有就用自动配置的； 如果有些组件可以存在多个，比如我们的视图解析器，就将用户配置的和自己默认的组合起来！ 方式二：扩展使用Spring MVC官方文档如下： If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components. 我们要做的就是编写一个@Configuration注解类，并且类型要为WebMvcConfigurer，还不能标注@EnableWebMvc注解；我们去自己写一个；我们新建一个包叫config，写一个类MyMvcConfig； 123456789101112131415161718192021package com.cutiebambi.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.View;import org.springframework.web.servlet.ViewResolver;import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import java.util.Locale;//如果你想diy一些定制化的功能，只要写这个组件，然后将它交给springboot, springboot就会帮我们自动装配。//扩展spring mvc@Configurationpublic class MyMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { //只需要访问 http://localhost:8080/bambi 就可以跳转到index.html registry.addViewController(\"/bambi\").setViewName(\"index\"); }} 我们去浏览器访问一下： 经过验证，确实跳转过来了！所以说，我们要扩展SpringMVC，官方推荐我们这么去使用，既保留了SpringBoot所有的自动配置，也能用我们扩展的配置！ 分析原理：1、WebMvcAutoConfiguration 是 SpringMVC的自动配置类，里面有一个类WebMvcAutoConfigurationAdapter 2、这个类上有一个注解，在做其他自动配置时会导入：@Import(EnableWebMvcConfiguration.class) 3、我们点进EnableWebMvcConfiguration这个类看一下，它继承了一个父类：DelegatingWebMvcConfiguration 这个父类中有这样一段代码： 1234567891011121314151617public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport { private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); public DelegatingWebMvcConfiguration() { } @Autowired( required = false ) //从容器中获取所有的Webmvc Configurer public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) { if (!CollectionUtils.isEmpty(configurers)) { this.configurers.addWebMvcConfigurers(configurers); } }} 4、我们可以在这个类中去寻找一个我们刚才设置的viewController当做参考，发现它调用了一个 123protected void addViewControllers(ViewControllerRegistry registry) { this.configurers.addViewControllers(registry);} 5、我们点进去看一下 123456789public void addViewControllers(ViewControllerRegistry registry) { Iterator var2 = this.delegates.iterator(); while(var2.hasNext()) { //将所有的WebMvcConfigurer相关配置来一起调用！包括我们自己配置的和Spring给我们配置的 WebMvcConfigurer delegate = (WebMvcConfigurer)var2.next(); delegate.addViewControllers(registry); }} 所以得出结论：所有的WebMvcConfiguration都会被作用，不止Spring自己的配置类，我们自己的配置类当然也会被调用； 全面接管SpringMVC测试加上@EnableWebMvc之后会发生什么？ 官方文档： 12//如果你想完全控制Spring MVC，你可以添加你自己的@Configuration，带有@EnableWebMvc注解，或者添加你自己的@Configuration注解的DelegatingWebMvcConfiguration，就像@EnableWebMvc的Javadoc中描述的那样。If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc, or alternatively add your own @Configuration-annotated DelegatingWebMvcConfiguration as described in the Javadoc of @EnableWebMvc. 全面接管即：SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己去配置！ 只需在我们的配置类中要加一个@EnableWebMvc。 我们看下如果我们全面接管了SpringMVC了，我们之前SpringBoot给我们配置的静态资源映射会不会无效，我们可以去测试一下； 不加注解之前，访问静态资源： 在工程static下添加一个静态资源 1234567&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\"/&gt;&lt;!-- 不加这行代码，文本中的汉字会乱码 --&gt;&lt;body&gt;&lt;h2&gt;hello bambi,我是静态资源~&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 给配置类加上注解：@EnableWebMvc 我们发现所有的SpringMVC自动配置都失效了！访问不到静态资源了； 当然，我们开发中，不推荐使用全面接管SpringMVC 思考：为什么加了一个注解，自动配置就失效了？ 查看代码，加上@EnableWebMvc其实就是导入了一个类: DelegatingWebMvcConfiguration, DelegatingWebMvcConfiguration类的作用是从容器中获取所有的WebMvcConfigurer。 123456@Retention(RetentionPolicy.RUNTIME)@Target({ElementType.TYPE})@Documented@Import({DelegatingWebMvcConfiguration.class})public @interface EnableWebMvc {} 123456789101112131415161718@Configuration( proxyBeanMethods = false)public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport { private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); public DelegatingWebMvcConfiguration() { } @Autowired( required = false ) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) { if (!CollectionUtils.isEmpty(configurers)) { this.configurers.addWebMvcConfigurers(configurers); } }} DelegatingWebMvcConfiguration继承了一个父类 WebMvcConfigurationSupport 1public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport 我们再来看一下Webmvc自动配置类 (WebMvcAutoConfiguration)的代码。只有当不存在WebMvcConfigurationSupport的时候才会生效，加了@EnableWebMvc之后就相当于是自动引入了WebMvcAutoConfiguration类，所以Spring Boot的自动配置类就会失效。 总结：@EnableWebMvc将WebMvcConfigurationSupport组件导入进来了；而导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能！这个WebMvcConfigurationSupport进来之后，就使WebMvcAutoConfiguration这个类不满足条件，导致自动配置类失效！在SpringBoot中会有非常多的扩展配置，只要看见了这个，我们就应该多留心注意~ 一个简单的员工管理系统准备工作 导入lombok依赖 Lombok官网: https://www.projectlombok.org/ Lombok项目是一个Java库，它会自动插入编辑器和构建工具中，Lombok提供了一组有用的注释，用来消除Java类中的大量样板代码。仅五个字符(@Data)就可以替换数百行代码从而产生干净，简洁且易于维护的Java类。用在实体类中，用注解生成构造方法，get/set，等方法 12345&lt;!-- lombok --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt; @Data：注解在类，生成setter/getter、equals、canEqual、hashCode、toString方法，如为final属性，则不会为该属性生成setter方法 模拟DB中的数据，编写部门和员工的实体类以及对应的Dao。 部门表实体类 1234567891011121314package com.cutiebambi.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;//部门表@Data@AllArgsConstructor@NoArgsConstructorpublic class Department { private Integer id; private String departmentName;} 部门表Dao层 123456789101112131415161718192021222324252627282930313233343536package com.cutiebambi.dao;import com.cutiebambi.pojo.Department;import org.springframework.stereotype.Repository;import java.util.Collection;import java.util.HashMap;import java.util.List;import java.util.Map;//部门dao@Repositorypublic class DepartmentDao { //模拟数据库中的数据 private static Map&lt;Integer, Department&gt; departments = null; static{ //创建一个部门表 departments = new HashMap&lt;Integer, Department&gt;(); departments.put(101, new Department(101, \"教学部\")); departments.put(102, new Department(102, \"市场部\")); departments.put(103, new Department(103, \"教研部\")); departments.put(104, new Department(104, \"运营部\")); departments.put(105, new Department(105, \"后勤部\")); } //获取所有部门信息 public Collection&lt;Department&gt; getDepartments(){ return departments.values(); } //根据id获取单个部门信息 public Department getDepartmentById(Integer id){ return departments.get(id); }} 员工表实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.cutiebambi.pojo;import lombok.AllArgsConstructor;import lombok.NoArgsConstructor;import java.util.Date;//员工表@NoArgsConstructorpublic class Employee { private Integer id; private String lastName; private String email; private Integer gender; //0:女 1:男 private Department department; private Date birth; public Employee(Integer id, String lastName, String email, Integer gender, Department department) { this.id = id; this.lastName = lastName; this.email = email; this.gender = gender; this.department = department; this.birth = new Date(); } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public Integer getGender() { return gender; } public void setGender(Integer gender) { this.gender = gender; } public Department getDepartment() { return department; } public void setDepartment(Department department) { this.department = department; } public Date getBirth() { return birth; } public void setBirth(Date birth) { this.birth = birth; }} 员工表Dao层12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.cutiebambi.dao;import com.cutiebambi.pojo.Department;import com.cutiebambi.pojo.Employee;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Repository;import org.springframework.util.StringUtils;import java.util.Collection;import java.util.HashMap;import java.util.Map;//员工dao@Repositorypublic class EmployeeDao { @Autowired //Field injection is not recommended private DepartmentDao departmentDao; private static Integer id = 1006; private static Map&lt;Integer, Employee&gt; employees = null; //模拟DB中的数据 static{ //创建一个员工表(自己写的时候，把这一行没写，直接用employees call put方法了。差点弄出来空指针异常了) employees = new HashMap&lt;Integer, Employee&gt;(); employees.put(1001, new Employee(1001, \"summer\", \"1@lucky.com\", 0, new Department(101, \"教学部\"))); employees.put(1002, new Employee(1002, \"jack\", \"2@lucky.com\", 1, new Department(101, \"市场部\"))); employees.put(1003, new Employee(1003, \"cecil\", \"3@lucky.com\", 1, new Department(101, \"教研部\"))); employees.put(1004, new Employee(1004, \"roy\", \"4@lucky.com\", 1, new Department(101, \"运营部\"))); employees.put(1005, new Employee(1005, \"cara\", \"5@lucky.com\", 0, new Department(101, \"后勤部\"))); } //增加一个员工 public void addEmployee(Employee employee){ //Integer id = 1006;//这行代码不能写在这里，要不每一次新增员工的时候，id都是从1006开始了！又是我犯的一个错误 if(employee.getId() == null){ employee.setId(id++); } employees.put(employee.getId(), employee); } //查询全部员工 public Collection&lt;Employee&gt; getEmployees(){ return employees.values(); } //根据id查询员工 public Employee getEmployeeById(Integer id){ return employees.get(id); } //删除员工 public void removeEmployeeById(Integer id){ employees.remove(id); }} 首页实现 实现通过localhost:8080或者localhost:8080/index进入首页的功能 123456789@Configurationpublic class MyMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { //只需要访问http://localhost:8080/或者http://localhost:8080/index就可以跳转到index.html页面 registry.addViewController(\"/\").setViewName(\"index\"); registry.addViewController(\"/index\").setViewName(\"index\"); }} 所有的静态资源导入都需要使用Thymeleaf接管。所以： 要先给静态资源导入Thymeleaf命名空间。1&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; 按照Thymeleaf的语法规则，修改静态资源文件。 123456&lt;!-- Bootstrap core CSS --&gt;&lt;link th:href=\"@{/css/bootstrap.min.css}\" rel=\"stylesheet\"&gt;&lt;!-- Custom styles for this template --&gt;&lt;link th:href=\"@{/css/signin.css}\" rel=\"stylesheet\"&gt;&lt;img class=\"mb-4\" th:src=\"@{/img/bootstrap-solid.svg}\" alt=\"\" width=\"72\" height=\"72\"&gt; 修改这里的时候有遇到下面这个问题。之前中英文我写的href是@{/index.html}，但是点击中文或者English的超链接的时候一直报错，导致国际化一直跳转失败。后来把href改为@{/index}问题才得以解决。 12345678&lt;button class=\"btn btn-lg btn-primary btn-block\" type=\"submit\"&gt; [[#{login.signIn}]] &lt;/button&gt;&lt;p class=\"mt-5 mb-3 text-muted\"&gt;© 2022-2023&lt;/p&gt;&lt;a class=\"btn btn-sm\" th:href=\"@{/index(l='zh_CN')}\"&gt;中文&lt;/a&gt;&lt;a class=\"btn btn-sm\" th:href=\"@{/index(l='en_US')}\"&gt;English&lt;/a&gt;&lt;!-- 之前这样写的，点击之后总是跳转到error页面&lt;a class=\"btn btn-sm\" th:href=\"@{/index.html(l='zh_CN')}\"&gt;中文&lt;/a&gt;&lt;a class=\"btn btn-sm\" th:href=\"@{/index.html(l='en_US')}\"&gt;English&lt;/a&gt;--&gt; 后来经过思考，发现如果改一下自定义Config，就可以通过href访问到/index.html页面了。但是至于为什么这个可以，我还不知道底层原理，后面知道了之后再补充到这里 12345678910@Configurationpublic class MyMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\"/\").setViewName(\"index\"); registry.addViewController(\"/index\").setViewName(\"index\"); //加上这行代码，上面的html就可以写成th:href=\"@{/index.html(l='en_US')}然后也能正常跳转了。 registry.addViewController(\"/index.html\").setViewName(\"index\"); }} ![](https://raw.githubusercontent.com/xiaofanshutu/typora2022/main/202210090836775.png) ![](https://raw.githubusercontent.com/xiaofanshutu/typora2022/main/202210090836715.png) 关闭模板引擎的缓存123spring: thymeleaf: cache: false 页面国际化准备工作 先在IDEA中统一设置properties的编码问题！ 配置文件编写 我们在resources资源文件下新建一个i18n目录，存放国际化配置文件 建立一个login.properties文件，还有一个login_zh_CN.properties；发现IDEA自动识别了我们要做国际化操作；文件夹变了！ 接着可以直接在Resource Bundle上右键，添加en_US国际化配置文件 接下来，我们就来编写国际化配置文件，我们可以看到idea下面有另外一个视图； 如果你的IDEA没有这个视图，那么去plugins里面下载如下插件，下载完之后页面就会显示Resource Bundle视图。 配置文件生效探究 我们去看一下SpringBoot对国际化的自动配置！这里又涉及到一个类：MessageSourceAutoConfiguration 里面有一个方法，这里发现SpringBoot已经自动配置好了管理我们国际化资源文件(就是在i8n文件夹下的文件)的组件 ResourceBundleMessageSource； （这个东西是识别国际化配置信息文件里的信息） 12345678910111213141516171819202122@Beanpublic MessageSource messageSource(MessageSourceProperties properties) { ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); //如果你配置了basename，那么就会用你配置的basename路径 if (StringUtils.hasText(properties.getBasename())) { messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(properties.getBasename()))); } if (properties.getEncoding() != null) { messageSource.setDefaultEncoding(properties.getEncoding().name()); } messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale()); Duration cacheDuration = properties.getCacheDuration(); if (cacheDuration != null) { messageSource.setCacheMillis(cacheDuration.toMillis()); } messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat()); messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage()); return messageSource;} 我们项目的国际化文件在i18n下面，所以配置我们的basename为i18n.login12345spring: thymeleaf: cache: false messages: basename: i18n.login 配置页面国际化值 去页面获取国际化的值，查看Thymeleaf的文档，找到message取值操作为：#{…}。 配置国际化解析 在Spring中有一个国际化的Locale （区域信息对象）；里面有一个叫做LocaleResolver （获取区域信息对象）的解析器！ 我们去我们webmvc（WebMvcAutoConfiguration.java）自动配置文件，寻找一下！看到SpringBoot默认配置： 1234567891011121314@Bean@ConditionalOnMissingBean( name = {\"localeResolver\"} //不存在localeResolver的时候，走这个bean设置默认Locale)public LocaleResolver localeResolver() { if (this.webProperties.getLocaleResolver() == org.springframework.boot.autoconfigure.web.WebProperties.LocaleResolver.FIXED) { return new FixedLocaleResolver(this.webProperties.getLocale()); } else { //接收端国际化分解 AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.webProperties.getLocale()); return localeResolver; }} 点进去AcceptHeaderLocaleResolver（这是源码给的一个国际化（地区）解析器，我们也可以参考这个写一个自己的国际化解析器） 12345678910111213141516171819public Locale resolveLocale(HttpServletRequest request) { Locale defaultLocale = this.getDefaultLocale(); if (defaultLocale != null &amp;&amp; request.getHeader(\"Accept-Language\") == null) { return defaultLocale; } else { Locale requestLocale = request.getLocale(); List&lt;Locale&gt; supportedLocales = this.getSupportedLocales(); if (!supportedLocales.isEmpty() &amp;&amp; !supportedLocales.contains(requestLocale)) { Locale supportedLocale = this.findSupportedLocale(request, supportedLocales); if (supportedLocale != null) { return supportedLocale; } else { return defaultLocale != null ? defaultLocale : requestLocale; } } else { return requestLocale; } }} 自己的国际化解析器 123456789101112131415161718192021222324252627package com.cutiebambi.config;import org.springframework.util.StringUtils;import org.springframework.web.servlet.LocaleResolver;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Locale;public class MyLocaleResolver implements LocaleResolver { @Override public Locale resolveLocale(HttpServletRequest request) { String language = request.getParameter(\"lang\"); Locale requestLocale = Locale.getDefault(); if(!StringUtils.isEmpty(language)){ String[] s = StringUtils.split(language, \"_\"); requestLocale = new Locale(s[0], s[1]); } return requestLocale; } @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) { }} 请求端携带上lang参数12&lt;a class=\"btn btn-sm\" th:href=\"@{/index(lang='zh_CN')}\"&gt;中文&lt;/a&gt;&lt;a class=\"btn btn-sm\" th:href=\"@{/index(lang='en_US')}\"&gt;English&lt;/a&gt; 将自己写的国际化解析器放进Spring Boot里面 12345//这样做之后，自己写的国际化组件就生效了@Bean//注入自己写的国际化组件public LocaleResolver localeResolver(){ return new MyLocaleResolver();} 测试自己的代码 点击英文 点击中文 总结页面国家化步骤： 我们需要配置i18n文件，并在application.properties配置文件中绑定，之后在对应的html中用thymeleaf获取（获取国家化信息使用#{} ，链接url是@{} ，变量${}） Thymeleaf 官网：https://www.thymeleaf.org/ 如果我们需要在项目中进行按钮自动切换，我们需要自己定义一个组件MyLocalResolver继承LocaleResolver 记得将自己写的组件配置到spring容器中，@Bean 登录功能与拦截器登录功能实现 LoginController 1234567891011121314151617181920212223package com.cutiebambi.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.util.StringUtils;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import javax.servlet.http.HttpSession;@Controllerpublic class LoginController { @RequestMapping(\"/user/login\") public String login(@RequestParam(name = \"userName\") String userName, @RequestParam(name = \"password\") String password, Model model, HttpSession session){ if(!StringUtils.isEmpty(userName) &amp;&amp; password.equals(\"1\")){ session.setAttribute(\"loginUser\", userName); return \"redirect:/main.html\"; //重定向 }else{ model.addAttribute(\"msg\", \"用户名或密码错误，登录失败\"); return \"index\"; } }} MyMvcConfig 1234567891011121314151617181920212223242526package com.cutiebambi.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.LocaleResolver;import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class MyMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { //只需要访问http://localhost:8080/或者http://localhost:8080/index就可以跳转到index.html页面 registry.addViewController(\"/\").setViewName(\"index\"); registry.addViewController(\"/index\").setViewName(\"index\"); registry.addViewController(\"/index.html\").setViewName(\"index\"); registry.addViewController(\"/main.html\").setViewName(\"dashboard\"); } //将自定义的国际化组件放进Spring Boot里。 @Bean public LocaleResolver localeResolver(){ return new MyLocaleResolver(); }} index.html 1234567891011&lt;body class=\"text-center\"&gt; &lt;!-- 修改form表单action --&gt; &lt;form class=\"form-signin\" th:action=\"@{/user/login}\"&gt; ... &lt;button class=\"btn btn-lg btn-primary btn-block\" type=\"submit\"&gt; [[#{login.signIn}]] &lt;/button&gt; &lt;p class=\"mt-5 mb-3 text-muted\"&gt;© 2022-2023&lt;/p&gt; &lt;a class=\"btn btn-sm\" th:href=\"@{/index(lang='zh_CN')}\"&gt;中文&lt;/a&gt; &lt;a class=\"btn btn-sm\" th:href=\"@{/index(lang='en_US')}\"&gt;English&lt;/a&gt; &lt;/form&gt;&lt;/body&gt; 将登录之后的左上角名字显示为登录的用户名 1&lt;a class=\"navbar-brand col-sm-3 col-md-2 mr-0\" href=\"http://getbootstrap.com/docs/4.0/examples/dashboard/#\" th:text=\"${session.loginUser}\"&gt;&lt;/a&gt; 验证结果 拦截器功能实现 LoginHandlerInterceptor 123456789101112131415161718192021222324252627282930313233package com.cutiebambi.config;import org.springframework.boot.web.servlet.server.Session;import org.springframework.util.StringUtils;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;public class LoginHandlerInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { /* //我写的代码 if(!StringUtils.isEmpty(request.getParameter(\"userName\")) &amp;&amp; request.getParameter(\"password\").equals(\"1\")){ return true; }else{ return false; } */ //老师的代码 HttpSession session = request.getSession(); if(session.getAttribute(\"loginUser\") != null){ return true; }else { session.setAttribute(\"msg\", \"用户名或者密码错误，我是从拦截器过来的提示信息\");// 感觉加上这行没什么作用 request.getRequestDispatcher(\"/index.html\").forward(request,response);//转发到index.html 显示提示信息 return false; } }} MyMvcConfig12345678910111213141516171819202122232425262728293031323334353637package com.cutiebambi.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.LocaleResolver;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@Configurationpublic class MyMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { //只需要访问http://localhost:8080/或者http://localhost:8080/index就可以跳转到index.html页面 registry.addViewController(\"/\").setViewName(\"index\"); registry.addViewController(\"/index\").setViewName(\"index\"); registry.addViewController(\"/index.html\").setViewName(\"index\"); registry.addViewController(\"/main.html\").setViewName(\"dashboard\"); } //将自定义的国际化组件放进Spring Boot里。 @Bean public LocaleResolver localeResolver(){ return new MyLocaleResolver(); } //拦截器 @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(\"/**\").excludePathPatterns(\"/\", \"/index.html\", \"/user/login\", \"/img/**\", \"/css/**\", \"/js/**\"); }} 展示员工列表将公共代码抽取存放在commons.html里面 点击员工管理按钮, 实现从后台获取员工列表数据并且在前台页面展示 新建一个EmployeeController 1234567891011121314151617181920212223242526package com.cutiebambi.controller;import com.cutiebambi.dao.EmployeeDao;import com.cutiebambi.pojo.Employee;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.util.StringUtils;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import javax.servlet.http.HttpSession;import java.util.Collection;@Controllerpublic class EmployeeController { @Autowired private EmployeeDao employeeDao; @RequestMapping(\"/employee/getEmployees\") public String getEmployees(Model model){ Collection&lt;Employee&gt; employees = employeeDao.getEmployees(); model.addAttribute(\"emps\", employees); return \"/emp/list\"; }} 点击前台’员工管理’tab，调用这个方法 前台接收并且解析获取到的数据123456789101112131415161718192021222324252627282930313233343536373839&lt;div class=\"row\"&gt; &lt;!-- 侧边栏 --&gt; &lt;div th:replace=\"~{/commons/commons.html :: sidebar(active='list.html')}\"&gt;&lt;/div&gt; &lt;main role=\"main\" class=\"col-md-9 ml-sm-auto col-lg-10 pt-3 px-4\"&gt; &lt;h2&gt;Section title&lt;/h2&gt; &lt;div class=\"table-responsive\"&gt; &lt;table class=\"table table-striped table-sm\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;lastName&lt;/th&gt; &lt;th&gt;email&lt;/th&gt; &lt;th&gt;gender&lt;/th&gt; &lt;th&gt;department&lt;/th&gt; &lt;th&gt;birth&lt;/th&gt; &lt;th&gt;action&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr th:each=\"employee : ${emps}\"&gt; &lt;td th:text=\"${employee.getId()}\"&gt;&lt;/td&gt; &lt;td th:text=\"${employee.getLastName()}\"&gt;&lt;/td&gt; &lt;td th:text=\"${employee.getEmail()}\"&gt;&lt;/td&gt; &lt;!-- 这里使用了三元运算符 --&gt; &lt;td th:text=\"${employee.getGender()} == 0? '女' : '男'\"&gt;&lt;/td&gt; &lt;td th:text=\"${employee.getDepartment().getDepartmentName()}\"&gt;&lt;/td&gt; &lt;!-- 格式化日期 --&gt; &lt;td th:text=\"${#calendars.format(employee.getBirth(),'yyyy/MM/dd HH:mm:ss')}\"&gt;&lt;/td&gt; &lt;td&gt; &lt;button class=\"btn btn-sm btn-primary\"&gt;增加&lt;/button&gt; &lt;button class=\"btn btn-sm btn-danger\"&gt;删除&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/main&gt;&lt;/div&gt; 侧边栏：根据点击的tab不同来实现动态高亮 添加，修改与删除员工错误处理https://blog.csdn.net/wang_luwei/article/details/123652585","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://xiaofanshutu.github.io/categories/SpringBoot/"}],"tags":[],"author":"cutiebambi"},{"title":"CS61A","slug":"CS61A","date":"2023-04-29T01:07:41.731Z","updated":"2024-01-17T23:38:56.334Z","comments":true,"path":"posts/e7a99a5e.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/e7a99a5e.html","excerpt":"","text":"Week1-0826命令 ls: lists all files in the current directory cd &lt;path to directory&gt;: change into the specified directory mkdir &lt;directory name&gt;: make a new directory with the given name mv &lt;source path&gt; &lt;destination path&gt;: move the file at the given source to the given destination ls cd $ cd C:/Users/cutiebambi/Desktop $ cd ..：跳转到上级目录 $ cd ：这个的意思是home directory，所以cd ~意思就是跳转到你的home directory $ cd：这是cd ~的一个缩写方式 mkdir$ mkdir 20230114 mv$ mv d:/20230114 d:/dest Python Basics 浮点除法 (/)：将第一个数字除以第二个数字，计算结果为带小数点的数字，即使数字被整除也是如此。 整除法 (//)：将第一个数字除以第二个数字，然后向下舍入，计算结果为整数。 模 (%)：计算除法剩余的正余数。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://xiaofanshutu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"cutiebambi"},{"title":"HTML5","slug":"HTML","date":"2023-04-29T01:07:41.731Z","updated":"2024-01-17T23:39:11.784Z","comments":true,"path":"posts/98f3a6d9.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/98f3a6d9.html","excerpt":"","text":"什么是HTMLHTML Hyper Text Markup Language(超文本标记语言) HTML的全称为超文本标记语言，是一种标记语言。它包括一系列标签．通过这些标签可以将网络上的文档格式统一，使分散的Internet资源连接为一个逻辑整体。HTML文本是由HTML命令组成的描述性文本，HTML命令可以说明文字，图形、动画、声音、表格、链接等。 W3C World Wide Web Consortium(万维网联盟) 万维网联盟创建于1994年，是Web技术领域最具权威和影响力的国际中立性技术标准机构。W3C已发布了200多项影响深远的Web技术标准及实施指南，如广为业界采用的超文本标记语言HTML（标准通用标记语言下的一个应用）、可扩展标记语言XML（标准通用标记语言下的一个子集）以及帮助残障人士有效获得Web信息的无障碍指南（WCAG）等，有效促进了Web技术的互相兼容，对互联网技术的发展和应用起到了基础性和根本性的支撑作用。 网页基本信息1234567891011121314151617&lt;!-- DOCTYPE: 告诉浏览器，我们要使用什么规范 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;!-- head: 代表网页头部 --&gt;&lt;head&gt; &lt;!-- meta: 描述性标签，用来描述我们网站的一些信息 --&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;!-- title: 网页标题 --&gt; &lt;title&gt;我的第一个HTML网页&lt;/title&gt;&lt;/head&gt;&lt;!-- body: 代表网页主体 --&gt;&lt;body&gt;你好，bambi&lt;/body&gt;&lt;/html&gt; 网页基本标签12345678910111213141516171819202122232425262728293031&lt;body&gt;&lt;!--标题标签--&gt;&lt;h1&gt;h1标题&lt;/h1&gt;&lt;h2&gt;h2标题&lt;/h2&gt;&lt;h3&gt;h2标题&lt;/h3&gt;&lt;h4&gt;h2标题&lt;/h4&gt;&lt;h5&gt;h2标题&lt;/h5&gt;&lt;h6&gt;h2标题&lt;/h6&gt;&lt;!--段落标签--&gt;&lt;p&gt; 这是一个段落标签&lt;/p&gt;&lt;!--换行标签--&gt;这是一个换行&lt;br&gt;标签&lt;!--水平线标签--&gt;&lt;hr&gt;&lt;!--字体样式标签-粗体--&gt;&lt;strong&gt;hope to see you on the top&lt;/strong&gt;&lt;!--字体样式标签-斜体--&gt;&lt;em&gt;boun prem&lt;/em&gt;&lt;!--特殊符号-空格--&gt;你&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;好&lt;!--特殊符号-大于--&gt;&amp;gt;&lt;!--特殊符号-小于--&gt;&amp;lt;&lt;!--特殊符号-版权所有--&gt;&amp;copy;&lt;/body&gt; 图像标签 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;HTML学习&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=\"resources/image/5.png\" title=\"海绵宝宝\" width=\"300\" height=\"300\" /&gt;&lt;/body&gt;&lt;/html&gt; 超链接标签及其应用文本超链接123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;HTML学习&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--href: 必填，表示要跳转到哪一个页面--&gt;&lt;!--target: 表示窗口在哪里打开--&gt;&lt;a href=\"test01.html\" target=\"_blank\"&gt;文本超链接&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 图像超链接12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;HTML学习&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"test01.html\" target=\"_blank\"&gt;&lt;img src=\"resources/image/5.png\" title=\"图片超链接\" width=\"300\" height=\"300\" /&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 锚链接123&lt;a id=\"bottom\"&gt;&lt;/a&gt;&lt;!--锚链接--&gt;&lt;a href=\"test01.html#bottom\"&gt;跳转到底部&lt;/a&gt; 功能性链接邮件链接12&lt;!--邮件链接--&gt;&lt;a href=\"mailto:15191434031@163.com\"&gt;邮件链接&lt;/a&gt; 块元素和行内元素 块元素 无论内容多少，该元素独占一行 (p, h1-h6) 行内元素 内容撑开宽度，左右都是行内元素的可以排在一行 (a, strong, em) 列表标签无序列表1234&lt;!--无序列表--&gt;&lt;ul&gt;a&lt;/ul&gt;&lt;ul&gt;b&lt;/ul&gt;&lt;ul&gt;c&lt;/ul&gt; 有序列表123456&lt;!--有序列表--&gt;&lt;ol&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;草莓&lt;/li&gt;&lt;/ol&gt; 自定义列表123456789&lt;!--自定义列表: 自定义列表一般用在网站底部--&gt;&lt;dl&gt; &lt;dt&gt;我的爱好 &lt;dd&gt;游泳&lt;/dd&gt; &lt;dd&gt;看书&lt;/dd&gt; &lt;dd&gt;听音乐&lt;/dd&gt; &lt;dd&gt;跑步&lt;/dd&gt; &lt;/dt&gt;&lt;/dl&gt; 表格标签1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;表格标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- tr:行 td:列 跨行:rowspan 跨列:colspan--&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td rowspan=\"3\"&gt;11&lt;/td&gt; &lt;td&gt;12&lt;/td&gt; &lt;td&gt;13&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;22&lt;/td&gt; &lt;td&gt;23&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt;33&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 媒体元素视频文件1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;媒体元素&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--controls:控制条autoplay:自动播放--&gt;&lt;video src=\"resources/video/02.mp4\" controls autoplay&gt;测试视频&lt;/video&gt;&lt;/body&gt;&lt;/html&gt; 视频能成功加载并且会自动播放 音频文件1&lt;audio src=\"resources/video/02.mp4\" controls autoplay&gt;&lt;/audio&gt; 页面结构分析 元素名 描述 header 标记头部区域的内容（用于页面或页面中的一块区域） footer 标记脚部区域的内容（用于整个页面或者页面的一块区域） section Web页面中的一块独立区域 article 独立的文章内容 aside 相关内容或应用（常用于侧边栏） nav 导航类辅助内容 iframe内联框架12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;内联框架&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;iframe src=\"test03.html\" name=\"mainFrame\"&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt; 初识表单post和get提交123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;提交表单&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"test01.html\" method=\"get\"&gt; &lt;p&gt;用户名：&lt;input type=\"text\"/&gt;&lt;/p&gt; &lt;p&gt;密 码：&lt;input type=\"password\"/&gt;&lt;/p&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;input type=\"reset\" value=\"重置\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 文本框和单选框 123456789101112131415161718&lt;!--文本输入框--&gt;文本输入框&lt;p&gt; &lt;input type=\"text\" name=\"name\"&gt;&lt;/p&gt;&lt;!--密码框--&gt;密码框&lt;p&gt; &lt;input type=\"password\"&gt;&lt;/p&gt;&lt;!--单选框，默认选中男checked--&gt;性别&lt;p&gt; &lt;input type=\"radio\" name=\"sex\" value=\"男\" checked&gt;男 &lt;input type=\"radio\" name=\"sex\" value=\"女\"&gt;女&lt;/p&gt; 按钮和多选框12345678910&lt;p&gt; &lt;input type=\"checkbox\" value=\"reading\" name=\"hobby\"&gt;阅读 &lt;input type=\"checkbox\" value=\"running\" name=\"hobby\" checked&gt;跑步 &lt;input type=\"checkbox\" value=\"yoga\" name=\"hobby\"&gt;瑜伽&lt;/p&gt;&lt;p&gt; &lt;input type=\"button\" value=\"按钮显示的文字\" name=\"btn1\"&gt; &lt;input type=\"image\" src=\"resources/image/5.png\" width=\"200\"&gt;&lt;/p&gt; 列表框文本域和文件域12345678910111213141516171819202122&lt;p&gt;下拉框 &lt;select name=\"水果天堂\"&gt; &lt;option value=\"banana\"&gt;香蕉&lt;/option&gt; &lt;option value=\"apple\" selected&gt;苹果&lt;/option&gt;&lt;!-- 苹果默认会是选中的 --&gt; &lt;option value=\"strawberry\"&gt;草莓&lt;/option&gt; &lt;/select&gt;&lt;/p&gt;&lt;p&gt;文本域 &lt;textarea name=\"remark\" cols=\"60\" rows=\"10\"&gt; 在这里写入备注内容 &lt;/textarea&gt;&lt;/p&gt;&lt;p&gt;文件域 &lt;input type=\"file\" name=\"file\"&gt; &lt;input type=\"button\" value=\"上传文件\" name=\"upload\"&gt;&lt;/p&gt; 搜索框滑块和简单验证123456789101112131415161718&lt;form&gt;&lt;p&gt;邮箱： &lt;input type=\"email\" name=\"email\"&gt;&lt;/p&gt;&lt;p&gt;URL： &lt;input type=\"url\" name=\"url\"&gt;&lt;/p&gt;&lt;p&gt;滑块： &lt;input type=\"range\" min=\"0\" max=\"100\" name=\"voice\" step=\"2\"&gt;&lt;/p&gt;&lt;p&gt;搜索： &lt;input type=\"search\" name=\"search\"&gt;&lt;/p&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 表单的应用 隐藏域hidden 只读readonly 禁用disable 表单初级验证 placeholder：提示信息 required：非空判断 pattern：正则表达式 123&lt;p&gt; 用户名：&lt;input type=\"text\" name=\"name\" required placeholder=\"请输入用户名\"&gt;&lt;/p&gt;","categories":[{"name":"HTML5","slug":"HTML5","permalink":"https://xiaofanshutu.github.io/categories/HTML5/"}],"tags":[],"author":"cutiebambi"},{"title":"Javascript","slug":"Javascript","date":"2023-04-29T01:07:41.731Z","updated":"2024-01-17T23:40:19.407Z","comments":true,"path":"posts/cbb79327.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/cbb79327.html","excerpt":"","text":"聊聊JavaScriptJavaScript的起源故事网景公司急需一种网页脚本语言，使得浏览器可以与网页互动。工程师Brendan Eich负责开发这种新语言。他觉得，没必要设计得很复杂，这种语言只要能够完成一些简单操作就够了，比如判断用户有没有填写表单。 Brendan Eich。1995年4月，网景公司录用了他。 Brendan Eich的主要方向和兴趣是函数式编程，网景公司招聘他的目的，是研究将Scheme语言作为网页脚本语言的可能性。 仅仅一个月之后，1995年5月，网景公司做出决策，未来的网页脚本语言必须”看上去与Java足够相似”，但是比Java简单，使得非专业的网页作者也能很快上手。这个决策实际上将Perl、Python、Tcl、Scheme等非面向对象编程的语言都排除在外了。 Brendan Eich被指定为这种”简化版Java语言”的设计师。 但是，他对Java一点兴趣也没有。为了应付公司安排的任务，他只用10天时间就把Javascript设计出来了。 由于设计时间太短，语言的一些细节考虑得不够严谨，导致后来很长一段时间，Javascript写出来的程序混乱不堪。如果Brendan Eich预见到，未来这种语言会成为互联网第一大语言，全世界有几百万学习者，他会不会多花一点时间呢？ 设计思想总的来说，他的设计思路是这样的： 1234（1）借鉴C语言的基本语法；（2）借鉴Java语言的数据类型和内存管理；（3）借鉴Scheme语言，将函数提升到\"第一等公民\"（first class）的地位；（4）借鉴Self语言，使用基于原型（prototype）的继承机制。 所以，Javascript语言实际上是两种语言风格的混合产物—-（简化的）函数式编程+（简化的）面向对象编程。这是由Brendan Eich（函数式编程）与网景公司（面向对象编程）共同决定的。 小结JavaScript是 Netscape 公司于 Sun 公司合作开发的。在“javascript”出现之前，Web浏览器不过是一种能够显示超文本文档的软件的基础部分。而在“javascript”出现之后，网页的内容不再局限于枯燥的文本，他们的可交互性得到了显著的改善。 Javascript的第一个版本，即javaScript1.0版本，出现在1995年推出的Netscape Navigatior住在这浏览器市场，微软的IE浏览器则扮演这追赶者的角色。微软在推出IE 3的时候发布了自己的VBScript语言并以JScript为名发布了javaScript的一个版本，一次很快跟上了Netscape的步伐。 详细内容： https://zhuanlan.zhihu.com/p/400339768 ECMAScriptECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会，European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，所以它可以理解为是JavaScript的一个标准,但实际上后两者是ECMA-262标准的实现和扩展。 一个合格的Java开发必须精通JavaScript 快速入门引入JavaScript内部标签123&lt;script&gt; alert(123);&lt;/script&gt; 外部引入1&lt;script src=\"hello.js\"&gt;&lt;/script&gt; 基本语法入门定义变量123456&lt;script&gt; //变量类型 变量名 = 变量值 var name = \"boun\"; var age = 13; alert(\"name= \" + name + \", age= \" + age);&lt;/script&gt; 条件控制123456&lt;script&gt; var score = 98; if(score &gt; 90){ alert(\"你的表现真的很不错，继续保持哦\") }&lt;/script&gt; 浏览器调试 在浏览器的控制台打印变量 console.log(score); 用浏览器F12调试代码 数据类型number：js不区分整数和小数123456123 //整数123.1 // 浮点数1.123e3 //科学计数法-80 //负数NaN //not a numberInfinity //无限大 字符串12'abc'\"abc\" 布尔值12truefalse 逻辑运算123&amp;&amp;与||或!非 比较运算1234=== 等于（类型不一样，值一样，也会判断为true）=== 绝对等于（类型一样，值一样，结果才会判断为true） NaN===NaN 结果为false，一般用isNaN来判断 null和undefinednull: 空 undefined: 未定义 数组123456789&lt;script&gt; //定义数组方式一（为了保证代码的可读性，尽量使用这种方式来定义数组） const arr = [1, 2, 3, 'hello', null, true]; //定义数组方式二 const arr2 = new Array(8, 9, null, false, 'hi'); console.log(arr); console.log(arr2);&lt;/script&gt; 根据下标取值，如果越界，则会报undefined错误 对象12345678&lt;script&gt; const person = { name: \"summer\", age: 3, tags: [\"js\", \"java\", \"springboot\"] }; console.log(person);&lt;/script&gt; 严格检查模式这个可以预防因js的随意性产生的一些问题。 数据类型字符串 正常字符串我们用单引号或双引号包裹 转义字符\\ 12345\\'\\n\\t\\u4e2d Unicode字符\"\\x41\" ASCII字符 多行字符串编写 12345`hello你好` 模板字符串 12let name = \"summer\";let msg = '你好呀，${name}'; 字符串长度 12var student = \"abby\";console.log(student.length); 字符串的可变性，不可变 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;我的第一个Javascript&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; var name=\"Summer\"; console.log(name.length); name[0]='b'; console.log(name);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 大小写转换 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;我的第一个Javascript&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; var name=\"Summer\"; console.log(name.toUpperCase()); console.log(name.toLowerCase());&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; indexOf12345&lt;script&gt; var name=\"Summer\"; console.log(name.indexOf('a'));//-1 console.log(name.indexOf('m'));//2&lt;/script&gt; subString 1234&lt;script&gt; var name=\"abcdef\"; console.log(name.substring(1,3));//bc [) 前包后不包&lt;/script&gt; 数组1var arr = [1,2,3,4,5]; 1.长度 1234&lt;script&gt; var arr = [1,2,3,4,5]; console.log(arr.length);//5&lt;/script&gt; 数组长度是可变的，如果给arr.length赋值，数组大小就会变化。 12345&lt;script&gt; const arr = [1, 2, 3, 4, 5]; arr.length = 10; console.log(arr.length);//10&lt;/script&gt; indexOf() 通过元素获得下标 1234&lt;script&gt; const arr = [1, 2, 3, 4, 5]; console.log(arr.indexOf(3));//2&lt;/script&gt; slice() 截取arr的一部分，返回一个新数组 1234&lt;script&gt; const arr = [1, 2, 3, 4, 5]; console.log(arr.slice(1,3));//[2, 3]&lt;/script&gt; push() pop() 从尾部插入数据/弹出尾部的数据 123456789&lt;script&gt; const arr = [1, 2, 3, 4, 5]; arr.push(6); arr.push(7); console.log(arr);//[1, 2, 3, 4, 5, 6, 7] arr.pop(); console.log(arr);//[1, 2, 3, 4, 5, 6]&lt;/script&gt; unshift() shift()从头部插入或弹出数据 1234567891011&lt;script&gt; const arr = [1, 2, 3, 4, 5]; //Inserts new elements at the start of an array, and returns the new length of the array. arr.unshift(6); arr.unshift(7); console.log(arr);//[7, 6, 1, 2, 3, 4, 5] //Removes the first element from an array and returns it. arr.shift(); console.log(arr);//[6, 1, 2, 3, 4, 5]&lt;/script&gt; sort() 12345&lt;script&gt; const arr = [5, 2, 6, 4, 1,3]; arr.sort(); console.log(arr);//[1, 2, 3, 4, 5, 6]&lt;/script&gt; reverse()元素反转 12345&lt;script&gt; const arr = [1, 2, 3, 4, 5, 6]; arr.reverse(); console.log(arr);//[6, 5, 4, 3, 2, 1]&lt;/script&gt; contact() 并没有修改原始数组，只是返回一个新数组 123456&lt;script&gt; const arr = [1, 2, 3, 4, 5, 6]; const arr2 = [7, 8, 9]; console.log(arr.concat(arr2));//[1, 2, 3, 4, 5, 6, 7, 8, 9] console.log(arr);//[1, 2, 3, 4, 5, 6]&lt;/script&gt; join() 12345&lt;script&gt; const arr = [1, 2, 3, 4, 5, 6]; console.log(arr.join(\"-\"));//1-2-3-4-5-6 console.log(arr);//[1, 2, 3, 4, 5, 6]&lt;/script&gt; 多维数组 对象对象就是若干个键值对，JavaScript中对象所有的键都是字符串，值是任意对象。 对象属性赋值 123456789&lt;script&gt; const person ={ name: \"summer\", age: 30, score: 80 } person.name = \"lucky\"; console.log(person);//{name: 'lucky', age: 30, score: 80}&lt;/script&gt; 使用一个不存在的对象属性，不会报错 动态的删减属性 动态添加属性 判断一个属性是否存在于这个对象中 判断一个属性是否是这个对象自身拥有的 流程控制if判断12345678&lt;script&gt; const name = \"summer\"; if(name.indexOf(\"m\") &gt; -1){ console.log(\"yes\"); }else{ console.log(\"no\"); }&lt;/script&gt; 1yes while循环1234567&lt;script&gt; let i = 10; while (i &gt; 0){ console.log(i); i--; }&lt;/script&gt; for循环12345678910111213141516171819202122232425&lt;script&gt; const array = [1, 2, 3, 4, 5]; //普通for console.log(\"=================\"); for (let i = 0; i &lt; array.length; i++) { console.log(array[i]); } //for...in... console.log(\"=================\"); for (const arrayKey in array) { console.log(arrayKey);//这个输出的是array各个值对应的key } console.log(\"=================\"); for (const arrayKey in array) { console.log(array[arrayKey]); } //for...of... console.log(\"=================\"); for (const number of array) { console.log(number); }&lt;/script&gt; foreach循环123456&lt;script&gt; const array = [1, 2, 3, 4, 5]; array.forEach(function (value){ console.log(value); });&lt;/script&gt; Map和Set (ES6新特性)1234&lt;script&gt; const map = new Map([[\"tom\", 90], [\"anny\", 85], [\"jack\", 95]]); console.log(map);// {'tom' =&gt; 90, 'anny' =&gt; 85, 'jack' =&gt; 95}&lt;/script&gt; Set：元素不重复的集合 1234&lt;script&gt; const set = new Set([1,2,3,2,5]); console.log(set);//{1, 2, 3, 5}&lt;/script&gt; Iterator作业：使用Iterator遍历Map和Set（使用for…of…或者for…in…）遍历数组 123456&lt;script&gt; const arr = [3, 4, 5]; for (let x of arr) { console.log(x); }&lt;/script&gt; 1234567&lt;script&gt; const arr = [3, 4, 5]; arr.name = \"halla\"; for (let number in arr) { console.log(number); }&lt;/script&gt; 遍历Map 123456&lt;script&gt; const map = new Map([[\"tom\", 90], [\"anny\", 85], [\"jack\", 95]]); for (const mapElement of map) { console.log(mapElement); }&lt;/script&gt; 遍历Set 123456&lt;script&gt; const set = new Set([1,2,3]); for (const number of set) { console.log(number); }&lt;/script&gt; 函数定义函数12345678910&lt;script&gt; //方式一 function abs(x) { if(x &gt;= 0){ return x; }else{ return -x; } }&lt;/script&gt; 1234567891011&lt;script&gt; //方式二 //function (x)是一个匿名函数，把结果赋给abs，通过abs就可以访问函数 const abs = function (x) { if (x &gt;= 0) { return x; } else { return -x; } };&lt;/script&gt; 调用函数1234abs(-8) //8abs(9) //9abs(10,123,456,789) //10 //参数问题，可以传入任意个参数abs() //NaN 参数问题如何规避？ 不存在参数 12345678910111213&lt;script&gt; //function (x)是一个匿名函数，把结果赋给abs，通过abs就可以访问函数 const abs = function (x) { if(typeof x != \"number\"){ console.log(\"参数格式不对，请重新传入参数\") } if (x &gt;= 0) { return x; } else { return -x; } };&lt;/script&gt; arguments arguments代表传递进来的所有参数，是一个数组 问题：abs(x, y, z) arguments会获取到包括x在内的所有参数的值，所以如果想要得到y的值，必须先拿到x的值 1234567891011121314151617&lt;script&gt; //function (x)是一个匿名函数，把结果赋给abs，通过abs就可以访问函数 const abs = function (x) { if(typeof x != \"number\"){ console.log(\"参数格式不对，请重新传入参数\") } if(arguments.length &gt; 1){ console.log(\"传入的参数值多于一个\") } if (x &gt;= 0) { return x; } else { return -x; } };&lt;/script&gt; rest rest参数只能写在最后，用…标识 1234567&lt;script&gt; const abs = function (x, y, ...z) { console.log(\"x=\" + x); console.log(\"y=\" + y); console.log(\"z=\" + z); };&lt;/script&gt; 变量的作用域1234567&lt;script&gt; function getNum() { var x = 1; x = x+1; } x = x+2;//Uncaught ReferenceError: x is not defined&lt;/script&gt; 1234567891011&lt;script&gt; function a() { const x = 1; function b() { const y = x + 1; console.log(\"y=\" + y);//y=2 }; return b(); const z = y + 1;//Uncaught ReferenceError: y is not defined }&lt;/script&gt; 全局变量12345678910&lt;script&gt; function a() { var x = 1; function f(){ console.log(x); } f(); console.log(x); }&lt;/script&gt; 123a()11 全局对象window1234&lt;!-- alert(str) 等价于 alert(window.str) --&gt;&lt;script&gt; var str = 123;&lt;/script&gt; 测试全局对象12345678910&lt;script&gt; var str = 123; window.alert(str); //123 var old_alert = window.alert; old_alert(str); //123 window.alert = function (x){ alert(x); //Uncaught RangeError: Maximum call stack size exceeded } window.alert(\"456\");&lt;/script&gt; 123456789&lt;script&gt; var str = 123; window.alert(str); //123 var old_alert = window.alert; old_alert(str); //123 window.alert = function (){ } window.alert(456); //没有任何弹出信息&lt;/script&gt; 123456789101112&lt;script&gt; var str = 123; window.alert(str); //123 var old_alert = window.alert; old_alert(str); //123 window.alert = function (){ } window.alert(456); //没有任何弹出信息 window.alert = old_alert; window.alert(789); //789&lt;/script&gt; 规范所有的全局变量都会绑定到window上，如果不同的文件用了同样的全局变量，就会冲突。 解决方案：定义唯一命名空间 12345678910&lt;script&gt; //唯一全局命名空间 var kuangstudy = []; //定义全局变量 kuangstudy.name = \"java\"; kuangstudy.add = function (a, b) { return a + b; }&lt;/script&gt; 局部作用域letES6之后引入了let，为了解决局部作用域冲突的问题。 用var定义变量 12345678&lt;script&gt; function aaa(){ for (var i = 0; i&lt;5; i++){ console.log(i); } console.log(i);//之前老师讲课的时候，这里是可以输出i的值的，但是我今天测试发现不能输出，会报undefined错误，应该是JS底层什么东西改了导致的。 }&lt;/script&gt; 用let定义变量 12345678&lt;script&gt; function aaa(){ for (let i = 0; i&lt;5; i++){ console.log(i); } console.log(i);//Uncaught ReferenceError: i is not defined }&lt;/script&gt; 常量constES6之前如何定义常量？123456&lt;script&gt; var PI = 3.14; console.log(PI);//3.14 PI = 3.15; console.log(PI);//3.15 常量PI的值被改变了&lt;/script&gt; ES6之后，引入了const 方法定义方法方法：把函数放在对象内部，对象只有两个东西，一个是属性，一个是方法。 1234567891011121314&lt;script&gt; const kuangshen = { name: \"kuang\", birth: 2020, age: function () { const now = new Date().getFullYear(); return now - this.birth; } }; //调用属性 console.log(kuangshen.name);//kuang //调用方法 console.log(kuangshen.age());//3&lt;/script&gt; 上面这段代码里面的this代表什么？ 123456789101112131415161718&lt;script&gt; function getAge() { const now = new Date().getFullYear(); return now - this.birth; } const kuangshen = { name: \"kuang\", birth: 2020, age: getAge }; //this默认指向调用它的那个对象 console.log(kuangshen.age());//3 //这里this指向了window对象，但是window对象没有birth属性，所以获取到的内容是NaN console.log(window.getAge());//NaN&lt;/script&gt; apply在js中可以控制this的指向！ 123456789101112131415&lt;script&gt; function getAge() { const now = new Date().getFullYear(); return now - this.birth; } const kuangshen = { name: \"kuang\", birth: 2020, age: getAge }; console.log(window.getAge.apply(kuangshen, []));//3 //this指向kuangshen，参数为空 console.log(window.getAge().apply(kuangshen, []));//Uncaught TypeError: window.getAge(...).apply is not a function &lt;/script&gt; 内部对象标准对象 Date基本使用1234567891011&lt;script&gt; const now = new Date(); console.log(\"年： \" + now.getFullYear()); console.log(\"月： \" + now.getMonth()); console.log(\"日： \" + now.getDate()); console.log(\"星期： \" + now.getDay()); console.log(\"时： \" + now.getHours()); console.log(\"分： \" + now.getMinutes()); console.log(\"秒： \" + now.getSeconds()); console.log(\"时间戳： \" + now.getTime());//时间戳是全世界统一的&lt;/script&gt; 12345678年： 2023月： 0日： 11星期： 3时： 10分： 36秒： 41时间戳： 1673404601231 转换1234567&lt;script&gt; //时间戳转换为Date对象 now = new Date(1673404601231); console.log(now); console.log(now.toLocaleString()); console.log(now.toUTCString());&lt;/script&gt; 123Wed Jan 11 2023 10:36:41 GMT+0800 (中国标准时间)2023/1/11 10:36:41Wed, 11 Jan 2023 02:36:41 GMT JSONJSON是什么？JSON是一个标记符的序列。这套标记符包含六个构造字符、字符串、数字和三个字面名。JSON是一个序列化的对象或数组。 六个构造字符：begin-array = ws %x5B ws ; [ 左方括号begin-object = ws %x7B ws ; { 左大括号end-array = ws %x5D ws ; ] 右方括号end-object = ws %x7D ws ; } 右大括号name-separator = ws %x3A ws ; : 冒号value-separator = ws %x2C ws ; , 逗号 在这六个构造字符的前或后允许存在无意义的空白符(ws):ws = *（%x20 /; 空间%x09 /; 水平标签%x0A /; 换行或换行%x0D）; 回程 JSON的构成:值可以是对象、数组、数字、字符串或者三个字面值(false、null、true)中的一个。值中的字面值中的英文必须使用小写。 对象由花括号括起来的逗号分割的成员构成，成员是字符串键和上文所述的值由逗号分割的键值对组成，如： 1{\"name\": \"John Doe\", \"age\": 18, \"address\": {\"country\" : \"china\", \"zip-code\": \"10000\"}} JSON中的对象可以包含多个键值对，并且有数组结构，该语言正是一次实现过程内容的描述。 数组是由方括号括起来的一组值构成，如： 1[3, 1, 4, 1, 5, 9, 2, 6] 字符串与C或者Java的字符串非常相似。字符串是由双引号包围的任意数量Unicode字符的集合，使用反斜线转义。一个字符（character）即一个单独的字符串（character string）。 数字也与C或者Java的数值非常相似。除去未曾使用的八进制与十六进制格式。除去一些编码细节。 一些合法的JSON的实例： 1{\"a\": 1, \"b\": [1, 2, 3]} 1[1, 2, \"3\", {\"a\": 4}] 13.14 1\"plain_text\" JSON和JS对象的区别？JSON 与 JS 对象的关系JSON 是 JS 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。 1var obj = {a: 'Hello', b: 'World'}; //这是一个对象，注意键名也是可以使用引号包裹的 1var json = '{\"a\": \"Hello\", \"b\": \"World\"}'; //这是一个 JSON 字符串，本质是一个字符串 JSON 和 JS 对象互转从JSON字符串转换为JS对象，使用 JSON.parse() 方法： 1var obj = JSON.parse('{\"a\": \"Hello\", \"b\": \"World\"}'); //结果是 {a: 'Hello', b: 'World'} 从JS对象转换为JSON字符串，使用 JSON.stringify() 方法： 1var json = JSON.stringify({a: 'Hello', b: 'World'}); //结果是 '{\"a\": \"Hello\", \"b\": \"World\"}' Ajax原生JS写法 xhr异步请求JQuery封装好的方法 $(“#name”).ajax(“”)axios面向对象编程什么是面向对象？类：模板 对象：具体的实例 在JavaScript中，这个需要换一个思维方式。 原型：","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://xiaofanshutu.github.io/categories/Javascript/"}],"tags":[],"author":"cutiebambi"},{"title":"Java Web","slug":"Java Web","date":"2022-06-12T00:31:41.000Z","updated":"2024-01-17T23:39:22.939Z","comments":true,"path":"posts/fb60fea1.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/fb60fea1.html","excerpt":"","text":"Java Web基本概念基本概念 用Java开发网页的技术统称为JavaWeb。 web程序：可以提供浏览器访问的程序； web应用分两种: 静态web资源（如html 页面）： 指web页面中的数据始终是不变。 所有用户看到都是同一个页面。 技术：HTML、CSS。 动态web资源： 指web页面中的浏览的数据是由服务器提供的。 所有用户看到都是同一个页面。 技术：JSP/Servlet、ASP、PHP等。 web应用程序编写完毕后，若想提供给外界访问：需要一个服务器来统一管理； web服务器常见的web的服务器： Apache Nginx IIS WebLogic WebSphere Tomcat Tomcat 因为技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。 Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和 并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP程序的首选。对于一个Java初学web的人来说，它是最佳的选择。 Tomcat安装tomcattomcat官网：http://tomcat.apache.org/ 1、选择合适在的压缩包 2、下载压缩包并解压 Tomcat启动和配置 启动tomcat，然后访问http://localhost:8080/测试 可能遇到的问题： Java环境变量没有配置 闪退问题：需要配置兼容性 乱码问题：配置文件中设置 配置 可以配置启动的端口号 123&lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt; tomcat默认端口号：8080 mysql默认端口号：3306 http默认端口号：80 https默认端口号：443 可以配置主机的名称 12&lt;Host name=\"localhost\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\"&gt; 默认的主机名称为：localhost-&gt;127.0.0.1 默认网站应用存放的位置为：webapps 面试题 请你谈谈网站是如何访问的。 输入一个域名，回车 检查本机的hosts配置文件下有没有这个域名映射 有：直接返回对应的ip地址，这个地址中，有我们要访问的web程序，可以直接访问。 1127.0.0.1 localhost 没有：去DNS服务器找，找到的话返回，找不到就返回找不到。 发布一个web网站将自己写的网站，放到服务器(Tomcat)中指定的web应用的文件夹（webapps）下，就可以访问了 网站应该有的结构 1234567891011121314--webapps：Tomcat服务器的web目录 -ROOT -betterme：自己新建的网站的目录名 -WEB-INF -classes: java程序 -lib：web应用所依赖的jar包 -web.xml：网站配置文件 - index.html：默认的首页 - static -css -style.css -js -img -..... Http什么是HTTP超文本传输协议（Hyper Text Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上。 文本：html，字符串，~ …. 超文本：图片，音乐，视频，定位，地图……. 默认端口：80 HTTPS （全称：Hyper Text Transfer Protocol over SecureSocket Layer），是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性 。HTTPS 在HTTP 的基础下加入SSL，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。 默认端口：443 两个时代 http1.0 HTTP/1.0：客户端与web服务器连接后，只能获得一个web资源。 http2.0 HTTP/1.1：客户端与web服务器连接后，可以获得多个web资源。 Http请求 客户端——发请求（Request）—–服务器 General 12345Request URL: https://www.baidu.com/ 请求地址Request Method: GET 请求方式，一般是GET/POSTStatus Code: 200 OK 状态码：200表示成功，404表示没有找到资源，500表示服务器错误Remote Address: 36.152.44.96:443 远程地址Referrer Policy: strict-origin-when-cross-origin 12345Accept: text/htmlAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,zh-TW;q=0.8Cache-Control: privateConnection: keep-alive 请求行（request line） 请求方式：GET, POST, HEAD, DELETE, PUT, TRACT GET: 请求能都携带的参数比较少，大小没有限制，会在浏览器的URL地址栏显示数据内容，不安全，但是高效。 POST：请求能够携带的参数没有限制，大小没有限制，不会在浏览器URL地址栏中显示数据内容，安全，但不高效。 消息头12345Accept: 告诉浏览器，它所支持的数据类型Accept-Encoding: 支持哪种编码格式 GBK UTF-8Accept-Language: 告诉浏览器，它的语言环境Cache-Control: 缓存控制Connection: 告诉浏览器，请求完成是断开还是保持连接 Http响应服务器—–响应—–客户端 Response Headers 1234Cache-Control: private 缓存控制Connection: keep-alive 连接Content-Encoding: gzip 编码Content-Type: text/html;charset=utf-8 HTTP请求的完全过程：https://blog.csdn.net/ailunlee/article/details/90600174 响应体12345678Accept：告诉浏览器，它所支持的数据类型Accept-Encoding：支持哪种编码格式 GBK UTF-8 GB2312 ISO8859-1Accept-Language：告诉浏览器，它的语言环境Cache-Control：缓存控制Connection：告诉浏览器，请求完成是断开还是保持连接HOST：主机Refresh：告诉客户端，多久刷新一次；Location：让网页重新定位； 响应状态码200：请求响应成功 3xx：请求重定向 重定向：你重新到我给你的位置去。 4xx：找不到资源 404 5xx：服务器代码错误 500 502 面试题：当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示出来，经历了什么？ Maven为什么要学习这个技术？ 在Java Web开发中，需要使用大量的jar包，我们手动去导入； 如何能够让一个东西自动帮我导入和配置这个jar包。 由此，Maven诞生了！ Maven项目架构管理工具我们目前用它就是为了方便导入jar包的！ Maven的核心思想：约定大于配置 有约束，不要去违反 下载安装Maven官网: https://maven.apache.org/ 下载完成后，解压即可； 配置环境变量在系统环境变量中，配置以下配置： M2_HOME (maven的目录下的bin目录) MAVEN_HOME (maven的目录) 在系统的path中添加 %MAVEN_HOME%\\bin 配置完成后，测试maven是否安装成功。 配置阿里云加速镜像使用阿里云Maven中央仓库作为下载源，速度更快更稳定。 maven 安装目录的 conf/settings.xml 在&lt;mirrors&gt;&lt;/mirrors&gt;标签中添加 mirror子节点 12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 本地仓库修改本地的仓库存放位置 maven 安装目录的 conf/settings.xml 在&lt;settings&gt;&lt;/settings&gt;标签中添加 localRepository子节点，按个人习惯存放。 1&lt;localRepository&gt;D:\\Tools\\apache-maven-3.8.5\\maven_repo&lt;/localRepository&gt; 在IDEA中使用Maven1、启动IDEA 2、 创建一个MavenWeb项目 3、等待项目初始化完毕 4、检查IDEA中的Maven设置 6、到这里，Maven在IDEA中的配置和使用就OK了! 创建一个普通的Maven项目 只有在Web应用下才有的项目结构 标记文件夹功能 在 IDEA中配置Tomcat1、添加tomcat 2、相关配置 3、启动tomcat pom文件pom.xml 是Maven的核心配置文件. 记录了项目具体依赖的Jar包的配置版本。 maven由于它是约定大于配置，有时候会遇到写的配置文件不生效的问题。 解决方案： 123456789101112131415161718192021&lt;!--在build中配置resources，来防止我们资源导出失败的问题--&gt;&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; Maven仓库的使用地址：https://mvnrepository.com ServletServlet简介Servlet用java语言开发动态资源网站的技术。 把实现了Servlet接口的Java程序叫做，Servlet servlet生成的class文件存放在tomcat中webapps目录下。 HelloServletSerlvet接口有两个默认的实现类：HttpServlet，GenericServlet 1、构建一个普通的Maven项目，删掉里面的src目录，以后我们的学习就在这个项目里面建立 Module；这个空的工程就是Maven主工程； 2、 关于Maven父子工程的理解： 父工程会显示子工程的信息。 子工程会继承父工程。 3、编写一个Servlet程序 3.1、在父工程引用相关的Jar包 123456789101112&lt;!-- servlet --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- jsp --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.3.3&lt;/version&gt;&lt;/dependency&gt; 3.2、编写一个普通类，继承HttpServlet 123456789101112131415package com.betterme;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class HelloServlet extends HttpServlet { @Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException { response.setContentType(\"text/html; charset=utf-8\"); response.getWriter().print(\"Hello,小番薯兔\"); }} 3.3、Servlet的映射 为什么需要映射：我们写的是JAVA程序，但是要通过浏览器访问，而浏览器需要连接web服务器， 所以我们需要再web服务中注册我们写的Servlet，让浏览器找到我们java程序的发布目录 12345678910&lt;!--注册Servlet--&gt;&lt;servlet&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;servlet-class&gt;com.betterme.HelloServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!--Servlet的请求路径--&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/betterme&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 3.4、配置Tomcat，并访问。 Servlet原理Servlet是由Web服务器调用。 Servlet映射问题1、一个Servlet可以指定一个映射路径 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 2、一个Servlet可以指定多个映射路径 1234567891011121314&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello2&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello3&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 3、一个Servlet可以指定通用映射路径 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 4、默认请求路径 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 5、指定一些后缀或者前缀等等… 12345&lt;!-- 注意，*前面不能加项目映射的路径--&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;*.demo&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 6、优先级问题指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求； 12345678910111213141516171819&lt;!--但是如果你在地址栏输入/hello, 也是能访问到HelloServlet的, 这就是因为固有的映射路径优先级最高--&gt;&lt;servlet&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;servlet-class&gt;com.betterme.HelloServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!--这里配置的是/*, 所以默认会进入error--&gt;&lt;servlet&gt; &lt;servlet-name&gt;error&lt;/servlet-name&gt; &lt;servlet-class&gt;com.betterme.ErrorServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;error&lt;/servlet-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; ServletContextweb容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext对象，它代表了当前的 web应用； 共享数据在一个Servlet中保存的数据，可以在另外一个servlet中拿到； 12345678910111213141516package com.betterme;import javax.servlet.ServletContext;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class HelloServlet extends HttpServlet { @Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException { ServletContext servletContext = this.getServletContext(); servletContext.setAttribute(\"name\", \"小番薯兔\"); }} 1234567891011121314151617package com.betterme;import javax.servlet.ServletContext;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class GetServlet extends HttpServlet { @Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException { ServletContext servletContext = this.getServletContext(); response.setContentType(\"text/html; charset=utf-8\"); response.getWriter().print(\"name:\" + servletContext.getAttribute(\"name\")); }} 1234567891011121314151617&lt;servlet&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;servlet-class&gt;com.betterme.HelloServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet&gt; &lt;servlet-name&gt;get&lt;/servlet-name&gt; &lt;servlet-class&gt;com.betterme.GetServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;get&lt;/servlet-name&gt; &lt;url-pattern&gt;/get&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 测试访问结果: 先访问hello路径保存数据到ServletContext 再访问get路径获取上面保存的数据 获取初始化参数12345678910111213&lt;context-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;12345&lt;/param-value&gt;&lt;/context-param&gt;&lt;servlet&gt; &lt;servlet-name&gt;get&lt;/servlet-name&gt; &lt;servlet-class&gt;com.betterme.GetInitParamServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;get&lt;/servlet-name&gt; &lt;url-pattern&gt;/get&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 1234567891011121314151617package com.betterme;import javax.servlet.ServletContext;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class GetInitParamServlet extends HttpServlet { @Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException { ServletContext servletContext = this.getServletContext(); response.setContentType(\"text/html; charset=utf-8\"); response.getWriter().print(servletContext.getInitParameter(\"password\")); }} 请求转发123456789101112131415161718package com.bambi.servlet;import javax.servlet.RequestDispatcher;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class DispatcherServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { ServletContext context = this.getServletContext(); RequestDispatcher requestDispatcher = context.getRequestDispatcher(\"/hello\");// 请求转发的路径 requestDispatcher.forward(req, resp); }} 1234567891011121314151617package com.bambi.servlet;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"进入HelloServlet doGet方法\"); ServletContext servletContext = this.getServletContext(); servletContext.setAttribute(\"name\", \"summer\"); }} 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;context-param&gt; &lt;param-name&gt;hobby&lt;/param-name&gt; &lt;param-value&gt;climbing&lt;/param-value&gt; &lt;/context-param&gt; &lt;servlet&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;servlet-class&gt;com.bambi.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;com.bambi.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/dispatcher&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 访问/dispatcher的时候，经过转发，实际会访问/hello.但是url不会改变 读取资源文件123456789101112131415161718192021package com.bambi.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.InputStream;import java.util.Properties;public class ReadPropertiesServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { InputStream resourceAsStream = this.getServletContext().getResourceAsStream(\"/WEB-INF/classes/db.properties\"); Properties properties = new Properties(); properties.load(resourceAsStream); String userName = properties.getProperty(\"userName\"); String password = properties.getProperty(\"password\"); resp.getWriter().print(userName + \": \" + password); }} 12userName= summerpassword= 12345 12345678&lt;servlet&gt; &lt;servlet-name&gt;read&lt;/servlet-name&gt; &lt;servlet-class&gt;com.bambi.servlet.ReadPropertiesServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;read&lt;/servlet-name&gt; &lt;url-pattern&gt;/read&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; java文件和resources目录下的文件都打包在了classes文件夹里面，这个文件夹我们俗称为classpath。 HttpServletResponseweb服务器接收到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest对象，代表响应的一个HttpServletResponse； 获取客户端请求过来的参数：HttpServletRequest 响应客户端响应一些信息：HttpServletResponse 简单分类负责向浏览器发送数据的方法 12ServletOutputStream getOutputStream() throws IOException;PrintWriter getWriter() throws IOException; 负责向浏览器发送响应头的方法 12345678910void setCharacterEncoding(String var1);void setContentLength(int var1);void setContentLengthLong(long var1);void setContentType(String var1);void setDateHeader(String var1, long var2);void addDateHeader(String var1, long var2);void setHeader(String var1, String var2);void addHeader(String var1, String var2);void setIntHeader(String var1, int var2);void addIntHeader(String var1, int var2); 响应的状态码 12345int SC_OK = 200;int SC_MULTIPLE_CHOICES = 300;int SC_BAD_REQUEST = 400;int SC_NOT_FOUND = 404;int SC_INTERNAL_SERVER_ERROR = 500; 常见应用验证码功能1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.*;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;public class ImageServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //让浏览器3秒刷新一次 resp.setHeader(\"refresh\", \"3\"); //在内存中创建一个图片 BufferedImage bufferedImage = new BufferedImage(80, 20, BufferedImage.TYPE_INT_RGB); //得到图片 Graphics2D graphics = (Graphics2D) bufferedImage.getGraphics(); //设置图片背景颜色 graphics.setBackground(Color.white); graphics.fillRect(0, 0, 80, 20); //给图片写数据 graphics.setColor(Color.red); graphics.setFont(new Font(null, Font.BOLD, 20)); graphics.drawString(generateNum(), 0, 20); resp.setContentType(\"image/png\"); resp.setDateHeader(\"expires\", -1); resp.setHeader(\"Cache-Control\", \"no-cache\"); //把图片写给浏览器 ImageIO.write(bufferedImage, \"png\", resp.getOutputStream()); } private String generateNum() { Random random = new Random(); String num = random.nextInt(9999999) + \"\"; StringBuffer stringBuffer = new StringBuffer(); for (int i = 0; i &lt; 7 - num.length(); i++) { stringBuffer.append(\"0\"); } num = stringBuffer.toString() + num; return num; }} 12345678&lt;servlet&gt;&lt;servlet-name&gt;randomNum&lt;/servlet-name&gt;&lt;servlet-class&gt;ImageServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;randomNum&lt;/servlet-name&gt;&lt;url-pattern&gt;/randomNum&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 下载文件 获取下载文件的路径 下载的文件名是什么 想办法让浏览器能够支持下载我们需要的东西 获取下载文件的输入流 获取OutputStream对象 将FileOutputStream流写入到buffer缓冲区 xxxxxxxxxx&nbsp;– listing properties –name=DB02pwd=130.133.13.14java 123456789101112131415161718192021222324252627282930import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.FileInputStream;import java.io.IOException;public class DownloadPicServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String realPath = this.getServletContext().getRealPath(\"/WEB-INF/classes/test.png\"); System.out.println(\"需要下载的文件的路径是\" + realPath); String fileName = realPath.substring(realPath.lastIndexOf(\"\\\\\") + 1); resp.setHeader(\"Content-disposition\", \"attachment;filename=\" + fileName); FileInputStream fileInputStream = new FileInputStream(realPath); int len = 0; byte[] buffer = new byte[1024]; ServletOutputStream outputStream = resp.getOutputStream(); while ((len = fileInputStream.read(buffer)) != -1) { outputStream.write(buffer, 0, len); } fileInputStream.close(); outputStream.close(); }} 12345678&lt;servlet&gt; &lt;servlet-name&gt;downloadPic&lt;/servlet-name&gt; &lt;servlet-class&gt;DownloadPicServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;downloadPic&lt;/servlet-name&gt; &lt;url-pattern&gt;/downloadPic&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 在地址栏输入downloadPic 回车 文件下载成功 如果文件名是中文，那么用URLEncoder.encode(fileName, “utf8”)把文件名转一下，要不可能会出现乱码 12345678910111213141516171819202122232425262728293031import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.FileInputStream;import java.io.IOException;import java.net.URLEncoder;public class DownloadPicServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String realPath = this.getServletContext().getRealPath(\"/WEB-INF/classes/测试中文文件名.png\"); System.out.println(\"需要下载的文件的路径是\" + realPath); String fileName = realPath.substring(realPath.lastIndexOf(\"\\\\\") + 1); resp.setHeader(\"Content-disposition\", \"attachment;filename=\" + URLEncoder.encode(fileName, \"utf8\")); FileInputStream fileInputStream = new FileInputStream(realPath); int len = 0; byte[] buffer = new byte[1024]; ServletOutputStream outputStream = resp.getOutputStream(); while ((len = fileInputStream.read(buffer)) != -1) { outputStream.write(buffer, 0, len); } fileInputStream.close(); outputStream.close(); }} 转发与重定向转发流程： 实现代码： 1request.getRequestDispatcher(\"/地址\").forward(request, response); 重定向流程： 实现代码 1response.sendRedirect(\"/地址\"); 123456789101112import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class RedirectServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.sendRedirect(\"/servlet_05_war/randomNum\"); }} 12345678&lt;servlet&gt; &lt;servlet-name&gt;redirect&lt;/servlet-name&gt; &lt;servlet-class&gt;RedirectServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;redirect&lt;/servlet-name&gt; &lt;url-pattern&gt;/redirect&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 1234567891011121314151617import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class Request extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //处理请求 String userName = req.getParameter(\"userName\"); String password = req.getParameter(\"password\"); System.out.println(userName + \":\" + password); //重定向一定要注意路径问题 resp.sendRedirect(\"/servlet_05_war/success.jsp\"); }} 12345678&lt;servlet&gt; &lt;servlet-name&gt;request&lt;/servlet-name&gt; &lt;servlet-class&gt;Request&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;request&lt;/servlet-name&gt; &lt;url-pattern&gt;/login&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; index.jsp 12345678910&lt;html&gt; &lt;body&gt; &lt;%--这里提交的路径，需要寻找到项目的路径--%&gt; &lt;form action=\"${pageContext.request.contextPath}/login\" method=\"get\"&gt; UserName:&lt;input type=\"text\" name=\"userName\"&gt; &lt;br&gt; Password:&lt;input type=\"password\" name=\"password\"&gt; &lt;br&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; success.jsp 1234567&lt;html&gt; &lt;body&gt; &lt;h1&gt;success~&lt;/h1&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 如果Request类不加重定向代码，那么submit之后就会进入一个空白页面，在路径上会把填写的userName和password打出来。 如果Request类加了重定向代码，那么submit之后就会进入重定向后的页面。 HttpServletRequestHttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，HTTP请求中的所有信息会被封装到HttpServletRequest，通过这个HttpServletRequest的方法，获得客户端的所有信息； 1//获取参数request.getParameter(\"p1\");request.getParameterValues(\"p2\");//设置request编码为UTF-8request.setCharacterEncoding(\"UTF-8\"); 获取前端传递的参数并且实现请求转发工程目录结构 12345678910111213141516171819202122232425262728293031import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Arrays;public class LoginServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.setCharacterEncoding(\"utf-8\"); resp.setCharacterEncoding(\"utf-8\"); //获取前台表单数据 String userName = req.getParameter(\"userName\"); String password = req.getParameter(\"password\"); String[] hobbies = req.getParameterValues(\"hobby\"); System.out.println(Arrays.toString(hobbies)); //请求转发 //这里的/指的是当前的web应用 req.getRequestDispatcher(\"/success.jsp\").forward(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); }} web.xml 12345678&lt;servlet&gt; &lt;servlet-name&gt;login&lt;/servlet-name&gt; &lt;servlet-class&gt;LoginServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;login&lt;/servlet-name&gt; &lt;url-pattern&gt;/login&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; index.jsp 123456789101112131415161718192021&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Login Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"${pageContext.request.contextPath}/login\" method=\"post\"&gt; 用户名：&lt;input type=\"text\" name=\"userName\"&gt; &lt;br&gt; 密码：&lt;input type=\"password\" name=\"password\"&gt; &lt;br&gt; 爱好：&lt;input type=\"checkbox\" name=\"hobby\" value=\"跑步\"&gt;跑步 &lt;input type=\"checkbox\" name=\"hobby\" value=\"阅读\"&gt;阅读 &lt;input type=\"checkbox\" name=\"hobby\" value=\"编程\"&gt;编程 &lt;input type=\"checkbox\" name=\"hobby\" value=\"听音乐\"&gt;听音乐 &lt;input type=\"checkbox\" name=\"hobby\" value=\"爬山\"&gt;爬山 &lt;br&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; success.jsp 123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Login Success Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Login success~&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; ==请求转发和重定向的区别== 相同点 页面都会实现跳转 不同点 请求转发的时候，url不会产生变化；307 重定向的时候，url地址栏会发生变化；302 Cookie &amp; Session会话用户打开一个 浏览器，点击了很多 超链接，访问多个web资源，关闭浏览器，这个过程可以称之为会话。 ==有状态会话==： 1、 服务端给客户端一个标识，客户端带上标识访问服务端即可: cookie 2、 服务器登记你来过了，下次你来的时候我来匹配你: seesion 保存会话的两种技术Cookie 1客户端技术 （响应，请求） Session 1服务器技术，利用这个技术，可以保存用户的会话信息。我们可以把信息或者数据放在Session中。 常见常见：网站登录之后，你下次不用再登录了，第二次访问直接就上去了！ Cookie什么是Cookie访问网站的时候，Cookie会在客户端保存。一般会保存在本地的 用户目录下 appdata； 1、访问网站时，服务器会返回cookie信息。 2、客户端访问服务器时，需要带上cookie，方便知道你是谁。 关于Cookie的细节问题 一个Cookie只能保存一个信息； 一个web站点可以给浏览器发送多个cookie，每个站点最多存放20个cookie； Cookie大小有限制4kb； 300个cookie浏览器上限 删除Cookie 不设置有效期，关闭浏览器，自动失效； 设置有效期时间为 0 ； 1cookie.setMaxAge(0); 中文编码解码12URLEncoder.encode(\"小番薯兔\", \"utf-8\");URLDecoder.decode(cookie.getValue(), \"utf-8\"); 练习12345678910111213141516171819202122232425262728293031323334353637383940414243package com.betterme.servlet;import javax.servlet.ServletException;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.util.Date;//保存用户上一次访问的时间public class CookieDemo01 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.setCharacterEncoding(\"utf-8\"); resp.setCharacterEncoding(\"utf-8\"); resp.setContentType(\"text/html;charset=utf-8\"); PrintWriter out = resp.getWriter(); //Cookie,服务器端从客户端获取。 Cookie[] cookies = req.getCookies();//这里返回数组，说明Cookie可能存在多个。 //判断Cookie是否存在 if (cookies != null) { out.print(\"你上一次访问这个网站的时间是：\"); for (Cookie cookie : cookies) { if (cookie.getName().equals(\"lastLoginTime\")) { //获取cookie中的值 long l = Long.parseLong(cookie.getValue()); Date date = new Date(l); out.write(date.toString()); } } } else { out.write(\"这是你第一次访问这个网站\"); } //服务器给客户端响应一个Cookie Cookie cookie = new Cookie(\"lastLoginTime\", System.currentTimeMillis() + \"\"); cookie.setMaxAge(24*60*60);//设置cookie过期时间 resp.addCookie(cookie); }} 12345678&lt;servlet&gt; &lt;servlet-name&gt;cookieDemo01&lt;/servlet-name&gt; &lt;servlet-class&gt;com.betterme.servlet.CookieDemo01&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;cookieDemo01&lt;/servlet-name&gt; &lt;url-pattern&gt;/cookieDemo01&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; https://gitee.com/xiaofanshutugoon/cloudimage/raw/master/img/snipaste_20220517_080641.png Session（重点）什么是Session 服务器会给每一个用户（浏览器）创建一个Seesion对象； 一个Seesion独占一个浏览器，只要浏览器没有关闭，这个Session就存在； 用户登录之后，整个网站他都可以访问！—&gt; Session的应用：保存用户的信息；用户的权限等等 Session和Cookie的区别 Cookie是把用户的数据写给用户的浏览器，浏览器保存 （可以保存多个） Session把用户的数据写到用户独占Session中，服务器端保存 （保存重要的信息，减少服务器资源的浪费） Session对象由服务器创建； 使用场景 保存一个登录用户的信息； 在整个网站中经常会使用的数据，我们将它保存在Session中； Session常用方法123456789101112//得到SessionHttpSession session = req.getSession();//给Session中存数据session.setAttribute(\"name\",\"admin\");//获取Session中的数据session.getAttribute(\"name\");//删除Session中的数据session.removeAttribute(\"name\");//获取Session的IDString sessionId = session.getId()//手动注销SessionSessionsession.invalidate(); 练习1保存一个字符串到session 12345678910111213141516171819202122232425262728293031package com.betterme.servlet;import javax.servlet.ServletException;import javax.servlet.http.*;import java.io.IOException;public class SessionDemo01 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //解决乱码问题 req.setCharacterEncoding(\"utf-8\"); resp.setCharacterEncoding(\"utf-8\"); resp.setContentType(\"text/html;charset=utf-8\"); //得到session HttpSession session = req.getSession(); //给session中存数据 session.setAttribute(\"name\", \"小番薯兔\"); //获取session的ID String id = session.getId(); //判断session是不是新session if (session.isNew()) { resp.getWriter().write(\"session创建成功, ID:\" + id); } else { resp.getWriter().write(\"这个session在服务器中已经存在了, ID:\" + id); } }} 用SessionDemo02获取SessionDemo01保存在session中的字符串 12345678910111213141516171819package com.betterme.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class SessionDemo02 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.setCharacterEncoding(\"utf-8\"); resp.setCharacterEncoding(\"utf-8\"); resp.setContentType(\"text/html;charset=utf-8\"); String name = (String) req.getSession().getAttribute(\"name\"); System.out.println(name); }} 练习2保存一个对象到session 12345678910111213141516171819202122232425262728293031323334package com.betterme.servlet;import com.betterme.servlet.pojo.Person;import javax.servlet.ServletException;import javax.servlet.http.*;import java.io.IOException;public class SessionDemo01 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //解决乱码问题 req.setCharacterEncoding(\"utf-8\"); resp.setCharacterEncoding(\"utf-8\"); resp.setContentType(\"text/html;charset=utf-8\"); //得到session HttpSession session = req.getSession(); //给session中存数据// session.setAttribute(\"name\", \"小番薯兔\"); session.setAttribute(\"person\", new Person(\"小番薯兔\", 23)); //获取session的ID String id = session.getId(); //判断session是不是新session if (session.isNew()) { resp.getWriter().write(\"session创建成功, ID:\" + id); } else { resp.getWriter().write(\"这个session在服务器中已经存在了, ID:\" + id); } }} 获取保存在session中的对象 123456789101112131415161718192021package com.betterme.servlet;import com.betterme.servlet.pojo.Person;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class SessionDemo02 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.setCharacterEncoding(\"utf-8\"); resp.setCharacterEncoding(\"utf-8\"); resp.setContentType(\"text/html;charset=utf-8\"); Person person = (Person) req.getSession().getAttribute(\"person\"); System.out.println(person); }} 练习3手动注销Session 123456789101112131415161718package com.betterme.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;public class SessionDemo03 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { HttpSession session = req.getSession(); session.removeAttribute(\"name\"); //手动注销Session session.invalidate(); }} 不同浏览器生成的sessionId是不同的。 手动清除session前 手动清除session后 会话自动过期12345&lt;!--设置Session默认的失效时间--&gt;&lt;session-config&gt; &lt;!--1分钟后Session自动失效，以分钟为单位--&gt; &lt;session-timeout&gt;1&lt;/session-timeout&gt;&lt;/session-config&gt; 1分钟后，刷新页面，重新生成了一个sessionId。 疑问：自动失效的这个，这个是只能让第一次的sessionId自动失效一次吗？经过测试，一旦重新生成了一个sessionId之后，这个sessionId就不会失效了。 下来查资料研究一下这里 JSP什么是JSPJava Server Pages(JSP)：Java服务器端页面，也和Servlet一样，用于动态Web技术！最大的特点： 写JSP就像在写HTML 区别： HTML只给用户提供静态的数据 JSP页面中可以嵌入JAVA代码，为用户提供动态数据； JSP原理学习思路：JSP到底是怎么执行的？ 代码层面没有任何问题 服务器内部工作 tomcat中有一个work目录； IDEA中使用Tomcat的会在IDEA的tomcat中生产一个work目录 浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet！ JSP最终也会被转换成为一个Java类！ JSP 本质上就是一个Servlet。 123public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase implements org.apache.jasper.runtime.JspSourceDependent, org.apache.jasper.runtime.JspSourceImports 1public abstract class HttpJspBase extends HttpServlet implements HttpJspPage 12345678910//初始化public void _jspInit() {}//销毁public void _jspDestroy() {}public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response) throws java.io.IOException, javax.servlet.ServletException { } 内置对象 12345678final javax.servlet.jsp.PageContext pageContext;//页面上下文javax.servlet.http.HttpSession session = null;//sessionfinal javax.servlet.ServletContext application;//applicationfinal javax.servlet.ServletConfig config;//configjavax.servlet.jsp.JspWriter out = null;//outfinal java.lang.Object page = this;//page 当前页HttpServletRequest request//请求HttpServletResponse response//响应 输出页面前增加的代码 12345678910111213try { response.setContentType(\"text/html\");//设置响应的页面类型 pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true); _jspx_page_context = pageContext; application = pageContext.getServletContext(); config = pageContext.getServletConfig(); session = pageContext.getSession(); out = pageContext.getOut(); _jspx_out = out;}以上的这些对象，我们可以在jsp页面上直接使用。 在JSP页面中，只要是java代码就会原封不动的输出，如果是html代码，就会被转换为out.write(“\\r\\n”); JSP基础语法任何语言都有自己的语法。 JSP 作为java技术的一种应用，它拥有一些自己扩充的语法（了解即可），可支持Java所有语法！ JSP表达式12345&lt;%-- JSP表达式 作用：用来将程序的输出，输出到客户端 &lt;%=变量或者表达式%&gt; --%&gt;&lt;%=new java.util.Date()%&gt; JSP脚本片段1234567891011121314151617181920212223242526272829&lt;%-- JSP脚本片段 作用：用来将程序的输出，输出到客户端 &lt;%=变量或者表达式%&gt; --%&gt;&lt;% int sum = 0; for (int i = 0; i &lt; 100; i++) { sum += i; } out.println(\"&lt;h1&gt;sum=\" + sum + \"&lt;/h1&gt;\");%&gt;&lt;% int x = 100; out.println(x);%&gt;&lt;p&gt;这是一个JSP文档&lt;/p&gt;&lt;% out.println(x);%&gt;&lt;%-- 在JSP代码中嵌入HTML元素 --%&gt;&lt;% for (int i = 0; i &lt; 3; i++) {%&gt;&lt;h2&gt;Hello Summer&lt;/h2&gt;&lt;% }%&gt; JSP声明12345678910&lt;!-- JSP声明 --&gt;&lt;%! static{ String message = \"Enjoy Every Day~\"; } private void testMethod(){ System.out.println(\"你好，明天~\"); }%&gt; JSP声明：会被编译到JSP生成Java的类中！其他的，就会被生成到_jspService方法中！ 在JSP，嵌入Java代码即可！ 1&lt;%%&gt;&lt;%=%&gt;&lt;%!%&gt;&lt;%--注释--%&gt; JSP的注释，不会在客户端显示，HTML注释就会！ JSP指令1234567891011&lt;%@page args.... %&gt;&lt;%@include file=\"\"%&gt;&lt;%--@include会将两个页面合二为一--%&gt;&lt;%@include file=\"common/header.jsp\"%&gt;&lt;h1&gt;网页主体&lt;/h1&gt;&lt;%@include file=\"common/footer.jsp\"%&gt;&lt;hr&gt;&lt;%--jSP标签jsp:include：拼接页面，本质还是三个--%&gt;&lt;jsp:include page=\"/common/header.jsp\"/&gt;&lt;h1&gt;网页主体&lt;/h1&gt;&lt;jsp:include page=\"/common/footer.jsp\"/&gt; 9大内置对象 PageContext Request Response Session Application —&gt; SerlvetContext config —&gt;SerlvetConfig out page ，不需要了解 exception 123456789101112131415161718192021222324252627282930313233343536&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%-- 内置对象 --%&gt;&lt;% pageContext.setAttribute(\"name1\", \"jack1\");//保存的数据只在一个页面中有效 request.setAttribute(\"name2\", \"jack2\");//保存的数据只在一次请求中有效，请求转发会携带这个数据 session.setAttribute(\"name3\", \"jack3\");//保存的数据只在一次会话中有效，从打开浏览器到关闭浏览器 application.setAttribute(\"name4\", \"jack4\");//保存的数据只在服务器中有效，从打开服务器到关闭服务器%&gt;&lt;%--脚本片段中的代码，会被原封不动的生成到.jsp_java--%&gt;&lt;% //从pageContext取出保存的值 String name1 = (String) pageContext.findAttribute(\"name1\"); String name2 = (String) pageContext.findAttribute(\"name2\"); String name3 = (String) pageContext.findAttribute(\"name3\"); String name4 = (String) pageContext.findAttribute(\"name4\"); String name5 = (String) pageContext.findAttribute(\"name5\");%&gt;&lt;%--使用EL表达式输出 ${} --%&gt;&lt;h1&gt;取出的值为：&lt;/h1&gt;&lt;h5&gt;${name1}&lt;/h5&gt;&lt;h5&gt;${name2}&lt;/h5&gt;&lt;h5&gt;${name3}&lt;/h5&gt;&lt;h5&gt;${name4}&lt;/h5&gt;&lt;h5&gt;${name5}&lt;/h5&gt;&lt;%--这种方式如果值不存在，EL表达式会自动给你过滤掉--%&gt;&lt;h5&gt;&lt;%=name5%&gt;&lt;/h5&gt;&lt;%--这种方式如果值不存在，那么会输出一个null--%&gt;&lt;/body&gt;&lt;/html&gt; 请求转发 12345678910111213&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% pageContext.forward(\"/index.jsp\"); //等价于 //request.getRequestDispatcher(\"/index.jsp\").forward(request, response); %&gt;&lt;/body&gt;&lt;/html&gt; request保存的数据只在一次请求中有效，请求转发会携带这个数据 将pageContextDemo01转发到pageContextDemo02，这个时候访问pageContextDemo01的时候，就能访问到name2 pageContextDemo01.jsp 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;pageContextDemo01&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%-- 内置对象 --%&gt;&lt;% pageContext.setAttribute(\"name1\", \"jack1\");//保存的数据只在一个页面中有效 request.setAttribute(\"name2\", \"jack2\");//保存的数据只在一次请求中有效，请求转发会携带这个数据 session.setAttribute(\"name3\", \"jack3\");//保存的数据只在一次会话中有效，从打开浏览器到关闭浏览器 application.setAttribute(\"name4\", \"jack4\");//保存的数据只在服务器中有效，从打开服务器到关闭服务器%&gt;&lt;%--脚本片段中的代码，会被原封不动的生成到.jsp_java--%&gt;&lt;% //从pageContext取出保存的值 String name1 = (String) pageContext.findAttribute(\"name1\"); String name2 = (String) pageContext.findAttribute(\"name2\"); String name3 = (String) pageContext.findAttribute(\"name3\"); String name4 = (String) pageContext.findAttribute(\"name4\"); String name5 = (String) pageContext.findAttribute(\"name5\");%&gt;&lt;%--请求转发--%&gt;&lt;% pageContext.forward(\"/pageContextDemo02.jsp\");%&gt;&lt;%--使用EL表达式输出 ${} --%&gt;&lt;h1&gt;取出的值为：&lt;/h1&gt;&lt;h5&gt;${name1}&lt;/h5&gt;&lt;h5&gt;${name2}&lt;/h5&gt;&lt;h5&gt;${name3}&lt;/h5&gt;&lt;h5&gt;${name4}&lt;/h5&gt;&lt;h5&gt;${name5}&lt;/h5&gt;&lt;%--这种方式如果值不存在，EL表达式会自动给你过滤掉--%&gt;&lt;h5&gt;&lt;%=name5%&gt;&lt;/h5&gt;&lt;%--这种方式如果值不存在，那么会输出一个null--%&gt;&lt;/body&gt;&lt;/html&gt; pageContextDemo02.jsp 12345678910111213141516171819202122232425262728&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;pageContextDemo02&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--脚本片段中的代码，会被原封不动的生成到.jsp_java--%&gt;&lt;% //从pageContext取出保存的值 String name1 = (String) pageContext.findAttribute(\"name1\"); String name2 = (String) pageContext.findAttribute(\"name2\"); String name3 = (String) pageContext.findAttribute(\"name3\"); String name4 = (String) pageContext.findAttribute(\"name4\"); String name5 = (String) pageContext.findAttribute(\"name5\");%&gt;&lt;%--使用EL表达式输出 ${} --%&gt;&lt;h1&gt;取出的值为：&lt;/h1&gt;&lt;h5&gt;${name1}&lt;/h5&gt;&lt;h5&gt;${name2}&lt;/h5&gt;&lt;h5&gt;${name3}&lt;/h5&gt;&lt;h5&gt;${name4}&lt;/h5&gt;&lt;h5&gt;${name5}&lt;/h5&gt;&lt;%--这种方式如果值不存在，EL表达式会自动给你过滤掉--%&gt;&lt;h5&gt;&lt;%=name5%&gt;&lt;/h5&gt;&lt;%--这种方式如果值不存在，那么会输出一个null--%&gt;&lt;/body&gt;&lt;/html&gt; 但是如果直接访问pageContextDemo02，还是不能访问name2 request：客户端向服务器发送请求，产生的数据，可能过会就用不上了，例：某个文章！ session：客户端向服务器发送请求，产生的数据，可能用完了还要用，例：用户信息； application：客户端向服务器发送请求，产生的数据，一个用户用完了，其他用户还可能使用。例：全局参数。 JSP标签、JSTL标签、EL表达式12345678910111213&lt;!-- JSTL表达式的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl-api&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- standard标签库 --&gt;&lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;/dependencies&gt; EL表达式${} 获取数据 执行运算 获取web开发的常用对象 JSP标签123456&lt;jsp:include page=\"相对 URL 地址\" flush=\"true\" /&gt;&lt;jsp:forward page=\"相对 URL 地址\" /&gt; &lt;jsp:param name=\"fontcolor\" value=\"red\" /&gt; &lt;jsp:param name=\"background\" value=\"black\" /&gt;&lt;/jsp:forward&gt; 示例jspTag1.jsp 123456789101112&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Better me&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;jsp:forward page=\"jspTag2.jsp\"&gt; &lt;jsp:param name=\"name\" value=\"lucky\"/&gt; &lt;jsp:param name=\"age\" value=\"10\"/&gt; &lt;/jsp:forward&gt;&lt;/body&gt;&lt;/html&gt; 示例jspTag2.jsp 12345678910111213&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Better me me&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%-- 通过JSP表达式获取name和age &lt;%=变量或者表达式%&gt; --%&gt; 姓名： &lt;%=request.getParameter(\"name\")%&gt; 年龄： &lt;%=request.getParameter(\"age\")%&gt;&lt;/body&gt;&lt;/html&gt; JSTL表达式JSTL支持通用的、结构化的任务，比如迭代，条件判断，XML文档操作，国际化标签，SQL标签。 核心标签（掌握部分即可） 格式化标签 SQL 标签 XML 标签 JSTL 函数 JSTL标签库使用步骤 引入对应的taglib 使用其中的方法 c:if123456789101112131415161718192021222324252627282930&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;%-- 引入JSTL核心标签库，我们才能使用JSTL标签 --%&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;if测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"coreif.jsp\" method=\"get\"&gt; &lt;%-- 通过EL表达式获取表单中的数据 ${param.参数名} --%&gt; &lt;input type=\"text\" name=\"userName\" value=\"${param.userName}\"&gt; &lt;input type=\"submit\" value=\"登录\"&gt;&lt;/form&gt;&lt;%-- 判断如果提交的用户名是管理员，则提示登录成功 --%&gt;&lt;c:if test=\"${param.userName == 'admin'}\" var=\"isAdmin\"&gt; &lt;c:out value=\"欢迎你登录系统，管理员\"&gt;&lt;/c:out&gt;&lt;/c:if&gt;&lt;c:if test=\"${param.userName != 'admin'}\" var=\"isAdmin\"&gt; &lt;c:out value=\"欢迎你登录系统，${param.userName}\" &gt;&lt;/c:out&gt;&lt;/c:if&gt;&lt;/body&gt;&lt;/html&gt; c:choose &amp; c:when1234567891011121314151617181920212223242526&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;%-- 引入JSTL核心标签库，我们才能使用JSTL标签 --%&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;c:set var=\"score\" value=\"95\"/&gt;&lt;c:choose&gt; &lt;c:when test=\"${score &gt;= 90}\"&gt; 优秀 &lt;/c:when&gt; &lt;c:when test=\"${score &gt;= 80}\"&gt; 良好 &lt;/c:when&gt; &lt;c:when test=\"${score &lt;= 70}\"&gt; 一般 &lt;/c:when&gt;&lt;/c:choose&gt;&lt;/body&gt;&lt;/html&gt; c:forEach12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;%@ page import=\"java.util.ArrayList\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;%-- 引入JSTL核心标签库，我们才能使用JSTL标签 --%&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% ArrayList&lt;String&gt; nameList = new ArrayList&lt;&gt;(); nameList.add(\"summer\"); nameList.add(\"lucky\"); nameList.add(\"cara\"); nameList.add(\"jacky\"); nameList.add(\"iris\"); nameList.add(\"mia\"); nameList.add(\"mat\"); nameList.add(\"cat\"); request.setAttribute(\"list\", nameList);%&gt;&lt;%--var: 每一次遍历出来的变量items: 要遍历的对象step: 步长--%&gt;&lt;c:forEach var=\"name\" items=\"${list}\"&gt; &lt;c:out value=\"${name}\"/&gt; &lt;br&gt;&lt;/c:forEach&gt;&lt;hr&gt;&lt;c:forEach var=\"name\" items=\"${list}\" begin=\"1\" end=\"5\" step=\"2\"&gt; &lt;c:out value=\"${name}\"/&gt; &lt;br&gt;&lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt; Java Bean实体类JavaBean有特定的写法： 必须要有一个无参构造 属性必须私有化 必须有对应的get/set方法； 一般用来和数据库的字段做映射 ORM（Object Relational Mapping）； ORM ：对象关系映射 数据库表—&gt;Java程序里面的一个类 字段—&gt;属性 行记录——&gt;对象 刚开始运行之后报了500错误，后来检查之后发现是因为实体类这里我只加了有参构造方法，没有无参构造方法 。但是 问我在jsp代码里面是下面这样用的，所以就报错。 123456789101112&lt;%@ page import=\"com.lucky.entity.User\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;jsp:useBean id=\"user\" class=\"com.lucky.entity.User\" scope=\"page\"/&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415package com.lucky.entity;public class User { private int id; private String name; private int age; private String sex; public User(int id, String name, int age, String sex) { this.id = id; this.name = name; this.age = age; this.sex = sex; }} 经过完善之后的代码如下： 1234567891011121314151617181920212223242526&lt;%@ page import=\"com.lucky.entity.User\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% //User user = new User();%&gt;&lt;jsp:useBean id=\"user\" class=\"com.lucky.entity.User\" scope=\"page\"/&gt;&lt;jsp:setProperty name=\"user\" property=\"id\" value=\"10001\"/&gt;&lt;jsp:setProperty name=\"user\" property=\"name\" value=\"李华\"/&gt;&lt;jsp:setProperty name=\"user\" property=\"age\" value=\"22\"/&gt;&lt;jsp:setProperty name=\"user\" property=\"sex\" value=\"女\"/&gt;id: &lt;jsp:getProperty name=\"user\" property=\"id\"/&gt; &lt;br&gt;name: &lt;jsp:getProperty name=\"user\" property=\"name\"/&gt; &lt;br&gt;age: &lt;jsp:getProperty name=\"user\" property=\"age\"/&gt; &lt;br&gt;sex: &lt;jsp:getProperty name=\"user\" property=\"sex\"/&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.lucky.entity;import java.util.ArrayList;import java.util.List;//实体类一般都是和数据库中的表一一对应public class User { private int id; private String name; private int age; private String sex; public User() { } public User(int id, String name, int age, String sex) { this.id = id; this.name = name; this.age = age; this.sex = sex; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; }} MVC什么是MVC Model：模型 View：视图 Controller ：控制器 开始的时候，web应用的操作，用户直接访问控制层，控制层就可以直接操作数据库； 123servlet--CRUD--&gt;数据库弊端：程序十分臃肿，不利于维护servlet的代码中：处理请求、响应、视图跳转、处理JDBC、处理业务代码、处理逻辑代码 MVC三层架构图 Model 业务处理 ：业务逻辑（Service） 数据持久层：CRUD （DAO） View 展示数据 提供链接发起Servlet请求 （a，form，img…） Controller 接收用户的请求 （req：请求参数、Session信息…） 交给业务层处理对应的代码 控制视图的跳转 1234561、登录2、接收用户的登录请求3、处理用户的请求（获取用户登录的参数，username，password）4、交给业务层处理登录业务（判断用户名密码是否正确：事务）5、Dao层查询用户名和密码是否正确6、数据库 过滤器、监听器FilterFilter：过滤器 ，用来过滤请求中的数据； 处理中文乱码 登录验证… 1、导入包（javax.servlet.Filter） 2、实现Filter接口，重写相应方法 123456789101112131415161718192021222324252627282930313233package com.bambi.filter;import javax.servlet.*;import java.io.IOException;public class CharacterEncodingFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\"执行init方法\"); } //chain: 链 /* 1. 过滤器中的所有代码，在过滤特定的请求的时候都会执行 2. 必须要让过滤器继续执行。 filterChain.doFilter(servletRequest, servletResponse); */ @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { servletRequest.setCharacterEncoding(\"utf-8\"); servletResponse.setCharacterEncoding(\"utf-8\"); servletResponse.setContentType(\"text/html; charset=utf-8\"); System.out.println(\"filter执行前\"); filterChain.doFilter(servletRequest, servletResponse);//让请求继续走，如果不写，程序到这里就被拦截停止了 System.out.println(\"filter执行后\"); } //Web服务器关闭的时候，就会执行销毁方法。 @Override public void destroy() { System.out.println(\"执行销毁方法\"); }} 3、在web.xml配置Filter 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;filter&gt; &lt;filter-name&gt;filter&lt;/filter-name&gt; &lt;filter-class&gt;com.bambi.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;filter&lt;/filter-name&gt; &lt;!--所有的请求，都会经过这个过滤器--&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;filter2&lt;/filter-name&gt; &lt;filter-class&gt;com.bambi.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;filter2&lt;/filter-name&gt; &lt;!--servletTest下面的所有请求，都会经过这个过滤器--&gt; &lt;url-pattern&gt;/servletTest/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 监听器实现一个监听器的接口；（有N种方式） 1、编写一个监听器，实现监听器的接口。 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.bambi.listener;import javax.servlet.ServletContext;import javax.servlet.http.HttpSessionEvent;import javax.servlet.http.HttpSessionListener;//统计网站在线人数：统计sessionpublic class OnlineCountListener implements HttpSessionListener { //创建session监听：看你的一举一动 //一旦创建session成功，就会出发一次这个事件 public void sessionCreated(HttpSessionEvent se) { ServletContext servletContext = se.getSession().getServletContext(); Integer onlineCount = (Integer)servletContext.getAttribute(\"onlineCount\"); if(onlineCount == null){ onlineCount = new Integer(1); }else{ int count = onlineCount.intValue(); onlineCount = new Integer(count + 1); } servletContext.setAttribute(\"onlineCount\", onlineCount); } //销毁session监听 //一旦销毁session就会触发一次这个事件 public void sessionDestroyed(HttpSessionEvent se) { ServletContext servletContext = se.getSession().getServletContext(); Integer onlineCount = (Integer)servletContext.getAttribute(\"onlineCount\"); if(onlineCount == null){ onlineCount = new Integer(0); }else{ int count = onlineCount.intValue(); onlineCount = new Integer(count - 1); } servletContext.setAttribute(\"onlineCount\", onlineCount); } /* * Session销毁 * * 1.手动销毁 * 2.自动销毁 * */} 2、在web.xml配置监听器 1234&lt;!-- 注册监听器 --&gt;&lt;listener&gt; &lt;listener-class&gt;com.bambi.listener.OnlineCountListener&lt;/listener-class&gt;&lt;/listener&gt; 过滤器、监听器的常见应用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.bambi.listener;import java.awt.*;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.awt.event.WindowListener;public class TestPanel { public static void main(String[] args) { Frame frame = new Frame(\"天天开心\"); Panel panel = new Panel(null); frame.setLayout(null); frame.setBounds(200,200,300,300); frame.setBackground(new Color(128,208,255)); panel.setBounds(30,30, 100, 100); panel.setBackground(new Color(200,150,160)); frame.add(panel); frame.setVisible(true); //适配器模式 frame.addWindowListener(new WindowAdapter() { @Override public void windowDeactivated(WindowEvent e) { System.out.println(\"关闭中~~~~\"); } }); //监听关闭事件 frame.addWindowListener(new WindowListener() { @Override public void windowOpened(WindowEvent e) { System.out.println(\"打开\"); } @Override public void windowClosing(WindowEvent e) { System.out.println(\"关闭中\"); System.exit(0); } @Override public void windowClosed(WindowEvent e) { System.out.println(\"关闭\"); } @Override public void windowIconified(WindowEvent e) { } @Override public void windowDeiconified(WindowEvent e) { } @Override public void windowActivated(WindowEvent e) { System.out.println(\"激活\"); } @Override public void windowDeactivated(WindowEvent e) { System.out.println(\"未激活\"); } }); }} 用户登录之后才能进入主页，用户注销之后不能进入主页 待写","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://xiaofanshutu.github.io/categories/Java-Web/"}],"tags":[],"author":"cutiebambi"},{"title":"IO学习笔记","slug":"IO学习笔记","date":"2022-05-28T00:31:41.000Z","updated":"2024-01-17T23:39:18.791Z","comments":true,"path":"posts/c89e3217.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/c89e3217.html","excerpt":"","text":"文件基础知识 常用的文件操作创建文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.File;import java.io.IOException;public class FileCreate { public static void main(String[] args) { FileCreate fileCreate = new FileCreate(); fileCreate.create01(); fileCreate.create02(); fileCreate.create03(); } //public File(String pathname)根据路径构造一个File对象 public void create01() { String pathname = \"D:\\\\goon\\\\test\\\\test01.doc\"; File file = new File(pathname); try { file.createNewFile(); } catch (IOException e) { System.out.println(\"创建文件失败\"); } } //public File(File parent, String child)根据父目录文件+子路径构造 public void create02() { String parentPath = \"D:\\\\\"; String child = \"goon\\\\test\\\\test02.doc\"; File parentFile = new File(parentPath); File file = new File(parentFile, child); try { file.createNewFile(); } catch (IOException e) { System.out.println(\"创建文件失败\"); } } //public File(String parent, String child)根据父目录+子路径构造 public void create03() { String parent = \"D:\\\\\"; String child = \"goon\\\\test\\\\test03.doc\"; File file = new File(parent, child); try { file.createNewFile(); } catch (IOException e) { System.out.println(\"创建文件失败\"); } }} 常用方法 getName() getAbsolutePath() getParent() length() exists() isFile() isDirectory() 12345678910111213141516171819202122232425262728293031323334import java.io.File;import java.io.IOException;public class FileMethods { public static void main(String[] args) { FileMethods fileMethods = new FileMethods(); fileMethods.createFile(); } public void createFile() { try { String parentPath = \"D:\\\\demo\\\\test\"; String child = \"a.txt\"; File parentFile = new File(parentPath); if (!parentFile.exists()) { parentFile.mkdirs(); } File file = new File(parentFile, child); if (!file.exists()) { file.createNewFile(); } System.out.println(\"文件名字：\" + file.getName());//a.txt System.out.println(\"文件绝对路径：\" + file.getAbsolutePath());//D:\\demo\\test\\a.txt System.out.println(\"文件父目录：\" + file.getParent());//D:\\demo\\test System.out.println(\"文件长度(字节)：\" + file.length());//0 System.out.println(\"文件是否存在：\" + file.exists());//true System.out.println(\"是不是一个文件：\" + file.isFile());//true System.out.println(\"是不是一个目录：\" + file.isDirectory());//false file.createNewFile(); } catch (IOException e) { System.out.println(\"创建文件失败\"); } }} 1234567文件名字：a.txt文件绝对路径：D:\\demo\\test\\a.txt文件父目录：D:\\demo\\test文件长度(字节)：0文件是否存在：true是不是一个文件：true是不是一个目录：false 目录的操作和删除123public boolean mkdir()创建一级目录public boolean mkdirs()创建多级目录public boolean delete()删除空目录或文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.io.File;public class FileOperation { public static void main(String[] args) { FileOperation fileOperation = new FileOperation(); fileOperation.fileFolderTest03(); } //1. 判断文件全路径是否存在，如果存在就删除该文件 public void fileFolderTest01() { String path = \"D:\\\\goon\\\\test\\\\test01.doc\"; File file = new File(path); if (file.exists()) { System.out.println(\"文件存在\"); file.delete(); System.out.println(\"删除成功\"); } } //2. 判断文件的父目录是否存在，如果存在就删除，不存在就提示文件父路径不存在 public void fileFolderTest02() { String path = \"D:\\\\demo\\\\test\"; File file = new File(path); if (file.exists()) { file.delete();//只能删除空目录或者文件 System.out.println(\"删除成功\"); } else { System.out.println(\"该路径不存在\"); } } //3. 判断文件父路径是否存在，如果存在就提示已经存在，不存在就创建该路径 public void fileFolderTest03() { String path = \"D:\\\\demo\\\\a\\\\b\\\\c\"; File file = new File(path); if (file.exists()) { System.out.println(\"该路径已存在\"); } else { boolean mkdirs = file.mkdirs(); if (mkdirs) { System.out.println(\"该路径不存在，但是已创建出该路径\"); } } }} IO流原理以及流的分类流的分类 抽象基类 字节流 字符流 输入流 InputStream Reader 输出流 OutputStream Writer InputStream FileInputStream12publicclass FileInputStream extends InputStream 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.example.hanshunping.io;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;public class FileInputStream_ { public static void main(String[] args) { FileInputStream_ fileInputStream_ = new FileInputStream_(); System.out.println(\"=====方式1=====\"); fileInputStream_.read01(); System.out.println(\"\\n\"); System.out.println(\"=====方式2=====\"); fileInputStream_.read02(); } //读取的文件里面不含中文 public void read01() { String name = \"D:\\\\test.txt\"; FileInputStream fileInputStream = null; try { fileInputStream = new FileInputStream(name); int readFlag; while ((readFlag = fileInputStream.read()) != -1) { System.out.print((char) readFlag); } } catch (FileNotFoundException e) { throw new RuntimeException(e); } catch (IOException e) { throw new RuntimeException(e); } finally { try { fileInputStream.close(); } catch (IOException e) { throw new RuntimeException(e); } } } //读取的文件里面含有中文 public void read02() { String name = \"D:\\\\test2.txt\"; FileInputStream fileInputStream = null; try { fileInputStream = new FileInputStream(name); byte[] bytes = new byte[50]; int readLength; //read(byte b[])：Reads up to b.length bytes of data from this input stream into an array of bytes. //return：the total number of bytes read into the buffer while ((readLength = fileInputStream.read(bytes)) != -1) { System.out.print(new String(bytes, 0, readLength)); } } catch (FileNotFoundException e) { throw new RuntimeException(e); } catch (IOException e) { throw new RuntimeException(e); } finally { try { fileInputStream.close(); } catch (IOException e) { throw new RuntimeException(e); } } }} 1234567=====方式1=====day day up!=====方式2=====每天进步一点点~哈哈~better me~ OutputStream FileOutputStream12publicclass FileOutputStream extends OutputStream xxxxxxxxxx&nbsp;import java.io.File;​public class FileOperation { &nbsp; &nbsp;public static void main(String[] args) { &nbsp; &nbsp; &nbsp; &nbsp;FileOperation fileOperation = new FileOperation(); &nbsp; &nbsp; &nbsp; &nbsp;fileOperation.fileFolderTest03(); &nbsp; }​ &nbsp; &nbsp;//1. 判断文件全路径是否存在，如果存在就删除该文件 &nbsp; &nbsp;public void fileFolderTest01() { &nbsp; &nbsp; &nbsp; &nbsp;String path = “D:\\goon\\test\\test01.doc”; &nbsp; &nbsp; &nbsp; &nbsp;File file = new File(path); &nbsp; &nbsp; &nbsp; &nbsp;if (file.exists()) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(“文件存在”); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;file.delete(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(“删除成功”); &nbsp; &nbsp; &nbsp; } &nbsp; }​ &nbsp; &nbsp;//2. 判断文件的父目录是否存在，如果存在就删除，不存在就提示文件父路径不存在 &nbsp; &nbsp;public void fileFolderTest02() { &nbsp; &nbsp; &nbsp; &nbsp;String path = “D:\\demo\\test”; &nbsp; &nbsp; &nbsp; &nbsp;File file = new File(path); &nbsp; &nbsp; &nbsp; &nbsp;if (file.exists()) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;file.delete();//只能删除空目录或者文件 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(“删除成功”); &nbsp; &nbsp; &nbsp; } else { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(“该路径不存在”); &nbsp; &nbsp; &nbsp; } &nbsp; }​ &nbsp; &nbsp;//3. 判断文件父路径是否存在，如果存在就提示已经存在，不存在就创建该路径 &nbsp; &nbsp;public void fileFolderTest03() { &nbsp; &nbsp; &nbsp; &nbsp;String path = “D:\\demo\\a\\b\\c”; &nbsp; &nbsp; &nbsp; &nbsp;File file = new File(path); &nbsp; &nbsp; &nbsp; &nbsp;if (file.exists()) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(“该路径已存在”); &nbsp; &nbsp; &nbsp; } else { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;boolean mkdirs = file.mkdirs(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (mkdirs) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(“该路径不存在，但是已创建出该路径”); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; } &nbsp; }}java 12345678910111213141516171819202122232425262728293031323334353637package com.example.hanshunping.io;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;public class FileOutputStream_ { public static void main(String[] args) { String path = \"D:\\\\test3.txt\"; FileOutputStream fileOutputStream = null; try { //1. 这种方式创建的FileOutputStream，当写入内容时，会覆盖原来的内容 //fileOutputStream = new FileOutputStream(path); //2. 这种方式创建的FileOutputStream，当写入内容时，不会覆盖原来的内容，新内容会追加到久内容后面 fileOutputStream = new FileOutputStream(path, true); //public void write(int b) char c = 'D'; fileOutputStream.write(c); //public void write(byte b[]) String str = \"hello summer\"; fileOutputStream.write(str.getBytes()); //public void write(byte b[], int off, int len) fileOutputStream.write(str.getBytes(), 0, 3); } catch (IOException e) { throw new RuntimeException(e); } finally { try { fileOutputStream.close(); } catch (IOException e) { throw new RuntimeException(e); } } }} 练习编程实现文件的拷贝 12345678910111213141516171819202122232425262728293031323334353637package com.example.hanshunping.io;import java.io.*;public class FileCopy { public static void main(String[] args) { String readPath = \"D:\\\\test.txt\"; String writePath = \"D:\\\\demo.txt\"; FileInputStream fileInputStream = null; FileOutputStream fileOutputStream = null; try { fileInputStream = new FileInputStream(readPath); fileOutputStream = new FileOutputStream(writePath); byte[] bytes = new byte[1024]; int readLength; while ((readLength = fileInputStream.read(bytes)) != -1) { fileOutputStream.write(bytes, 0, readLength); } } catch (FileNotFoundException e) { throw new RuntimeException(e); } catch (IOException e) { throw new RuntimeException(e); } finally { try { if (fileInputStream != null) { fileInputStream.close(); } if (fileOutputStream != null) { fileOutputStream.close(); } } catch (IOException e) { throw new RuntimeException(e); } } }} FileReader 常用方法 new FileReader(File/String) read()每次读取单个字符，返回该字符，如果到文件末尾则返回-1 read(char[])批量读取多个字符到数组，返回读取到的字符数，如果到文件末尾则返回-1 相关API new String(char[])将char[]转换成String new String(char[], off, len)将char[]的指定部分转换成String 练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;public class FileReader_ { public static void main(String[] args) { System.out.println(\"=====方式1=====\"); String path = \"D:\\\\test.txt\"; FileReader fileReader = null; try { fileReader = new FileReader(path); int readData; while ((readData = fileReader.read()) != -1) { System.out.print((char) readData); } } catch (IOException e) { throw new RuntimeException(e); } finally { if(fileReader != null){ try { fileReader.close(); } catch (IOException e) { throw new RuntimeException(e); } } } System.out.println(\"=====方式2=====\"); try { fileReader = new FileReader(path); char[] chr = new char[500]; int readLength; while ((readLength = fileReader.read(chr)) != -1) { System.out.print(new String(chr, 0, readLength)); } } catch (IOException e) { throw new RuntimeException(e); } finally { if(fileReader != null){ try { fileReader.close(); } catch (IOException e) { throw new RuntimeException(e); } } } }} 123456789101112131415161718192021222324252627282930313233343536=====方式1=====public class FileCreate { public static void main(String[] args) { FileCreate fileCreate = new FileCreate(); fileCreate.create01(); } //public File(String pathname)根据路径构造一个File对象 public void create01() { String pathname = \"D:\\\\goon\\\\test\\\\test01.doc\"; File file = new File(pathname); try { file.createNewFile(); } catch (IOException e) { System.out.println(\"创建文件失败\"); } }}=====方式2=====public class FileCreate { public static void main(String[] args) { FileCreate fileCreate = new FileCreate(); fileCreate.create01(); } //public File(String pathname)根据路径构造一个File对象 public void create01() { String pathname = \"D:\\\\goon\\\\test\\\\test01.doc\"; File file = new File(pathname); try { file.createNewFile(); } catch (IOException e) { System.out.println(\"创建文件失败\"); } }} FileWriter 常用方法 new FileWriter(File/String)：覆盖模式，相当于流的指针在首端 new FileWriter(File/String, true)：追加模式，相当于流的指针在尾端 write(int)：写入单个字符 write(char[])：写入指定数组 write(char[], off, len)：写入指定数组的指定部分 write(string)：写入整个字符串 write(string, off, len)：写入字符串的指定部分 相关API toCharArray: 将String转换成char[] 【String类的方法】 注意： ==FileWriter使用后，必须要关闭(close)或者刷新(flush)，否则写入不到指定的文件。== 练习123456789101112131415161718192021222324252627282930313233343536373839import java.io.FileWriter;import java.io.IOException;public class FileWriter_ { public static void main(String[] args) { String fileName = \"D:\\\\demo\\\\test\\\\b.txt\"; FileWriter fileWriter = null; try { //1. FileWriter(String fileName) fileWriter = new FileWriter(fileName); //2. write(String str) fileWriter.write(\"D\"); //3. write(String str) fileWriter.write(\"你好呀!\"); //4. write(String str, int off, int len) fileWriter.write(\"little rabbit\", 7, 6); char[] chars = \"hello world\".toCharArray(); //5. write(char cbuf[]) fileWriter.write(chars); //6. write(char cbuf[], int off, int len) fileWriter.write(chars, 6, 5); } catch (IOException e) { throw new RuntimeException(e); } finally { if (fileWriter != null) { try { fileWriter.close(); } catch (IOException e) { throw new RuntimeException(e); } } } }} 1D你好呀!rabbithello worldworld 节点流和处理流概述节点流 分类 字节输入流 字节输出流 字符输入流 字符输出流 抽象基类 InputStream OutputStream Reader Writer 访问文件 FileInputStream FileOutputStream FileReader FileWriter 访问数组 ByteArrayInputStream ByteArrayOutputStream CharArrayReader CharArrayWriter 访问管道 PipedInputStream PipedOutputStream PipedReader PipedWriter 访问字符串 StringReader StringWriter 处理流 分类 字节输入流 字节输出流 字符输入流 字符输出流 抽象基类 InputStream OutputStream Reader Writer 对象流 ObjectInputStream ObjectOutputStream 文件流 FileInputStream FileOutputStream 转换流 InputStreamReader OutputStreamWriter 打印流 PrintStream PrintWriter （父）FilterInputStream （父）FilterOutputStream （父）FilterReader FilterWriter 推回输入流 （子）PushbackInputStream （子）PushbackReader 特殊流 （子）DataInputStream （子）DataOutputStream 缓冲流 （子）BufferedInputStream （子）BufferedOutputStream BufferedReader BufferedWriter 节点流和处理流的区别和联系 节点流是底层流/低级流，直接跟数据源相关。 处理流既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出。 处理流也叫包装流，它可以对节点流进行包装。使用了修饰器设计模式，不会直接与数据源相连。 字符处理流BufferedReader&amp;BufferedWriter12public class BufferedReaderextends Reader 12public class BufferedWriterextends Writer 1234567891011121314151617181920212223import org.springframework.util.StringUtils;import java.io.*;public class BufferedCopy { public static void main(String[] args) throws IOException { String fileSrc = \"D:\\\\demo\\\\test\\\\a.txt\"; String fileDest = \"D:\\\\demo\\\\test\\\\b.txt\"; BufferedReader bufferedReader = new BufferedReader(new FileReader(fileSrc)); BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(fileDest)); String content = \"\"; while ((content = bufferedReader.readLine()) != null) { bufferedWriter.write(content); } if(bufferedReader != null){ bufferedReader.close(); } if(bufferedWriter != null){ bufferedWriter.close(); } }} 字节处理流BufferedInputStream&amp;BufferedOutputStream12public class BufferedInputStreamextends FilterInputStream 12public class BufferedOutputStreamextends FilterOutputStream 用字节处理流实现图片拷贝123456789101112131415161718192021222324252627import java.io.*;public class BufferedInputStreamCopy { public static void main(String[] args) throws IOException { String fileSrc = \"D:\\\\demo\\\\test\\\\a.jpg\"; String fileDest = \"D:\\\\demo\\\\test\\\\b.jpg\"; byte[] bytes = new byte[100]; BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(fileSrc)); BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(fileDest)); int length; //读取方式一// while ((length = bufferedInputStream.read()) != -1) {// bufferedOutputStream.write(length);// } //读取方式二 while ((length = bufferedInputStream.read(bytes)) != -1) { bufferedOutputStream.write(bytes, 0, length); } if (bufferedInputStream != null) { bufferedInputStream.close(); } if (bufferedOutputStream != null) { bufferedOutputStream.close(); } }} 对象处理流对象处理流的使用细节 读写顺序要一致。 序列化或反序列化的对象，需要实现Serializable接口。 序列化的类中建议添加serialVersionUID，为了提高版本的兼容性。 序列化对象时，默认将里面的所有属性都进行序列化。但是如果成员是被static或者transient修饰的，则不会被序列化。 序列化对象时，要求里面属性的类型也需要实现序列化接口。 序列化具备可继承性，即如果某类已经实现了序列化，则它的所有子类也默认实现了序列化。 ObjectOutputStream123public class ObjectOutputStreamextends OutputStreamimplements ObjectOutput, ObjectStreamConstants 练习用ObjectOutputStream序列化一个基本数据类型和一个Dog对象，并存储到test.dat文件中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.io.Serializable;public class ObjectOutputStream_ { public static void main(String[] args) throws IOException { String name = \"D:\\\\demo\\\\test\\\\test.dat\"; FileOutputStream fileOutputStream = new FileOutputStream(name); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeInt(9); objectOutputStream.writeObject(new Dog(\"旺财\", 1)); if (objectOutputStream != null) { objectOutputStream.close(); } }}class Dog implements Serializable { private String name; private int age; public Dog(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Dog{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; }} ObjectInputStream123public class ObjectInputStreamextends InputStreamimplements ObjectInput, ObjectStreamConstants 练习使用ObjectInputStream读取test.dat并且反序列化数据 123456789101112131415161718192021import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.ObjectInputStream;public class ObjectInputStream_ { public static void main(String[] args) throws IOException, ClassNotFoundException { String name = \"D:\\\\demo\\\\test\\\\test.dat\"; FileInputStream fileInputStream = new FileInputStream(name); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); System.out.println(objectInputStream.readInt()); //刚开始忘了注释这一行，运行下面那一行的时候报错了 java.io.EOFException //System.out.println(objectInputStream.readObject()); Dog dog = (Dog) objectInputStream.readObject(); System.out.println(dog.getName()); System.out.println(dog.getAge()); if (objectInputStream != null) { objectInputStream.close(); } }} 标准输入输出流123456789101112131415161718192021222324252627import java.io.InputStream;import java.io.PrintStream;import java.util.Scanner;public class StandardStream { public static void main(String[] args) { //1. public final static InputStream in = null; //2. 编译类型：InputStream InputStream in = System.in; //3. 运行类型：BufferedInputStream //4. 表示标准输入 键盘 System.out.println(System.in);//java.io.BufferedInputStream@4d7e1886 //1. public final static PrintStream out = null; //2. 编译类型：PrintStream PrintStream out = System.out; //3. 运行类型：PrintStream //4. 表示标准输出 显示器 System.out.println(System.out);//java.io.PrintStream@3cd1a2f1 System.out.println(\"标准输出，打印到显示器\"); Scanner scanner = new Scanner(System.in); System.out.println(\"从键盘接收数据：\"); System.out.println(\"next = \" + scanner.next()); }} 123456java.io.BufferedInputStream@4d7e1886java.io.PrintStream@3cd1a2f1标准输出，打印到显示器从键盘接收数据：hellonext = hello 转换流通过乱码问题引出转换流12345678910import java.io.*;public class CodeIssue { public static void main(String[] args) throws IOException { String fileName = \"D:\\\\demo\\\\test\\\\code_issue.txt\"; BufferedReader bufferedReader = new BufferedReader(new FileReader(fileName)); System.out.println(bufferedReader.readLine()); bufferedReader.close(); }} 1���ѽ 所以就引出了转换流。 InputStreamReader123java.lang.Object java.io.Reader java.io.InputStreamReader 12public class InputStreamReaderextends Reader 练习将字节流FileInputStream用gbk的编码格式包装成字符流InputStreamReader，接着再包装成BufferedReader。 123456789101112import java.io.*;public class BufferedReader_ { public static void main(String[] args) throws IOException { String fileName = \"D:\\\\demo\\\\test\\\\code_issue.txt\"; String charset = \"gbk\"; InputStreamReader inputStreamReader = new InputStreamReader(new FileInputStream(fileName), charset); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); System.out.println(bufferedReader.readLine()); bufferedReader.close(); }} 1你好呀 OutputStreamWriter123java.lang.Object java.io.Writer java.io.OutputStreamWriter 12public class OutputStreamWriterextends Writer 练习将字节流FileOutputStream用utf8的编码格式包装成字符流OutputStreamWriter，对文件进行写入，按照gbk的格式。 1234567891011import java.io.*;public class OutputStreamWriter_ { public static void main(String[] args) throws IOException { String fileName = \"D:\\\\demo\\\\test\\\\aa.txt\"; String charset = \"utf8\"; OutputStreamWriter outputStreamWriter = new OutputStreamWriter(new FileOutputStream(fileName), charset); outputStreamWriter.write(\"你好，世界！\"); outputStreamWriter.close(); }} 打印流PrintStream（字节打印流）1234java.lang.Object java.io.OutputStream java.io.FilterOutputStream java.io.PrintStream 123public class PrintStreamextends FilterOutputStreamimplements Appendable, Closeable 12345678import java.io.PrintStream;public class PrintStream_ { public static void main(String[] args) { PrintStream printStream = System.out; printStream.print(\"你好，明天！\"); }} 1你好，明天！ PrintWriter（字符打印流）123java.lang.Object java.io.Writer java.io.PrintWriter 12public class PrintWriterextends Writer Properties普通方法读取配置文件配置文件内容 12name=DB01pwd=130.133.13.14 1234567891011121314import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;public class Properties01 { public static void main(String[] args) throws IOException { BufferedReader bufferedReader = new BufferedReader(new FileReader(\"src\\\\sql.properties\")); String content; while ((content = bufferedReader.readLine()) != null) { String[] stars = content.split(\"=\"); System.out.println(stars[0] + \": \" + stars[1]); } }} 12name: DB01pwd: 130.133.13.14 Properties类基本介绍12public class Propertiesextends Hashtable&lt;Object,Object&gt; Properties类常用方法Properties类读取配置文件123456789101112import java.io.FileReader;import java.io.IOException;import java.util.Properties;public class Properties02 { public static void main(String[] args) throws IOException { Properties properties = new Properties(); properties.load(new FileReader(\"src\\\\sql.properties\")); System.out.println(properties.getProperty(\"name\")); System.out.println(properties.getProperty(\"pwd\")); }} 12DB01130.133.13.14 Properties类添加新的key-value到配置文件1234567891011121314import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.util.Properties;public class Properties03 { public static void main(String[] args) throws IOException { Properties properties = new Properties(); properties.load(new FileReader(\"src\\\\sql.properties\")); properties.put(\"通过程序添加的key\", \"通过程序添加的value\"); properties.store(new FileWriter(\"src\\\\sql.properties\"), null); properties.list(System.out); }} 12345-- listing properties --name=DB01通过程序添加的key=通过程序添加的valuepwd=130.133.13.14charset=utf8 double check: 检查local file，新的key-value添加成功 这里记录一个小插曲，测试的时候，用IDEA打开这个配置文件的时候，出现了乱码。 上面这个问题的解决办法如下： File-&gt;Setting Properties类读取配置文件，并且修改某一个key-value1234567891011121314import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.util.Properties;public class Properties03 { public static void main(String[] args) throws IOException { Properties properties = new Properties(); properties.load(new FileReader(\"src\\\\sql.properties\")); properties.put(\"name\", \"DB02\"); properties.store(new FileWriter(\"src\\\\sql.properties\"), null); properties.list(System.out); }} 123-- listing properties --name=DB02pwd=130.133.13.14","categories":[{"name":"Java IO","slug":"Java-IO","permalink":"https://xiaofanshutu.github.io/categories/Java-IO/"}],"tags":[],"author":"cutiebambi"},{"title":"Java集合练习题","slug":"Java集合框架学习笔记","date":"2022-05-08T00:31:41.000Z","updated":"2024-01-17T23:40:02.482Z","comments":true,"path":"posts/efe18b52.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/efe18b52.html","excerpt":"","text":"集合的理解和好处集合的理解和好处 可以动态保存任意多个对象，使用比较方便 提供了一系列方便的操作对象的方法：add,remove,set,get等 使用集合添加，删除新元素的代码，会很简洁 集合的框架体系 Collection接口和常用方法1public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; Collection接口实现类的特点 可以存放多个元素 Collection的有些实现类是有序的 Collection的有些实现类是无序的 Collection接口常用方法 add: 添加单个元素 remove：删除指定元素 contains：查找元素是否存在 size：获取元素个数 isEmpty：判断是否为空 clear：清空 addAll：添加多个元素 containsAll：查找多个元素是否存在 removeAll：删除多个元素 Collection接口的元素遍历方式方式1 - Iterator（迭代器）==代码== 12345678910111213141516// Collection// Map// 1. 集合主要是两组（单列集合，双列集合）// 2. Collection接口有两个重要的子接口，List Set，他们的实现子类都是单列集合// 3. Map接口的实现子类都是双列集合public static void main(String[] args){ Collection collection = new ArrayList(); collection.add(\"test1\"); collection.add(\"test2\"); collection.add(\"test3\"); Iterator iterator = collection.iterator(); while (iterator.hasNext()) { Object next = iterator.next(); System.out.println(next); }} 123test1test2test3 方式2 - 增强for循环==增强for循环的特点== 增强for可以在collection集合上使用 增强for底层仍然调用的是迭代器 可以这样理解，增强for就是简化版的迭代器遍历 123public Iterator&lt;E&gt; iterator() { return new Itr();} ==代码== 12345678910public static void main(String[] args){ Collection collection = new ArrayList(); collection.add(\"test1\"); collection.add(\"test2\"); collection.add(\"test3\"); for (Object o : collection) { System.out.println(o); }} 123test1test2test3 List接口和常用方法List接口特点 List集合中的元素是有序的（即添加和取出顺序一致）、并且可以重复。 List集合中的每个元素都有其对应的顺序索引，即支持索引。 List容器中的元素都对应一个整数型序号记载其在容器中的位置，可以根据序号存取容器中的元素。 JDK API中List接口的实现类有： Java1.8 API Doc List接口常用的方法： void add(int index, E element)Inserts the specified element at the specified position in this list (optional operation). boolean addAll(int index, Collection&lt;? extends E&gt; c)Inserts all of the elements in the specified collection into this list at the specified position (optional operation). E get(int index)Returns the element at the specified position in this list. int indexOf(Object o)Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. int lastIndexOf(Object o)Returns the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element. E remove(int index)Removes the element at the specified position in this list (optional operation). E set(int index, E element)Replaces the element at the specified position in this list with the specified element (optional operation). List subList(int fromIndex, int toIndex)Returns a view of the portion of this list between the specified fromIndex, inclusive, and toIndex, exclusive. List接口课堂练习123456789101112131415161718192021222324252627public class ListExercise { public static void main(String[] args) { // 添加10个以上元素 List list = new ArrayList(); for (int i = 0; i &lt; 20; i++) { list.add(\"Hello\" + i); } // 在2号位置插入一个元素“summergoon” list.add(1, \"summergoon\"); // 获取第5个元素 System.out.println(list.get(4)); // 删除第6个元素 list.remove(5); // 修改第7个元素 list.set(6, \"modify\"); // 再使用迭代器遍历集合 Iterator iterator = list.iterator(); while (iterator.hasNext()) { Object next = iterator.next(); System.out.println(next); } }} List的元素遍历方式方式1：Iterator迭代器12345678910111213public static void main(String[] args) { List list = new ArrayList(); list.add(\"tom\"); list.add(\"jerry\"); list.add(\"naonao\"); // Iterator Iterator iterator = list.iterator(); while (iterator.hasNext()) { Object next = iterator.next(); System.out.println(next); }} 方式二：增强for1234567891011public static void main(String[] args) { List list = new ArrayList(); list.add(\"tom\"); list.add(\"jerry\"); list.add(\"naonao\"); // 增强for for (Object o : list) { System.out.println(o); }} 方式三：普通for1234567891011public static void main(String[] args) { List list = new ArrayList(); list.add(\"tom\"); list.add(\"jerry\"); list.add(\"naonao\"); // 普通for for (int i = 0; i &lt; list.size(); i++) { System.out.println(list.get(i)); }} 上面三种的输出都是一样的 123tomjerrynaonao 课堂练习12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Book implements Comparable&lt;Book&gt; { private String name; private String author; private double price; public Book(String name, String author, double price) { this.name = name; this.author = author; this.price = price; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } public double getPrice() { return price; } public void setPrice(double price) { this.price = price; } @Override public String toString() { return \"Book{\" + \"name='\" + name + '\\'' + \", author='\" + author + '\\'' + \", price=\" + price + '}'; } @Override public int compareTo(Book o) { return (int) (this.price - o.price); }} 1234567891011121314public class ListSort { public static void main(String[] args) { List list = new ArrayList(); list.add(new Book(\"如何拥抱一只刺猬\", \"测试1\", 69.9)); list.add(new Book(\"动物的家\", \"测试2\", 30.6)); list.add(new Book(\"我长大了\", \"测试3\", 90.9)); Collections.sort(list); for (Object o : list) { System.out.println(o); } }} 123Book{name='动物的家', author='测试2', price=30.6}Book{name='如何拥抱一只刺猬', author='测试1', price=69.9}Book{name='我长大了', author='测试3', price=90.9} ArrayList源码剖析ArrayList的注意事项 Implements all optional list operations, and permits all elements, including null. ArrayList是由数组来实现数据存储的。 ArrayList基本等同于Vector，ArrayList是线程不安全的（但是执行效率高）。在多线程的情况下，不建议使用ArrayList。 ArrayList底层操作机制源码分析（重点、难点） ArrayList中维护了一个Object类型的数组elementData 当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第1次添加，则扩容elementData为10，如果需要再次扩容，则扩容elementData为1.5倍。 1public ArrayList() 如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如果需要扩容，则扩容elementData为1.5倍。 1public ArrayList(int initialCapacity) 源码剖析使用无参构造器创建ArrayList对象，跟踪源码1234567891011121314151617181920public class ArrayListSource { public static void main(String[] args) { //使用无参构造器创建ArrayList对象 List list = new ArrayList(); for (int i = 1; i &lt;= 10; i++) { list.add(i); } for (int i = 11; i &lt;= 15; i++) { list.add(i); } list.add(100); list.add(200); list.add(null); for (Object o : list) { System.out.println(o); } }} 创建一个空的elementData[] 123456/** * Constructs an empty list with an initial capacity of ten. */public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;} 装箱 12345public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);} 执行list.add (1) 先确定是否要扩容 (2)然后再执行赋值 12345public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;} 确定是否要扩容 123private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));} 计算minCapacity 123456private static int calculateCapacity(Object[] elementData, int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity;} (1)modCount++记录集合被修改的次数 (2)如果elementData的大小不够，就调用grow()去扩容。 1234567private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);} (1)真正的扩容 (2)使用扩容机制来确定要扩容到多大 (3)第一次newCapacity = 10 (4)第二次及其以后，按照1.5倍扩容 (5)扩容使用的是Arrays.copyOf() 1234567891011private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);} 使用有参构造器创建ArrayList对象，跟踪源码【待写】Vector源码剖析Vector的基本介绍 Vector类的定义说明 Vector底层也是一个对象数组， 1protected Object[] elementData; Vector是线程同步的，即线程安全，Vector类的操作方法带有synchronized 123456public synchronized E get(int index) { if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); return elementData(index);} 源码剖析使用无参构造器创建Vector对象，跟踪源码12345678910public class Vector_ { public static void main(String[] args) { Vector vector = new Vector(); for (int i = 0; i &lt; 10; i++) { vector.add(i); } vector.add(100); vector.add(200); }} 装箱操作 12345public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);} 执行vector.add (1)modCount++：记录集合被修改的次数 (2)先确定是否需要扩容 (3)然后再执行赋值 123456public synchronized boolean add(E e) { modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true;} 如果elementData的大小不够，就调用grow()去扩容 12345private void ensureCapacityHelper(int minCapacity) { // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);} 真正的扩容 (1)使用扩容机制来确定要扩容到多大 (2)capacityIncrement=0，第一次oldCapacity=10，newCapacity=oldCapacity*2=20，即相当于按照2倍扩容 (3)扩容使用的是Arrays.copyOf() 1234567891011private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity);} 使用有参构造器创建Vector对象，跟踪源码【待写】Vector底层结构和ArrayList的比较 底层结构 版本 线程 安全（同步）效率 扩容倍数 ArrayList 可变数组 jdk1.2 不安全，效率高 如果 有参构造1.5倍如果是无参1. 第一次102. 第二次开始按1.5扩 Vector 可变数组 Object[] jdk1.0 安全，效率低 如果指定大小，则每次直接按2倍扩如果是无参构造，默认10，满了 之后，按2倍扩容 LinkedList源码剖析模拟双向链表1234567891011121314151617181920212223242526272829303132333435363738public class HashSetStructure { public static void main(String[] args) { // 1. 创建一个数组，数组的类型是Node[] // 2. 有些人，直接把Node[] 数组称为 表 Node[] table = new Node[16]; // 3. 创建节点 Node summer = new Node(\"summer\", null); table[2] = summer; Node ada = new Node(\"ada\", null); summer.next = ada;// 将ada挂载到summer Node cara = new Node(\"cara\", null); ada.next = cara;// 将cara挂载到jack Node lucky = new Node(\"lucky\", null); table[3] = lucky; for (Node node : table) { System.out.println(node); } }}class Node {// 节点，存储数据，可以指向下一个节点，从而形成链表 Object item;// 存放数据 Node next;// 指向下一个节点 public Node(Object item, Node next) { this.item = item; this.next = next; } @Override public String toString() { return \"Node{\" + \"item=\" + item + \", next=\" + next + '}'; }} 12345678910111213141516nullnullNode{item=summer, next=Node{item=ada, next=Node{item=cara, next=null}}}Node{item=lucky, next=null}nullnullnullnullnullnullnullnullnullnullnullnull LinkedList源码剖析add 12345678public LinkedList() {}protected AbstractSequentialList() {}protected AbstractList() {}protected AbstractCollection() {} 12345public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);} 1234public boolean add(E e) { linkLast(e); return true;} 1234567891011void linkLast(E e) { final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;} remove 123public E remove() { return removeFirst();} 123456public E removeFirst() { final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f);} 123456789101112131415private E unlinkFirst(Node&lt;E&gt; f) { // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element;} remove(3) 1234public E remove(int index) { checkElementIndex(index); return unlink(node(index));} 1234private void checkElementIndex(int index) { if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));} 123private boolean isElementIndex(int index) { return index &gt;= 0 &amp;&amp; index &lt; size;} 123456789101112131415Node&lt;E&gt; node(int index) { // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) { Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; } else { Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; }} 12345678910111213141516171819202122232425E unlink(Node&lt;E&gt; x) { // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) { first = next; } else { prev.next = next; x.prev = null; } if (next == null) { last = prev; } else { next.prev = prev; x.next = null; } x.item = null; size--; modCount++; return element;} 得到某个元素 1234public E get(int index) { checkElementIndex(index); return node(index).item;} 1234private void checkElementIndex(int index) { if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));} 123private boolean isElementIndex(int index) { return index &gt;= 0 &amp;&amp; index &lt; size;} 123456789101112131415Node&lt;E&gt; node(int index) { // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) { Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; } else { Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; }} LinkedList和ArrayList比较 底层结构 增删的效率 改查的效率 ArrayList 可变数组 较低数组扩容 较高 LinkedList 双向链表 较高通过链表追加 较低 实际中如何选择？ 如果“改查”操作多，选择ArrayList 如果“增删”操作多，选择LinkedList Set接口和常用方法Set接口基本介绍PS: Set接口的实现类的对象，简称Set接口对象 无序（添加和取出的顺序不一致），没有索引 不允许重复元素，所以最多包含一个null JDK API中Set接口的实现类如下： Set接口常用方法和List接口一样，Set接口也是Collection的子接口，常用方法和Collection接口一样。 Set接口的遍历方式和Collection的遍历方式一样，因为Set接口是Collection接口的子接口。 Iterator迭代器 增强for ==不能使用==索引的方式 12345678910111213141516171819202122232425public class Set_ { public static void main(String[] args) { System.out.println(\"======添加数据======\"); Set set = new HashSet(); set.add(\"joan\"); set.add(\"summer\"); set.add(null); set.add(\"joan\"); set.add(null); System.out.println(set); System.out.println(\"======Iterator遍历======\"); Iterator iterator = set.iterator(); while (iterator.hasNext()) { Object obj = iterator.next(); System.out.println(obj); } System.out.println(\"======增强for遍历======\"); for (Object o : set) { System.out.println(o); } System.out.println(\"======删除数据======\"); set.remove(\"joan\"); System.out.println(set); }} 123456789101112======添加数据======[null, joan, summer]======Iterator遍历======nulljoansummer======增强for遍历======nulljoansummer======删除数据======[null, summer] HashSet源码剖析HashSet的全面说明 HashSet实现了Set接口 HashSet实际上是HashMap 123public HashSet() { map = new HashMap&lt;&gt;();} 可以存放null值，但是只能有一个null HashSet不保证元素是有序的，取决于hash后，再确定索引的结果（即不保证数据存放和取出的顺序一致） 不能有重复的元素/对象 HashSet案例说明12345678910111213141516171819202122public class HashSet_ { public static void main(String[] args) { Set set = new HashSet(); //执行add方法后，会返回一个boolean值 //如果添加成功，返回true，否则返回false //可以通过remove指定删除哪个对象 System.out.println(set.add(\"joan\")); System.out.println(set.add(\"lucky\")); System.out.println(set.add(\"summer\")); System.out.println(set.add(\"null\")); System.out.println(set.add(\"joan\"));// false: 不能添加重复元素 System.out.println(set.add(\"jack\")); System.out.println(set.add(\"null\"));// false: 不能添加重复元素 System.out.println(\"=====删除前=====\"); System.out.println(set); set.remove(\"null\");// 将会删掉null System.out.println(\"=====删除后=====\"); System.out.println(set); }} 1234567891011truetruetruetruefalsetruefalse=====删除前=====[lucky, joan, null, summer, jack]=====删除后=====[lucky, joan, summer, jack] HashSet底层机制说明 HashSet底层是HashMap， HashMap底层是数组+链表+红黑树 添加一个元素时，==先得到Hash值==，会转换成索引值 找到存储数据表table，看这个索引位置是否已经存放有元素 如果没有，直接加入 如果有，==调用equals方法比较==，如果相同，就放弃添加，如果不相同，则添加到最后 在Java8中，如果一条链表的元素个数到TREEIFY_THRESHOLD(默认是8)，并且table的大小&gt;=MIN_TREEIFY_CAPACITY(默认64)，就会进行树化（红黑树） 模拟简单的数组+链表结构1234567891011121314151617181920212223242526272829303132333435363738public class HashSetStructure { public static void main(String[] args) { // 1. 创建一个数组，数组的类型是Node[] // 2. 有些人，直接把Node[] 数组称为 表 Node[] table = new Node[16]; // 3. 创建节点 Node summer = new Node(\"summer\", null); table[2] = summer; Node ada = new Node(\"ada\", null); summer.next = ada;// 将ada挂载到summer Node cara = new Node(\"cara\", null); ada.next = cara;// 将cara挂载到jack Node lucky = new Node(\"lucky\", null); table[3] = lucky; for (Node node : table) { System.out.println(node); } }}class Node {// 节点，存储数据，可以指向下一个节点，从而形成链表 Object item;// 存放数据 Node next;// 指向下一个节点 public Node(Object item, Node next) { this.item = item; this.next = next; } @Override public String toString() { return \"Node{\" + \"item=\" + item + \", next=\" + next + '}'; }} 12345678910111213141516nullnullNode{item=summer, next=Node{item=ada, next=Node{item=cara, next=null}}}Node{item=lucky, next=null}nullnullnullnullnullnullnullnullnullnullnullnull 分析HashSet的添加元素的底层是如何实现的( hash() + equals() ) 源码剖析123456789public class HashSetSource { public static void main(String[] args) { HashSet hashSet = new HashSet(); hashSet.add(\"java\"); hashSet.add(\"php\"); hashSet.add(\"java\"); System.out.println(hashSet); }} 分析上面的代码： 执行构造器 123public HashSet() { map = new HashMap&lt;&gt;();} 执行add()方法 1234// 这里的PRESENT是 private static final Object PRESENT = new Object();public boolean add(E e) { return map.put(e, PRESENT)==null;} 123public V put(K key, V value) {// key: java value: PRESENT(object) return putVal(hash(key), key, value, false, true);} 执行hash(key) 方法会得到key对应的hash值，这个hash值不是hashCode，是根据算法(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)得到对应的hash值.(这个hash值就是table表对应的索引值) 1234static final int hash(Object key) {// key: java int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); // 无符号右移16位} hashCode() 123456789101112public int hashCode() { int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) { char val[] = value; for (int i = 0; i &lt; value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h;} ==核心代码（重点中的重点）== 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { //定义辅助变量 Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //如果当前table是null，或者大小等于0，就第一次扩容，扩到16个空间 if ((tab = table) == null || (n = tab.length) == 0)//table是hashMap的一个属性，这个table就是放node节点的一个数组。类型是：Node[] n = (tab = resize()).length; //(1)根据key，得到hash，去计算该key应该存放到table表的哪个索引位置，并让p指向这个索引位置的对象 //(2)判断p指向的索引位置的对象是否为null //(2.1)如果p指向的索引位置的对象为null，表示还没有存放元素，就创建一个Node(key=\"java\", value=\"PRESENT\") // 就放在该位置tab[i] = newNode(hash, key, value, null); if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null);//(set_pic_2) //(2.2)如果p指向的索引位置的对象不为null else { //一个开发技巧：在需要局部变量（辅助变量）的时候，再创建 Node&lt;K,V&gt; e; K k; //如果当前索引位置对应的链表的第一个元素的hash值和准备添加的key的hash值一样。并且满足下面两个条件之一： //(1) 准备加入的key和p指向的Node节点的k是同一个对象(set_pic_3) //(2) p指向的Node节点的对象k和准备加入的key经equals()方法比较后相同(set_pic_4) //如果满足上面两个条件之一，那么就不能加入 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 再判断p是不是一颗红黑树，如果是红黑树，就调用putTreeVal来进行添加 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); //如果table对应索引位置，已经是一个链表，就使用for循环比较 //(1) 依次和链表的每一个元素比较后，都不相同，则加入到该链表最后(set_pic_5) //(2) 在依次和该链表的每一个元素比较的过程中，如果有相同情况，就直接break else { //set_pic_6 for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st // TREEIFY_THRESHOLD=8 //注意：在把元素添加到链表后，会立即进行判断，判断该链表是否已经达到8个节点, // 如果达到8个节点，就调用treeifyBin(tab, hash)对当前链表进行树化（转成红黑树） // 在转成红黑树时，还会进行一个判断，如果该table数组的大小小于MIN_TREEIFY_CAPACITY（64）， // 判断条件如下： // if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) // resize(); // 如果上面条件成立，不会马上转成红黑树，会先进行table扩容 // 只有当上面的条件不成立的时候，才进行转成红黑树 treeifyBin(tab, hash); break;//添加到节点后面然后退出 } if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break;//放弃添加然后退出 // 这句代码，p依次指向它自己的下一个节点，这样就达到了循环每一个节点 p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; //onlyIfAbsent是put方法调用putVal的时候传入进来的参数，永远为false //public V put(K key, V value) { // return putVal(hash(key), key, value, false[这个参数对应的就是onlyIfAbsent], true); //} if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; //size就是每加入一个节点Node(k, v, h, next), size就会增加 if (++size &gt; threshold) resize();// 扩容 //这个方法其实是给它的子类用的 afterNodeInsertion(evict); //返回null表示添加成功 return null;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778final Node&lt;K,V&gt;[] resize() { Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) { if (oldCap &gt;= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold } else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else { // zero initial threshold signifies using defaults //DEFAULT_INITIAL_CAPACITY: 1&lt;&lt;4 2*2*2*2=16 newCap = DEFAULT_INITIAL_CAPACITY; //DEFAULT_LOAD_FACTOR: 0.75 //临界值0.75*16=12（缓冲层） newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({\"rawtypes\",\"unchecked\"}) //辅助变量newTable执行完下面这行代码后，就会变成有16个位置的空数组 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; //hashMap的table变成有16个位置的空数组（(set_pic_1)） table = newTab; if (oldTab != null) { for (int j = 0; j &lt; oldCap; ++j) { Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else { // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do { next = e.next; if ((e.hash &amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab;} set_pic_1： set_pic_2：刚开始创建一个空table, 接着，当插入一个数据之后 set_pic_3：插入数据时，判断能不能插入根据：即将要插入的key对应的对象和p所指向的Node对应的key的对象是否一样 set_pic_4：添加数据时，equals()方法存在的意义 set_pic_5： set_pic_6： 123Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) { return new Node&lt;&gt;(hash, key, value, next);} 分析HashSet的扩容和转成红黑树机制 HashSet底层是HashMap，第一次添加时，table数组扩容到16，临界值（threshold）是16*加载因子（loadFactor）是0.75 = 12 如果table数组使用到了临界值12，就会扩容到162 = 32， 新的临界值就是 320.75 = 24, 以此类推 在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD（默认是8），并且table的大小 &gt;= MIN_TREEIFY_CAPACITY（默认是64），就会进行树化（转成红黑树），==否则仍然采用数组扩容机制== 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class HashSetIncrement { public static void main(String[] args) { // HashSet底层是HashMap，第一次添加时，table数组扩容到16， // 临界值（threshold）是16*加载因子（loadFactor）是0.75 = 12 // 如果table数组使用到了临界值12，就会扩容到16*2 = 32， 新的临界值就是 32*0.75 = 24, 以此类推 HashSet hashSet = new HashSet();// for (int i = 0; i &lt; 100; i++) {// hashSet.add(i);// } // 在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD（默认是8）， // 并且table的大小 &gt;= MIN_TREEIFY_CAPACITY（默认是64），就会进行树化（转成红黑树）， // 否则仍然采用数组扩容机制// for (int i = 0; i &lt; 12; i++) {// hashSet.add(new A(i));// } // 当我们向hashSet增加一个元素，这个元素在底层封装了一个数据Node，加入到了table，就算是size++， // 而不是说非得增加到table表的第一个才算是增加size++ for (int i = 0; i &lt; 7; i++) { hashSet.add(new A(i)); } for (int j = 0; j &lt; 7; j++) { hashSet.add(new B(j)); } }}class A { private int i; public A(int i) { this.i = i; } @Override public int hashCode() { return 100; } @Override public String toString() { return \"A{\" + \"i=\" + i + '}'; }}class B{ private int n; public B(int n) { this.n = n; } @Override public int hashCode() { return 200; } @Override public String toString() { return \"B{\" + \"n=\" + n + '}'; }} HashSet课堂 练习1我的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class HashSetExercise { public static void main(String[] args) { // 定义一个Employee类，name，age // 创建3个Employee对象放入HashSet中 // name和age相同时，认为是相同员工，不能添加到HashSet中 HashSet hashSet = new HashSet(); Employee jack = new Employee(\"jack\", 10); Employee jack2 = new Employee(\"jack\", 10); Employee lucky = new Employee(\"lucky\", 10); hashSet.add(jack); hashSet.add(jack2); hashSet.add(lucky); System.out.println(hashSet); }}class Employee { private String name; private int age; public Employee(String name, int age) { this.name = name; this.age = age; } @Override public int hashCode() { return (name + age).hashCode(); } // 刚开始我没有重写equals方法，导致虽然名字和年龄相同了，但是还是插入到了HashSet里面 @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Employee employee = (Employee) o; return age == employee.age &amp;&amp; Objects.equals(name, employee.name); } @Override public String toString() { return \"Employee{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; }} 运行结果： 1[Employee{name='jack', age=10}, Employee{name='lucky', age=10}] 老师的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class HashSetExercise { public static void main(String[] args) { // 定义一个Employee类，name，age // 创建3个Employee对象放入HashSet中 // name和age相同时，认为是相同员工，不能添加到HashSet中 HashSet hashSet = new HashSet(); Employee jack = new Employee(\"jack\", 10); Employee jack2 = new Employee(\"jack\", 10); Employee lucky = new Employee(\"lucky\", 10); hashSet.add(jack); hashSet.add(jack2); hashSet.add(lucky); System.out.println(hashSet); }}class Employee { private String name; private int age; public Employee(String name, int age) { this.name = name; this.age = age; } // 老师的代码和我的代码的主要区别就在equals()和hashCode()方法这里 @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Employee employee = (Employee) o; return age == employee.age &amp;&amp; Objects.equals(name, employee.name); } @Override public int hashCode() { return Objects.hash(name, age); } @Override public String toString() { return \"Employee{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; }} 1[Employee{name='lucky', age=10}, Employee{name='jack', age=10}] HashSet课堂 练习2我的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import java.util.HashSet;import java.util.Objects;public class HashSetExercise { public static void main(String[] args) { // 定义一个Employee类，name，sal, birthday(MyDate类型，属性包括：year，month，day) // 创建3个Employee对象放入HashSet中 // name和birthday相同时，认为是相同员工，不能添加到HashSet中 HashSet hashSet = new HashSet(); hashSet.add(new Employee(\"jack\", 18000, new MyDate(1989, 3, 5))); hashSet.add(new Employee(\"lucky\", 9000, new MyDate(1996, 7, 1))); hashSet.add(new Employee(\"jack\", 26000, new MyDate(1989, 3, 5))); System.out.println(hashSet); }}class Employee { private String name; private int sal; private MyDate date; public Employee(String name, int sal, MyDate date) { this.name = name; this.sal = sal; this.date = date; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Employee employee = (Employee) o; return Objects.equals(name, employee.name) &amp;&amp; Objects.equals(date, employee.date); } @Override public int hashCode() { return Objects.hash(name, date); } @Override public String toString() { return \"Employee{\" + \"name='\" + name + '\\'' + \", sal=\" + sal + \", date=\" + date + '}'; }}class MyDate { private int year; private int month; private int day; public MyDate(int year, int month, int day) { this.year = year; this.month = month; this.day = day; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; MyDate myDate = (MyDate) o; return year == myDate.year &amp;&amp; month == myDate.month &amp;&amp; day == myDate.day; } @Override public int hashCode() { return Objects.hash(year, month, day); } @Override public String toString() { return \"MyDate{\" + \"year=\" + year + \", month=\" + month + \", day=\" + day + '}'; }} 1[Employee{name='lucky', sal=9000, date=MyDate{year=1996, month=7, day=1}}, Employee{name='jack', sal=18000, date=MyDate{year=1989, month=3, day=5}}] Map接口和常用方法Map接口实现类特点 用于保存具有映射关系的数据Key-Value Map中的key和value可以是任意引用类型的数据，会封装到HashMap$Node对象中 Map中的key不允许重复，原因和HashSet一样 Map中的value可以重复 Map中的key可以为null，value也可以为null，key为null只能有一个，value为null可以有多个，和第4点前后呼应 常用String类作为Map的key Key和value之间存在单向一对一的关系，即通过key可以找到对应的value值 Map存放的数据是Key-Value Map接口和常用方法Map体系的继承图 Map接口的常用方法12345678910111213141516171819202122232425262728293031323334353637383940public class MapMethod { public static void main(String[] args) { Map map = new HashMap(); //1. put map.put(\"小丸子\", \"樱桃小丸子\"); map.put(\"桔梗\", \"犬夜叉\"); map.put(\"月野兔\", \"美少女战士\"); map.put(\"唐三\", \"同样的key，value会覆盖\"); map.put(\"唐三\", \"斗罗大陆\"); map.put(null, \"null key\"); map.put(\"null value\", null); map.put(\"学校\", new School(\"哈哈大学\")); System.out.println(map);// {null=null key, 学校=com.example.hanshunping.map.School@4d7e1886, 唐三=斗罗大陆, 小丸子=樱桃小丸子, null value=null, 月野兔=美少女战士, 桔梗=犬夜叉} //2.get System.out.println(map.get(\"月野兔\"));// 美少女战士 //3.size System.out.println(map.size());// 7 //4.isEmpty System.out.println(map.isEmpty());// false //5.containsKey System.out.println(map.containsKey(\"猪太郎\"));// false System.out.println(map.containsKey(\"小丸子\"));// true //6.remove System.out.println(map.remove(\"test\"));// null Object remover = map.remove(null); System.out.println(remover.getClass());// class java.lang.String System.out.println(map);// {学校=com.example.hanshunping.map.School@4d7e1886, 唐三=斗罗大陆, 小丸子=樱桃小丸子, null value=null, 月野兔=美少女战士, 桔梗=犬夜叉} //7.clear map.clear(); System.out.println(map);// {} }}class School { private String name; public School(String name) { this.name = name; }} Map接口的元素遍历方式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class MapFor { public static void main(String[] args) { Map map = new HashMap(); map.put(\"小丸子\", \"樱桃小丸子\"); map.put(\"桔梗\", \"犬夜叉\"); map.put(\"月野兔\", \"美少女战士\"); map.put(\"唐三\", \"斗罗大陆\"); //1.keySet //(1)增强for System.out.println(\"=====1.keySet 增强for=====\"); for (Object key : map.keySet()) { System.out.println(key + \"-\" + map.get(key)); } //(2)迭代器 System.out.println(\"=====1.keySet 迭代器=====\"); Iterator iterator = map.keySet().iterator(); while (iterator.hasNext()) { Object next = iterator.next();// 这里iterator.next()的类型是class java.lang.String System.out.println(next); } //2.values //(1)增强for System.out.println(\"=====2.values 增强for=====\"); for (Object value : map.values()) { System.out.println(value); } //(2)迭代器 System.out.println(\"=====2.values 迭代器=====\"); Collection values = map.values(); Iterator valuesIterator = values.iterator(); while (valuesIterator.hasNext()) { Object next = valuesIterator.next();// valuesIterator.next()的类型是class java.lang.String System.out.println(next); } //3.entrySet Set set = map.entrySet(); //(1)增强for System.out.println(\"=====3.entrySet 增强for=====\"); for (Object o : set) { Map.Entry entry = (Map.Entry) o;// o的类型是class java.util.HashMap$Node System.out.println(entry.getValue() + \"-\" + entry.getValue()); } //(2)迭代器 System.out.println(\"=====3.entrySet 迭代器=====\"); Iterator entrySetIterator = set.iterator(); while (entrySetIterator.hasNext()) { Object next = entrySetIterator.next();// entrySetIterator.next()的类型是class java.util.HashMap$Node Map.Entry entry = (Map.Entry) next; System.out.println(entry.getValue() + \"-\" + entry.getValue()); } }} 123456789101112131415161718192021222324252627282930=====1.keySet 增强for=====唐三-斗罗大陆小丸子-樱桃小丸子月野兔-美少女战士桔梗-犬夜叉=====1.keySet 迭代器=====唐三小丸子月野兔桔梗=====2.values 增强for=====斗罗大陆樱桃小丸子美少女战士犬夜叉=====2.values 迭代器=====斗罗大陆樱桃小丸子美少女战士犬夜叉=====3.entrySet 增强for=====斗罗大陆-斗罗大陆樱桃小丸子-樱桃小丸子美少女战士-美少女战士犬夜叉-犬夜叉=====3.entrySet 迭代器=====斗罗大陆-斗罗大陆樱桃小丸子-樱桃小丸子美少女战士-美少女战士犬夜叉-犬夜叉 Map接口课堂练习123456789101112131415161718192021222324252627282930313233public class MapExercise { public static void main(String[] args) { Map map = new HashMap(); Employee jack = new Employee(\"jack\", 1001, 31000); Employee rose = new Employee(\"rose\", 1002, 25000); Employee jacky = new Employee(\"jacky\", 1003, 9000); map.put(jack.getId(), jack); map.put(rose.getId(), rose); map.put(jacky.getId(), jacky); // keySet-增强for遍历 System.out.println(\"=====keySet-增强for遍历=====\"); Employee employee = null; for (Object key : map.keySet()) { employee = (Employee) map.get(key); if (employee.getSalary() &gt; 18000) { System.out.println(employee.toString()); } } // entrySet-迭代器遍历 System.out.println(\"=====entrySet-迭代器遍历=====\"); Set set = map.entrySet(); Iterator iterator = set.iterator(); while (iterator.hasNext()) { Object next = iterator.next(); Map.Entry entry = (Map.Entry) next; Employee employee1 = (Employee) entry.getValue(); if (employee1.getSalary() &gt; 18000) { System.out.println(employee1); } } }} 123456=====keySet-增强for遍历=====Employee{name='jack', id=1001, salary=31000.0}Employee{name='rose', id=1002, salary=25000.0}=====entrySet-迭代器遍历=====Employee{name='jack', id=1001, salary=31000.0}Employee{name='rose', id=1002, salary=25000.0} Map接口底层代码分析1234567891011121314151617181920212223242526public class MapSource_ { public static void main(String[] args) { Map hashMap = new HashMap(); hashMap.put(\"no1\", \"小可爱1号\"); hashMap.put(\"no2\", \"小可爱2号\"); //1. k-v 最后是 HashMap$Node node = newNode(hash, key, value, null); //2. k-v 为了方便程序员遍历, 还会创建一个EntrySet集合, 该集合存放的元素的类型是Entry, 而一个Entry对象里面就有k,v,EntrySet&lt;Entry&lt;K, V&gt;&gt; // 底层代码: public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() Set set = hashMap.entrySet(); System.out.println(set.getClass()); // class java.util.HashMap$EntrySet //3. entrySet里面数据定义的类型是Map.Entry, 底层代码: Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet(); 但是实际上存放的还是HashMap$Node. // 为什么可以把一个Node类型存放到Map.Entry里面呢? 这是因为HashMap$Node实现了Map$Entry. 底层代码：static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; for (Object obj : set) { System.out.println(obj.getClass());// class java.util.HashMap$Node } //4. 既然key,value已经存放到HashMap$Node, 那为什么设计者设计的时候, 又把对象存放到了EntrySet里面呢? 这是因为对象存放到entrySet之后, 就方便我们程序员遍历了. // 为什么会方便程序员遍历呢? 这是因为Map.Entry提供了两个重要的方法 (1)K getKey(); (2)V getValue(); for (Object o : set) { Map.Entry entry = (Map.Entry) o; System.out.println(entry.getKey() + \"-\" + entry.getValue()); } }} 12345class java.util.HashMap$EntrySetclass java.util.HashMap$Nodeclass java.util.HashMap$Nodeno2-小可爱2号no1-小可爱1号 ==entry里面的key和value其实是指向node节点 key和value的引用== HashMap源码剖析HashMap基本介绍 Map接口的常用实现类：==HashMap==、Hashtable和Properties。 HashMap是以Key-Value键值对的方式来存储数据的（Entry）。 Key不能重复，value可以重复，允许有null key和null value。 如果添加相同的key，后面的会覆盖前面的key-value，等同于修改。（key不变，value会替换） 与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的。 HashMap没有实现同步，因此线程是不安全的。方法没有做同步互斥的操作（synchronized），public V put(K key, V value) HashMap底层代码剖析执行HashMap() 123public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted} 123public V put(K key, V value) { return putVal(hash(key), key, value, false, true);} 1234static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);} 123456789101112public int hashCode() { int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) { char val[] = value; for (int i = 0; i &lt; value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { //定义辅助变量 Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //如果当前table是null，或者大小等于0，就第一次扩容，扩到16个空间 if ((tab = table) == null || (n = tab.length) == 0)//table是hashMap的一个属性，这个table就是放node节点的一个数组。类型是：Node[] n = (tab = resize()).length; //(1)根据key，得到hash，去计算该key应该存放到table表的哪个索引位置，并让p指向这个索引位置的对象 //(2)判断p指向的索引位置的对象是否为null //(2.1)如果p指向的索引位置的对象为null，表示还没有存放元素，就创建一个Node(key=\"java\", value=\"PRESENT\") // 就放在该位置tab[i] = newNode(hash, key, value, null); if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); //(2.2)如果p指向的索引位置的对象不为null else { //一个开发技巧：在需要局部变量（辅助变量）的时候，再创建 Node&lt;K,V&gt; e; K k; //如果当前索引位置对应的链表的第一个元素和准备添加的key的hash值一样。并且满足下面两个条件之一： //(1) 准备加入的key和现存的p指向的Node节点的key是同一个对象 //(2) 现存的p指向的Node节点的key的equals()和准备加入的key比较后相同 //如果满足上面两个条件之一，那么就不能加入 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 再判断p是不是一颗红黑树，如果是红黑树，就调用putTreeVal来进行添加 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); //如果table对应索引位置，已经是一个链表，就使用for循环比较 //(1) 依次和链表的每一个元素比较后，都不相同，则加入到该链表最后 //(2) 在依次和该链表的每一个元素比较的过程中，如果有相同情况，就直接break else { //如果找到的节点后面是链表，就循环比较 for (int binCount = 0; ; ++binCount) {//死循环 if ((e = p.next) == null) {//如果整个链表没有和它相同的，就加到链表的最后 p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st // TREEIFY_THRESHOLD=8 //注意：在把元素添加到链表后，会立即进行判断，判断该链表是否已经达到8个节点, // 如果达到8个节点，就调用treeifyBin(tab, hash)对当前链表进行树化（转成红黑树） // 在转成红黑树时，还会进行一个判断，判断该table数组的大小是否小于MIN_TREEIFY_CAPACITY（64）， // 判断条件如下： // if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) // resize(); // 如果小于64，不会马上转成红黑树，会先进行table扩容 // 只有当上面的条件不成立的时候，才进行转成红黑树 treeifyBin(tab, hash); break;//添加到节点后面然后退出 } //如果在循环比较的过程中，有相同的 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break;//放弃添加然后退出 // 这句代码，p依次指向它自己的下一个节点，这样就达到了循环每一个节点 p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; //onlyIfAbsent是put方法调用putVal的时候传入进来的参数，永远为false //public V put(K key, V value) { // return putVal(hash(key), key, value, false[这个参数对应的就是onlyIfAbsent], true); //} if (!onlyIfAbsent || oldValue == null) //这里就实现了map同key的时候，后面的value会覆盖前面的value e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; //size就是每加入一个节点Node(k, v, h, next), size就会增加 if (++size &gt; threshold) resize();// 扩容 afterNodeInsertion(evict); //返回null表示添加成功 return null;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778final Node&lt;K,V&gt;[] resize() { Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) { if (oldCap &gt;= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold } else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else { // zero initial threshold signifies using defaults //DEFAULT_INITIAL_CAPACITY: 1&lt;&lt;4 2*2*2*2=16 newCap = DEFAULT_INITIAL_CAPACITY; //DEFAULT_LOAD_FACTOR: 0.75 //临界值0.75*16=12（缓冲层） newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({\"rawtypes\",\"unchecked\"}) //辅助变量newTable执行完下面这行代码后，就会变成有16个位置的空数组 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; //hashMap的table变成有16个位置的空数组 table = newTab; if (oldTab != null) { for (int j = 0; j &lt; oldCap; ++j) { Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else { // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do { next = e.next; if ((e.hash &amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab;} HashMap表的扩容和树化模拟扩容123456789101112131415161718192021222324252627import java.util.HashMap;import java.util.Objects;public class HashMapSource2 { public static void main(String[] args) { HashMap map = new HashMap(); for (int i = 1; i &lt; 16; i++) { map.put(new Test(i), \"小番薯\"); } System.out.println(map); }}class Test { private int number; public Test(int number) { this.number = number; } @Override public String toString() { return \"\\nTest{\" + \"number=\" + number + '}'; }} 0 -&gt; 16(12) 16(12) -&gt; 32(24) 32(24) -&gt; 64(48) 64(48) -&gt; 128(96) table表也不能一直无限扩容下去，有个限制，如果大于等于MAXIMUM_CAPACITY(1 &lt;&lt; 30 = 1073741824)就不能再继续扩容下去了 模拟树化1234567891011121314151617181920212223242526272829303132import java.util.HashMap;import java.util.Objects;public class HashMapSource2 { public static void main(String[] args) { HashMap map = new HashMap(); for (int i = 1; i &lt; 16; i++) { map.put(new Test(i), \"兔子\"); } System.out.println(map); }}class Test { private int number; //重写hashCode方法，为了让添加的节点都会在table表的同一个索引位置上。 @Override public int hashCode() { return 10; } public Test(int number) { this.number = number; } @Override public String toString() { return \"\\nTest{\" + \"number=\" + number + '}'; }} 12345678910111213141516{Test{number=9}=兔子, Test{number=1}=兔子, Test{number=2}=兔子, Test{number=14}=兔子, Test{number=3}=兔子, Test{number=4}=兔子, Test{number=5}=兔子, Test{number=6}=兔子, Test{number=15}=兔子, Test{number=7}=兔子, Test{number=8}=兔子, Test{number=10}=兔子, Test{number=12}=兔子, Test{number=11}=兔子, Test{number=13}=兔子} 刚开始table是null 插入第一条数据之后，table扩容到16，临界值为12 一直插入数据，直到当前10号索引位置的所挂载的元素超过8个，这个时候不会立即进行树化，因为table表的空间还小于64，所以table表就会进行再一次扩容，这一次会扩容到32，临界值会变为24。 当再进行一次数据的插入操作之后，table表会再一次进行扩容，这一次会扩容到64，临界值会变为48。 再插入一条数据，这个时候，table的索引位置10就会树化，变为TreeNode HashTable源码剖析Hashtable基本介绍 存放的元素是键值对。 key和value都不能是null。 Key不能重复，value可以重复，允许有null key和null value。 Hashtable的方法基本和HashMap类似。 与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的。 Hashtable是线程安全的。(synchronized) 123456789101112131415public class Hashtable_ { public static void main(String[] args) { Hashtable hashtable = new Hashtable(); hashtable.put(\"小丸子\", \"樱桃小丸子\"); hashtable.put(\"桔梗\", \"犬夜叉\"); hashtable.put(\"月野兔\", \"美少女战士\"); hashtable.put(\"唐三\", \"哈哈\");//会被下面的value覆盖 hashtable.put(\"唐三\", \"斗罗大陆\"); /* hashtable.put(null, \"key是null\");//会抛异常 java.lang.NullPointerException hashtable.put(\"value是null\", null);//会抛异常 java.lang.NullPointerException */ System.out.println(hashtable); }} 1{唐三=斗罗大陆, 月野兔=美少女战士, 小丸子=樱桃小丸子, 桔梗=犬夜叉} HashMap底层代码剖析123456789public class Hashtable_ { public static void main(String[] args) { Hashtable hashtable = new Hashtable(); for (int i = 1; i &lt; 10; i++) { hashtable.put(\"student\" + i, \"test\"); } System.out.println(hashtable); }} 底层有数组，Hashtable$Entry[]， 初始化大小为11。临界值是8，threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1); 123public Hashtable() { this(11, 0.75f);//initialCapacity:11 loadFactor:0.75} 1234567891011121314151617181920212223public synchronized V put(K key, V value) { // Make sure the value is not null if (value == null) {//value如果为null在这里就会抛出空指针异常 throw new NullPointerException(); } // Makes sure the key is not already in the hashtable. Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; @SuppressWarnings(\"unchecked\") Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index]; for(; entry != null ; entry = entry.next) { if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) { V old = entry.value; entry.value = value; return old; } } //这里正式执行添加数据操作 addEntry(hash, key, value, index); return null;} 执行方法addEntry，将key-value封装到Entry. 1234567891011121314151617181920private void addEntry(int hash, K key, V value, int index) { modCount++; Entry&lt;?,?&gt; tab[] = table; //如果table表的size大于等于临界值，就会进行table的扩容 if (count &gt;= threshold) { // Rehash the table if the threshold is exceeded rehash(); tab = table; hash = key.hashCode(); index = (hash &amp; 0x7FFFFFFF) % tab.length; } // Creates the new entry. @SuppressWarnings(\"unchecked\") Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index]; tab[index] = new Entry&lt;&gt;(hash, key, value, e); count++;} 123456789101112131415161718192021222324252627282930protected void rehash() { int oldCapacity = table.length; Entry&lt;?,?&gt;[] oldMap = table; // overflow-conscious code //oldCapacity &lt;&lt; 1 + 1 = 2*oldCapacity + 1 int newCapacity = (oldCapacity &lt;&lt; 1) + 1; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) { if (oldCapacity == MAX_ARRAY_SIZE) // Keep running with MAX_ARRAY_SIZE buckets return; newCapacity = MAX_ARRAY_SIZE; } Entry&lt;?,?&gt;[] newMap = new Entry&lt;?,?&gt;[newCapacity]; modCount++; threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1); table = newMap; for (int i = oldCapacity ; i-- &gt; 0 ;) { for (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != null ; ) { Entry&lt;K,V&gt; e = old; old = old.next; int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity; e.next = (Entry&lt;K,V&gt;)newMap[index]; newMap[index] = e; } }} Hashtable和HashMap对比 版本 线程安全（同步）？ 效率 允许null key和null value？ HashMap 1.2 不安全 高 允许 Hashtable 1.0 安全 较低 不允许 PropertiesProperties基本介绍 Properties可以用于从*.properties中加载数据到Properties类对象，进行数据的读取和修改。 工作中*.properties通常作为配置文件。 Properties用法1234567891011121314151617181920212223242526272829303132public class Properties_ { public static void main(String[] args) { Properties properties = new Properties(); //1.put //不能存null key或者null value。 public class Properties extends Hashtable&lt;Object,Object&gt; //properties.put(null, \"null key\"); //properties.put(\"null value\", null);//Exception in thread \"main\" java.lang.NullPointerException properties.put(\"1001\", \"jack\");//Exception in thread \"main\" java.lang.NullPointerException properties.put(\"1001\", \"lucky\");//相同的key，后一个value会替换前一个value。 properties.put(\"1002\", \"cara\"); properties.put(\"1003\", \"ada\"); System.out.println(\"=====put=====\"); System.out.println(properties); //2.get System.out.println(\"=====get=====\"); System.out.println(properties.get(\"1001\")); //3.getProperty(String key) System.out.println(\"=====getProperty(String key)=====\"); System.out.println(properties.getProperty(\"1002\")); //4.getProperty(String key, String defaultValue) System.out.println(\"=====getProperty(String key, String defaultValue)=====\"); System.out.println(properties.getProperty(\"1005\", \"user not exists\")); //3.remove properties.remove(\"1003\"); System.out.println(\"=====remove=====\"); System.out.println(properties); }} 12345678910=====put====={1003=ada, 1002=cara, 1001=lucky}=====get=====lucky=====getProperty(String key)=====cara=====getProperty(String key, String defaultValue)=====user not exists=====remove====={1002=cara, 1001=lucky} Properties源码剖析123public Properties() { this(null);} 123public Properties(Properties defaults) { this.defaults = defaults;} 123public Hashtable() { this(11, 0.75f);} 123456789101112131415161718192021222324public synchronized V put(K key, V value) { // Make sure the value is not null if (value == null) { throw new NullPointerException(); } // Makes sure the key is not already in the hashtable. Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; @SuppressWarnings(\"unchecked\") Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index]; for(; entry != null ; entry = entry.next) { //如果要插入的的key的hash值和准备插入的table索引位置的对象的hash值一样，并且equals方法相等，那么就执行替换操作 if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) { V old = entry.value; entry.value = value;//替换 return old; } } addEntry(hash, key, value, index); return null;} 1234567891011121314151617181920private void addEntry(int hash, K key, V value, int index) { modCount++; Entry&lt;?,?&gt; tab[] = table; if (count &gt;= threshold) { // Rehash the table if the threshold is exceeded //如果table中的数据大于等于临界值，就会扩容 rehash(); tab = table; hash = key.hashCode(); index = (hash &amp; 0x7FFFFFFF) % tab.length; } // Creates the new entry. @SuppressWarnings(\"unchecked\") Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index]; tab[index] = new Entry&lt;&gt;(hash, key, value, e); count++;} 1234567891011121314151617181920212223242526272829303132protected void rehash() { int oldCapacity = table.length; Entry&lt;?,?&gt;[] oldMap = table; // overflow-conscious code //2*oldCapacity + 1 int newCapacity = (oldCapacity &lt;&lt; 1) + 1; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) { if (oldCapacity == MAX_ARRAY_SIZE) // Keep running with MAX_ARRAY_SIZE buckets return; newCapacity = MAX_ARRAY_SIZE; } Entry&lt;?,?&gt;[] newMap = new Entry&lt;?,?&gt;[newCapacity]; modCount++; //计算新的临界值 threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1); table = newMap; //遍历旧数据，将原来的值再放到新的map上 for (int i = oldCapacity ; i-- &gt; 0 ;) { for (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != null ; ) { Entry&lt;K,V&gt; e = old; old = old.next; int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity; e.next = (Entry&lt;K,V&gt;)newMap[index]; newMap[index] = e; } }} TreeSet源码剖析TreeSet基本介绍 TreeSet基本用法使用无参构造器创建TreeSet对象1234567891011public class TreeSet_ { public static void main(String[] args) { //输出的结果和数据插入的顺序不一致 TreeSet treeSet = new TreeSet(); treeSet.add(\"jack\"); treeSet.add(\"roy\"); treeSet.add(\"alisa\"); treeSet.add(\"cecil\"); System.out.println(treeSet); }} 1[alisa, cecil, jack, roy] 使用有参构造器创建TreeSet对象12345678910111213141516public class TreeSetSortable { public static void main(String[] args) { //按字母升序排列 TreeSet treeSet = new TreeSet(new Comparator() { @Override public int compare(Object o1, Object o2) { return ((String) o1).compareTo(((String) o2)); } }); treeSet.add(\"jack\"); treeSet.add(\"roy\"); treeSet.add(\"alisa\"); treeSet.add(\"cecil\"); System.out.println(treeSet); }} 1[alisa, cecil, jack, roy] TreeSet源码剖析123public TreeSet(Comparator&lt;? super E&gt; comparator) { this(new TreeMap&lt;&gt;(comparator));} 123public boolean add(E e) { return m.put(e, PRESENT)==null;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public V put(K key, V value) { Entry&lt;K,V&gt; t = root; //插入第一个数据，t为null，进入这个if条件 if (t == null) { compare(key, key); // type (and possibly null) check //插入数据 root = new Entry&lt;&gt;(key, value, null); size = 1; modCount++; return null; } int cmp; Entry&lt;K,V&gt; parent; // split comparator and comparable paths //comparator会动态绑定到我们写的匿名内部类对象 Comparator&lt;? super K&gt; cpr = comparator; if (cpr != null) { do { parent = t; //比较 cmp = cpr.compare(key, t.key); if (cmp &lt; 0) //t=t.left，如果左侧还有节点，那么while循环会继续比较 t = t.left; else if (cmp &gt; 0) //t=t.right，如果右侧还有节点，那么while循环会继续比较 t = t.right; else return t.setValue(value); } while (t != null); } else { if (key == null) throw new NullPointerException(); @SuppressWarnings(\"unchecked\") Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; do { parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); } while (t != null); } Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); if (cmp &lt; 0) parent.left = e; else parent.right = e; fixAfterInsertion(e); size++; modCount++; return null;} TreeMap源码剖析TreeMap基本介绍 TreeMap基本用法使用无参构造器创建TreeMap对象12345678910111213//Constructs a new, empty tree map, using the natural ordering of its keys. All keys inserted into the map must implement the Comparable interface. Furthermore, all such keys must be mutually comparable.public class TreeMap_ { public static void main(String[] args) { TreeMap treeMap = new TreeMap(); treeMap.put(\"jack\", \"1001\"); treeMap.put(\"henry\", \"1002\"); treeMap.put(\"roy\", \"1003\"); treeMap.put(\"winnie\", \"1004\"); treeMap.put(\"cecil\", \"1005\"); treeMap.put(\"cara\", \"1006\"); System.out.println(treeMap); }} 1{cara=1006, cecil=1005, henry=1002, jack=1001, roy=1003, winnie=1004} 使用有参构造器创建TreeMap对象1234567891011121314151617public class TreeMapSortable { public static void main(String[] args) { TreeMap treeMap = new TreeMap(new Comparator() { @Override public int compare(Object o1, Object o2) { return ((String) o1).length() - (((String) o2).length()); } }); treeMap.put(\"jack\", \"1001\"); treeMap.put(\"henry\", \"1002\"); treeMap.put(\"roy\", \"1003\"); treeMap.put(\"winnie\", \"1004\"); treeMap.put(\"cecil\", \"1005\"); treeMap.put(\"cara\", \"1006\"); System.out.println(treeMap); }} 1{roy=1003, jack=1006, henry=1005, winnie=1004} TreeMap源码剖析123public TreeMap(Comparator&lt;? super K&gt; comparator) { this.comparator = comparator;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public V put(K key, V value) { Entry&lt;K,V&gt; t = root; if (t == null) { compare(key, key); // type (and possibly null) check root = new Entry&lt;&gt;(key, value, null); size = 1; modCount++; return null; } int cmp; Entry&lt;K,V&gt; parent; // split comparator and comparable paths Comparator&lt;? super K&gt; cpr = comparator; if (cpr != null) { do { parent = t; cmp = cpr.compare(key, t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); } while (t != null); } else { if (key == null) throw new NullPointerException(); @SuppressWarnings(\"unchecked\") Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; do { parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); } while (t != null); } Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); if (cmp &lt; 0) parent.left = e; else parent.right = e; fixAfterInsertion(e); size++; modCount++; return null;} 123456public V setValue(V value) { //如果key相同，value会进行替换 V oldValue = this.value; this.value = value; return oldValue;} Collections工具类Collections工具类基本介绍12public class Collectionsextends Object Collections工具类常用方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;public class Collections_ { public static void main(String[] args) { List list = new ArrayList(); list.add(\"roy\"); list.add(\"cecil\"); list.add(\"summer\"); list.add(\"roy\"); //reverse: 反转list中的元素 Collections.reverse(list); System.out.println(\"=====reverse=====\"); System.out.println(list); //shuffle: 对list中的元素进行随机排序 System.out.println(\"=====shuffle=====\"); for (int i = 0; i &lt; 3; i++) { Collections.shuffle(list); System.out.println(list); } //sort: 根据元素的自然顺序对list集合元素进行升序排序 System.out.println(\"=====sort=====\"); Collections.sort(list); System.out.println(list); //sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c: 按指定顺序对元素进行排序 Collections.sort(list, new Comparator() { @Override public int compare(Object o1, Object o2) { return ((String) o2).length() - ((String) o1).length(); } }); System.out.println(\"=====sort传入比较器=====\"); System.out.println(list); //swap: 将j处元素和i处元素进行交换 System.out.println(\"=====swap=====\"); Collections.swap(list, 2, 1); System.out.println(list); //frequency: 返回集合中指定元素出现的次数 System.out.println(\"=====frequency=====\"); System.out.println(Collections.frequency(list, \"roy\")); //copy: 将src中的内容复制到dest中 System.out.println(\"=====copy=====\"); List list1 = new ArrayList(); list.add(\"henry\"); list.add(\"jacky\"); list.add(\"jack\"); Collections.copy(list, list1); System.out.println(list); //replaceAll: 使用新值替换List对象的所有旧值 System.out.println(\"=====replaceAll=====\"); Collections.replaceAll(list, \"roy\", \"lucky\"); System.out.println(list); //max: 根据元素的自然顺序，返回给定集合中的最大元素 System.out.println(\"=====max=====\"); System.out.println(Collections.max(list)); //max: 根据Comparator指定的顺序，返回给定集合中的最大元素 System.out.println(\"=====max=====\"); System.out.println(Collections.max(list, new Comparator() { @Override public int compare(Object o1, Object o2) { return ((String) o2).length() - ((String) o1).length(); } })); //min: 根据元素的自然顺序，返回给定集合中的最小元素 System.out.println(\"=====min=====\"); System.out.println(Collections.min(list)); //min: 根据Comparator指定的顺序，返回给定集合中的最小元素 System.out.println(\"=====min=====\"); System.out.println(Collections.min(list, new Comparator() { @Override public int compare(Object o1, Object o2) { return ((String) o2).compareTo(((String) o1)); } })); }} 1234567891011121314151617181920212223242526=====reverse=====[roy, summer, cecil, roy]=====shuffle=====[roy, roy, summer, cecil][roy, cecil, roy, summer][roy, cecil, summer, roy]=====sort=====[cecil, roy, roy, summer]=====sort传入比较器=====[summer, cecil, roy, roy]=====swap=====[summer, roy, cecil, roy]=====frequency=====2=====copy=====[summer, roy, cecil, roy, henry, jacky, jack]=====replaceAll=====[summer, lucky, cecil, lucky, henry, jacky, jack]=====max=====summer=====max=====jack=====min=====cecil=====min=====summer 集合框架练习练习题一题目： 封装一个新闻类，包含标题和内容属性，提供get、set方法，重写toString方法，打印对象时只打印标题。 只提供一个带参数的构造器，实例化对象时，只初始化标题；并且实例化两个对象。 将新闻对象添加到ArrayList集合中，并且进行倒序遍历。 在遍历集合的过程中，对新闻标题进行处理，超过15个字的，只保留前15个，然后在后边加上”…” 在控制台打印遍历经过处理的新闻标题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Homework01 { public static void main(String[] args) { ArrayList arrayList = new ArrayList(); News news01 = new News(\"a今天是世界读书日 在书中“读”行四海 用画笔畅游太空\"); News news02 = new News(\"b海军 中国人民解放军海军成立73周年 十年之变：人民海军风浪中步履铿锵\"); arrayList.add(news01); arrayList.add(news02); Collections.sort(arrayList, new Comparator() { @Override public int compare(Object o1, Object o2) { return ((News) o2).getTitle().compareTo(((News) o1).getTitle()); } }); Iterator iterator = arrayList.iterator(); while (iterator.hasNext()) { News news = (News) iterator.next(); String title = news.getTitle(); if (title.length() &gt; 15) { news.setTitle(title.substring(0, 15) + \"...\"); } System.out.println(news.getTitle()); } }}class News { private String title; private String content; public News(String title) { this.title = title; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } @Override public String toString() { return \"News{\" + \"title='\" + title + '\\'' + '}'; }} 12b海军 中国人民解放军海军成立...a今天是世界读书日 在书中“读... 练习题二使用ArrayList完成对象Car{name, price}的各种操作 add: 添加单个元素 remove： 删除指定元素 contains：查找元素是否存在 size：获取元素个数 isEmpty：判断是否为空 clear：清空 addAll：添加多个元素 containsAll：查找多个元素是否都存在 removeAll：删除多个元素 使用增强for和迭代器来遍历所有的Car，需要重写Car的toString()方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class Homework02 { public static void main(String[] args) { List list = new ArrayList(); List list2 = new ArrayList(); List list3 = new ArrayList(); Car car1 = new Car(\"亚洲龙\", 270000); Car car2 = new Car(\"奥迪A7L\", 770000); Car car3 = new Car(\"思域\", 160000); Car car4 = new Car(\"宋PLUS\", 205000); Car car5 = new Car(\"速腾\", 165000); //add list.add(car1); System.out.println(\"===add===\" + list); //addAll list2.add(car2); list2.add(car3); list.addAll(list2); list3.add(car4); list3.add(car5); list.addAll(list3); System.out.println(\"===addAll===\" + list); //remove list.remove(car3); System.out.println(\"===remove===\" + list); //contains System.out.println(\"===contains===\" + list.contains(car3)); //size System.out.println(\"===size===\" + list.size()); //isEmpty System.out.println(\"===isEmpty===\" + list.isEmpty()); //containsAll System.out.println(\"===containsAll===\" + list.containsAll(list3)); //removeAll System.out.println(\"===removeAll===\" + list.removeAll(list2)); //遍历集合 System.out.println(\"=====增强for循环遍历集合=====\"); for (Object o : list) { System.out.println((Car) o); } System.out.println(\"=====迭代器遍历集合=====\"); Iterator iterator = list.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } //clear list.clear(); System.out.println(\"===clear===\" + list); }}class Car { private String name; private double price; public Car(String name, double price) { this.name = name; this.price = price; } @Override public String toString() { return \"Car{\" + \"name='\" + name + '\\'' + \", price=\" + price + '}'; }} 1234567891011121314151617===add===[Car{name='亚洲龙', price=270000.0}]===addAll===[Car{name='亚洲龙', price=270000.0}, Car{name='奥迪A7L', price=770000.0}, Car{name='思域', price=160000.0}, Car{name='宋PLUS', price=205000.0}, Car{name='速腾', price=165000.0}]===remove===[Car{name='亚洲龙', price=270000.0}, Car{name='奥迪A7L', price=770000.0}, Car{name='宋PLUS', price=205000.0}, Car{name='速腾', price=165000.0}]===contains===false===size===4===isEmpty===false===containsAll===true===removeAll===true=====增强for循环遍历集合=====Car{name='亚洲龙', price=270000.0}Car{name='宋PLUS', price=205000.0}Car{name='速腾', price=165000.0}=====迭代器遍历集合=====Car{name='亚洲龙', price=270000.0}Car{name='宋PLUS', price=205000.0}Car{name='速腾', price=165000.0}===clear===[] 练习题三 使用HashMap类实例化一个Map类型的对象m，key是String类型，value是int类型，分别用于存储员工的姓名和工资。jack-100,summer-1000,roy:2000 将jack的工资改为2600元。 为所有员工工资加薪100元。 遍历集合中的所有员工。 遍历集合中所有的工资。 123456789101112131415161718192021222324252627282930313233import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;public class Homework03 { public static void main(String[] args) { Map map = new HashMap(); map.put(\"lucky\", 5000); map.put(\"lucy\", 6000); map.put(\"henry\", 3500); map.put(\"lucky\", 8000); Iterator iterator = map.keySet().iterator(); while (iterator.hasNext()) { String key = (String) iterator.next(); int salary = (int) map.get(key); salary += 100; map.put(key, salary); } Set set = map.entrySet(); for (Object o : set) { Map.Entry entry = (Map.Entry) o; System.out.println(entry.getValue()); } System.out.println(\"===============\"); for (Object o : set) { Map.Entry entry = (Map.Entry) o; System.out.println(entry.getKey()); } }} 1234567810036006100===============luckyhenrylucy 练习题四分析HashSet和TreeSet分别如何实现去重的？ 练习题五分析下面的代码运行会不会抛出异常，并从源码层面说明原因。 1234567891011import java.util.TreeSet;public class TreeSet_ { public static void main(String[] args) { TreeSet treeSet = new TreeSet(); treeSet.add(new Person()); }}class Person {} 12345Exception in thread \"main\" java.lang.ClassCastException: com.example.hanshunping.collection.Person cannot be cast to java.lang.Comparable at java.util.TreeMap.compare(TreeMap.java:1294) at java.util.TreeMap.put(TreeMap.java:538) at java.util.TreeSet.add(TreeSet.java:255) at com.example.hanshunping.collection.TreeSet_.main(TreeSet_.java:8) 练习题六分析下面这段代码的输出结果是什么？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.HashSet;import java.util.Objects;public class Homework06 { public static void main(String[] args) { HashSet hashSet = new HashSet(); Person p1 = new Person(1001, \"AA\"); Person p2 = new Person(1001, \"BB\"); hashSet.add(p1); hashSet.add(p2); p1.setName(\"CC\"); hashSet.remove(p1); System.out.println(hashSet); hashSet.add(new Person(1001, \"CC\")); System.out.println(hashSet); hashSet.add(new Person(1001, \"AA\")); System.out.println(hashSet); }}class Person { private int id; private String name; public Person(int id, String name) { this.id = id; this.name = name; } @Override public String toString() { return \"Person{\" + \"id=\" + id + \", name='\" + name + '\\'' + '}'; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return id == person.id &amp;&amp; Objects.equals(name, person.name); } @Override public int hashCode() { return Objects.hash(id, name); } public void setId(int id) { this.id = id; } public void setName(String name) { this.name = name; }} 123[Person{id=1001, name='CC'}, Person{id=1001, name='BB'}][Person{id=1001, name='CC'}, Person{id=1001, name='BB'}, Person{id=1001, name='CC'}][Person{id=1001, name='CC'}, Person{id=1001, name='BB'}, Person{id=1001, name='CC'}, Person{id=1001, name='AA'}]","categories":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"https://xiaofanshutu.github.io/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}],"tags":[],"author":"cutiebambi"},{"title":"Java面向对象总结","slug":"Java面向对象基础","date":"2022-04-06T13:20:01.000Z","updated":"2024-01-17T23:40:08.640Z","comments":true,"path":"posts/ec82f976.html","link":"","permalink":"https://xiaofanshutu.github.io/posts/ec82f976.html","excerpt":"","text":"Java基础包机制包就相当于文件夹 学习阿里巴巴开发手册 Java方法什么是方法12System.out.println();类名.对象.方法名 方法的定义及调用方法重载方法名相同，参数不同。 命令行传参可变参数任何方法最多只能有一个可变参数，并且必须是参数列表最后一个。 递归（工作中不常用）示例代码1234567891011public static void main(String[] args) { System.out.println(f(5));}public static int f(int i) { if (i == 1) { return 1; } else { return i * f(i - 1); }} Java数组数组概述相同数据类型的有序集合 1int[] arrays = {1, 2, 3}; 数组声明创建12int[] num = new int[10];num.length 三种初始化静态初始化1int[] arrays = {1, 2, 3}; 动态初始化123int[] arrays = new int[2];arrays[0] = 1;arrays[1] = 2; 默认初始化数组是引用类型，它的元素相当于类的实例变量。 123int[] arrays = new int[2];System.out.println(arrays[0]);//输出0System.out.println(arrays[1]);//输出0 数组的四个基本特点 长度是确定的。一旦创建，就不可以改变大小。 元素必须是相同类型。 元素可以是任何数据类型，包括基本类型和引用类型。 数组变量属于引用类型，数组也可以看做是对象，数组中的每个元素相当于该对象的成员变量。 数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，数组本身都是在堆中的。 数组使用 for循环 1234int[] arrays = new int[]{1,2,3};for (int i = 0; i &lt; arrays.length; i++) { System.out.println(arrays[i] + \" \");} 增强for循环 1234int[] arrays = new int[]{1,2,3};for (int num: arrays) { System.out.println(num + \" \");} 作为方法参数 作为方法返回值 多维数组1int[][] arrays = {{1,2}, {3,4}, {5,6}} Arrays类Arrays类中的方法都是static修饰的。 Arrays类的结构图 扩展知识：IDEA中的Structure模块使用详解 类方法的展示 开头的 m 标识是表示方法，如果出现 f 标识则表示为属性； m 或者 f 后面紧跟着的是方法或者属性的访问修饰符： #红色关闭的锁表示为private； #圆圈表示不带任何修饰符，default； #一把钥匙代表protected； #绿色打开的锁代表public； 接下来是方法名称； 括号内为方法的入参类型； 冒号后面为方法的返回值类型； 顶部各个图标说明 表示展示的顺序按照访问权限从public到private的格式展示；（structure排序都是先展示方法，再展示属性，这个不可设置和更改） 表示展示的顺序按照开头字母a-z的顺序来展示； 会展示实现的接口类和继承的抽象类，把所有的实现方法展示在其中； 会展示类中所有属性的get、set方法； 会展示所有的属性字段；（注意：单独使用只会展示修饰符为public的属性字段，想要展示其他访问修饰符的字段需要结合下面说到的红色锁来实现）； structure默认只会展示被public修饰的属性，需要查看非公有属性需要使用该按钮； 展示所继承的方法，包括所继承的object方法； 会展示出匿名内部类； 会展示出使用的lambda表达式； 点击左侧属性和方法时，右侧代码跟着滚动定位； 点击右侧代码中的属性和方法时，左侧的structure中对应的属性和方法跟着滚动定位； 常用方法 给数组赋值：通过fill方法 对数组排序：通过sort方法，按升序排序 比较数组：通过equals方法比较数组中的元素是否相等 查找数组元素：通过binarySearch方法能对排序好的数组进行二分查找操作 冒泡排序外层循环：控制循环的次数 内层循环：比较两个数字的大小 123456789101112131415public static void main(String[] args) { int[] arrays = new int[]{10,20,3, 8, 65, 99, 130, 120}; for (int i = 0; i &lt; arrays.length; i++) { for (int j = 0; j &lt; i; j++) { if(arrays[i] &gt; arrays[j]){ int num = arrays[i]; arrays[i] = arrays[j]; arrays[j] = num; } } } for (int array: arrays) { System.out.print(array + \" \"); }} 1130 120 99 65 20 10 8 3 稀疏数组这一节我跳过了，没有学 什么是面向对象面向对象的本质就是：以类的方式组织代码，以对象的组织（封装）数据。 从认识论角度考虑是先有对象后有类。对象，是具体的事物。类，是抽象的，是对对象的抽象。 从代码运行角度考虑是先有类后有对象。类是对象的模板。 回顾方法及加深理解方法的定义break和return的区别 break 跳出当前循环；但是如果是嵌套循环，则只能跳出当前的这一层循环，只有逐层break才能跳出所有循环。 123456789public void breakTest() { for (int i = 0; i &lt; 10; i++) { if (i == 6) { break; // 在执行i==6时强制终止循环，i==6不会被执行 } System.out.println(i); }} 输出结果为0 1 2 3 4 5 ；6以后的都不会输出 10 1 2 3 4 5 continue ​ 终止当前循环，但是不会跳出循环，终止当前循环后，会根据条件，继续往下根据循环条件执行循环。 123456789public void continueTest() { for (int i = 0; i &lt; 10; i++) { if (i == 6) { continue; // i==6不会被执行，而是被中断了 } System.out.println(i); }} 输出结果为0 1 2 3 4 5 7 8 9；只有6没有输出 10 1 2 3 4 5 7 8 9 return 从当前的方法中退出，返回到该调用方法的语句处，继续执行。 返回一个值给调用该方法的语句，返回值的数据类型必须与方法的声明中的返回值类型一致。 Java中break continue和return的区别 方法的调用静态方法与非静态方法的区别 ==调用方法不同== 静态方法可以直接调用，类名调用和对象调用。 非静态方法只能通过对象调用。 ==生命周期不同== 静态方法的生命周期和对应的类一样长，静态方法和静态变量会跟随着类的定义而被分配合装载入内存中。一直到线程结束，静态属性和方法才会被销毁。（也就是静态方法属于类） 非静态方法的生命周期和类的实例化对象一样长，只有当类实例化了一个对象，非静态方法才会被创建，而当这个对象被销毁的时候，非静态方法也马上被销毁。（也就是非静态方法属于对象） 这个内容是参考这个文章写的 静态方法和非静态方法的区别 java中的this关键字 当局部变量与成员变量重名的时候，可以使用this表明用的是对象的成员变量。 当方法需要一个该类的对象做参数的时候，可以用this代替。 当一个方法需要返回对当前对象的引用的时候，可以用return this。 现在针对上面的每一种情况，写一个例子，方便理解。 第一点： 123456789101112131415161718192021222324252627282930public class learnKeywordThis { public String s = \"A\"; public learnKeywordThis() { } public learnKeywordThis(String s) { System.out.println(\"s的值 = \" + s); s = \"B\"; System.out.println(\"经过s=\\\"B\\\"赋值后成员变量s的值\"); System.out.println(\"成员变量s的值 = \" + this.s); this.s = \"B\"; System.out.println(\"经过this.s=\\\"B\\\"赋值后成员变量s的值\"); System.out.println(\"成员变量s的值 = \" + this.s); } public void show() { System.out.println(\"无参构造器中成员变量s的值 = \" + s); } public static void main(String[] args) { System.out.println(\"调用无参构造器\"); new learnKeywordThis().show(); System.out.println(\"调用含参构造器后\"); new learnKeywordThis(\"C\"); }} Output 12345678调用无参构造器无参构造器中成员变量s的值 = A调用含参构造器后s的值 = C经过s=\"B\"赋值后成员变量s的值成员变量s的值 = A经过this.s=\"B\"赋值后成员变量s的值成员变量s的值 = B 第二点： 1234567891011121314151617181920class B { B(A a) { a.show(); }}public class A { public void doB() { new B(this); } public void show() { System.out.println(\"我是A\"); } public static void main(String[] args) { new A().doB(); }} Output 1我是A 12345678910111213141516171819class B { public B() { System.out.println(\"这里的this是\" + this.getClass().getSimpleName()); } public void Bshow() { System.out.println(\"这里的this是\" + this.getClass().getSimpleName()); }}public class A extends B { public A() { } public static void main(String[] args) { new A(); new B().Bshow(); }} 123这里的this是A这里的this是B这里的this是B 我们这里讨论了this的五种用法，但是都是根据this的定义引申出在不同情况下的用法。this只能在方法内部使用，当调用方法中含有this的时候，this就指的调用该方法的对象的引用，当方法参数中需要传入一个类的对象的时候，用this代指这个传入类的对象。当用构造方法初始化成员变量的时候，JVM会默认传入当前对象来初始化成员变量。 Java this的一两点使用 Java this keyword Oracle Using the this keyword 形参和实参值传递和引用传递类与对象的关系创建与初始化对象使用new关键字创建对象使用new关键字创建对象的时候，除了分配内存空间之外，还会给创建好的对象进行默认的初始化以及对类中构造器的调用。 使用new关键字，本质是在调用构造器 构造器必须要掌握哦 构造器： 和类名相同 没有返回值 作用： new 本质是在调用构造方法 初始化对象的值 注意点： 定义有参构造之后，如果想使用无参构造，就必须显示的定义一个无参的构造。 Alt+Insert快捷键 Java简单的内存图 前期学习的一个小总结 类与对象 类是一个模板，抽象的，对象是一个具体的实例。 方法 定义，调用。 对象的引用 引用类型 基本类型 对象是通过引用来操作的： 栈 —-&gt; 堆 属性：字段Field 成员变量 默认初始化： ​ 数字：0 0.0 ​ char：u0000 ​ boolean：false ​ 引用：null 修饰符 属性类型 属性名 = 属性值！ 对象的创建和使用 必须使用new关键字创建对象，构造器 Person person = new Person(); 对象的属性 person.name 对象的方法 person.sleep(); 类 静态的属性 属性 动态的行为 方法 封装该露的露，该藏的藏写程序要追求高内聚，低耦合。 高内聚：类的内部数据操作细节自己完成，不允许外部干涉。 低耦合：仅仅暴露少量的方法给外部使用。 属性私有，get/set12345678910public class Application { public static void main(String[] args) { Student s1 = new Student(); s1.setName(\"jack\"); s1.setAge(30); System.out.println(\"name:\" + s1.getName() + \",age: \" + s1.getAge()); }} 12345678910111213141516171819202122public class Student { //属性私有 private String name; private int age; // 提供一些可以操作这些属性的公有方法. get/set public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} 1name:jack,age: 30 封装的意义 提高程序的安全性，保护数据 隐藏代码的实现细节 统一接口 系统可维护性增加了 继承概念​ 继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。 ​ extends ​ Java中的类只有单继承，没有多继承 ​ 继承就是扩展，子类对父类的扩展 ​ 子类和父类之间的关系，具有“is a”的关系。 ​ 子类继承父类，子类就会拥有父类的全部方法（私有的东西不会被继承） ​ 记住一个快捷键：Ctrl+H Object类在Java中，所有的类默认直接或间接继承Object类 super代码理解12345public class Application { public static void main(String[] args) { Student s1 = new Student(); }} 12345public class Person { public Person() { System.out.println(\"Person的无参构造执行了\"); }} 12345public class Student extends Person { public Student() { System.out.println(\"Student的无参构造执行了\"); }} 12Person的无参构造执行了Student的无参构造执行了 super注意点 super调用父类的构造方法，必须在构造方法的第一个 super必须只能出现在子类的方法或者构造方法中 super和this不能同时调用构造方法 ​ VS this ​ 代表的对象不同： ​ this：本身调用者这个对象 ​ super：代表父类对象的应用 ​ 前提： ​ this：没有继承也可以使用 ​ super：只能在继承条件下才可以使用 ​ 构造方法： ​ this()：本类的构造 ​ super()：父类的构造 方法重写（重点）重点需要有继承关系，子类重写父类的方法！ 方法名必须相同 参数列表必须相同 修饰符：范围可以扩大，但是不能缩小。 Public&gt;Protected&gt;Default&gt;Private 抛出的异常：范围可以被缩小，但是不能扩大。 ClassNotFoundException –&gt; Exception(大) 重写，子类的方法和父类必须要一致，方法体不同 为什么需要重写： 父类的功能，子类不一定需要，或者不一定满足。 Alt+Insert; Override 代码理解1234567891011public class Application { public static void main(String[] args) { // 方法的调用只和左边，定义的数据类型有关系 Student s1 = new Student(); s1.say(); // 父类的引用指向了子类 Person p = new Student(); p.say(); }} 12Student的say方法Student的say方法 多态多态概念 即同一个方法可以根据发送对象的不同而采用多种不同的行为方式 一个对象的实际类型是确定的，但可以指向对象的引用的类型有很多 多态存在的条件 有继承关系 子类重写父类的方法 父类引用指向子类对象 instanceof123public class Person {} 123public class Student extends Person {} 123public class Teacher extends Person {} 123456789101112131415161718192021222324252627public class Application { public static void main(String[] args) { Object object = new Student(); System.out.println(\"===Object object = new Student();===\"); System.out.println(object instanceof Student);// true System.out.println(object instanceof Person);// true System.out.println(object instanceof Object);// true System.out.println(object instanceof Teacher);// false System.out.println(object instanceof String);// false Person person = new Student(); System.out.println(\"===Person person = new Student();===\"); System.out.println(person instanceof Student);// true System.out.println(person instanceof Person);// true System.out.println(person instanceof Object);// true System.out.println(person instanceof Teacher);// false //System.out.println(person instanceof String);// 编译错误 Student student = new Student(); System.out.println(\"===Student student = new Student();===\"); System.out.println(student instanceof Student);// true System.out.println(student instanceof Person);// true System.out.println(student instanceof Object);// true //System.out.println(student instanceof Teacher);// 编译错误 //System.out.println(student instanceof String);// 编译错误 }} 多态注意事项 多态是方法的多态，属性没有多态 父类和子类，是要有联系的。 类型转换异常！ ClassCastException! 存在条件：继承关系，方法需要重写，父类引用指向子类对象！ Father f1 = new Son(); 父类引用指向子类对象 把子类转换为父类，向上转型 把父类转换为子类，向下转型；强制转换 方便方法的调用，减少重复代码 代码理解123456789101112public class Application { public static void main(String[] args) { // 一个对象的实际类型是确定的，但是可以指向的引用类型就不确定。 // 父类的引用指向子类 // 对象能执行哪些方法，主要看对象左边的类型，和右边的关系不大。 Student s1 = new Student(); Person p1 = new Student(); Object obj = new Student(); s1.run(); p1.run(); // 子类重写了父类的方法，所以这里执行的是子类的方法 }} 12345public class Person { public void run(){ System.out.println(\"Person run\"); }} 123456public class Student extends Person { @Override public void run() { System.out.println(\"Student run\"); }} 代码执行结果： 12Student runStudent run static关键字详解静态方法12345public class Student { public static void getInfo() { System.out.println(\"call get info method\"); }} 12345public class Application { public static void main(String[] args) { Student.getInfo(); }} 静态属性123456public class Student { public static String name; public static int rank; public String country; public int age;} 12345678public class Application { public static void main(String[] args) { Student student = new Student(); String name = Student.name; int rank = Student.rank; int age = student.age; }} 静态代码块12345678public class Application { public static void main(String[] args) { Person person = new Person(); System.out.println(\"=============\"); Person person2 = new Person(); }} 123456静态代码块匿名代码块构造方法=============匿名代码块构造方法 静态导入包12345678910// 静态导入包import static java.lang.Math.random;import static java.lang.Math.PI;public class Application { public static void main(String[] args) { System.out.println(random()); System.out.println(PI); }} 120.30151016218947913.141592653589793 抽象类1234567891011// abstract 抽象类， extends 单继承public abstract class Action { // 约束~有人帮我们实现 // abstract 抽象方法，只有方法名字，没有方法的实现。 public abstract void doSomething(); //1. 不能new这个抽象类，只能靠子类去实现它；约束！ //2. 抽象类中可以写普通的方法 //3. 抽象方法必须在抽象类中 // 抽象的抽象：约束} 存在抽象类的构造器吗？ 通过查看代码，发现编译后的class文件如下： 123456public abstract class Action { public Action() { } public abstract void doSomething();} 接口普通类、抽象类和接口的对比 普通类：只有具体实现 抽象类：集体实现和规范（抽象方法）都有 接口：只有规范，自己无法写方法 声明类的关键字是class，声明接口的关键字是interface接口的概念 接口就是规范，定义的是一组规则。 接口的本质在是契约，制定好之后大家都去遵守。 OO的精髓，是对对象的抽象，最能体现这一点的就是接口。 接口的作用 约束 定义一些方法，让不同的人去实现。 方法都是public abstract 属性都是public static final 接口不能被实例化，接口中没有构造方法 implements可以实现多个接口 必须要重写接口中的方法 代码理解12345678910111213141516171819202122232425262728package com.example.kuangshenjava.oop.demo09;public class UserServiceImpl implements UserService, TimeService { @Override public void add(String name) { } @Override public void remove(String name) { } @Override public void update(String name) { } @Override public void search(String name) { } @Override public void getTime() { }} 123456789package com.example.kuangshenjava.oop.demo09;public interface UserService { // 接口中所有的定义方法其实都是抽象的public abstract public abstract void add(String name); void remove(String name); void update(String name); void search(String name);} 12345package com.example.kuangshenjava.oop.demo09;public interface TimeService { void getTime();} 内部类12345678910111213141516171819public class Outer { private int id; public void out() { System.out.println(\"这是外部类的方法\"); } //普通内部类 public class Inner { private void in() { System.out.println(\"这是内部类的方法\"); } } //获得外部类的私有属性 public void getID() { System.out.println(id); }} 1234567891011121314public class Outer { private int id; public void out() { System.out.println(\"这是外部类的方法\"); } //静态内部类 public static class Inner { private void in() { System.out.println(\"这是静态内部类的方法\"); } }} 12345678910public class Outer { //局部内部类 public void method() { class Inner { private void in() { System.out.println(\"这是局部内部类的方法\"); } } }} 123456789101112public class Outer { public static void main(String[] args) { //没有名字初始化类，不用将实例保存到变量中。 new Recorder().getInfo(); }}class Recorder { public void getInfo() { System.out.println(\"Call getInfo method\"); }} 异常异常体系结构 记住以下几个关键字try catch finally throw throws 注意： throw是在代码块内的，即用于捕获方法内的异常并抛出时用 throws是针对方法的，即将方法的异常信息抛出去 可以理解为throw是主动（在方法内容里我们是主动捕获并throw的），而throws是被动（在方法上是没有捕获异常进行处理，直接throws的） 使用位置不同：throw位于方法体内部，可以作为单独语句使用，throws必须跟在方法参数列表后面，不能单独使用。 内容不同：throw抛出一个异常对象，而且只能是一个，throws后面跟异常类，可以有多个。 小技巧：IDEA快捷键 psvm ctrl + alt + t","categories":[{"name":"Java面向对象和基础","slug":"Java面向对象和基础","permalink":"https://xiaofanshutu.github.io/categories/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"cutiebambi"}],"categories":[{"name":"Oracle","slug":"Oracle","permalink":"https://xiaofanshutu.github.io/categories/Oracle/"},{"name":"MySQL","slug":"MySQL","permalink":"https://xiaofanshutu.github.io/categories/MySQL/"},{"name":"Java","slug":"Java","permalink":"https://xiaofanshutu.github.io/categories/Java/"},{"name":"Spring6","slug":"Spring6","permalink":"https://xiaofanshutu.github.io/categories/Spring6/"},{"name":"Spring","slug":"Spring","permalink":"https://xiaofanshutu.github.io/categories/Spring/"},{"name":"HTML5","slug":"HTML5","permalink":"https://xiaofanshutu.github.io/categories/HTML5/"},{"name":"Java基础","slug":"Java基础","permalink":"https://xiaofanshutu.github.io/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"新技术FreeMarker","slug":"新技术FreeMarker","permalink":"https://xiaofanshutu.github.io/categories/%E6%96%B0%E6%8A%80%E6%9C%AFFreeMarker/"},{"name":"日常","slug":"日常","permalink":"https://xiaofanshutu.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"八股文","slug":"八股文","permalink":"https://xiaofanshutu.github.io/categories/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://xiaofanshutu.github.io/categories/SpringBoot/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://xiaofanshutu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"Javascript","slug":"Javascript","permalink":"https://xiaofanshutu.github.io/categories/Javascript/"},{"name":"Java Web","slug":"Java-Web","permalink":"https://xiaofanshutu.github.io/categories/Java-Web/"},{"name":"Java IO","slug":"Java-IO","permalink":"https://xiaofanshutu.github.io/categories/Java-IO/"},{"name":"Java集合框架","slug":"Java集合框架","permalink":"https://xiaofanshutu.github.io/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"},{"name":"Java面向对象和基础","slug":"Java面向对象和基础","permalink":"https://xiaofanshutu.github.io/categories/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%9F%BA%E7%A1%80/"}],"tags":[]}