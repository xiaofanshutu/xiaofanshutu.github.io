<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>caomeidafu</title>
  
  
  <link href="https://xiaofanshutu.github.io/atom.xml" rel="self"/>
  
  <link href="https://xiaofanshutu.github.io/"/>
  <updated>2025-09-07T23:28:25.714Z</updated>
  <id>https://xiaofanshutu.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://xiaofanshutu.github.io/posts/0.html"/>
    <id>https://xiaofanshutu.github.io/posts/0.html</id>
    <published>2025-09-07T23:26:13.342Z</published>
    <updated>2025-09-07T23:28:25.714Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://s2.loli.net/2022/09/24/AulBzXWK6JCPMH5.png" alt="image-20220924223020333"></p><h1 id="泛型程序设计"><a href="#泛型程序设计" class="headerlink" title="泛型程序设计"></a>泛型程序设计</h1><p>在前面我们学习了最重要的类和对象，了解了面向对象编程的思想，注意，非常重要，面向对象是必须要深入理解和掌握的内容，不能草草结束。在本章节，我们还会继续深入了解，从泛型开始，再到数据结构，最后再开始我们的集合类学习，循序渐进。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>为了统计学生成绩，要求设计一个Score对象，包括课程名称、课程号、课程成绩，但是成绩分为两种，一种是以<code>优秀、良好、合格</code> 来作为结果，还有一种就是 <code>60.0、75.5、92.5</code> 这样的数字分数，可能高等数学这门课是以数字成绩进行结算，而计算机网络实验这门课是以等级进行结算，这两种分数类型都有可能出现，那么现在该如何去设计这样的一个Score类呢？</p><p>现在的问题就是，成绩可能是<code>String</code>类型，也可能是<code>Integer</code>类型，如何才能很好的去存可能出现的两种类型呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Score</span> </span>{<br>    String name;<br>    String id;<br>    Object value;  <span class="hljs-comment">//因为Object是所有类型的父类，因此既可以存放Integer也能存放String</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Score</span><span class="hljs-params">(String name, String id, Object value)</span> </span>{<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.value = value;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>以上的方法虽然很好地解决了多种类型存储问题，但是Object类型在编译阶段并不具有良好的类型判断能力，很容易出现以下的情况：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br><br>    Score score = <span class="hljs-keyword">new</span> Score(<span class="hljs-string">"数据结构与算法基础"</span>, <span class="hljs-string">"EP074512"</span>, <span class="hljs-string">"优秀"</span>);  <span class="hljs-comment">//是String类型的</span><br><br>    ...<br><br>    Integer number = (Integer) score.score;  <span class="hljs-comment">//获取成绩需要进行强制类型转换，虽然并不是一开始的类型，但是编译不会报错</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>使用Object类型作为引用，对于使用者来说，由于是Object类型，所以说并不能直接判断存储的类型到底是String还是Integer，取值只能进行强制类型转换，显然无法在编译期确定类型是否安全，项目中代码量非常之大，进行类型比较又会导致额外的开销和增加代码量，如果不经比较就很容易出现类型转换异常，代码的健壮性有所欠缺</p><p>所以说这种解决办法虽然可行，但并不是最好的方案。</p><p>为了解决以上问题，JDK 5新增了泛型，它能够在编译阶段检查类型安全，大大提升开发效率。</p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型其实就一个待定类型，我们可以使用一个特殊的名字表示泛型，泛型在定义时并不明确是什么类型，而是需要到使用时才会确定对应的泛型类型。</p><p>我们可以将一个类定义为一个泛型类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Score</span>&lt;<span class="hljs-title">T</span>&gt; </span>{   <span class="hljs-comment">//泛型类需要使用&lt;&gt;，我们需要在里面添加1 - N个类型变量</span><br>    String name;<br>    String id;<br>    T value;   <span class="hljs-comment">//T会根据使用时提供的类型自动变成对应类型</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Score</span><span class="hljs-params">(String name, String id, T value)</span> </span>{   <span class="hljs-comment">//这里T可以是任何类型，但是一旦确定，那么就不能修改了</span><br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.value = value;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们来看看这是如何使用的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Score&lt;String&gt; score = <span class="hljs-keyword">new</span> Score&lt;String&gt;(<span class="hljs-string">"计算机网络"</span>, <span class="hljs-string">"EP074512"</span>, <span class="hljs-string">"优秀"</span>);<br>  <span class="hljs-comment">//因为现在有了类型变量，在使用时同样需要跟上&lt;&gt;并在其中填写明确要使用的类型</span><br>  <span class="hljs-comment">//这样我们就可以根据不同的类型进行选择了</span><br>    String value = score.value;   <span class="hljs-comment">//一旦类型明确，那么泛型就变成对应的类型了</span><br>    System.out.println(value);<br>}<br></code></pre></td></tr></tbody></table></figure><p>泛型将数据类型的确定控制在了编译阶段，在编写代码的时候就能明确泛型的类型，如果类型不符合，将无法通过编译！因为是具体使用对象时才会明确具体类型，所以说静态方法中是不能用的：</p><p><img src="https://s2.loli.net/2022/09/27/RCqAhvMGzNwfH7J.png" alt="image-20220927135128332"></p><p>只不过这里需要注意一下，我们在方法中使用待确定类型的变量时，因为此时并不明确具体是什么类型，那么默认会认为这个变量是一个Object类型的变量，因为无论具体类型是什么，一定是Object类的子类：</p><p><img src="https://s2.loli.net/2022/09/26/gkFs35US9rxo7f2.png" alt="image-20220926235642963"></p><p>我们可以对其进行强制类型转换，但是实际上没多大必要：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>{<br>    String str = (String) t;   <span class="hljs-comment">//都明确要用String了，那这里定义泛型不是多此一举吗</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>因为泛型本身就是对某些待定类型的简单处理，如果都明确要使用什么类型了，那大可不必使用泛型。还有，不能通过这个不确定的类型变量就去直接创建对象和对应的数组：</p><p><img src="https://s2.loli.net/2022/09/27/RlHYhPSUJ5ICswG.png" alt="image-20220927134825845"></p><p>注意，具体类型不同的泛型类变量，不能使用不同的变量进行接收：</p><p><img src="https://s2.loli.net/2022/09/25/jhekq9ZKHoiT2yI.png" alt="image-20220925170746329"></p><p>如果要让某个变量支持引用确定了任意类型的泛型，那么可以使用<code>?</code>通配符：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Test&lt;?&gt; test = <span class="hljs-keyword">new</span> Test&lt;Integer&gt;();<br>    test = <span class="hljs-keyword">new</span> Test&lt;String&gt;();<br>  Object o = test.value;    <span class="hljs-comment">//但是注意，如果使用通配符，那么由于类型不确定，所以说具体类型同样会变成Object</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>当然，泛型变量不止可以只有一个，如果需要使用多个的话，我们也可以定义多个：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">A</span>, <span class="hljs-title">B</span>, <span class="hljs-title">C</span>&gt; </span>{   <span class="hljs-comment">//多个类型变量使用逗号隔开</span><br>    <span class="hljs-keyword">public</span> A a;<br>    <span class="hljs-keyword">public</span> B b;<br>    <span class="hljs-keyword">public</span> C c;<br>}<br></code></pre></td></tr></tbody></table></figure><p>那么在使用时，就需要将这三种类型都进行明确指定：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Test&lt;String, Integer, Character&gt; test = <span class="hljs-keyword">new</span> Test&lt;&gt;();  <span class="hljs-comment">//使用钻石运算符可以省略其中的类型</span><br>    test.a = <span class="hljs-string">"lbwnb"</span>;<br>    test.b = <span class="hljs-number">10</span>;<br>    test.c = <span class="hljs-string">'淦'</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>是不是感觉好像还是挺简单的？只要是在类中，都可以使用类型变量：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">T</span>&gt;</span>{<br>    <br>    <span class="hljs-keyword">private</span> T value;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(T value)</span> </span>{<br>        <span class="hljs-keyword">this</span>.value = value;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> value;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>只不过，泛型只能确定为一个引用类型，基本类型是不支持的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">T</span>&gt;</span>{<br>    <span class="hljs-keyword">public</span> T value;<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/09/26/TI6tWwj4vXFdenr.png" alt="image-20220926232135111"></p><p>如果要存放基本数据类型的值，我们只能使用对应的包装类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Test&lt;Integer&gt; test = <span class="hljs-keyword">new</span> Test&lt;&gt;();<br>}<br></code></pre></td></tr></tbody></table></figure><p>当然，如果是基本类型的数组，因为数组本身是引用类型，所以说是可以的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Test&lt;<span class="hljs-keyword">int</span>[]&gt; test = <span class="hljs-keyword">new</span> Test&lt;&gt;();<br>}<br></code></pre></td></tr></tbody></table></figure><p>通过使用泛型，我们就可以将某些不明确的类型在具体使用时再明确。</p><h3 id="泛型与多态"><a href="#泛型与多态" class="headerlink" title="泛型与多态"></a>泛型与多态</h3><p>不只是类，包括接口、抽象类，都是可以支持泛型的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Study</span>&lt;<span class="hljs-title">T</span>&gt; </span>{<br>    <span class="hljs-function">T <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>当子类实现此接口时，我们可以选择在实现类明确泛型类型，或是继续使用此泛型让具体创建的对象来确定类型：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        A a = <span class="hljs-keyword">new</span> A();<br>        Integer i = a.test();<br>    }<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Study</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>{   <br>      <span class="hljs-comment">//在实现接口或是继承父类时，如果子类是一个普通类，那么可以直接明确对应类型</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>或者是继续摆烂，依然使用泛型：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        A&lt;String&gt; a = <span class="hljs-keyword">new</span> A&lt;&gt;();<br>        String i = a.test();<br>    }<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Study</span>&lt;<span class="hljs-title">T</span>&gt; </span>{   <br>      <span class="hljs-comment">//让子类继续为一个泛型类，那么可以不用明确</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>继承也是同样的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&lt;<span class="hljs-title">T</span>&gt; </span>{<br>    <br>}<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span>&lt;<span class="hljs-title">String</span>&gt; </span>{<br><br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>当然，类型变量并不是只能在泛型类中才可以使用，我们也可以定义泛型方法。</p><p>当某个方法（无论是是静态方法还是成员方法）需要接受的参数类型并不确定时，我们也可以使用泛型来表示：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        String str = test(<span class="hljs-string">"Hello World!"</span>);<br>    }<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>{   <span class="hljs-comment">//在返回值类型前添加&lt;&gt;并填写泛型变量表示这个是一个泛型方法</span><br>        <span class="hljs-keyword">return</span> t;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>泛型方法会在使用时自动确定泛型类型，比如上我们定义的是类型T作为参数，同样的类型T作为返回值，实际传入的参数是一个字符串类型的值，那么T就会自动变成String类型，因此返回值也是String类型。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    String[] strings = <span class="hljs-keyword">new</span> String[<span class="hljs-number">1</span>];<br>    Main main = <span class="hljs-keyword">new</span> Main();<br>    main.add(strings, <span class="hljs-string">"Hello"</span>);<br>    System.out.println(Arrays.toString(strings));<br>}<br><br><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T[] arr, T t)</span></span>{<br>    arr[<span class="hljs-number">0</span>] = t;<br>}<br></code></pre></td></tr></tbody></table></figure><p>实际上泛型方法在很多工具类中也有，比如说Arrays的排序方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer[] arr = {<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>};<br>Arrays.sort(arr, <span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() {   <br>  <span class="hljs-comment">//通过创建泛型接口的匿名内部类，来自定义排序规则，因为匿名内部类就是接口的实现类，所以说这里就明确了类型</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> </span>{   <span class="hljs-comment">//这个方法会在执行排序时被调用（别人来调用我们的实现）</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    }<br>});<br></code></pre></td></tr></tbody></table></figure><p>比如现在我们想要让数据从大到小排列，我们就可以自定义：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Integer[] arr = {<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>};<br>    Arrays.sort(arr, <span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() {<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> </span>{   <span class="hljs-comment">//两个需要比较的数会在这里给出</span><br>            <span class="hljs-keyword">return</span> o2 - o1;    <br>          <span class="hljs-comment">//compare方法要求返回一个int来表示两个数的大小关系，大于0表示大于，小于0表示小于</span><br>          <span class="hljs-comment">//这里直接o2-o1就行，如果o2比o1大，那么肯定应该排在前面，所以说返回正数表示大于</span><br>        }<br>    });<br>    System.out.println(Arrays.toString(arr));<br>}<br></code></pre></td></tr></tbody></table></figure><p>因为我们前面学习了Lambda表达式，像这种只有一个方法需要实现的接口，直接安排了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Integer[] arr = {<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>};<br>    Arrays.sort(arr, (o1, o2) -&gt; o2 - o1);   <span class="hljs-comment">//瞬间变一行，效果跟上面是一样的</span><br>    System.out.println(Arrays.toString(arr));<br>}<br></code></pre></td></tr></tbody></table></figure><p>包括数组复制方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    String[] arr = {<span class="hljs-string">"AAA"</span>, <span class="hljs-string">"BBB"</span>, <span class="hljs-string">"CCC"</span>};<br>    String[] newArr = Arrays.copyOf(arr, <span class="hljs-number">3</span>);   <span class="hljs-comment">//这里传入的类型是什么，返回的类型就是什么，也是用到了泛型</span><br>    System.out.println(Arrays.toString(newArr));<br>}<br></code></pre></td></tr></tbody></table></figure><p>因此，泛型实际上在很多情况下都能够极大地方便我们对于程序的代码设计。</p><h3 id="泛型的界限"><a href="#泛型的界限" class="headerlink" title="泛型的界限"></a>泛型的界限</h3><p>现在有一个新的需求，现在没有String类型的成绩了，但是成绩依然可能是整数，也可能是小数，这时我们不希望用户将泛型指定为除数字类型外的其他类型，我们就需要使用到泛型的上界定义：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Score</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span>&gt; </span>{   <span class="hljs-comment">//设定类型参数上界，必须是Number或是Number的子类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> T value;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Score</span><span class="hljs-params">(String name, String id, T value)</span> </span>{<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.value = value;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> value;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>只需要在泛型变量的后面添加<code>extends</code>关键字即可指定上界，使用时，具体类型只能是我们指定的上界类型或是上界类型的子类，不得是其他类型。否则一律报错：</p><p><img src="https://s2.loli.net/2022/09/27/BAgmdCkDFL62V8H.png" alt="image-20220927000902574"></p><p>实际上就像这样：</p><p><img src="https://s2.loli.net/2022/09/27/rLnjHp73tdFSPUM.png" alt="img"></p><p>同样的，当我们在使用变量时，泛型通配符也支持泛型的界限：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Score&lt;? extends Integer&gt; score = <span class="hljs-keyword">new</span> Score&lt;&gt;(<span class="hljs-string">"数据结构与算法"</span>, <span class="hljs-string">"EP074512"</span>, <span class="hljs-number">60</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>那么既然泛型有上界，那么有没有下界呢？肯定的啊：</p><p><img src="https://s2.loli.net/2022/09/27/UJg7s41NC9Gn6fX.png" alt="image-20220927002611032"></p><p>只不过下界仅适用于通配符，对于类型变量来说是不支持的。下界限定就像这样：</p><p><img src="https://s2.loli.net/2022/09/27/QFZNSCpnAmKG7qr.png" alt="4aa52791-73f4-448f-bab3-9133ea85d850.jpg"></p><p>那么限定了上界后，我们再来使用这个对象的泛型成员，会变成什么类型呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Score&lt;? extends Number&gt; score = <span class="hljs-keyword">new</span> Score&lt;&gt;(<span class="hljs-string">"数据结构与算法基础"</span>, <span class="hljs-string">"EP074512"</span>, <span class="hljs-number">10</span>);<br>    Number o = score.getValue();   <span class="hljs-comment">//可以看到，此时虽然使用的是通配符，但是不再是Object类型，而是对应的上界</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>但是我们限定下界的话，因为还是有可能是Object，所以说依然是跟之前一样：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Score&lt;? <span class="hljs-keyword">super</span> Number&gt; score = <span class="hljs-keyword">new</span> Score&lt;&gt;(<span class="hljs-string">"数据结构与算法基础"</span>, <span class="hljs-string">"EP074512"</span>, <span class="hljs-number">10</span>);<br>    Object o = score.getValue();<br>}<br></code></pre></td></tr></tbody></table></figure><p>通过给设定泛型上限，我们就可以更加灵活地控制泛型的具体类型范围。</p><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>前面我们已经了解如何使用泛型，那么泛型到底是如何实现的呢，程序编译之后的样子是什么样的？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &lt;<span class="hljs-title">T</span>&gt;</span>{<br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> T <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>实际上在Java中并不是真的有泛型类型（为了兼容之前的Java版本）因为所有的对象都是属于一个普通的类型，一个泛型类型编译之后，实际上会直接使用默认的类型：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> Object <span class="hljs-title">test</span><span class="hljs-params">(Object t)</span></span>;  <span class="hljs-comment">//默认就是Object</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>当然，如果我们给类型变量设定了上界，那么会从默认类型变成上界定义的类型：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span>&gt;</span>{   <span class="hljs-comment">//设定上界为Number</span><br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> T <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>那么编译之后：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> Number <span class="hljs-title">test</span><span class="hljs-params">(Number t)</span></span>;  <span class="hljs-comment">//上界Number，因为现在只可能出现Number的子类</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>因此，泛型其实仅仅是在编译阶段进行类型检查，当程序在运行时，并不会真的去检查对应类型，所以说哪怕是我们不去指定类型也可以直接使用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Test test = <span class="hljs-keyword">new</span> Test();    <span class="hljs-comment">//对于泛型类Test，不指定具体类型也是可以的，默认就是原始类型</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>只不过此时编译器会给出警告：</p><p><img src="https://s2.loli.net/2022/09/27/kVCIg3TilOuLFmj.png" alt="image-20220927131226728"></p><p>同样的，由于类型擦除，实际上我们在使用时，编译后的代码是进行了强制类型转换的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    A&lt;String&gt; a = <span class="hljs-keyword">new</span> B();<br>    String  i = a.test(<span class="hljs-string">"10"</span>);     <span class="hljs-comment">//因为类型A只有返回值为原始类型Object的方法</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>实际上编译之后：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    A a = <span class="hljs-keyword">new</span> B();<br>    String i = (String) a.test(<span class="hljs-string">"10"</span>);   <span class="hljs-comment">//依靠强制类型转换完成的</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>不过，我们思考一个问题，既然继承泛型类之后可以明确具体类型，那么为什么<code>@Override</code>不会出现错误呢？我们前面说了，重写的条件是需要和父类的返回值类型和形参一致，而泛型默认的原始类型是Object类型，子类明确后变为其他类型，这显然不满足重写的条件，但是为什么依然能编译通过呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span>&lt;<span class="hljs-title">String</span>&gt;</span>{<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function">String <span class="hljs-title">test</span><span class="hljs-params">(String s)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们来看看编译之后长啥样：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Compiled from "B.java"</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">test</span>.<span class="hljs-title">entity</span>.<span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">com</span>.<span class="hljs-title">test</span>.<span class="hljs-title">entity</span>.<span class="hljs-title">A</span>&lt;<span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">String</span>&gt; </span>{<br>  <span class="hljs-keyword">public</span> com.test.entity.B();<br>  java.lang.<span class="hljs-function">String <span class="hljs-title">test</span><span class="hljs-params">(java.lang.String)</span></span>;<br>  java.lang.<span class="hljs-function">Object <span class="hljs-title">test</span><span class="hljs-params">(java.lang.Object)</span></span>;   <span class="hljs-comment">//桥接方法，这才是真正重写的方法，但是使用时会调用上面的方法</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>通过反编译进行观察，实际上是编译器帮助我们生成了一个桥接方法用于支持重写：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>{<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">test</span><span class="hljs-params">(Object obj)</span> </span>{   <span class="hljs-comment">//这才是重写的桥接方法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.test((String) obj);   <span class="hljs-comment">//桥接方法调用我们自己写的方法</span><br>    }<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test</span><span class="hljs-params">(String str)</span> </span>{   <span class="hljs-comment">//我们自己写的方法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>类型擦除机制其实就是为了方便使用后面集合类（不然每次都要强制类型转换）同时为了向下兼容采取的方案。因此，泛型的使用会有一些限制：</p><p>首先，在进行类型判断时，不允许使用泛型，只能使用原始类型：</p><p><img src="https://s2.loli.net/2022/09/27/q7DQ9lAweJLOFky.png" alt="image-20220927133232627"></p><p>只能判断是不是原始类型，里面的具体类型是不支持的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Test&lt;String&gt; test = <span class="hljs-keyword">new</span> Test&lt;&gt;();<br>System.out.println(test <span class="hljs-keyword">instanceof</span> Test);   <span class="hljs-comment">//在进行类型判断时，不允许使用泛型，只能使用原始类型</span><br></code></pre></td></tr></tbody></table></figure><p>还有，泛型类型是不支持创建参数化类型数组的：</p><p><img src="https://s2.loli.net/2022/09/27/7tK5APuSZovBLIc.png" alt="image-20220927133611288"></p><p>要用只能用原始类型：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Test[] test = <span class="hljs-keyword">new</span> Test[<span class="hljs-number">10</span>];   <span class="hljs-comment">//同样是因为类型擦除导致的，运行时可不会去检查具体类型是什么</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>只不过只是把它当做泛型类型的数组还是可以用的：</p><p><img src="https://s2.loli.net/2022/09/27/upjWbyq9XC5FLDv.png" alt="image-20220927134335255"></p><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>学习了泛型，我们来介绍一下再JDK 1.8中新增的函数式接口。</p><p>函数式接口就是JDK1.8专门为我们提供好的用于Lambda表达式的接口，这些接口都可以直接使用Lambda表达式，非常方便，这里我们主要介绍一下四个主要的函数式接口：</p><p><strong>Supplier供给型函数式接口：</strong>这个接口是专门用于供给使用的，其中只有一个get方法用于获取需要的对象。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span>   <span class="hljs-comment">//函数式接口都会打上这样一个注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Supplier</span>&lt;<span class="hljs-title">T</span>&gt; </span>{<br>    <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">//实现此方法，实现供给功能</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>比如我们要实现一个专门供给Student对象Supplier，就可以使用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>{<br>        System.out.println(<span class="hljs-string">"我是学生！"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//专门供给Student对象的Supplier</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Supplier&lt;Student&gt; STUDENT_SUPPLIER = Student::<span class="hljs-keyword">new</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Student student = STUDENT_SUPPLIER.get();<br>    student.hello();<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>Consumer消费型函数式接口：</strong>这个接口专门用于消费某个对象的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Consumer</span>&lt;<span class="hljs-title">T</span>&gt; </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(T t)</span></span>;    <span class="hljs-comment">//这个方法就是用于消费的，没有返回值</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> Consumer&lt;T&gt; <span class="hljs-title">andThen</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; after)</span> </span>{   <span class="hljs-comment">//这个方法便于我们连续使用此消费接口</span><br>        Objects.requireNonNull(after);<br>        <span class="hljs-keyword">return</span> (T t) -&gt; { accept(t); after.accept(t); };<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>使用起来也是很简单的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//专门消费Student对象的Consumer</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Consumer&lt;Student&gt; STUDENT_CONSUMER = student -&gt; System.out.println(student+<span class="hljs-string">" 真好吃！"</span>);<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Student student = <span class="hljs-keyword">new</span> Student();<br>    STUDENT_CONSUMER.accept(student);<br>}<br></code></pre></td></tr></tbody></table></figure><p>当然，我们也可以使用<code>andThen</code>方法继续调用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Student student = <span class="hljs-keyword">new</span> Student();<br>    STUDENT_CONSUMER   <span class="hljs-comment">//我们可以提前将消费之后的操作以同样的方式预定好</span><br>            .andThen(stu -&gt; System.out.println(<span class="hljs-string">"我是吃完之后的操作！"</span>)) <br>            .andThen(stu -&gt; System.out.println(<span class="hljs-string">"好了好了，吃饱了！"</span>))<br>            .accept(student);   <span class="hljs-comment">//预定好之后，再执行</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>这样，就可以在消费之后进行一些其他的处理了，使用很简洁的代码就可以实现：</p><p><img src="https://s2.loli.net/2022/09/27/Pu1jGzKNSvnV9YZ.png" alt="image-20220927181706365"></p><p><strong>Function函数型函数式接口：</strong>这个接口消费一个对象，然后会向外供给一个对象（前两个的融合体）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Function</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">R</span>&gt; </span>{<br>    <span class="hljs-function">R <span class="hljs-title">apply</span><span class="hljs-params">(T t)</span></span>;   <span class="hljs-comment">//这里一共有两个类型参数，其中一个是接受的参数类型，还有一个是返回的结果类型</span><br><br>    <span class="hljs-keyword">default</span> &lt;V&gt; <span class="hljs-function">Function&lt;V, R&gt; <span class="hljs-title">compose</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> V, ? extends T&gt; before)</span> </span>{<br>        Objects.requireNonNull(before);<br>        <span class="hljs-keyword">return</span> (V v) -&gt; apply(before.apply(v));<br>    }<br><br>    <span class="hljs-keyword">default</span> &lt;V&gt; <span class="hljs-function">Function&lt;T, V&gt; <span class="hljs-title">andThen</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> R, ? extends V&gt; after)</span> </span>{<br>        Objects.requireNonNull(after);<br>        <span class="hljs-keyword">return</span> (T t) -&gt; after.apply(apply(t));<br>    }<br><br>    <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Function&lt;T, T&gt; <span class="hljs-title">identity</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> t -&gt; t;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>这个接口方法有点多，我们一个一个来看，首先还是最基本的<code>apply</code>方法，这个是我们需要实现的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这里实现了一个简单的功能，将传入的int参数转换为字符串的形式</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Function&lt;Integer, String&gt; INTEGER_STRING_FUNCTION = Object::toString;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    String str = INTEGER_STRING_FUNCTION.apply(<span class="hljs-number">10</span>);<br>    System.out.println(str);<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以使用<code>compose</code>将指定函数式的结果作为当前函数式的实参：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    String str = INTEGER_STRING_FUNCTION<br>            .compose((String s) -&gt; s.length())   <span class="hljs-comment">//将此函数式的返回值作为当前实现的实参</span><br>            .apply(<span class="hljs-string">"lbwnb"</span>);   <span class="hljs-comment">//传入上面函数式需要的参数</span><br>    System.out.println(str);<br>}<br></code></pre></td></tr></tbody></table></figure><p>相反的，<code>andThen</code>可以将当前实现的返回值进行进一步的处理，得到其他类型的值：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Boolean str = INTEGER_STRING_FUNCTION<br>            .andThen(String::isEmpty)   <span class="hljs-comment">//在执行完后，返回值作为参数执行andThen内的函数式，最后得到的结果就是最终的结果了</span><br>            .apply(<span class="hljs-number">10</span>);<br>    System.out.println(str);<br>}<br></code></pre></td></tr></tbody></table></figure><p>比较有趣的是，Function中还提供了一个将传入参数原样返回的实现：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Function&lt;String, String&gt; function = Function.identity();   <span class="hljs-comment">//原样返回</span><br>    System.out.println(function.apply(<span class="hljs-string">"不会吧不会吧，不会有人听到现在还是懵逼的吧"</span>));<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>Predicate断言型函数式接口：</strong>接收一个参数，然后进行自定义判断并返回一个boolean结果。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Predicate</span>&lt;<span class="hljs-title">T</span>&gt; </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>;    <span class="hljs-comment">//这个方法就是我们要实现的</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title">and</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; other)</span> </span>{<br>        Objects.requireNonNull(other);<br>        <span class="hljs-keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title">negate</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> (t) -&gt; !test(t);<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title">or</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; other)</span> </span>{<br>        Objects.requireNonNull(other);<br>        <span class="hljs-keyword">return</span> (t) -&gt; test(t) || other.test(t);<br>    }<br><br>    <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Predicate&lt;T&gt; <span class="hljs-title">isEqual</span><span class="hljs-params">(Object targetRef)</span> </span>{<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">null</span> == targetRef)<br>                ? Objects::isNull<br>                : object -&gt; targetRef.equals(object);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以来编写一个简单的例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>{<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> score;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Predicate&lt;Student&gt; STUDENT_PREDICATE = student -&gt; student.score &gt;= <span class="hljs-number">60</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Student student = <span class="hljs-keyword">new</span> Student();<br>    student.score = <span class="hljs-number">80</span>;<br>    <span class="hljs-keyword">if</span>(STUDENT_PREDICATE.test(student)) {  <span class="hljs-comment">//test方法的返回值是一个boolean结果</span><br>        System.out.println(<span class="hljs-string">"及格了，真不错，今晚奖励自己一次"</span>);<br>    } <span class="hljs-keyword">else</span> {<br>        System.out.println(<span class="hljs-string">"不是，Java都考不及格？隔壁初中生都在打ACM了"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们也可以使用组合条件判断：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Student student = <span class="hljs-keyword">new</span> Student();<br>    student.score = <span class="hljs-number">80</span>;<br>    <span class="hljs-keyword">boolean</span> b = STUDENT_PREDICATE<br>            .and(stu -&gt; stu.score &gt; <span class="hljs-number">90</span>)   <span class="hljs-comment">//需要同时满足这里的条件，才能返回true</span><br>            .test(student);<br>    <span class="hljs-keyword">if</span>(!b) System.out.println(<span class="hljs-string">"Java到现在都没考到90分？你的室友都拿国家奖学金了"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>同样的，这个类型提供了一个对应的实现，用于判断两个对象是否相等：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Predicate&lt;String&gt; predicate = Predicate.isEqual(<span class="hljs-string">"Hello World"</span>);   <span class="hljs-comment">//这里传入的对象会和之后的进行比较</span><br>    System.out.println(predicate.test(<span class="hljs-string">"Hello World"</span>));<br>}<br></code></pre></td></tr></tbody></table></figure><p>通过使用这四个核心的函数式接口，我们就可以使得代码更加简洁，具体的使用场景会在后面讲解。</p><h3 id="判空包装"><a href="#判空包装" class="headerlink" title="判空包装"></a>判空包装</h3><p>Java8还新增了一个非常重要的判空包装类Optional，这个类可以很有效的处理空指针问题。</p><p>比如对于下面这样一个很简单的方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String str)</span></span>{   <span class="hljs-comment">//传入字符串，如果不是空串，那么就打印长度</span><br>    <span class="hljs-keyword">if</span>(!str.isEmpty()) {<br>        System.out.println(<span class="hljs-string">"字符串长度为："</span>+str.length());<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>但是如果我们在传入参数时，丢个null进去，直接原地爆炸：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    test(<span class="hljs-keyword">null</span>);<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String str)</span></span>{ <br>    <span class="hljs-keyword">if</span>(!str.isEmpty()) {   <span class="hljs-comment">//此时传入的值为null，调用方法马上得到空指针异常</span><br>        System.out.println(<span class="hljs-string">"字符串长度为："</span>+str.length());<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>因此我们还需要在使用之前进行判空操作：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String str)</span></span>{<br>    <span class="hljs-keyword">if</span>(str == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;   <span class="hljs-comment">//这样就可以防止null导致的异常了</span><br>    <span class="hljs-keyword">if</span>(!str.isEmpty()) {<br>        System.out.println(<span class="hljs-string">"字符串长度为："</span>+str.length());<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>虽然这种方式很好，但是在Java8之后，有了Optional类，它可以更加优雅地处理这种问题，我们来看看如何使用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String str)</span></span>{<br>    Optional<br>            .ofNullable(str)   <span class="hljs-comment">//将传入的对象包装进Optional中</span><br>            .ifPresent(s -&gt; System.out.println(<span class="hljs-string">"字符串长度为："</span>+s.length()));  <br>  <span class="hljs-comment">//如果不为空，则执行这里的Consumer实现</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>优雅，真是太优雅了，同样的功能，现在我们只需要两行就搞定了，而且代码相当简洁。如果你学习过JavaScript或是Kotlin等语言，它的语法就像是：</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> str : String? = <span class="hljs-literal">null</span><br>str?.upperCase()<br></code></pre></td></tr></tbody></table></figure><p>并且，包装之后，我们再获取时可以优雅地处理为空的情况：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String str)</span></span>{<br>    String s = Optional.ofNullable(str).get();   <span class="hljs-comment">//get方法可以获取被包装的对象引用，但是如果为空的话，会抛出异常</span><br>    System.out.println(s);<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以对于这种有可能为空的情况进行处理，如果为空，那么就返回另一个备选方案：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String str)</span></span>{<br>    String s = Optional.ofNullable(str).orElse(<span class="hljs-string">"我是为null的情况备选方案"</span>);<br>    System.out.println(s);<br>}<br></code></pre></td></tr></tbody></table></figure><p>是不是感觉很方便？我们还可以将包装的类型直接转换为另一种类型：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String str)</span></span>{<br>    Integer i = Optional<br>            .ofNullable(str)<br>            .map(String::length)   <span class="hljs-comment">//使用map来进行映射，将当前类型转换为其他类型，或者是进行处理</span><br>            .orElse(-<span class="hljs-number">1</span>);<br>    System.out.println(i);<br>}<br></code></pre></td></tr></tbody></table></figure><p>当然，Optional的方法比较多，这里就不一一介绍了。</p><hr><h2 id="数据结构基础"><a href="#数据结构基础" class="headerlink" title="数据结构基础"></a>数据结构基础</h2><p><strong>注意：</strong>本部分内容难度很大，推荐计算机专业课程《数据结构与算法》作为前置学习课程。本部分介绍数据结构只是为了为后面的集合类型做准备。</p><p>学习集合类之前，我们还有最关键的内容需要学习，同第二章一样，自底向上才是最佳的学习方向，比起直接带大家认识集合类，不如先了解一下数据结构，只有了解了数据结构基础，才能更好地学习集合类，同时，数据结构也是你以后深入学习JDK源码的必备条件（学习不要快餐式）当然，我们主要是讲解Java，数据结构作为铺垫作用，所以我们只会讲解关键的部分，其他部分可以在数据结构与算法篇视频教程中详细学习。</p><blockquote><p>在计算机科学中，数据结构是一种数据组织、管理和存储的格式,它可以帮助我们实现对数据高效的访问和修改。更准确地说,数据结构是数据值的集合，可以体现数据值之间的关系，以及可以对数据进行应用的函数或操作。</p></blockquote><p>通俗地说，我们需要去学习在计算机中如何去更好地管理我们的数据，才能让我们对我们的数据控制更加灵活！</p><p><img src="https://s2.loli.net/2022/07/10/9RwL7pxgyfoB3WT.png" alt="image-20220710103307583"></p><p>比如现在我们需要保存100个学生的数据，那么你首先想到的肯定是使用数组吧！没错，没有什么比数组更适合存放这100个学生的数据了，但是如果我们现在有了新的需求呢？我们不仅仅是存放这些数据，我们还希望能够将这些数据按顺序存放，支持在某个位置插入一条数据、删除一条数据、修改一条数据等，这时候，数组就显得有些乏力了。</p><p>数组无法做到这么高级的功能，那么我们就需要定义一种更加高级的数据结构来做到，我们可以使用线性表（Linear List）</p><blockquote><p>线性表是由同一类型的数据元素构成的有序序列的线性结构。线性表中元素的个数就是线性表的长度，表的起始位置称为表头，表的结束位置称为表尾，当一个线性表中没有元素时，称为空表。</p></blockquote><p>线性表一般需要包含以下功能：</p><ul><li><strong>获取指定位置上的元素：</strong>直接获取线性表指定位置<code>i</code>上的元素。</li><li><strong>插入元素：</strong>在指定位置<code>i</code>上插入一个元素。</li><li><strong>删除元素：</strong>删除指定位置<code>i</code>上的一个元素。</li><li><strong>获取长度：</strong>返回线性表的长度。</li></ul><p>也就是说，现在我们需要设计的是一种功能完善的表结构，它不像是数组那么低级，而是真正意义上的表：</p><p><img src="https://s2.loli.net/2022/07/23/Ve6dlqROzhumD5o.png" alt="image-20220723112639416"></p><p>简单来说它就是列表，比如我们的菜单，我们在点菜时就需要往菜单列表中添加菜品或是删除菜品，这时列表就很有用了，因为数组长度固定、操作简单，而我们添加菜品、删除菜品这些操作又要求长度动态变化、操作多样。</p><p>那么，如此高级的数据结构，我们该如何去实现呢？实现线性表的结构一般有两种，一种是顺序存储实现，还有一种是链式存储实现，我们先来看第一种，也是最简单的的一种。</p><h3 id="线性表：顺序表"><a href="#线性表：顺序表" class="headerlink" title="线性表：顺序表"></a>线性表：顺序表</h3><p>前面我们说到，既然数组无法实现这样的高级表结构，那么我就基于数组，对其进行强化，也就是说，我们存放数据还是使用数组，但是我们可以为其编写一些额外的操作来强化为线性表，像这样底层依然采用顺序存储实现的线性表，我们称为顺序表。</p><p><img src="https://s2.loli.net/2022/07/24/elBvx4Zo1AJ2WqT.png" alt="image-20220724150015044"></p><p>这里我们可以先定义一个新的类型：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; </span>{   <span class="hljs-comment">//泛型E，因为表中要存的具体数据类型待定</span><br>    <span class="hljs-keyword">int</span> capacity = <span class="hljs-number">10</span>;   <span class="hljs-comment">//当前顺序表的容量</span><br>  <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;   <span class="hljs-comment">//当前已经存放的元素数量</span><br>    <span class="hljs-keyword">private</span> Object[] array = <span class="hljs-keyword">new</span> Object[capacity];   <span class="hljs-comment">//底层存放数据的数组</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>顺序表的插入和删除操作，其实就是：</p><p><img src="https://s2.loli.net/2022/09/27/24Glc7UQjLt5Wny.jpg" alt="67813f22-3607-4351-934d-f8127e6ba15a"></p><p>当插入元素时，需要将插入位置给腾出来，也就是将后面的所有元素向后移，同样的，如果要删除元素，那么也需要将所有的元素向前移动，顺序表是紧凑的，不能出现空位。</p><p>所以说我们可以来尝试实现一下，首先是插入方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E element, <span class="hljs-keyword">int</span> index)</span></span>{   <span class="hljs-comment">//插入方法需要支持在指定下标位置插入</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size; i &gt; index; i--)   <span class="hljs-comment">//从后往前，一个一个搬运元素</span><br>        array[i] = array[i - <span class="hljs-number">1</span>];<br>    array[index] = element;   <span class="hljs-comment">//腾出位置之后，直接插入元素放到对应位置上</span><br>    size++;   <span class="hljs-comment">//插入完成之后，记得将size自增</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>只不过这样并不完美，因为我们的插入操作并不是在任何位置都支持插入的，我们允许插入的位置只能是 [0, size] 这个范围内</p><p><img src="https://s2.loli.net/2022/07/23/H67F1crBhqQiXxg.png" alt="image-20220723153933279"></p><p>所以说我们需要在插入之前进行判断：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E element, <span class="hljs-keyword">int</span> index)</span></span>{<br>    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt; size)    <span class="hljs-comment">//插入之前先判断插入位置是否合法</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">"插入位置非法，合法的插入位置为：0 ~ "</span>+size);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size; i &gt; index; i--)<br>        array[i] = array[i - <span class="hljs-number">1</span>];<br>    array[index] = element;<br>    size++;<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们来测试一下吧：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.add(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>);    <span class="hljs-comment">//一上来只能在第一个位置插入，第二个位置肯定是非法的</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>于是就成功得到异常：</p><p><img src="https://s2.loli.net/2022/09/27/rtkRMaWseE2Cm1z.png" alt="image-20220927211134905"></p><p>只不过依然不够完美，万一我们的顺序表装满了咋办？所以说，我们在插入元素之前，需要进行判断，如果已经装满了，那么我们需要先扩容之后才能继续插入新的元素：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E element, <span class="hljs-keyword">int</span> index)</span></span>{<br>    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt; size)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">"插入位置非法，合法的插入位置为：0 ~ "</span>+size);<br>    <span class="hljs-keyword">if</span>(capacity == size) {<br>        <span class="hljs-keyword">int</span> newCapacity = capacity + (capacity &gt;&gt; <span class="hljs-number">1</span>);   <span class="hljs-comment">//扩容规则就按照原本容量的1.5倍来吧</span><br>        Object[] newArray = <span class="hljs-keyword">new</span> Object[newCapacity];    <span class="hljs-comment">//创建一个新的数组来存放更多的元素</span><br>        System.arraycopy(array, <span class="hljs-number">0</span>, newArray, <span class="hljs-number">0</span>, size);   <span class="hljs-comment">//使用arraycopy快速拷贝原数组内容到新的数组</span><br>        array = newArray;   <span class="hljs-comment">//更换为新的数组</span><br>      capacity = newCapacity;   <span class="hljs-comment">//容量变成扩容之后的</span><br>    }<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size; i &gt; index; i--)<br>        array[i] = array[i - <span class="hljs-number">1</span>];<br>    array[index] = element;<br>    size++;<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们来重写一下<code>toString</code>方法打印当前存放的元素：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{<br>    StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) builder.append(array[i]).append(<span class="hljs-string">" "</span>);<br>    <span class="hljs-keyword">return</span> builder.toString();<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以看到，我们的底层数组会自动扩容，便于我们使用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>        list.add(i, i);<br>    System.out.println(list);<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/09/27/6SMZxC5QI3cgXYk.png" alt="image-20220927212426959"></p><p>我们接着来看删除操作，其实操作差不多，只需要将后面的覆盖到前面就可以了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings("unchecked")</span>   <span class="hljs-comment">//屏蔽未经检查警告</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>{   <span class="hljs-comment">//删除对应位置上的元素，注意需要返回被删除的元素</span><br>    E e = (E) array[index];   <span class="hljs-comment">//因为存放的是Object类型，这里需要强制类型转换为E</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index; i &lt; size; i++)   <span class="hljs-comment">//从前往后，挨个往前搬一位</span><br>        array[i] = array[i + <span class="hljs-number">1</span>];<br>    size--;    <span class="hljs-comment">//删完记得将size--</span><br>    <span class="hljs-keyword">return</span> e;<br>}<br></code></pre></td></tr></tbody></table></figure><p>同样的，我们需要对删除的合法范围进行判断：</p><p><img src="https://s2.loli.net/2022/07/23/uHBjUfKpd9ygScW.png" alt="image-20220723160901921"></p><p>所以说我们也来进行一下判断：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings("unchecked")</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>{<br>    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt; size - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">"删除位置非法，合法的插入位置为：0 ~ "</span>+(size - <span class="hljs-number">1</span>));<br>    E e = (E) array[index];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index; i &lt; size; i++)<br>        array[i] = array[i + <span class="hljs-number">1</span>];<br>    size--;<br>    <span class="hljs-keyword">return</span> e;<br>}<br></code></pre></td></tr></tbody></table></figure><p>因为删除不需要考虑容量的问题，所以说这里的删除操作就编写完成了。</p><p>当然，我们还得支持获取指定下标位置上的元素，这个就简单了，直接从数组中那就行了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings("unchecked")</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>{<br>    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt; size - <span class="hljs-number">1</span>)   <span class="hljs-comment">//在插入之前同样要进行范围检查</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">"非法的位置，合法的位置为：0 ~ "</span>+(size - <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">return</span> (E) array[index];   <span class="hljs-comment">//直接返回就完事</span><br>}<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>{   <span class="hljs-comment">//获取当前存放的元素数量</span><br>    <span class="hljs-keyword">return</span> size;<br>}<br></code></pre></td></tr></tbody></table></figure><p>是不是感觉顺便表其实还是挺简单的，也就是一个数组多了一些操作罢了。</p><h3 id="线性表：链表"><a href="#线性表：链表" class="headerlink" title="线性表：链表"></a>线性表：链表</h3><p>前面我们介绍了如何使用数组实现线性表，我们接着来看第二种方式，我们可以使用链表来实现，那么什么是链表呢？</p><p><img src="https://s2.loli.net/2022/07/23/ruemiRQplVy7q9s.png" alt="image-20220723171648380"></p><p>链表不同于顺序表，顺序表底层采用数组作为存储容器，需要分配一块连续且完整的内存空间进行使用，而链表则不需要，它通过一个指针来连接各个分散的结点，形成了一个链状的结构，每个结点存放一个元素，以及一个指向下一个结点的指针，通过这样一个一个相连，最后形成了链表。它不需要申请连续的空间，只需要按照顺序连接即可，虽然物理上可能不相邻，但是在逻辑上依然是每个元素相邻存放的，这样的结构叫做链表（单链表）。</p><p>链表分为带头结点的链表和不带头结点的链表，戴头结点的链表就是会有一个头结点指向后续的整个链表，但是头结点不存放数据：</p><p><img src="https://s2.loli.net/2022/07/23/gRUEfOqbtrGN2JZ.png" alt="image-20220723180221112"></p><p>而不带头结点的链表就像上面那样，第一个节点就是存放数据的结点，一般设计链表都会采用带头结点的结构，因为操作更加方便。</p><p>我们来尝试定义一下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt; </span>{<br>  <span class="hljs-comment">//链表的头结点，用于连接之后的所有结点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;E&gt; head = <span class="hljs-keyword">new</span> Node&lt;&gt;(<span class="hljs-keyword">null</span>);<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;   <span class="hljs-comment">//当前的元素数量还是要存一下，方便后面操作</span><br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>{  <span class="hljs-comment">//结点类，仅供内部使用</span><br>        E element;   <span class="hljs-comment">//每个结点都存放元素</span><br>        Node&lt;E&gt; next;   <span class="hljs-comment">//以及指向下一个结点的引用</span><br>      <br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(E element)</span> </span>{<br>            <span class="hljs-keyword">this</span>.element = element;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>接着我们来设计一下链表的插入和删除，我们前面实现了顺序表的插入，那么链表的插入该怎么做呢？</p><p><img src="https://s2.loli.net/2022/07/23/71dgFSWDfoELiXB.png" alt="image-20220723175548491"></p><p>我们可以先修改新插入的结点的后继结点（也就是下一个结点）指向，指向原本在这个位置的结点：</p><p><img src="https://s2.loli.net/2022/07/23/8MNURYiacWZqwu6.png" alt="image-20220723220552680"></p><p>接着我们可以将前驱结点（也就是上一个结点）的后继结点指向修改为我们新插入的结点：</p><p><img src="https://s2.loli.net/2022/07/23/ysETUJb6cgBz2Qx.png" alt="image-20220723175745472"></p><p>这样，我们就成功插入了一个新的结点，现在新插入的结点到达了原本的第二个位置上：</p><p><img src="https://s2.loli.net/2022/07/23/Kb7jCiWa3o4AN8D.png" alt="image-20220723175842075"></p><p>按照这个思路，我们来实现一下，首先设计一下方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E element, <span class="hljs-keyword">int</span> index)</span></span>{<br>    Node&lt;E&gt; prev = head;   <span class="hljs-comment">//先找到对应位置的前驱结点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) <br>        prev = prev.next;<br>    Node&lt;E&gt; node = <span class="hljs-keyword">new</span> Node&lt;&gt;(element);   <span class="hljs-comment">//创建新的结点</span><br>    node.next = prev.next;   <span class="hljs-comment">//先让新的节点指向原本在这个位置上的结点</span><br>    prev.next = node;   <span class="hljs-comment">//然后让前驱结点指向当前结点</span><br>    size++;   <span class="hljs-comment">//完事之后一样的，更新size</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>我们来重写一下toString方法看看能否正常插入：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{<br>    StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();<br>    Node&lt;E&gt; node = head.next;   <span class="hljs-comment">//从第一个结点开始，一个一个遍历，遍历一个就拼接到字符串上去</span><br>    <span class="hljs-keyword">while</span> (node != <span class="hljs-keyword">null</span>) {<br>        builder.append(node.element).append(<span class="hljs-string">" "</span>);<br>        node = node.next;<br>    }<br>    <span class="hljs-keyword">return</span> builder.toString();<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以看到我们的插入操作是可以正常工作的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    LinkedList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    list.add(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>);<br>    list.add(<span class="hljs-number">30</span>, <span class="hljs-number">0</span>);<br>    list.add(<span class="hljs-number">20</span>, <span class="hljs-number">1</span>);<br>    System.out.println(list);<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/09/27/Mpj9azwWciemAZY.png" alt="image-20220927235051844"></p><p>只不过还不够完美，跟之前一样，我们还得考虑插入位置是否合法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E element, <span class="hljs-keyword">int</span> index)</span></span>{<br>    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt; size)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">"插入位置非法，合法的插入位置为：0 ~ "</span>+size);<br>    Node&lt;E&gt; prev = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++)<br>        prev = prev.next;<br>    Node&lt;E&gt; node = <span class="hljs-keyword">new</span> Node&lt;&gt;(element);<br>    node.next = prev.next;<br>    prev.next = node;<br>    size++;<br>}<br></code></pre></td></tr></tbody></table></figure><p>插入操作完成之后，我们接着来看删除操作，那么我们如何实现删除操作呢？实际上也会更简单一些，我们可以直接将待删除节点的前驱结点指向修改为待删除节点的下一个：</p><p><img src="https://s2.loli.net/2022/07/23/N5sZx9T2a8lOzoC.png" alt="image-20220723222922058"></p><p><img src="https://s2.loli.net/2022/07/23/tNYnBJe9pczUq1Z.png" alt="image-20220723223103306"></p><p>这样，在逻辑上来说，待删除结点其实已经不在链表中了，所以我们只需要释放掉待删除结点占用的内存空间就行了：</p><p><img src="https://s2.loli.net/2022/07/23/MFE2gZuS5eOysDW.png" alt="image-20220723223216420"></p><p>那么我们就按照这个思路来编写一下程序：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>{<br>    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt; size - <span class="hljs-number">1</span>)   <span class="hljs-comment">//同样的，先判断位置是否合法</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">"删除位置非法，合法的删除位置为：0 ~ "</span>+(size - <span class="hljs-number">1</span>));<br>    Node&lt;E&gt; prev = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++)   <span class="hljs-comment">//同样需要先找到前驱结点</span><br>        prev = prev.next;<br>    E e = prev.next.element;   <span class="hljs-comment">//先把待删除结点存放的元素取出来</span><br>    prev.next = prev.next.next;  <span class="hljs-comment">//可以删了</span><br>    size--;   <span class="hljs-comment">//记得size--</span><br>    <span class="hljs-keyword">return</span> e;<br>}<br></code></pre></td></tr></tbody></table></figure><p>是不是感觉还是挺简单的？这样，我们就成功完成了链表的删除操作。</p><p>我们接着来实现一下获取对应位置上的元素：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>{<br>    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt; size - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">"非法的位置，合法的位置为：0 ~ "</span>+(size - <span class="hljs-number">1</span>));<br>    Node&lt;E&gt; node = head;<br>    <span class="hljs-keyword">while</span> (index-- &gt;= <span class="hljs-number">0</span>)   <span class="hljs-comment">//这里直接让index减到-1为止</span><br>        node = node.next;<br>    <span class="hljs-keyword">return</span> node.element;<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-keyword">return</span> size;<br>}<br></code></pre></td></tr></tbody></table></figure><p>这样，我们的链表就编写完成了，实际上只要理解了那种结构，其实还是挺简单的。</p><p><strong>问题</strong>：什么情况下使用顺序表，什么情况下使用链表呢？</p><ul><li>通过分析顺序表和链表的特性我们不难发现，链表在随机访问元素时，需要通过遍历来完成，而顺序表则利用数组的特性直接访问得到，所以，当我们读取数据多于插入或是删除数据的情况下时，使用顺序表会更好。</li><li>而顺序表在插入元素时就显得有些鸡肋了，因为需要移动后续元素，整个移动操作会浪费时间，而链表则不需要，只需要修改结点 指向即可完成插入，所以在频繁出现插入或删除的情况下，使用链表会更好。</li></ul><p>虽然单链表使用起来也比较方便，不过有一个问题就是，如果我们想要操作某一个结点，比如删除或是插入，那么由于单链表的性质，我们只能先去找到它的前驱结点，才能进行。为了解决这种查找前驱结点非常麻烦的问题，我们可以让结点不仅保存指向后续结点的指针，同时也保存指向前驱结点的指针：</p><p><img src="https://s2.loli.net/2022/07/24/oeXm6nyW7I9lPMf.png" alt="image-20220724123947104"></p><p>这样我们无论在哪个结点，都能够快速找到对应的前驱结点，就很方便了，这样的链表我们成为双向链表（双链表）</p><h3 id="线性表：栈"><a href="#线性表：栈" class="headerlink" title="线性表：栈"></a>线性表：栈</h3><p>栈（也叫堆栈，Stack）是一种特殊的线性表，它只能在在表尾进行插入和删除操作，就像下面这样：</p><p><img src="https://s2.loli.net/2022/07/24/D3heysaM9EpAgS4.png" alt="image-20220724210955622"></p><p>也就是说，我们只能在一端进行插入和删除，当我们依次插入1、2、3、4这四个元素后，连续进行四次删除操作，删除的顺序刚好相反：4、3、2、1，我们一般将其竖着看：</p><p><img src="https://s2.loli.net/2022/07/24/2NxUpCIRLoZt9Ky.png" alt="image-20220724211442421"></p><p>底部称为栈底，顶部称为栈顶，所有的操作只能在栈顶进行，也就是说，被压在下方的元素，只能等待其上方的元素出栈之后才能取出，就像我们往箱子里里面放的书一样，因为只有一个口取出里面的物品，所以被压在下面的书只能等上面的书被拿出来之后才能取出，这就是栈的思想，它是一种先进后出的数据结构（FILO，First In, Last Out）</p><p>实现栈也是非常简单的，可以基于我们前面的顺序表或是链表，这里我们需要实现两个新的操作：</p><ul><li>pop：出栈操作，从栈顶取出一个元素。</li><li>push：入栈操作，向栈中压入一个新的元素。</li></ul><p>栈可以使用顺序表实现，也可以使用链表实现，这里我们就使用链表，实际上使用链表会更加的方便，我们可以直接将头结点指向栈顶结点，而栈顶结点连接后续的栈内结点：</p><p><img src="https://s2.loli.net/2022/07/24/outf2S7D3WzQK8c.png" alt="image-20220724222836333"></p><p>当有新的元素入栈，只需要在链表头部插入新的结点即可，我们来尝试编写一下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedStack</span>&lt;<span class="hljs-title">E</span>&gt; </span>{<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;E&gt; head = <span class="hljs-keyword">new</span> Node&lt;&gt;(<span class="hljs-keyword">null</span>);   <span class="hljs-comment">//大体内容跟链表类似</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>{<br>        E element;<br>        Node&lt;E&gt; next;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(E element)</span> </span>{<br>            <span class="hljs-keyword">this</span>.element = element;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>接着我们来编写一下入栈操作：</p><p><img src="https://s2.loli.net/2022/07/24/GdBj3g5YRFzSsVw.png" alt="image-20220724223550553"></p><p>代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(E element)</span></span>{<br>    Node&lt;E&gt; node = <span class="hljs-keyword">new</span> Node&lt;&gt;(element);   <span class="hljs-comment">//直接创建新结点</span><br>    node.next = head.next;    <span class="hljs-comment">//新结点的下一个变成原本的栈顶结点</span><br>    head.next = node;     <span class="hljs-comment">//头结点的下一个改成新的结点</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>这样，我们就可以轻松实现入栈操作了。其实出栈也是同理，所以我们只需要将第一个元素移除即可：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>{<br>  <span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>)   <span class="hljs-comment">//如果栈已经没有元素了，那么肯定是没办法取的</span><br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException(<span class="hljs-string">"栈为空"</span>);<br>    E e = head.next.element;   <span class="hljs-comment">//先把待出栈元素取出来</span><br>    head.next = head.next.next;   <span class="hljs-comment">//直接让头结点的下一个指向下一个的下一个</span><br>    <span class="hljs-keyword">return</span> e;<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们来测试一下吧：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    LinkedStack&lt;String&gt; stack = <span class="hljs-keyword">new</span> LinkedStack&lt;&gt;();<br>    stack.push(<span class="hljs-string">"AAA"</span>);<br>    stack.push(<span class="hljs-string">"BBB"</span>);<br>    stack.push(<span class="hljs-string">"CCC"</span>);<br>    System.out.println(stack.pop());<br>    System.out.println(stack.pop());<br>    System.out.println(stack.pop());<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以看到，入栈顺序和出栈顺序是完全相反的：</p><p><img src="https://s2.loli.net/2022/09/28/yaWmfPDU63X8BQn.png" alt="image-20220928101152179"></p><p>其实还是挺简单的。</p><h3 id="线性表：队列"><a href="#线性表：队列" class="headerlink" title="线性表：队列"></a>线性表：队列</h3><p>前面我们学习了栈，栈中元素只能栈顶出入，它是一种特殊的线性表，同样的，队列（Queue）也是一种特殊的线性表。</p><p>就像我们在超市、食堂需要排队一样，我们总是排成一列，先到的人就排在前面，后来的人就排在后面，越前面的人越先完成任务，这就是队列，队列有队头和队尾：</p><p><img src="https://s2.loli.net/2022/07/25/xBuZckTNtR54AEq.png" alt="image-20220725103600318"></p><p>秉承先来后到的原则，队列中的元素只能从队尾进入，只能从队首出去，也就是说，入队顺序为1、2、3、4，那么出队顺序也一定是1、2、3、4，所以队列是一种先进先出（FIFO，First In, First Out）的数据结构。</p><p>队列也可以使用链表和顺序表来实现，只不过使用链表的话就不需要关心容量之类的问题了，会更加灵活一些：</p><p><img src="https://s2.loli.net/2022/07/25/lwGgHXqAV5z2KNk.png" alt="image-20220725145214955"></p><p>注意我们需要同时保存队首和队尾两个指针，因为是单链表，所以队首需要存放指向头结点的指针，因为需要的是前驱结点，而队尾则直接是指向尾结点的指针即可，后面只需要直接在后面拼接就行。</p><p>当有新的元素入队时，只需要拼在队尾就行了，同时队尾指针也要后移一位：</p><p><img src="https://s2.loli.net/2022/07/25/ufmFEwrS9xVKoIZ.png" alt="image-20220725145608827"></p><p>出队时，只需要移除队首指向的下一个元素即可：</p><p><img src="https://s2.loli.net/2022/07/25/geJRFwHKhGT69XD.png" alt="image-20220725145707707"></p><p>那么我们就按照这个思路，来编写一下代码吧：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedQueue</span>&lt;<span class="hljs-title">E</span>&gt; </span>{<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;E&gt; head = <span class="hljs-keyword">new</span> Node&lt;&gt;(<span class="hljs-keyword">null</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">offer</span><span class="hljs-params">(E element)</span></span>{  <span class="hljs-comment">//入队操作</span><br>        Node&lt;E&gt; last = head;<br>        <span class="hljs-keyword">while</span> (last.next != <span class="hljs-keyword">null</span>)   <span class="hljs-comment">//入队直接丢到最后一个结点的屁股后面就行了</span><br>            last = last.next;<br>        last.next = <span class="hljs-keyword">new</span> Node&lt;&gt;(element);<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>{   <span class="hljs-comment">//出队操作</span><br>        <span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>)   <span class="hljs-comment">//如果队列已经没有元素了，那么肯定是没办法取的</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException(<span class="hljs-string">"队列为空"</span>);<br>        E e = head.next.element;<br>        head.next = head.next.next;   <span class="hljs-comment">//直接从队首取出</span><br>        <span class="hljs-keyword">return</span> e;<br>    }<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>{<br>        E element;<br>        Node&lt;E&gt; next;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(E element)</span> </span>{<br>            <span class="hljs-keyword">this</span>.element = element;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>其实使用起来还是挺简单的，我们来测试一下吧：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    LinkedQueue&lt;String&gt; stack = <span class="hljs-keyword">new</span> LinkedQueue&lt;&gt;();<br>    stack.offer(<span class="hljs-string">"AAA"</span>);<br>    stack.offer(<span class="hljs-string">"BBB"</span>);<br>    stack.offer(<span class="hljs-string">"CCC"</span>);<br>    System.out.println(stack.poll());<br>    System.out.println(stack.poll());<br>    System.out.println(stack.poll());<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/09/28/FUS1Rc8JuEMT6bq.png" alt="image-20220928154121872"></p><p>可以看到，队列遵从先进先出，入队顺序和出队顺序是一样的。</p><h3 id="树：二叉树"><a href="#树：二叉树" class="headerlink" title="树：二叉树"></a>树：二叉树</h3><p>树是一种全新的数据结构，它就像一棵树的树枝一样，不断延伸。</p><p><img src="https://s2.loli.net/2022/08/08/NajFZzXHxUCDQBW.png" alt="树枝666"></p><p>在我们的程序中，想要表示出一棵树，就可以像下面这样连接：</p><p><img src="https://s2.loli.net/2022/08/01/aoBjrR5bPqWzCel.png" alt="image-20220801210920230"></p><p>可以看到，现在一个结点下面可能会连接多个节点，并不断延伸，就像树枝一样，每个结点都有可能是一个分支点，延伸出多个分支，从位于最上方的结点开始不断向下，而这种数据结构，我们就称为<strong>树</strong>（Tree）注意分支只能向后单独延伸，之后就分道扬镳了，<strong>不能与其他分支上的结点相交！</strong></p><ul><li>我们一般称位于最上方的结点为树的<strong>根结点</strong>（Root）因为整棵树正是从这里开始延伸出去的。</li><li>每个结点连接的子结点数目（分支的数目），我们称为结点的<strong>度</strong>（Degree），而各个结点度的最大值称为树的度。</li><li>每个结点延伸下去的下一个结点都可以称为一棵<strong>子树</strong>（SubTree）比如结点<code>B</code>及其之后延伸的所有分支合在一起，就是一棵<code>A</code>的子树。</li><li>每个<strong>结点的层次</strong>（Level）按照从上往下的顺序，树的根结点为<code>1</code>，每向下一层<code>+1</code>，比如<code>G</code>的层次就是<code>3</code>，整棵树中所有结点的最大层次，就是这颗<strong>树的深度</strong>（Depth），比如上面这棵树的深度为4，因为最大层次就是4。</li></ul><p>由于整棵树错综复杂，所以说我们需要先规定一下结点之间的称呼，就像族谱那样：</p><ul><li>与当前结点直接向下相连的结点，我们称为<strong>子结点</strong>（Child），比如<code>B、C、D</code>结点，都是<code>A</code>的子结点，就像族谱中的父子关系一样，下一代一定是子女，相反的，那么<code>A</code>就是<code>B、C、D</code>的<strong>父结点</strong>（Parent），也可以叫双亲结点。</li><li>如果某个节点没有任何的子结点（结点度为0时）那么我们称这个结点为<strong>叶子结点</strong>（因为已经到头了，后面没有分支了，这时就该树枝上长叶子了那样）比如<code>K、L、F、G、M、I、J</code>结点，都是叶子结点。</li><li>如果两个结点的父结点是同一个，那么称这两个节点为<strong>兄弟结点</strong>（Sibling）比如<code>B</code>和<code>C</code>就是兄弟结点，因为都是<code>A</code>的孩子。</li><li>从根结点开始一直到某个结点的整条路径的所有结点，都是这个结点的<strong>祖先结点</strong>（Ancestor）比如<code>L</code>的祖先结点就是<code>A、B、E</code></li></ul><p>那么在了解了树的相关称呼之后，相信各位就应该对树有了一定的了解，虽然概念比较多，但是还请各位一定记住，不然后面就容易听懵。</p><p>而我们本章需要着重讨论的是<strong>二叉树</strong>（Binary Tree）它是一种特殊的树，它的度最大只能为<code>2</code>，所以我们称其为二叉树，一棵二叉树大概长这样：</p><p><img src="https://s2.loli.net/2022/08/01/QGLfnYWFby37deP.png" alt="image-20220801224008266"></p><p>并且二叉树任何结点的子树是有左右之分的，不能颠倒顺序，比如A结点左边的子树，称为左子树，右边的子树称为右子树。</p><p>当然，对于某些二叉树我们有特别的称呼，比如，在一棵二叉树中，所有分支结点都存在左子树和右子树，且叶子结点都在同一层：</p><p><img src="https://s2.loli.net/2022/08/01/btfjlJhDuWrSXYi.png" alt="image-20220801231216578"></p><p>这样的二叉树我们称为<strong>满二叉树</strong>，可以看到整棵树都是很饱满的，没有出现任何度为1的结点，当然，还有一种特殊情况：</p><p><img src="https://s2.loli.net/2022/08/01/QGLfnYWFby37deP.png" alt="image-20220801224008266"></p><p>可以看到只有最后一层有空缺，并且所有的叶子结点是按照从左往右的顺序排列的，这样的二叉树我们一般称其为<strong>完全二叉树</strong>，所以，一棵满二叉树，一定是一棵完全二叉树。</p><p>我们接着来看看二叉树在程序中的表示形式，我们在前面使用链表的时候，每个结点不仅存放对应的数据，而且会存放一个指向下一个结点的引用：</p><p><img src="https://s2.loli.net/2022/07/23/ruemiRQplVy7q9s.png" alt="image-20220723171648380"></p><p>而二叉树也可以使用这样的链式存储形式，只不过现在一个结点需要存放一个指向左子树的引用和一个指向右子树的引用了：</p><p><img src="https://s2.loli.net/2022/08/06/H9MqkghmAjFJnuO.png" alt="image-20220806111610082"></p><p>通过这种方式，我们就可以通过连接不同的结点形成一颗二叉树了，这样也更便于我们去理解它，我们首先定义一个类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>&lt;<span class="hljs-title">E</span>&gt; </span>{<br>    <span class="hljs-keyword">public</span> E element;<br>    <span class="hljs-keyword">public</span> TreeNode&lt;E&gt; left, right;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeNode</span><span class="hljs-params">(E element)</span></span>{<br>        <span class="hljs-keyword">this</span>.element = element;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>比如我们现在想要构建一颗像这样的二叉树：</p><p><img src="https://s2.loli.net/2022/08/05/uan6A3ZRLykt289.png" alt="image-20220805231744693"></p><p>首先我们需要创建好这几个结点：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    TreeNode&lt;Character&gt; a = <span class="hljs-keyword">new</span> TreeNode&lt;&gt;(<span class="hljs-string">'A'</span>);<br>    TreeNode&lt;Character&gt; b = <span class="hljs-keyword">new</span> TreeNode&lt;&gt;(<span class="hljs-string">'B'</span>);<br>    TreeNode&lt;Character&gt; c = <span class="hljs-keyword">new</span> TreeNode&lt;&gt;(<span class="hljs-string">'C'</span>);<br>    TreeNode&lt;Character&gt; d = <span class="hljs-keyword">new</span> TreeNode&lt;&gt;(<span class="hljs-string">'D'</span>);<br>    TreeNode&lt;Character&gt; e = <span class="hljs-keyword">new</span> TreeNode&lt;&gt;(<span class="hljs-string">'E'</span>);<br>    <br>}<br></code></pre></td></tr></tbody></table></figure><p>接着我们从最上面开始，挨着进行连接，首先是A这个结点：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    ...<br>    a.left = b;<br>    a.right = c;<br>    b.left = d;<br>    b.right = e;<br>}<br></code></pre></td></tr></tbody></table></figure><p>这样的话，我们就成功构建好了这棵二叉树，比如现在我们想通过根结点访问到D：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(a.left.left.element);<br></code></pre></td></tr></tbody></table></figure><p>断点调试也可以看的很清楚：</p><p><img src="https://s2.loli.net/2022/09/30/XCkDxVBFz2bWph8.png" alt="image-20220930160452608"></p><p>这样，我们就通过使用链式结构，成功构建出了一棵二叉树。</p><p>接着我们来看看如何遍历一棵二叉树，也就是说我们想要访问二叉树的每一个结点，由于树形结构特殊，遍历顺序并不唯一，所以一共有四种访问方式：<strong>前序遍历、中序遍历、后序遍历、层序遍历。</strong>不同的访问方式输出都结点顺序也不同。</p><p>首先我们来看最简单的前序遍历：</p><p><img src="https://s2.loli.net/2022/08/06/G6ujstSVZ2XWJLE.png" alt="image-20220806171459056"></p><p>前序遍历是一种勇往直前的态度，走到哪就遍历到那里，先走左边再走右边，比如上面的这个图，首先会从根节点开始：</p><p><img src="https://s2.loli.net/2022/08/06/qCFMosHtujEZ3U6.png" alt="image-20220806171431845"></p><p>从A开始，先左后右，那么下一个就是B，然后继续走左边，是D，现在ABD走完之后，B的左边结束了，那么就要开始B的右边了，所以下一个是E，E结束之后，现在A的左子树已经全部遍历完成了，然后就是右边，接着就是C，C没有左子树了，那么只能走右边了，最后输出F，所以上面这个二叉树的前序遍历结果为：ABDECF</p><ol><li>打印根节点</li><li>前序遍历左子树</li><li>前序遍历右子树</li></ol><p>我们不难发现规律，整棵二叉树（包括子树）的根节点一定是出现在最前面的，比如A在最前面，A的左子树根结点B也是在最前面的。我们现在就来尝试编写一下代码实现一下，先把二叉树构建出来：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    TreeNode&lt;Character&gt; a = <span class="hljs-keyword">new</span> TreeNode&lt;&gt;(<span class="hljs-string">'A'</span>);<br>    TreeNode&lt;Character&gt; b = <span class="hljs-keyword">new</span> TreeNode&lt;&gt;(<span class="hljs-string">'B'</span>);<br>    TreeNode&lt;Character&gt; c = <span class="hljs-keyword">new</span> TreeNode&lt;&gt;(<span class="hljs-string">'C'</span>);<br>    TreeNode&lt;Character&gt; d = <span class="hljs-keyword">new</span> TreeNode&lt;&gt;(<span class="hljs-string">'D'</span>);<br>    TreeNode&lt;Character&gt; e = <span class="hljs-keyword">new</span> TreeNode&lt;&gt;(<span class="hljs-string">'E'</span>);<br>    TreeNode&lt;Character&gt; f = <span class="hljs-keyword">new</span> TreeNode&lt;&gt;(<span class="hljs-string">'F'</span>);<br>    a.left = b;<br>    a.right = c;<br>    b.left = d;<br>    b.right = e;<br>    c.right = f;<br>}<br></code></pre></td></tr></tbody></table></figure><p>组装好之后，我们来实现一下前序遍历的方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode&lt;T&gt; root)</span></span>{<br>    System.out.print(root.element + <span class="hljs-string">" "</span>);   <span class="hljs-comment">//首先肯定要打印，这个是必须的</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>打印完成之后，我们就按照先左后右的规则往后遍历下一个结点，这里我们就直接使用递归来完成：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode&lt;T&gt; root)</span></span>{<br>    System.out.print(root.element + <span class="hljs-string">" "</span>);<br>    preOrder(root.left);    <span class="hljs-comment">//先走左边</span><br>    preOrder(root.right);   <span class="hljs-comment">//再走右边</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>不过还没完，我们的递归肯定是需要一个终止条件的，不可能无限地进行下去，如果已经走到底了，那么就不能再往下走了，所以：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode&lt;T&gt; root)</span></span>{<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>    System.out.print(root.element);<br>    preOrder(root.left);<br>    preOrder(root.right);<br>}<br></code></pre></td></tr></tbody></table></figure><p>最后我们来测试一下吧：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    ...<br>    preOrder(a);<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以看到结果为：</p><p><img src="https://s2.loli.net/2022/08/06/hZ8qEfWaP5o6L2j.png" alt="image-20220806173227580"></p><p>这样我们就通过一个简单的递归操作完成了对一棵二叉树的前序遍历，如果不太好理解，建议结合调试进行观察。</p><p>那么前序遍历我们了解完了，接着就是中序遍历了，中序遍历在顺序上与前序遍历不同，前序遍历是走到哪就打印到哪，而中序遍历需要先完成整个左子树的遍历后再打印，然后再遍历其右子树。</p><p>我们还是以上面的二叉树为例：</p><p><img src="https://s2.loli.net/2022/08/06/W6Yb5M92gQApNJa.png" alt="image-20220806230603967"></p><p>首先需要先不断遍历左子树，走到最底部，但是沿途并不进行打印，而是到底之后，再打印，所以第一个打印的是D，接着由于没有右子树，所以我们回到B，此时再打印B，然后再去看B的右结点E，由于没有左子树和右子树了，所以直接打印E，左边遍历完成，接着回到A，打印A，然后对A的右子树重复上述操作。所以说遍历的基本规则还是一样的，只是打印值的时机发生了改变。</p><ol><li>中序遍历左子树</li><li>打印结点</li><li>中序遍历右子树</li></ol><p>所以这棵二叉树的中序遍历结果为：DBEACF，我们可以发现一个规律，就是在某个结点的左子树中所有结点，其中序遍历结果也是按照这样的规律排列的，比如A的左子树中所有结点，中序遍历结果中全部都在A的左边，右子树中所有的结点，全部都在A的右边（这个规律很关键，后面在做一些算法题时会用到）</p><p>那么怎么才能将打印调整到左子树全部遍历结束之后呢？其实很简单：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode&lt;T&gt; root)</span></span>{<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>    inOrder(root.left);    <span class="hljs-comment">//先完成全部左子树的遍历</span><br>    System.out.print(root.element);    <span class="hljs-comment">//等待左子树遍历完成之后再打印</span><br>    inOrder(root.right);    <span class="hljs-comment">//然后就是对右子树进行遍历</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>我们只需要将打印放到左子树遍历之后即可，这样打印出来的结果就是中序遍历的结果了：</p><p><img src="https://s2.loli.net/2022/08/06/V2KdMy3T5Beo8vx.png" alt="image-20220806231752418"></p><p>这样，我们就实现了二叉树的中序遍历，实际上还是很好理解的。</p><p>接着我们来看一下后序遍历，后序遍历继续将打印的时机延后，需要等待左右子树全部遍历完成，才会去进行打印。</p><p><img src="https://s2.loli.net/2022/08/06/YE2rODdqpCInUa9.png" alt="image-20220806233407910"></p><p>首先还是一路向左，到达结点D，此时结点D没有左子树了，接着看结点D还有没有右子树，发现也没有，左右子树全部遍历完成，那么此时再打印D，同样的，D完事之后就回到B了，此时接着看B的右子树，发现有结点E，重复上述操作，E也打印出来了，接着B的左右子树全部OK，那么再打印B，接着A的左子树就完事了，现在回到A，看到A的右子树，继续重复上述步骤，当A的右子树也遍历结束后，最后再打印A结点。</p><ol><li>后序遍历左子树</li><li>后序遍历右子树</li><li>打印结点</li></ol><p>所以最后的遍历顺序为：DEBFCA，不难发现，整棵二叉树（包括子树）根结点一定是在后面的，比如A在所有的结点的后面，B在其子节点D、E的后面，这一点恰恰和前序遍历相反（注意不是得到的结果相反，是规律相反）</p><p>所以，按照这个思路，我们来编写一下后序遍历：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode&lt;T&gt; root)</span></span>{<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>    postOrder(root.left);<br>    postOrder(root.right);<br>    System.out.print(root.element);  <span class="hljs-comment">//时机延迟到最后</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>结果如下：</p><p><img src="https://s2.loli.net/2022/08/06/6Vx9fmSUcqw51Mp.png" alt="image-20220806234428922"></p><p>最后我们来看层序遍历，实际上这种遍历方式是我们人脑最容易理解的，它是按照每一层在进行遍历：</p><p><img src="https://s2.loli.net/2022/08/07/ywF6r9MU1JSPIge.png" alt="image-20220807205135936"></p><p>层序遍历实际上就是按照从上往下每一层，从左到右的顺序打印每个结点，比如上面的这棵二叉树，那么层序遍历的结果就是：ABCDEF，像这样一层一层的挨个输出。</p><p>虽然理解起来比较简单，但是如果让你编程写出来，该咋搞？是不是感觉有点无从下手？</p><p>我们可以利用队列来实现层序遍历，首先将根结点存入队列中，接着循环执行以下步骤：</p><ul><li>进行出队操作，得到一个结点，并打印结点的值。</li><li>将此结点的左右孩子结点依次入队。</li></ul><p>不断重复以上步骤，直到队列为空。</p><p>我们来分析一下，首先肯定一开始A在里面：</p><p><img src="https://s2.loli.net/2022/08/07/ZsNpeVUivEjCymt.png" alt="image-20220807211522409"></p><p>接着开始不断重复上面的步骤，首先是将队首元素出队，打印A，然后将A的左右孩子依次入队：</p><p><img src="https://s2.loli.net/2022/08/07/v8yXWNato3sfeUn.png" alt="image-20220807211631110"></p><p>现在队列中有B、C两个结点，继续重复上述操作，B先出队，打印B，然后将B的左右孩子依次入队：</p><p><img src="https://s2.loli.net/2022/08/07/Qkprfi5RhAXP7Cd.png" alt="image-20220807211723776"></p><p>现在队列中有C、D、E这三个结点，继续重复，C出队并打印，然后将F入队：</p><p><img src="https://s2.loli.net/2022/08/07/MxQTArlWK2gDjqi.png" alt="image-20220807211800852"></p><p>我们发现，这个过程中，打印的顺序正好就是我们层序遍历的顺序，所以说队列还是非常有用的，这里我们可以直接把之前的队列拿来用。那么现在我们就来上代码吧，首先是之前的队列：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedQueue</span>&lt;<span class="hljs-title">E</span>&gt; </span>{<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;E&gt; head = <span class="hljs-keyword">new</span> Node&lt;&gt;(<span class="hljs-keyword">null</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">offer</span><span class="hljs-params">(E element)</span></span>{<br>        Node&lt;E&gt; last = head;<br>        <span class="hljs-keyword">while</span> (last.next != <span class="hljs-keyword">null</span>)<br>            last = last.next;<br>        last.next = <span class="hljs-keyword">new</span> Node&lt;&gt;(element);<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>{<br>        <span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException(<span class="hljs-string">"队列为空"</span>);<br>        E e = head.next.element;<br>        head.next = head.next.next;<br>        <span class="hljs-keyword">return</span> e;<br>    }<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>{   <span class="hljs-comment">//这里多写了一个判断队列为空的操作，方便之后使用</span><br>        <span class="hljs-keyword">return</span> head.next == <span class="hljs-keyword">null</span>;   <span class="hljs-comment">//直接看头结点后面还有没有东西就行了</span><br>    }<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>{<br>        E element;<br>        Node&lt;E&gt; next;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(E element)</span> </span>{<br>            <span class="hljs-keyword">this</span>.element = element;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们来尝试编写一下层序遍历：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode&lt;T&gt; root)</span></span>{<br>    LinkedQueue&lt;TreeNode&lt;T&gt;&gt; queue = <span class="hljs-keyword">new</span> LinkedQueue&lt;&gt;();  <span class="hljs-comment">//创建一个队列</span><br>    queue.offer(root);    <span class="hljs-comment">//将根结点丢进队列</span><br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) {   <span class="hljs-comment">//如果队列不为空，就一直不断地取出来</span><br>        TreeNode&lt;T&gt; node = queue.poll();   <span class="hljs-comment">//取一个出来</span><br>        System.out.print(node.element);  <span class="hljs-comment">//打印</span><br>        <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>) queue.offer(node.left);   <span class="hljs-comment">//如果左右孩子不为空，直接将左右孩子丢进队列</span><br>        <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>) queue.offer(node.right);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以看到结果就是层序遍历的结果：</p><p><img src="https://s2.loli.net/2022/08/07/YlUfDhPoQrg9TkB.png" alt="image-20220807215630429"></p><p>当然，使用递归也可以实现，但是需要单独存放结果然后单独输出，不是很方便，所以说这里就不演示了。</p><h3 id="树：二叉查找树和平衡二叉树"><a href="#树：二叉查找树和平衡二叉树" class="headerlink" title="树：二叉查找树和平衡二叉树"></a>树：二叉查找树和平衡二叉树</h3><p><strong>注意：</strong>本部分只进行理论介绍，不做代码实现。</p><p>还记得我们开篇讲到的二分搜索算法吗？通过不断缩小查找范围，最终我们可以以很高的效率找到有序数组中的目标位置。而二叉查找树则利用了类似的思想，我们可以借助其来像二分搜索那样快速查找。</p><p><strong>二叉查找树</strong>也叫二叉搜索树或是二叉排序树，它具有一定的规则：</p><ul><li>左子树中所有结点的值，均小于其根结点的值。</li><li>右子树中所有结点的值，均大于其根结点的值。</li><li>二叉搜索树的子树也是二叉搜索树。</li></ul><p>一棵二叉搜索树长这样：</p><p><img src="https://s2.loli.net/2022/08/14/k9G7Ad2cqezgEtJ.png" alt="image-20220814191444130"></p><p>这棵树的根结点为18，而其根结点左边子树的根结点为10，包括后续结点，都是满足上述要求的。二叉查找树满足左边一定比当前结点小，右边一定比当前结点大的规则，比如我们现在需要在这颗树种查找值为15的结点：</p><ol><li>从根结点18开始，因为15小于18，所以从左边开始找。</li><li>接着来到10，发现10比15小，所以继续往右边走。</li><li>来到15，成功找到。</li></ol><p>实际上，我们在对普通二叉树进行搜索时，可能需要挨个进行查看比较，而有了二叉搜索树，查找效率就大大提升了，它就像我们前面的二分搜索那样。</p><p>利用二叉查找树，我们在搜索某个值的时候，效率会得到巨大提升。但是虽然看起来比较完美，也是存在缺陷的，比如现在我们依次将下面的值插入到这棵二叉树中：</p><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">20 </span><span class="hljs-number">15</span> <span class="hljs-number">13</span> <span class="hljs-number">8</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><p>在插入完成后，我们会发现这棵二叉树竟然长这样：</p><p><img src="https://s2.loli.net/2022/08/15/E1Pf2pGv4b9Lj7t.png" alt="image-20220815113242191"></p><p>因为根据我们之前编写的插入规则，小的一律往左边放，现在正好来的就是这样一串递减的数字，最后就组成了这样的一棵只有一边的二叉树，这种情况，与其说它是一棵二叉树，不如说就是一个链表，如果这时我们想要查找某个结点，那么实际上查找的时间并没有得到任何优化，直接就退化成线性查找了。</p><p>所以，二叉查找树只有在理想情况下，查找效率才是最高的，而像这种极端情况，就性能而言几乎没有任何的提升。我们理想情况下，这样的效率是最高的：</p><p><img src="https://s2.loli.net/2022/08/15/k1jzXPoOMp9caHy.png" alt="image-20220815113705827"></p><p>所以，我们在进行结点插入时，需要尽可能地避免这种一边倒的情况，这里就需要引入<strong>平衡二叉树</strong>的概念了。实际上我们发现，在插入时如果不去维护二叉树的平衡，某一边只会无限制地延伸下去，出现极度不平衡的情况，而我们理想中的二叉查找树左右是尽可能保持平衡的，<strong>平衡二叉树</strong>（AVL树）就是为了解决这样的问题而生的。</p><p>它的性质如下：</p><ul><li>平衡二叉树一定是一棵二叉查找树。</li><li>任意结点的左右子树也是一棵平衡二叉树。</li><li>从根节点开始，左右子树都高度差不能超过1，否则视为不平衡。</li></ul><p>可以看到，这些性质规定了平衡二叉树需要保持高度平衡，这样我们的查找效率才不会因为数据的插入而出现降低的情况。二叉树上节点的左子树高度 减去 右子树高度， 得到的结果称为该节点的<strong>平衡因子</strong>（Balance Factor），比如：</p><p><img src="https://s2.loli.net/2022/08/15/vaI9qji1KYOP8kt.png" alt="image-20220815210652973"></p><p>通过计算平衡因子，我们就可以快速得到是否出现失衡的情况。比如下面的这棵二叉树，正在执行插入操作：</p><p><img src="https://s2.loli.net/2022/08/15/DMnPqGhawy5Z92V.png" alt="image-20220815115219250"></p><p>可以看到，当插入之后，不再满足平衡二叉树的定义时，就出现了失衡的情况，而对于这种失衡情况，为了继续保持平衡状态，我们就需要进行处理了。我们可能会遇到以下几种情况导致失衡：</p><p><img src="https://s2.loli.net/2022/08/15/KcOQVhlFxzwsIb9.png" alt="image-20220815115836604"></p><p>根据插入结点的不同偏向情况，分为LL型、LR型、RR型、RL型。针对于上面这几种情况，我们依次来看一下如何进行调整，使得这棵二叉树能够继续保持平衡：</p><p>动画网站：<a href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html%EF%BC%88%E5%AE%9E%E5%9C%A8%E4%B8%8D%E7%90%86%E8%A7%A3%E5%8F%AF%E4%BB%A5%E7%9C%8B%E7%9C%8B%E5%8A%A8%E7%94%BB%E6%98%AF%E6%80%8E%E4%B9%88%E8%B5%B0%E7%9A%84%EF%BC%89">https://www.cs.usfca.edu/~galles/visualization/AVLtree.html（实在不理解可以看看动画是怎么走的）</a></p><ol><li><p><strong>LL型调整</strong>（右旋）</p><p><img src="https://s2.loli.net/2022/08/15/KqBaWLJwOj34Ec8.png" alt="image-20220815211641144"></p><p>首先我们来看这种情况，这是典型的LL型失衡，为了能够保证二叉树的平衡，我们需要将其进行<strong>旋转</strong>来维持平衡，去纠正最小不平衡子树即可。那么怎么进行旋转呢？对于LL型失衡，我们只需要进行右旋操作，首先我们先找到最小不平衡子树，注意是最小的那一个：</p><p><img src="https://s2.loli.net/2022/08/15/q4aYvzrnjdTgAtK.png" alt="image-20220815212552176"></p><p>可以看到根结点的平衡因子是2，是目前最小的出现不平衡的点，所以说从根结点开始向左的三个结点需要进行右旋操作，右旋需要将这三个结点中间的结点作为新的根结点，而其他两个结点现在变成左右子树：</p><p><img src="https://s2.loli.net/2022/08/15/fJKz3FWclm9orVT.png" alt="image-20220815213222964"></p><p>这样，我们就完成了右旋操作，可以看到右旋之后，所有的结点继续保持平衡，并且依然是一棵二叉查找树。</p></li><li><p><strong>RR型调整</strong>（左旋）</p><p>前面我们介绍了LL型以及右旋解决方案，相反的，当遇到RR型时，我们只需要进行左旋操作即可：</p><p><img src="https://s2.loli.net/2022/08/15/kIl8ZT6Psr7mNSg.png" alt="image-20220815214026710"></p><p>操作和上面是一样的，只不过现在反过来了而已：</p><p><img src="https://s2.loli.net/2022/08/15/LB9DOJpyIlxQWTm.png" alt="image-20220815214408651"></p><p>这样，我们就完成了左旋操作，使得这棵二叉树继续保持平衡状态了。</p></li><li><p><strong>RL型调整</strong>（先右旋，再左旋）</p><p>剩下两种类型比较麻烦，需要旋转两次才行。我们来看看RL型长啥样：</p><p><img src="https://s2.loli.net/2022/08/15/fwcrEIgBxWLVGXs.png" alt="image-20220815214859501"></p><p>可以看到现在的形状是一个回旋镖形状的，先右后左的一个状态，也就是RL型，针对于这种情况，我们需要先进行右旋操作，注意这里的右旋操作针对的是后两个结点：</p><p><img src="https://s2.loli.net/2022/08/15/ukK6C4PNBwoaJbc.png" alt="image-20220815215929303"></p><p>其中右旋和左旋的操作，与之前一样，该怎么分配左右子树就怎么分配，完成两次旋转后，可以看到二叉树重新变回了平衡状态。</p></li><li><p><strong>LR型调整</strong>（先左旋，再右旋）</p><p>和上面一样，我们来看看LR型长啥样，其实就是反着的：</p><p><img src="https://s2.loli.net/2022/08/15/6Cj8VlgGekULXvP.png" alt="image-20220815220609357"></p><p>形状是先向左再向右，这就是典型的LR型了，我们同样需要对其进行两次旋转：</p><p><img src="https://s2.loli.net/2022/08/15/y6WscFPxHuzTiaI.png" alt="image-20220815221349044"></p><p>这里我们先进行的是左旋，然后再进行的右旋，这样二叉树就能继续保持平衡了。</p></li></ol><p>这样，我们只需要在插入结点时注意维护整棵树的平衡因子，保证其处于稳定状态，这样就可以让这棵树一直处于高度平衡的状态，不会再退化了。</p><h3 id="树：红黑树"><a href="#树：红黑树" class="headerlink" title="树：红黑树"></a>树：红黑树</h3><p><strong>注意：</strong>本部分只进行理论介绍，不做代码实现。</p><p>很多人都说红黑树难，其实就那几条规则，跟着我推一遍其实还是很简单的，当然前提是一定要把前面的平衡二叉树搞明白。</p><p>前面我们讲解了二叉平衡树，通过在插入结点时维护树的平衡，这样就不会出现极端情况使得整棵树的查找效率急剧降低了。但是这样是否开销太大了一点，因为一旦平衡因子的绝对值超过1那么就失衡，这样每插入一个结点，就有很大的概率会导致失衡，我们能否不这么严格，但同时也要在一定程度上保证平衡呢？这就要提到红黑树了。</p><p>在线动画网站：<a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">https://www.cs.usfca.edu/~galles/visualization/RedBlack.html</a></p><p>红黑树也是二叉查找树的一种，它大概长这样，可以看到结点有红有黑：</p><p><img src="https://s2.loli.net/2022/08/15/t86B7sxvYeP9TiR.png" alt="image-20220815222810537"></p><p>它并不像平衡二叉树那样严格要求高度差不能超过1，而是只需要满足五个规则即可，它的规则如下：</p><ul><li>规则1：每个结点可以是黑色或是红色。</li><li>规则2：根结点一定是黑色。</li><li>规则3：红色结点的父结点和子结点不能为红色，也就是说不能有两个连续的红色。</li><li>规则4：所有的空结点都是黑色（空结点视为NIL，红黑树中是将空节点视为叶子结点）</li><li>规则5：每个结点到空节点（NIL）路径上出现的黑色结点的个数都相等。</li></ul><p>它相比平衡二叉树，通过不严格平衡和改变颜色，就能在一定程度上减少旋转次数，这样的话对于整体性能是有一定提升的，只不过我们在插入结点时，就有点麻烦了，我们需要同时考虑变色和旋转这两个操作了，但是会比平衡二叉树更简单。</p><p>那么什么时候需要变色，什么时候需要旋转呢？我们通过一个简单例子来看看：</p><p><img src="https://s2.loli.net/2022/08/16/wIj5qnhxFAHcyG7.png" alt="image-20220816104917851"></p><p>首先这棵红黑树只有一个根结点，因为根结点必须是黑色，所以说直接变成黑色。现在我们要插入一个新的结点了，所有新插入的结点，默认情况下都是红色：</p><p><img src="https://s2.loli.net/2022/08/16/yHRXgbsvOM27xLr.png" alt="image-20220816105119178"></p><p>所以新来的结点7根据规则就直接放到11的左边就行了，然后注意7的左右两边都是NULL，那么默认都是黑色，这里就不画出来了。同样的，我们往右边也来一个：</p><p><img src="https://s2.loli.net/2022/08/16/kJiA71fQuKHnIdb.png" alt="image-20220816105553070"></p><p>现在我们继续插入一个结点：</p><p><img src="https://s2.loli.net/2022/08/16/VEQLu5mb1tcTyzd.png" alt="image-20220816105656320"></p><p>插入结点4之后，此时违反了红黑树的规则3，因为红色结点的父结点和子结点不能为红色，此时为了保持以红黑树的性质，我们就需要进行<strong>颜色变换</strong>才可以，那么怎么进行颜色变换呢？我们只需要直接将父结点和其兄弟结点同时修改为黑色（为啥兄弟结点也需要变成黑色？因为要满足性质5）然后将爷爷结点改成红色即可：</p><p><img src="https://s2.loli.net/2022/08/16/kuc1B3lqhNUwaSM.png" alt="image-20220816113259643"></p><p>当然这里还需注意一下，因为爷爷结点正常情况会变成红色，相当于新来了个红色的，这时还得继续往上看有没有破坏红黑树的规则才可以，直到没有为止，比如这里就破坏了性质一，爷爷结点现在是根结点（不是根结点就不需要管了），必须是黑色，所以说还要给它改成黑色才算结束：</p><p><img src="https://s2.loli.net/2022/08/16/dpRX5DGsfWVwnQi.png" alt="image-20220816113339344"></p><p>接着我们继续插入结点：</p><p><img src="https://s2.loli.net/2022/08/16/4ZAhv7R9YusI8q6.png" alt="image-20220816113939172"></p><p>此时又来了一个插在4左边的结点，同样是连续红色，我们需要进行变色才可以讲解问题，但是我们发现，如果变色的话，那么从11开始到所有NIL结点经历的黑色结点数量就不对了：</p><p><img src="https://s2.loli.net/2022/08/16/n3M6Kfsb4jHtIci.png" alt="image-20220816114245996"></p><p>所以说对于这种<strong>父结点为红色，父结点的兄弟结点为黑色</strong>（NIL视为黑色）的情况，变色无法解决问题了，那么我们只能考虑旋转了，旋转规则和我们之前讲解的平衡二叉树是一样的，这实际上是一种LL型失衡：</p><p><img src="https://s2.loli.net/2022/08/16/POTaBfosmQiceWk.png" alt="image-20220816115015892"></p><p>同样的，如果遇到了LR型失衡，跟前面一样，先左旋在右旋，然后进行变色即可：</p><p><img src="https://s2.loli.net/2022/08/16/XqFr7hJwe38AakK.png" alt="image-20220816115924938"></p><p>而RR型和RL型同理，这里就不进行演示了，可以看到，红黑树实际上也是通过颜色规则在进行旋转调整的，当然旋转和变色的操作顺序可以交换。所以，在插入时比较关键的判断点如下：</p><ul><li>如果整棵树为NULL，直接作为根结点，变成黑色。</li><li>如果父结点是黑色，直接插入就完事。</li><li>如果父结点为红色，且父结点的兄弟结点也是红色，直接变色即可（但是注意得继续往上看有没有破坏之前的结构）</li><li>如果父结点为红色，但父结点的兄弟结点为黑色，需要先根据情况（LL、RR、LR、RL）进行旋转，然后再变色。</li></ul><p>在了解这些步骤之后，我们其实已经可以尝试去编写一棵红黑树出来了，当然代码太过复杂，这里就不演示了。</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>在之前，我们已经学习了多种查找数据的方式，比如最简单的，如果数据量不大的情况下，我们可以直接通过顺序查找的方式在集合中搜索我们想要的元素；当数据量较大时，我们可以使用二分搜索来快速找到我们想要的数据，不过需要要求数据按照顺序排列，并且不允许中途对集合进行修改。</p><p>在学习完树形结构篇之后，我们可以利用二叉查找树来建立一个便于我们查找的树形结构，甚至可以将其优化为平衡二叉树或是红黑树来进一步提升稳定性。</p><p>这些都能够极大地帮助我们查找数据，而散列表，则是我们数据结构系列内容的最后一块重要知识。</p><p>散列（Hashing）通过散列函数（哈希函数）将要参与检索的数据与散列值（哈希值）关联起来，生成一种便于搜索的数据结构，我们称其为散列表（哈希表），也就是说，现在我们需要将一堆数据保存起来，这些数据会通过哈希函数进行计算，得到与其对应的哈希值，当我们下次需要查找这些数据时，只需要再次计算哈希值就能快速找到对应的元素了：</p><p><img src="https://s2.loli.net/2022/08/18/Tcj6Spy2Pt5ZIuW.png" alt="image-20220818214145347"></p><p>散列函数也叫哈希函数，哈希函数可以对一个目标计算出其对应的哈希值，并且，只要是同一个目标，无论计算多少次，得到的哈希值都是一样的结果，不同的目标计算出的结果介乎都不同。哈希函数在现实生活中应用十分广泛，比如很多下载网站都提供下载文件的MD5码校验，可以用来判别文件是否完整，哈希函数多种多样，目前应用最为广泛的是SHA-1和MD5，比如我们在下载IDEA之后，会看到有一个验证文件SHA-256校验和的选项，我们可以点进去看看：</p><p><img src="https://s2.loli.net/2022/08/18/tD8AjiGwvJkdahE.png" alt="image-20220818214908458"></p><p>点进去之后，得到：</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">e54a026da11d05d9bb0172f4ef936ba2366f985b5424e7eecf9e9341804d65bf</span> *ideaIU-<span class="hljs-number">2022</span>.<span class="hljs-number">2</span>.<span class="hljs-number">1</span>.dmg<br></code></pre></td></tr></tbody></table></figure><p>这一串由数字和小写字母随意组合的一个字符串，就是安装包文件通过哈希算法计算得到的结果，那么这个东西有什么用呢？我们的网络可能有时候会出现卡顿的情况，导致我们下载的文件可能会出现不完整的情况，因为哈希函数对同一个文件计算得到的结果是一样的，我们可以在本地使用同样的哈希函数去计算下载文件的哈希值，如果与官方一致，那么就说明是同一个文件，如果不一致，那么说明文件在传输过程中出现了损坏。</p><p>可见，哈希函数在这些地方就显得非常实用，在我们的生活中起了很大的作用，它也可以用于布隆过滤器和负载均衡等场景，这里不多做介绍了。</p><p>前面我们介绍了散列函数，我们知道可以通过散列函数计算一个目标的哈希值，那么这个哈希值计算出来有什么用呢，对我们的程序设计有什么意义呢？我们可以利用哈希值的特性，设计一张全新的表结构，这种表结构是专为哈希设立的，我们称其为哈希表（散列表）</p><p><img src="https://s2.loli.net/2022/08/18/M2o1vE7hHasN8DP.png" alt="image-20220818220944783"></p><p>我们可以将这些元素保存到哈希表中，而保存的位置则与其对应的哈希值有关，哈希值是通过哈希函数计算得到的，我们只需要将对应元素的关键字（一般是整数）提供给哈希函数就可以进行计算了，一般比较简单的哈希函数就是取模操作，哈希表长度是多少（长度最好是一个素数），模就是多少：</p><p><img src="https://s2.loli.net/2022/08/19/CAPhlJnQeLjMHfd.png" alt="image-20220819170355221"></p><p>比如现在我们需要插入一个新的元素（关键字为17）到哈希表中：</p><p><img src="https://s2.loli.net/2022/08/19/ovieRjrzlXhKMC2.png" alt="image-20220819171430332"></p><p>插入的位置为计算出来的哈希值，比如上面是8，那么就在下标位置8插入元素，同样的，我们继续插入27：</p><p><img src="https://s2.loli.net/2022/08/19/pisuSAIZyf5JE7B.png" alt="image-20220819210336314"></p><p>这样，我们就可以将多种多样的数据保存到哈希表中了，注意保存的数据是无序的，因为我们也不清楚计算完哈希值最后会放到哪个位置。那么如果现在我们想要从哈希表中查找数据呢？比如我们现在需要查找哈希表中是否有14这个元素：</p><p><img src="https://s2.loli.net/2022/08/19/H1hAvQPjNui2RYt.png" alt="image-20220819211656628"></p><p>同样的，直接去看哈希值对应位置上看看有没有这个元素，如果没有，那么就说明哈希表中没有这个元素。可以看到，哈希表在查找时只需要进行一次哈希函数计算就能直接找到对应元素的存储位置，效率极高。</p><p>我们来尝试编写一下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashTable</span>&lt;<span class="hljs-title">E</span>&gt; </span>{<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TABLE_SIZE = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object[] TABLE = <span class="hljs-keyword">new</span> Object[TABLE_SIZE];<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(E element)</span></span>{<br>        <span class="hljs-keyword">int</span> index = hash(element);<br>        TABLE[index] = element;<br>    }<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(E element)</span></span>{<br>        <span class="hljs-keyword">int</span> index = hash(element);<br>        <span class="hljs-keyword">return</span> TABLE[index] == element;<br>    }<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object object)</span></span>{   <span class="hljs-comment">//哈希函数，计算出存放的位置</span><br>        <span class="hljs-keyword">int</span> hashCode = object.hashCode();  <br>      <span class="hljs-comment">//每一个对象都有一个独一无二的哈希值，可以通过hashCode方法得到（只有极小的概率会出现相同的情况）</span><br>        <span class="hljs-keyword">return</span> hashCode % TABLE_SIZE;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>这样，我们就实现了一个简单的哈希表和哈希函数，通过哈希表，我们可以将数据的查找时间复杂度提升到常数阶。</p><p>前面我介绍了哈希函数，通过哈希函数计算得到一个目标的哈希值，但是在某些情况下，哈希值可能会出现相同的情况：</p><p><img src="https://s2.loli.net/2022/08/19/XqpZd1YP5ulEJRy.png" alt="image-20220819215004653"></p><p>比如现在同时插入14和23这两个元素，他们两个计算出来的哈希值是一样的，都需要在5号下标位置插入，这时就出现了打架的情况，那么到底是把哪一个放进去呢？这种情况，我们称为<strong>哈希碰撞</strong>（哈希冲突）</p><p>这种问题是很严重的，因为哈希函数的设计不同，难免会出现这种情况，这种情况是不可避免的，我们只能通过使用更加高级的哈希函数来尽可能避免这种情况，但是无法完全避免。当然，如果要完全解决这种问题，我们还需要去寻找更好的方法。这里我们只介绍一种比较重要的，会在后面集合类中用到的方案。</p><p>实际上常见的哈希冲突解决方案是<strong>链地址法</strong>，当出现哈希冲突时，我们依然将其保存在对应的位置上，我们可以将其连接为一个链表的形式：</p><p><img src="https://s2.loli.net/2022/09/30/Hd1LDvkY6ScVTN2.png" alt="image-20220820220237535"></p><p>当表中元素变多时，差不多就变成了这样，我们一般将其横过来看：</p><p><img src="https://s2.loli.net/2022/09/30/kr4CcVEwI72AiDU.png" alt="image-20220820221104298"></p><p>通过结合链表的形式，哈希冲突问题就可以得到解决了，但是同时也会出现一定的查找开销，因为现在有了链表，我们得挨个往后看才能找到，当链表变得很长时，查找效率也会变低，此时我们可以考虑结合其他的数据结构来提升效率。比如当链表长度达到8时，自动转换为一棵平衡二叉树或是红黑树，这样就可以在一定程度上缓解查找的压力了。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashTable</span>&lt;<span class="hljs-title">E</span>&gt; </span>{<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TABLE_SIZE = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;E&gt;[] TABLE = <span class="hljs-keyword">new</span> Node[TABLE_SIZE];<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashTable</span><span class="hljs-params">()</span></span>{<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; TABLE_SIZE; i++)<br>            TABLE[i] = <span class="hljs-keyword">new</span> Node&lt;&gt;(<span class="hljs-keyword">null</span>);<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(E element)</span></span>{<br>        <span class="hljs-keyword">int</span> index = hash(element);<br>        Node&lt;E&gt; prev = TABLE[index];<br>        <span class="hljs-keyword">while</span> (prev.next != <span class="hljs-keyword">null</span>)<br>            prev = prev.next;<br>        prev.next = <span class="hljs-keyword">new</span> Node&lt;&gt;(element);<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(E element)</span></span>{<br>        <span class="hljs-keyword">int</span> index = hash(element);<br>        Node&lt;E&gt; node = TABLE[index].next;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-keyword">null</span>) {<br>            <span class="hljs-keyword">if</span>(node.element == element)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            node = node.next;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object object)</span></span>{<br>        <span class="hljs-keyword">int</span> hashCode = object.hashCode();<br>        <span class="hljs-keyword">return</span> hashCode % TABLE_SIZE;<br>    }<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>{<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> E element;<br>        <span class="hljs-keyword">private</span> Node&lt;E&gt; next;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Node</span><span class="hljs-params">(E element)</span></span>{<br>            <span class="hljs-keyword">this</span>.element = element;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>实际上这种方案代码写起来也会更简单，使用也更方便一些。</p><p>至此，数据结构相关内容，我们就讲解到这里，学习这些数据结构，实际上也是为了方便各位小伙伴对于后续结合类的学习，因为集合类的底层实现就是这些数据结构。</p><hr><h2 id="实战练习"><a href="#实战练习" class="headerlink" title="实战练习"></a>实战练习</h2><p>合理利用集合类，我们可以巧妙地解决各种各样的难题。</p><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p>本题来自LeetCode：<a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></p><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p><blockquote><p>输入：head = [1,2,3,4,5]<br>输出：[5,4,3,2,1]</p></blockquote><p>示例 2：</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p><blockquote><p>输入：head = [1,2]<br>输出：[2,1]</p></blockquote><p>这道题依然是考察各位小伙伴对于链表相关操作的掌握程度，我们如何才能将一个链表的顺序进行反转，关键就在于如何修改每个节点的指针指向。</p><h3 id="括号匹配问题"><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a>括号匹配问题</h3><p>本题来自LeetCode：<a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></p><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>示例 1：</p><blockquote><p>输入：s = “()”<br>输出：true</p></blockquote><p>示例 2：</p><blockquote><p>输入：s = “()[]{}”<br>输出：true</p></blockquote><p>示例 3：</p><blockquote><p>输入：s = “(]”<br>输出：false</p></blockquote><p><strong>示例 4：</strong></p><blockquote><p>输入：s = “([)]”<br>输出：false</p></blockquote><p><strong>示例 5：</strong></p><blockquote><p>输入：s = “{[]}”<br>输出：true</p></blockquote><p>题干很明确，就是需要我们去对这些括号完成匹配，如果给定字符串中的括号无法完成一一匹配的话，那么就表示匹配失败。实际上这种问题我们就可以利用前面学习的栈这种数据结构来解决，我们可以将所有括号的左半部分放入栈中，当遇到右半部分时，进行匹配，如果匹配失败，那么就失败，如果匹配成功，那么就消耗一个左半部分，直到括号消耗完毕。</p><h3 id="实现计算器"><a href="#实现计算器" class="headerlink" title="实现计算器"></a>实现计算器</h3><p>输入一个计算公式（含加减乘除运算符，没有负数但是有小数）得到结果，比如输入：1+4*3/1.321，得到结果为：2.2</p><p>现在请你设计一个Java程序，实现计算器。</p>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/09/24/AulBzXWK6JCPMH5.png&quot; alt=&quot;image-20220924223020333&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;泛型程序设计&quot;&gt;&lt;a href=&quot;#泛型程序设计&quot; class=&quot;headerlink&quot; title=&quot;泛型程序设计&quot;&gt;&lt;/a&gt;泛型程序设计&lt;/h1&gt;&lt;p&gt;在前面我们学习了最重要的类和对象，了解了面向对象编程的思想，注意，非常重要，面向对象是必须要深入理解和掌握的内容，不能草草结束。在本章节，我们还会继续深入了解，从泛型开始，再到数据结构，最后再开始我们的集合类学习，循序渐进。&lt;/p&gt;
&lt;h2 id=&quot;泛型&quot;&gt;&lt;a href=&quot;#泛型&quot; class=&quot;headerlink&quot; title=&quot;泛型&quot;&gt;&lt;/a&gt;泛型&lt;/h2&gt;&lt;p&gt;为了统计学生成绩，要求设计一个Score对象，包括课程名称、课程号、课程成绩，但是成绩分为两种，一种是以&lt;code&gt;优秀、良好、合格&lt;/code&gt; 来作为结果，还有一种就是 &lt;code&gt;60.0、75.5、92.5&lt;/code&gt; 这样的数字分数，可能高等数学这门课是以数字成绩进行结算，而计算机网络实验这门课是以等级进行结算，这两种分数类型都有可能出现，那么现在该如何去设计这样的一个Score类呢？&lt;/p&gt;
&lt;p&gt;现在的问题就是，成绩可能是&lt;code&gt;String&lt;/code&gt;类型，也可能是&lt;code&gt;Integer&lt;/code&gt;类型，如何才能很好的去存可能出现的两种类型呢？&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Score&lt;/span&gt; &lt;/span&gt;{&lt;br&gt;    String name;&lt;br&gt;    String id;&lt;br&gt;    Object value;  &lt;span class=&quot;hljs-comment&quot;&gt;//因为Object是所有类型的父类，因此既可以存放Integer也能存放String&lt;/span&gt;&lt;br&gt;&lt;br&gt;  	&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Score&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String name, String id, Object value)&lt;/span&gt; &lt;/span&gt;{&lt;br&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;br&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.id = id;&lt;br&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.value = value;&lt;br&gt;    }&lt;br&gt;}&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;以上的方法虽然很好地解决了多种类型存储问题，但是Object类型在编译阶段并不具有良好的类型判断能力，很容易出现以下的情况：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs java&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br&gt;&lt;br&gt;    Score score = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Score(&lt;span class=&quot;hljs-string&quot;&gt;&quot;数据结构与算法基础&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;EP074512&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;优秀&quot;&lt;/span&gt;);  &lt;span class=&quot;hljs-comment&quot;&gt;//是String类型的&lt;/span&gt;&lt;br&gt;&lt;br&gt;    ...&lt;br&gt;&lt;br&gt;    Integer number = (Integer) score.score;  &lt;span class=&quot;hljs-comment&quot;&gt;//获取成绩需要进行强制类型转换，虽然并不是一开始的类型，但是编译不会报错&lt;/span&gt;&lt;br&gt;}&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://xiaofanshutu.github.io/posts/0.html"/>
    <id>https://xiaofanshutu.github.io/posts/0.html</id>
    <published>2025-09-07T23:26:13.331Z</published>
    <updated>2025-09-07T23:28:25.711Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://s2.loli.net/2022/10/04/aRsN9WoS7BcC3uY.png" alt="image-20221004132312588"></p><h1 id="多线程与反射"><a href="#多线程与反射" class="headerlink" title="多线程与反射"></a>多线程与反射</h1><p>前面我们已经讲解了JavaSE的大部分核心内容，最后一章，我们还将继续学习JavaSE中提供的各种高级特性。这些高级特性对于我们之后的学习，会有着举足轻重的作用。</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p><strong>注意：</strong>本章节会涉及到 <strong>操作系统</strong> 相关知识。</p><p>在了解多线程之前，让我们回顾一下<code>操作系统</code>中提到的进程概念：</p><p><img src="https://s2.loli.net/2022/10/04/GhrSTfNRsc2jFZM.jpg" alt="b040eadb-8aa1-4b2a-b587-2c0a6b4efa0b"></p><p>进程是程序执行的实体，每一个进程都是一个应用程序（比如我们运行QQ、浏览器、LOL、网易云音乐等软件），都有自己的内存空间，CPU一个核心同时只能处理一件事情，当出现多个进程需要同时运行时，CPU一般通过<code>时间片轮转调度</code>算法，来实现多个进程的同时运行。</p><p><img src="https://s2.loli.net/2022/10/04/hUkGafu7vztB4qR.png" alt="image-20221004132729868"></p><p>在早期的计算机中，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。但是，如果我希望两个任务同时进行，就必须运行两个进程，由于每个进程都有一个自己的内存空间，进程之间的通信就变得非常麻烦（比如要共享某些数据）而且执行不同进程会产生上下文切换，非常耗时，那么能否实现在一个进程中就能够执行多个任务呢？</p><p><img src="https://s2.loli.net/2022/10/04/okgq3HEKGn6jBVw.png" alt="image-20221004132700554"></p><p>后来，线程横空出世，一个进程可以有多个线程，线程是程序执行中一个单一的顺序控制流程，现在线程才是程序执行流的最小单元，各个线程之间共享程序的内存空间（也就是所在进程的内存空间），上下文切换速度也高于进程。</p><p>在Java中，我们从开始，一直以来编写的都是单线程应用程序（运行<code>main()</code>方法的内容），也就是说只能同时执行一个任务（无论你是调用方法、还是进行计算，始终都是依次进行的，也就是同步的），而如果我们希望同时执行多个任务（两个方法<strong>同时</strong>在运行或者是两个计算同时在进行，也就是异步的），就需要用到Java多线程框架。实际上一个Java程序启动后，会创建很多线程，不仅仅只运行一个主线程：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    ThreadMXBean bean = ManagementFactory.getThreadMXBean();<br>    <span class="hljs-keyword">long</span>[] ids = bean.getAllThreadIds();<br>    ThreadInfo[] infos = bean.getThreadInfo(ids);<br>    <span class="hljs-keyword">for</span> (ThreadInfo info : infos) {<br>        System.out.println(info.getThreadName());<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>关于除了main线程默认以外的线程，涉及到JVM相关底层原理，在这里不做讲解，了解就行。</p><h3 id="线程的创建和启动"><a href="#线程的创建和启动" class="headerlink" title="线程的创建和启动"></a>线程的创建和启动</h3><p>通过创建Thread对象来创建一个新的线程，Thread构造方法中需要传入一个Runnable接口的实现（其实就是编写要在另一个线程执行的内容逻辑）同时Runnable只有一个未实现方法，因此可以直接使用lambda表达式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span> </span>{<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span><br><span class="hljs-comment">     * to create a thread, starting the thread causes the object's</span><br><span class="hljs-comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span><br><span class="hljs-comment">     * thread.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span><br><span class="hljs-comment">     * take any action whatsoever.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span>     java.lang.Thread#run()</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>创建好后，通过调用<code>start()</code>方法来运行此线程：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; {    <span class="hljs-comment">//直接编写逻辑</span><br>        System.out.println(<span class="hljs-string">"我是另一个线程！"</span>);<br>    });<br>    t.start();   <span class="hljs-comment">//调用此方法来开始执行此线程</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>可能上面的例子看起来和普通的单线程没两样，那我们先来看看下面这段代码的运行结果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        System.out.println(<span class="hljs-string">"我是线程："</span>+Thread.currentThread().getName());<br>        System.out.println(<span class="hljs-string">"我正在计算 0-10000 之间所有数的和..."</span>);<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">10000</span>; i++) {<br>            sum += i;<br>        }<br>        System.out.println(<span class="hljs-string">"结果："</span>+sum);<br>    });<br>    t.start();<br>    System.out.println(<span class="hljs-string">"我是主线程！"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现，这段代码执行输出结果并不是按照从上往下的顺序了，因为他们分别位于两个线程，他们是同时进行的！如果你还是觉得很疑惑，我们接着来看下面的代码运行结果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) {<br>            System.out.println(<span class="hljs-string">"我是一号线程："</span>+i);<br>        }<br>    });<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) {<br>            System.out.println(<span class="hljs-string">"我是二号线程："</span>+i);<br>        }<br>    });<br>    t1.start();<br>    t2.start();<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以看到打印实际上是在交替进行的，也证明了他们是在同时运行！</p><p><strong>注意</strong>：我们发现还有一个run方法，也能执行线程里面定义的内容，但是run是直接在当前线程执行，并不是创建一个线程执行！</p><p><img src="https://s2.loli.net/2022/10/04/Srx4H8YyRWqXofc.png" alt="image-20221004133119997"></p><p>实际上，线程和进程差不多，也会等待获取CPU资源，一旦获取到，就开始按顺序执行我们给定的程序，当需要等待外部IO操作（比如Scanner获取输入的文本），就会暂时处于休眠状态，等待通知，或是调用<code>sleep()</code>方法来让当前线程休眠一段时间：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br>    System.out.println(<span class="hljs-string">"l"</span>);<br>    Thread.sleep(<span class="hljs-number">1000</span>);    <span class="hljs-comment">//休眠时间，以毫秒为单位，1000ms = 1s</span><br>    System.out.println(<span class="hljs-string">"b"</span>);<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    System.out.println(<span class="hljs-string">"w"</span>);<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    System.out.println(<span class="hljs-string">"nb!"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们也可以使用<code>stop()</code>方法来强行终止此线程：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        Thread me = Thread.currentThread();   <span class="hljs-comment">//获取当前线程对象</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) {<br>            System.out.println(<span class="hljs-string">"打印:"</span>+i);<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">20</span>) me.stop();  <span class="hljs-comment">//此方法会直接终止此线程</span><br>        }<br>    });<br>    t.start();<br>}<br></code></pre></td></tr></tbody></table></figure><p>虽然<code>stop()</code>方法能够终止此线程，但是并不是所推荐的做法，有关线程中断相关问题，我们会在后面继续了解。</p><p><strong>思考</strong>：猜猜以下程序输出结果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) value++;<br>        System.out.println(<span class="hljs-string">"线程1完成"</span>);<br>    });<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) value++;<br>        System.out.println(<span class="hljs-string">"线程2完成"</span>);<br>    });<br>    t1.start();<br>    t2.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);  <span class="hljs-comment">//主线程停止1秒，保证两个线程执行完成</span><br>    System.out.println(value);<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现，value最后的值并不是我们理想的结果，有关为什么会出现这种问题，在我们学习到线程锁的时候，再来探讨。</p><h3 id="线程的休眠和中断"><a href="#线程的休眠和中断" class="headerlink" title="线程的休眠和中断"></a>线程的休眠和中断</h3><p>我们前面提到，一个线程处于运行状态下，线程的下一个状态会出现以下情况：</p><ul><li>当CPU给予的运行时间结束时，会从运行状态回到就绪（可运行）状态，等待下一次获得CPU资源。</li><li>当线程进入休眠 / 阻塞(如等待IO请求) / 手动调用<code>wait()</code>方法时，会使得线程处于等待状态，当等待状态结束后会回到就绪状态。</li><li>当线程出现异常或错误 / 被<code>stop()</code> 方法强行停止 / 所有代码执行结束时，会使得线程的运行终止。</li></ul><p>而这个部分我们着重了解一下线程的休眠和中断，首先我们来了解一下如何使得线程进如休眠状态：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        <span class="hljs-keyword">try</span> {<br>            System.out.println(<span class="hljs-string">"l"</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);   <span class="hljs-comment">//sleep方法是Thread的静态方法，它只作用于当前线程（它知道当前线程是哪个）</span><br>            System.out.println(<span class="hljs-string">"b"</span>);    <span class="hljs-comment">//调用sleep后，线程会直接进入到等待状态，直到时间结束</span><br>        } <span class="hljs-keyword">catch</span> (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>    });<br>    t.start();<br>}<br></code></pre></td></tr></tbody></table></figure><p>通过调用<code>sleep()</code>方法来将当前线程进入休眠，使得线程处于等待状态一段时间。我们发现，此方法显示声明了会抛出一个InterruptedException异常，那么这个异常在什么时候会发生呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        <span class="hljs-keyword">try</span> {<br>            Thread.sleep(<span class="hljs-number">10000</span>);  <span class="hljs-comment">//休眠10秒</span><br>        } <span class="hljs-keyword">catch</span> (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>    });<br>    t.start();<br>    <span class="hljs-keyword">try</span> {<br>        Thread.sleep(<span class="hljs-number">3000</span>);   <span class="hljs-comment">//休眠3秒，一定比线程t先醒来</span><br>        t.interrupt();   <span class="hljs-comment">//调用t的interrupt方法</span><br>    } <span class="hljs-keyword">catch</span> (InterruptedException e) {<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现，每一个Thread对象中，都有一个<code>interrupt()</code>方法，调用此方法后，会给指定线程添加一个中断标记以告知线程需要立即停止运行或是进行其他操作，由线程来响应此中断并进行相应的处理，我们前面提到的<code>stop()</code>方法是强制终止线程，这样的做法虽然简单粗暴，但是很有可能导致资源不能完全释放，而类似这样的发送通知来告知线程需要中断，让线程自行处理后续，会更加合理一些，也是更加推荐的做法。我们来看看interrupt的用法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        System.out.println(<span class="hljs-string">"线程开始运行！"</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>){   <span class="hljs-comment">//无限循环</span><br>            <span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted()){   <span class="hljs-comment">//判断是否存在中断标志</span><br>                <span class="hljs-keyword">break</span>;   <span class="hljs-comment">//响应中断</span><br>            }<br>        }<br>        System.out.println(<span class="hljs-string">"线程被中断了！"</span>);<br>    });<br>    t.start();<br>    <span class="hljs-keyword">try</span> {<br>        Thread.sleep(<span class="hljs-number">3000</span>);   <span class="hljs-comment">//休眠3秒，一定比线程t先醒来</span><br>        t.interrupt();   <span class="hljs-comment">//调用t的interrupt方法</span><br>    } <span class="hljs-keyword">catch</span> (InterruptedException e) {<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>通过<code>isInterrupted()</code>可以判断线程是否存在中断标志，如果存在，说明外部希望当前线程立即停止，也有可能是给当前线程发送一个其他的信号，如果我们并不是希望收到中断信号就是结束程序，而是通知程序做其他事情，我们可以在收到中断信号后，复位中断标记，然后继续做我们的事情：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        System.out.println(<span class="hljs-string">"线程开始运行！"</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>){<br>            <span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted()){   <span class="hljs-comment">//判断是否存在中断标志</span><br>                System.out.println(<span class="hljs-string">"发现中断信号，复位，继续运行..."</span>);<br>                Thread.interrupted();  <span class="hljs-comment">//复位中断标记（返回值是当前是否有中断标记，这里不用管）</span><br>            }<br>        }<br>    });<br>    t.start();<br>    <span class="hljs-keyword">try</span> {<br>        Thread.sleep(<span class="hljs-number">3000</span>);   <span class="hljs-comment">//休眠3秒，一定比线程t先醒来</span><br>        t.interrupt();   <span class="hljs-comment">//调用t的interrupt方法</span><br>    } <span class="hljs-keyword">catch</span> (InterruptedException e) {<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>复位中断标记后，会立即清除中断标记。那么，如果现在我们想暂停线程呢？我们希望线程暂时停下，比如等待其他线程执行完成后，再继续运行，那这样的操作怎么实现呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        System.out.println(<span class="hljs-string">"线程开始运行！"</span>);<br>        Thread.currentThread().suspend();   <span class="hljs-comment">//暂停此线程</span><br>        System.out.println(<span class="hljs-string">"线程继续运行！"</span>);<br>    });<br>    t.start();<br>    <span class="hljs-keyword">try</span> {<br>        Thread.sleep(<span class="hljs-number">3000</span>);   <span class="hljs-comment">//休眠3秒，一定比线程t先醒来</span><br>        t.resume();   <span class="hljs-comment">//恢复此线程</span><br>    } <span class="hljs-keyword">catch</span> (InterruptedException e) {<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>虽然这样很方便地控制了线程的暂停状态，但是这两个方法我们发现实际上也是不推荐的做法，它很容易导致死锁！有关为什么被弃用的原因，我们会在线程锁继续探讨。</p><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>实际上，Java程序中的每个线程并不是平均分配CPU时间的，为了使得线程资源分配更加合理，Java采用的是抢占式调度方式，优先级越高的线程，优先使用CPU资源！我们希望CPU花费更多的时间去处理更重要的任务，而不太重要的任务，则可以先让出一部分资源。线程的优先级一般分为以下三种：</p><ul><li>MIN_PRIORITY  最低优先级</li><li>MAX_PRIORITY  最高优先级</li><li>NOM_PRIORITY  常规优先级</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        System.out.println(<span class="hljs-string">"线程开始运行！"</span>);<br>    });<br>    t.start();<br>    t.setPriority(Thread.MIN_PRIORITY);  <span class="hljs-comment">//通过使用setPriority方法来设定优先级</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>优先级越高的线程，获得CPU资源的概率会越大，并不是说一定优先级越高的线程越先执行！</p><h3 id="线程的礼让和加入"><a href="#线程的礼让和加入" class="headerlink" title="线程的礼让和加入"></a>线程的礼让和加入</h3><p>我们还可以在当前线程的工作不重要时，将CPU资源让位给其他线程，通过使用<code>yield()</code>方法来将当前资源让位给其他同优先级线程：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        System.out.println(<span class="hljs-string">"线程1开始运行！"</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) {<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>) {<br>                System.out.println(<span class="hljs-string">"让位！"</span>);<br>                Thread.yield();<br>            }<br>            System.out.println(<span class="hljs-string">"1打印："</span>+i);<br>        }<br>        System.out.println(<span class="hljs-string">"线程1结束！"</span>);<br>    });<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        System.out.println(<span class="hljs-string">"线程2开始运行！"</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) {<br>            System.out.println(<span class="hljs-string">"2打印："</span>+i);<br>        }<br>    });<br>    t1.start();<br>    t2.start();<br>}<br></code></pre></td></tr></tbody></table></figure><p>观察结果，我们发现，在让位之后，尽可能多的在执行线程2的内容。</p><p>当我们希望一个线程等待另一个线程执行完成后再继续进行，我们可以使用<code>join()</code>方法来实现线程的加入：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        System.out.println(<span class="hljs-string">"线程1开始运行！"</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) {<br>            System.out.println(<span class="hljs-string">"1打印："</span>+i);<br>        }<br>        System.out.println(<span class="hljs-string">"线程1结束！"</span>);<br>    });<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        System.out.println(<span class="hljs-string">"线程2开始运行！"</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) {<br>            System.out.println(<span class="hljs-string">"2打印："</span>+i);<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">10</span>){<br>                <span class="hljs-keyword">try</span> {<br>                    System.out.println(<span class="hljs-string">"线程1加入到此线程！"</span>);<br>                    t1.join();    <span class="hljs-comment">//在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容</span><br>                } <span class="hljs-keyword">catch</span> (InterruptedException e) {<br>                    e.printStackTrace();<br>                }<br>            }<br>        }<br>    });<br>    t1.start();<br>    t2.start();<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现，线程1加入后，线程2等待线程1待执行的内容全部执行完成之后，再继续执行的线程2内容。注意，线程的加入只是等待另一个线程的完成，并不是将另一个线程和当前线程合并！我们来看看：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">"开始运行！"</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) {<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">"打印："</span>+i);<br>        }<br>        System.out.println(<span class="hljs-string">"线程1结束！"</span>);<br>    });<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        System.out.println(<span class="hljs-string">"线程2开始运行！"</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) {<br>            System.out.println(<span class="hljs-string">"2打印："</span>+i);<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">10</span>){<br>                <span class="hljs-keyword">try</span> {<br>                    System.out.println(<span class="hljs-string">"线程1加入到此线程！"</span>);<br>                    t1.join();    <span class="hljs-comment">//在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容</span><br>                } <span class="hljs-keyword">catch</span> (InterruptedException e) {<br>                    e.printStackTrace();<br>                }<br>            }<br>        }<br>    });<br>    t1.start();<br>    t2.start();<br>}<br></code></pre></td></tr></tbody></table></figure><p>实际上，t2线程只是暂时处于等待状态，当t1执行结束时，t2才开始继续执行，只是在效果上看起来好像是两个线程合并为一个线程在执行而已。</p><h3 id="线程锁和线程同步"><a href="#线程锁和线程同步" class="headerlink" title="线程锁和线程同步"></a>线程锁和线程同步</h3><p>在开始讲解线程同步之前，我们需要先了解一下多线程情况下Java的内存管理：</p><p><img src="https://s2.loli.net/2022/10/04/ZvI8neF3tdGJwS4.png" alt="image-20221004203914215"></p><p>线程之间的共享变量（比如之前悬念中的value变量）存储在主内存（main memory）中，每个线程都有一个私有的工作内存（本地内存），工作内存中存储了该线程以读/写共享变量的副本。它类似于我们在<code>计算机组成原理</code>中学习的多核心处理器高速缓存机制：</p><p><img src="https://s2.loli.net/2022/10/04/SKlbIZyvxMnauLJ.png" alt="image-20221004204209038"></p><p>高速缓存通过保存内存中数据的副本来提供更加快速的数据访问，但是如果多个处理器的运算任务都涉及同一块内存区域，就可能导致各自的高速缓存数据不一致，在写回主内存时就会发生冲突，这就是引入高速缓存引发的新问题，称之为：缓存一致性。</p><p>实际上，Java的内存模型也是这样类似设计的，当我们同时去操作一个共享变量时，如果仅仅是读取还好，但是如果同时写入内容，就会出现问题！好比说一个银行，如果我和我的朋友同时在银行取我账户里面的钱，难道取1000还可能吐2000出来吗？我们需要一种更加安全的机制来维持秩序，保证数据的安全性！</p><p>比如我们可以来看看下面这个问题：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) value++;<br>        System.out.println(<span class="hljs-string">"线程1完成"</span>);<br>    });<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) value++;<br>        System.out.println(<span class="hljs-string">"线程2完成"</span>);<br>    });<br>    t1.start();<br>    t2.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);  <span class="hljs-comment">//主线程停止1秒，保证两个线程执行完成</span><br>    System.out.println(value);<br>}<br></code></pre></td></tr></tbody></table></figure><p>实际上，当两个线程同时读取value的时候，可能会同时拿到同样的值，而进行自增操作之后，也是同样的值，再写回主内存后，本来应该进行2次自增操作，实际上只执行了一次！</p><p><img src="https://s2.loli.net/2022/10/04/T2l3xfIP17Gr5dw.png" alt="image-20221004204439553"></p><p>通过synchronized关键字来创造一个线程锁，首先我们来认识一下synchronized代码块，它需要在括号中填入一个内容，必须是一个对象或是一个类，我们在value自增操作外套上同步代码块：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {<br>            <span class="hljs-keyword">synchronized</span> (Main.class){  <span class="hljs-comment">//使用synchronized关键字创建同步代码块</span><br>                value++;<br>            }<br>        }<br>        System.out.println(<span class="hljs-string">"线程1完成"</span>);<br>    });<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {<br>            <span class="hljs-keyword">synchronized</span> (Main.class){<br>                value++;<br>            }<br>        }<br>        System.out.println(<span class="hljs-string">"线程2完成"</span>);<br>    });<br>    t1.start();<br>    t2.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);  <span class="hljs-comment">//主线程停止1秒，保证两个线程执行完成</span><br>    System.out.println(value);<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现，现在得到的结果就是我们想要的内容了，因为在同步代码块执行过程中，拿到了我们传入对象或类的锁（传入的如果是对象，就是对象锁，不同的对象代表不同的对象锁，如果是类，就是类锁，类锁只有一个，实际上类锁也是对象锁，是Class类实例，但是Class类实例同样的类无论怎么获取都是同一个），但是注意两个线程必须使用同一把锁！</p><p>当一个线程进入到同步代码块时，会获取到当前的锁，而这时如果其他使用同样的锁的同步代码块也想执行内容，就必须等待当前同步代码块的内容执行完毕，在执行完毕后会自动释放这把锁，而其他的线程才能拿到这把锁并开始执行同步代码块里面的内容（实际上synchronized是一种悲观锁，随时都认为有其他线程在对数据进行修改，后面在JUC篇视频教程中我们还会讲到乐观锁，如CAS算法）</p><p>那么我们来看看，如果使用的是不同对象的锁，那么还能顺利进行吗？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br>    Main main1 = <span class="hljs-keyword">new</span> Main();<br>    Main main2 = <span class="hljs-keyword">new</span> Main();<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {<br>            <span class="hljs-keyword">synchronized</span> (main1){<br>                value++;<br>            }<br>        }<br>        System.out.println(<span class="hljs-string">"线程1完成"</span>);<br>    });<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {<br>            <span class="hljs-keyword">synchronized</span> (main2){<br>                value++;<br>            }<br>        }<br>        System.out.println(<span class="hljs-string">"线程2完成"</span>);<br>    });<br>    t1.start();<br>    t2.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);  <span class="hljs-comment">//主线程停止1秒，保证两个线程执行完成</span><br>    System.out.println(value);<br>}<br></code></pre></td></tr></tbody></table></figure><p>当对象不同时，获取到的是不同的锁，因此并不能保证自增操作的原子性，最后也得不到我们想要的结果。</p><p>synchronized关键字也可以作用于方法上，调用此方法时也会获取锁：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>{<br>    value++;<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) add();<br>        System.out.println(<span class="hljs-string">"线程1完成"</span>);<br>    });<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) add();<br>        System.out.println(<span class="hljs-string">"线程2完成"</span>);<br>    });<br>    t1.start();<br>    t2.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);  <span class="hljs-comment">//主线程停止1秒，保证两个线程执行完成</span><br>    System.out.println(value);<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现实际上效果是相同的，只不过这个锁不用你去给，如果是静态方法，就是使用的类锁，而如果是普通成员方法，就是使用的对象锁。通过灵活的使用synchronized就能很好地解决我们之前提到的问题了。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>其实死锁的概念在<code>操作系统</code>中也有提及，它是指两个线程相互持有对方需要的锁，但是又迟迟不释放，导致程序卡住：</p><p><img src="https://s2.loli.net/2022/10/04/Ja6TPO23wCI8pvn.png" alt="image-20221004205058223"></p><p>我们发现，线程A和线程B都需要对方的锁，但是又被对方牢牢把握，由于线程被无限期地阻塞，因此程序不可能正常终止。我们来看看以下这段代码会得到什么结果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br>    Object o1 = <span class="hljs-keyword">new</span> Object();<br>    Object o2 = <span class="hljs-keyword">new</span> Object();<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        <span class="hljs-keyword">synchronized</span> (o1){<br>            <span class="hljs-keyword">try</span> {<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                <span class="hljs-keyword">synchronized</span> (o2){<br>                    System.out.println(<span class="hljs-string">"线程1"</span>);<br>                }<br>            } <span class="hljs-keyword">catch</span> (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    });<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        <span class="hljs-keyword">synchronized</span> (o2){<br>            <span class="hljs-keyword">try</span> {<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                <span class="hljs-keyword">synchronized</span> (o1){<br>                    System.out.println(<span class="hljs-string">"线程2"</span>);<br>                }<br>            } <span class="hljs-keyword">catch</span> (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    });<br>    t1.start();<br>    t2.start();<br>}<br></code></pre></td></tr></tbody></table></figure><p>所以，我们在编写程序时，一定要注意，不要出现这种死锁的情况。那么我们如何去检测死锁呢？我们可以利用jstack命令来检测死锁，首先利用jps找到我们的java进程：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">nagocoler@NagodeMacBook-Pro ~ % jps<br>51592 Launcher<br>51690 Jps<br>14955 <br>51693 Main<br>nagocoler@NagodeMacBook-Pro ~ % jstack 51693<br>...<br>Java stack information for the threads listed above:<br>===================================================<br>"Thread-1":<br>at com.test.Main.lambda$main$1(Main.java:46)<br>- waiting to lock &lt;0x000000076ad27fc0&gt; (a java.lang.Object)<br>- locked &lt;0x000000076ad27fd0&gt; (a java.lang.Object)<br>at com.test.Main$$Lambda$2/1867750575.run(Unknown Source)<br>at java.lang.Thread.run(Thread.java:748)<br>"Thread-0":<br>at com.test.Main.lambda$main$0(Main.java:34)<br>- waiting to lock &lt;0x000000076ad27fd0&gt; (a java.lang.Object)<br>- locked &lt;0x000000076ad27fc0&gt; (a java.lang.Object)<br>at com.test.Main$$Lambda$1/396873410.run(Unknown Source)<br>at java.lang.Thread.run(Thread.java:748)<br><br>Found 1 deadlock.<br></code></pre></td></tr></tbody></table></figure><p>jstack自动帮助我们找到了一个死锁，并打印出了相关线程的栈追踪信息，同样的，使用<code>jconsole</code>也可以进行监测。</p><p>因此，前面说不推荐使用 <code>suspend()</code>去挂起线程的原因，是因为<code>suspend()</code>在使线程暂停的同时，并不会去释放任何锁资源。其他线程都无法访问被它占用的锁。直到对应的线程执行<code>resume()</code>方法后，被挂起的线程才能继续，从而其它被阻塞在这个锁的线程才可以继续执行。但是，如果<code>resume()</code>操作出现在<code>suspend()</code>之前执行，那么线程将一直处于挂起状态，同时一直占用锁，这就产生了死锁。</p><h3 id="wait和notify方法"><a href="#wait和notify方法" class="headerlink" title="wait和notify方法"></a>wait和notify方法</h3><p>其实我们之前可能就发现了，Object类还有三个方法我们从来没有使用过，分别是<code>wait()</code>、<code>notify()</code>以及<code>notifyAll()</code>，他们其实是需要配合synchronized来使用的（实际上锁就是依附于对象存在的，每个对象都应该有针对于锁的一些操作，所以说就这样设计了）当然，只有在同步代码块中才能使用这些方法，正常情况下会报错，我们来看看他们的作用是什么：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br>    Object o1 = <span class="hljs-keyword">new</span> Object();<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        <span class="hljs-keyword">synchronized</span> (o1){<br>            <span class="hljs-keyword">try</span> {<br>                System.out.println(<span class="hljs-string">"开始等待"</span>);<br>                o1.wait();     <span class="hljs-comment">//进入等待状态并释放锁</span><br>                System.out.println(<span class="hljs-string">"等待结束！"</span>);<br>            } <span class="hljs-keyword">catch</span> (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    });<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        <span class="hljs-keyword">synchronized</span> (o1){<br>            System.out.println(<span class="hljs-string">"开始唤醒！"</span>);<br>            o1.notify();     <span class="hljs-comment">//唤醒处于等待状态的线程</span><br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) {<br>               System.out.println(i);   <br>            }<br>          <span class="hljs-comment">//唤醒后依然需要等待这里的锁释放之前等待的线程才能继续</span><br>        }<br>    });<br>    t1.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    t2.start();<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以发现，对象的<code>wait()</code>方法会暂时使得此线程进入等待状态，同时会释放当前代码块持有的锁，这时其他线程可以获取到此对象的锁，当其他线程调用对象的<code>notify()</code>方法后，会唤醒刚才变成等待状态的线程（这时并没有立即释放锁）。注意，必须是在持有锁（同步代码块内部）的情况下使用，否则会抛出异常！</p><p>notifyAll其实和notify一样，也是用于唤醒，但是前者是唤醒所有调用<code>wait()</code>后处于等待的线程，而后者是看运气随机选择一个。</p><h3 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h3><p>既然每个线程都有一个自己的工作内存，那么能否只在自己的工作内存中创建变量仅供线程自己使用呢？</p><p><img src="https://img2018.cnblogs.com/blog/1368768/201906/1368768-20190613220434628-1803630402.png" alt="img"></p><p>我们可以使用ThreadLocal类，来创建工作内存中的变量，它将我们的变量值存储在内部（只能存储一个变量），不同的线程访问到ThreadLocal对象时，都只能获取到当前线程所属的变量。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br>    ThreadLocal&lt;String&gt; local = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();  <span class="hljs-comment">//注意这是一个泛型类，存储类型为我们要存放的变量类型</span><br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        local.set(<span class="hljs-string">"lbwnb"</span>);   <span class="hljs-comment">//将变量的值给予ThreadLocal</span><br>        System.out.println(<span class="hljs-string">"变量值已设定！"</span>);<br>        System.out.println(local.get());   <span class="hljs-comment">//尝试获取ThreadLocal中存放的变量</span><br>    });<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        System.out.println(local.get());   <span class="hljs-comment">//尝试获取ThreadLocal中存放的变量</span><br>    });<br>    t1.start();<br>    Thread.sleep(<span class="hljs-number">3000</span>);    <span class="hljs-comment">//间隔三秒</span><br>    t2.start();<br>}<br></code></pre></td></tr></tbody></table></figure><p>上面的例子中，我们开启两个线程分别去访问ThreadLocal对象，我们发现，第一个线程存放的内容，第一个线程可以获取，但是第二个线程无法获取，我们再来看看第一个线程存入后，第二个线程也存放，是否会覆盖第一个线程存放的内容：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br>    ThreadLocal&lt;String&gt; local = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();  <span class="hljs-comment">//注意这是一个泛型类，存储类型为我们要存放的变量类型</span><br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        local.set(<span class="hljs-string">"lbwnb"</span>);   <span class="hljs-comment">//将变量的值给予ThreadLocal</span><br>        System.out.println(<span class="hljs-string">"线程1变量值已设定！"</span>);<br>        <span class="hljs-keyword">try</span> {<br>            Thread.sleep(<span class="hljs-number">2000</span>);    <span class="hljs-comment">//间隔2秒</span><br>        } <span class="hljs-keyword">catch</span> (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        System.out.println(<span class="hljs-string">"线程1读取变量值："</span>);<br>        System.out.println(local.get());   <span class="hljs-comment">//尝试获取ThreadLocal中存放的变量</span><br>    });<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        local.set(<span class="hljs-string">"yyds"</span>);   <span class="hljs-comment">//将变量的值给予ThreadLocal</span><br>        System.out.println(<span class="hljs-string">"线程2变量值已设定！"</span>);<br>    });<br>    t1.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);    <span class="hljs-comment">//间隔1秒</span><br>    t2.start();<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现，即使线程2重新设定了值，也没有影响到线程1存放的值，所以说，不同线程向ThreadLocal存放数据，只会存放在线程自己的工作空间中，而不会直接存放到主内存中，因此各个线程直接存放的内容互不干扰。</p><p>我们发现在线程中创建的子线程，无法获得父线程工作内存中的变量：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    ThreadLocal&lt;String&gt; local = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>       local.set(<span class="hljs-string">"lbwnb"</span>);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>            System.out.println(local.get());<br>        }).start();<br>    });<br>    t.start();<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以使用InheritableThreadLocal来解决：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    ThreadLocal&lt;String&gt; local = <span class="hljs-keyword">new</span> InheritableThreadLocal&lt;&gt;();<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>       local.set(<span class="hljs-string">"lbwnb"</span>);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>            System.out.println(local.get());<br>        }).start();<br>    });<br>    t.start();<br>}<br></code></pre></td></tr></tbody></table></figure><p>在InheritableThreadLocal存放的内容，会自动向子线程传递。</p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>我们有时候会有这样的需求，我希望定时执行任务，比如3秒后执行，其实我们可以通过使用<code>Thread.sleep()</code>来实现：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">new</span> TimerTask(() -&gt; System.out.println(<span class="hljs-string">"我是定时任务！"</span>), <span class="hljs-number">3000</span>).start();   <span class="hljs-comment">//创建并启动此定时任务</span><br>}<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimerTask</span></span>{<br>    Runnable task;<br>    <span class="hljs-keyword">long</span> time;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TimerTask</span><span class="hljs-params">(Runnable runnable, <span class="hljs-keyword">long</span> time)</span></span>{<br>        <span class="hljs-keyword">this</span>.task = runnable;<br>        <span class="hljs-keyword">this</span>.time = time;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>{<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>            <span class="hljs-keyword">try</span> {<br>                Thread.sleep(time);<br>                task.run();   <span class="hljs-comment">//休眠后再运行</span><br>            } <span class="hljs-keyword">catch</span> (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        }).start();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们通过自行封装一个TimerTask类，并在启动时，先休眠3秒钟，再执行我们传入的内容。那么现在我们希望，能否循环执行一个任务呢？比如我希望每隔1秒钟执行一次代码，这样该怎么做呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">new</span> TimerLoopTask(() -&gt; System.out.println(<span class="hljs-string">"我是定时任务！"</span>), <span class="hljs-number">3000</span>).start();   <span class="hljs-comment">//创建并启动此定时任务</span><br>}<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimerLoopTask</span></span>{<br>    Runnable task;<br>    <span class="hljs-keyword">long</span> loopTime;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TimerLoopTask</span><span class="hljs-params">(Runnable runnable, <span class="hljs-keyword">long</span> loopTime)</span></span>{<br>        <span class="hljs-keyword">this</span>.task = runnable;<br>        <span class="hljs-keyword">this</span>.loopTime = loopTime;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>{<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>            <span class="hljs-keyword">try</span> {<br>                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>){   <span class="hljs-comment">//无限循环执行</span><br>                    Thread.sleep(loopTime);<br>                    task.run();   <span class="hljs-comment">//休眠后再运行</span><br>                }<br>            } <span class="hljs-keyword">catch</span> (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        }).start();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>现在我们将单次执行放入到一个无限循环中，这样就能一直执行了，并且按照我们的间隔时间进行。</p><p>但是终究是我们自己实现，可能很多方面还没考虑到，Java也为我们提供了一套自己的框架用于处理定时任务：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Timer timer = <span class="hljs-keyword">new</span> Timer();    <span class="hljs-comment">//创建定时器对象</span><br>    timer.schedule(<span class="hljs-keyword">new</span> TimerTask() {   <span class="hljs-comment">//注意这个是一个抽象类，不是接口，无法使用lambda表达式简化，只能使用匿名内部类</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br>            System.out.println(Thread.currentThread().getName());    <span class="hljs-comment">//打印当前线程名称</span><br>        }<br>    }, <span class="hljs-number">1000</span>);    <span class="hljs-comment">//执行一个延时任务</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以通过创建一个Timer类来让它进行定时任务调度，我们可以通过此对象来创建任意类型的定时任务，包延时任务、循环定时任务等。我们发现，虽然任务执行完成了，但是我们的程序并没有停止，这是因为Timer内存维护了一个任务队列和一个工作线程：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Timer</span> </span>{<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The timer task queue.  This data structure is shared with the timer</span><br><span class="hljs-comment">     * thread.  The timer produces tasks, via its various schedule calls,</span><br><span class="hljs-comment">     * and the timer thread consumes, executing timer tasks as appropriate,</span><br><span class="hljs-comment">     * and removing them from the queue when they're obsolete.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TaskQueue queue = <span class="hljs-keyword">new</span> TaskQueue();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The timer thread.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TimerThread thread = <span class="hljs-keyword">new</span> TimerThread(queue);<br>  <br>...<br>}<br></code></pre></td></tr></tbody></table></figure><p>TimerThread继承自Thread，是一个新创建的线程，在构造时自动启动：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Timer</span><span class="hljs-params">(String name)</span> </span>{<br>    thread.setName(name);<br>    thread.start();<br>}<br></code></pre></td></tr></tbody></table></figure><p>而它的run方法会循环地读取队列中是否还有任务，如果有任务依次执行，没有的话就暂时处于休眠状态：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">try</span> {<br>        mainLoop();<br>    } <span class="hljs-keyword">finally</span> {<br>        <span class="hljs-comment">// Someone killed this Thread, behave as if Timer cancelled</span><br>        <span class="hljs-keyword">synchronized</span>(queue) {<br>            newTasksMayBeScheduled = <span class="hljs-keyword">false</span>;<br>            queue.clear();  <span class="hljs-comment">// Eliminate obsolete references</span><br>        }<br>    }<br>}<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The main timer loop.  (See class comment.)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mainLoop</span><span class="hljs-params">()</span> </span>{<br>  <span class="hljs-keyword">try</span> {<br>       TimerTask task;<br>       <span class="hljs-keyword">boolean</span> taskFired;<br>       <span class="hljs-keyword">synchronized</span>(queue) {<br>         <span class="hljs-comment">// Wait for queue to become non-empty</span><br>          <span class="hljs-keyword">while</span> (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled)   <span class="hljs-comment">//当队列为空同时没有被关闭时，会调用wait()方法暂时处于等待状态，当有新的任务时，会被唤醒。</span><br>                queue.wait();<br>          <span class="hljs-keyword">if</span> (queue.isEmpty())<br>             <span class="hljs-keyword">break</span>;    <span class="hljs-comment">//当被唤醒后都没有任务时，就会结束循环，也就是结束工作线程</span><br>                      ...<br>}<br></code></pre></td></tr></tbody></table></figure><p><code>newTasksMayBeScheduled</code>实际上就是标记当前定时器是否关闭，当它为false时，表示已经不会再有新的任务到来，也就是关闭，我们可以通过调用<code>cancel()</code>方法来关闭它的工作线程：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">synchronized</span>(queue) {<br>        thread.newTasksMayBeScheduled = <span class="hljs-keyword">false</span>;<br>        queue.clear();<br>        queue.notify();  <span class="hljs-comment">//唤醒wait使得工作线程结束</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>因此，我们可以在使用完成后，调用Timer的<code>cancel()</code>方法以正常退出我们的程序：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Timer timer = <span class="hljs-keyword">new</span> Timer();<br>    timer.schedule(<span class="hljs-keyword">new</span> TimerTask() {<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br>            System.out.println(Thread.currentThread().getName());<br>            timer.cancel();  <span class="hljs-comment">//结束</span><br>        }<br>    }, <span class="hljs-number">1000</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>不要把操作系统重的守护进程和守护线程相提并论！</p><p>守护进程在后台运行运行，不需要和用户交互，本质和普通进程类似。而守护线程就不一样了，当其他所有的非守护线程结束之后，守护线程自动结束，也就是说，Java中所有的线程都执行完毕后，守护线程自动结束，因此守护线程不适合进行IO操作，只适合打打杂：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>{<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>){<br>            <span class="hljs-keyword">try</span> {<br>                System.out.println(<span class="hljs-string">"程序正常运行中..."</span>);<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            } <span class="hljs-keyword">catch</span> (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    });<br>    t.setDaemon(<span class="hljs-keyword">true</span>);   <span class="hljs-comment">//设置为守护线程（必须在开始之前，中途是不允许转换的）</span><br>    t.start();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>在守护线程中产生的新线程也是守护的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>{<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        Thread it = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>){<br>                <span class="hljs-keyword">try</span> {<br>                    System.out.println(<span class="hljs-string">"程序正常运行中..."</span>);<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                } <span class="hljs-keyword">catch</span> (InterruptedException e) {<br>                    e.printStackTrace();<br>                }<br>            }<br>        });<br>        it.start();<br>    });<br>    t.setDaemon(<span class="hljs-keyword">true</span>);   <span class="hljs-comment">//设置为守护线程（必须在开始之前，中途是不允许转换的）</span><br>    t.start();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="再谈集合类"><a href="#再谈集合类" class="headerlink" title="再谈集合类"></a>再谈集合类</h3><p>集合类中有一个东西是Java8新增的Spliterator接口，翻译过来就是：可拆分迭代器（Splitable Iterator）和Iterator一样，Spliterator也用于遍历数据源中的元素，但它是为了并行执行而设计的。Java 8已经为集合框架中包含的所有数据结构提供了一个默认的Spliterator实现。在集合跟接口Collection中提供了一个<code>spliterator()</code>方法用于获取可拆分迭代器。</p><p>其实我们之前在讲解集合类的根接口时，就发现有这样一个方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title">parallelStream</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(), <span class="hljs-keyword">true</span>); <span class="hljs-comment">//parallelStream就是利用了可拆分迭代器进行多线程操作</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>并行流，其实就是一个多线程执行的流，它通过默认的ForkJoinPool实现（这里不讲解原理），它可以提高你的多线程任务的速度。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>));<br>    list<br>            .parallelStream()    <span class="hljs-comment">//获得并行流</span><br>            .forEach(i -&gt; System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" -&gt; "</span>+i));<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现，forEach操作的顺序，并不是我们实际List中的顺序，同时每次打印也是不同的线程在执行！我们可以通过调用<code>forEachOrdered()</code>方法来使用单线程维持原本的顺序：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>));<br>    list<br>            .parallelStream()    <span class="hljs-comment">//获得并行流</span><br>            .forEachOrdered(System.out::println);<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们之前还发现，在Arrays数组工具类中，也包含大量的并行方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>};<br>    Arrays.parallelSort(arr);   <span class="hljs-comment">//使用多线程进行并行排序，效率更高</span><br>    System.out.println(Arrays.toString(arr));<br>}<br></code></pre></td></tr></tbody></table></figure><p>更多地使用并行方法，可以更加充分地发挥现代计算机多核心的优势，但是同时需要注意多线程产生的异步问题！</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>};<br>    Arrays.parallelSetAll(arr, i -&gt; {<br>        System.out.println(Thread.currentThread().getName());<br>        <span class="hljs-keyword">return</span> arr[i];<br>    });<br>    System.out.println(Arrays.toString(arr));<br>}<br></code></pre></td></tr></tbody></table></figure><p>因为多线程的加入，我们之前认识的集合类都废掉了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) {<br>            list.add(i);   <span class="hljs-comment">//两个线程同时操作集合类进行插入操作</span><br>        }<br>    }).start();<br>    <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1000</span>; i &lt; <span class="hljs-number">2000</span>; i++) {<br>            list.add(i);<br>        }<br>    }).start();<br>    Thread.sleep(<span class="hljs-number">2000</span>);<br>    System.out.println(list.size());<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现，有些时候运气不好，得到的结果并不是2000个元素，而是：</p><p><img src="https://s2.loli.net/2022/10/04/m1nZfG4wPCOQx8V.png" alt="image-20221004212332535"></p><p>因为之前的集合类，并没有考虑到多线程运行的情况，如果两个线程同时执行，那么有可能两个线程同一时间都执行同一个方法，这种情况下就很容易出问题：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>{<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 当数组容量更好还差一个满的时候，这个时候两个线程同时走到了这里，因为都判断为没满，所以说没有进行扩容，但是实际上两个线程都要插入一个元素进来</span><br>    elementData[size++] = e;   <span class="hljs-comment">//当两个线程同时在这里插入元素，直接导致越界访问</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>当然，在Java早期的时候，还有一些老的集合类，这些集合类都是线程安全的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br>    Vector&lt;Integer&gt; list = <span class="hljs-keyword">new</span> Vector&lt;&gt;();   <span class="hljs-comment">//我们可以使用Vector代替List使用</span><br>  <span class="hljs-comment">//Hashtable&lt;Integer, String&gt;   也可以使用Hashtable来代替Map</span><br>    <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) {<br>            list.add(i);<br>        }<br>    }).start();<br>    <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1000</span>; i &lt; <span class="hljs-number">2000</span>; i++) {<br>            list.add(i);<br>        }<br>    }).start();<br><br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    System.out.println(list.size());<br>}<br></code></pre></td></tr></tbody></table></figure><p>因为这些集合类中的每一个方法都加了锁，所以说不会出现多线程问题，但是这些老的集合类现在已经不再使用了，我们会在JUC篇视频教程中介绍专用于并发编程的集合类。</p><p>通过对Java多线程的了解，我们就具备了利用多线程解决问题的思维！</p><h3 id="实战：生产者与消费者"><a href="#实战：生产者与消费者" class="headerlink" title="实战：生产者与消费者"></a>实战：生产者与消费者</h3><p>所谓的生产者消费者模型，是通过一个容器来解决生产者和消费者的强耦合问题。通俗的讲，就是生产者在不断的生产，消费者也在不断的消费，可是消费者消费的产品是生产者生产的，这就必然存在一个中间容器，我们可以把这个容器想象成是一个货架，当货架空的时候，生产者要生产产品，此时消费者在等待生产者往货架上生产产品，而当货架有货物的时候，消费者可以从货架上拿走商品，生产者此时等待货架出现空位，进而补货，这样不断的循环。</p><p>通过多线程编程，来模拟一个餐厅的2个厨师和3个顾客，假设厨师炒出一个菜的时间为3秒，顾客吃掉菜品的时间为4秒。</p><hr><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p><strong>注意：</strong>本章节涉及到JVM相关底层原理，难度会有一些大。</p><p>反射就是把Java类中的各个成分映射成一个个的Java对象。即在运行状态中，对于任意一个类，都能够知道这个类所有的属性和方法，对于任意一个对象，都能调用它的任意一个方法和属性。这种动态获取信息及动态调用对象方法的功能叫Java的反射机制。</p><p>简而言之，我们可以通过反射机制，获取到类的一些属性，包括类里面有哪些字段，有哪些方法，继承自哪个类，甚至还能获取到泛型！它的权限非常高，慎重使用！</p><h3 id="Java类加载机制"><a href="#Java类加载机制" class="headerlink" title="Java类加载机制"></a>Java类加载机制</h3><p>在学习Java的反射机制之前，我们需要先了解一下类的加载机制，一个类是如何被加载和使用的：</p><p><img src="https://s2.loli.net/2022/10/04/vZ4onhuJWcALHNP.png" alt="image-20221004213335479"></p><p>在Java程序启动时，JVM会将一部分类（class文件）先加载（并不是所有的类都会在一开始加载），通过ClassLoader将类加载，在加载过程中，会将类的信息提取出来（存放在元空间中，JDK1.8之前存放在永久代），同时也会生成一个Class对象存放在内存（堆内存），注意此Class对象只会存在一个，与加载的类唯一对应！</p><p>为了方便各位小伙伴理解，你们就直接理解为默认情况下（仅使用默认类加载器）每个类都有且只有一个唯一的Class对象存放在JVM中，我们无论通过什么方式访问，都是始终是那一个对象。Class对象中包含我们类的一些信息，包括类里面有哪些方法、哪些变量等等。</p><h3 id="Class类详解"><a href="#Class类详解" class="headerlink" title="Class类详解"></a>Class类详解</h3><p>通过前面，我们了解了类的加载，同时会提取一个类的信息生成Class对象存放在内存中，而反射机制其实就是利用这些存放的类信息，来获取类的信息和操作类。那么如何获取到每个类对应的Class对象呢，我们可以通过以下方式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>{<br>    Class&lt;String&gt; clazz = String.class;   <span class="hljs-comment">//使用class关键字，通过类名获取</span><br>    Class&lt;?&gt; clazz2 = Class.forName(<span class="hljs-string">"java.lang.String"</span>);   <span class="hljs-comment">//使用Class类静态方法forName()，通过包名.类名获取，注意返回值是Class&lt;?&gt;</span><br>    Class&lt;?&gt; clazz3 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"cpdd"</span>).getClass();  <span class="hljs-comment">//通过实例对象获取</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>注意Class类也是一个泛型类，只有第一种方法，能够直接获取到对应类型的Class对象，而以下两种方法使用了<code>?</code>通配符作为返回值，但是实际上都和第一个返回的是同一个对象：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;String&gt; clazz = String.class;   <span class="hljs-comment">//使用class关键字，通过类名获取</span><br>Class&lt;?&gt; clazz2 = Class.forName(<span class="hljs-string">"java.lang.String"</span>);   <span class="hljs-comment">//使用Class类静态方法forName()，通过包名.类名获取，注意返回值是Class&lt;?&gt;</span><br>Class&lt;?&gt; clazz3 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"cpdd"</span>).getClass();<br><br>System.out.println(clazz == clazz2);<br>System.out.println(clazz == clazz3);<br></code></pre></td></tr></tbody></table></figure><p>通过比较，验证了我们一开始的结论，在JVM中每个类始终只存在一个Class对象，无论通过什么方法获取，都是一样的。现在我们再来看看这个问题：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Class&lt;?&gt; clazz = <span class="hljs-keyword">int</span>.class;   <span class="hljs-comment">//基本数据类型有Class对象吗？</span><br>    System.out.println(clazz);<br>}<br></code></pre></td></tr></tbody></table></figure><p>迷了，不是每个类才有Class对象吗，基本数据类型又不是类，这也行吗？实际上，基本数据类型也有对应的Class对象（反射操作可能需要用到），而且我们不仅可以通过class关键字获取，其实本质上是定义在对应的包装类中的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The {<span class="hljs-doctag">@code</span> Class} instance representing the primitive type</span><br><span class="hljs-comment"> * {<span class="hljs-doctag">@code</span> int}.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span>   JDK1.1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SuppressWarnings("unchecked")</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Class&lt;Integer&gt;  TYPE = (Class&lt;Integer&gt;) Class.getPrimitiveClass(<span class="hljs-string">"int"</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Return the Virtual Machine's Class object for the named</span><br><span class="hljs-comment"> * primitive type</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getPrimitiveClass(String name);   <span class="hljs-comment">//C++实现，并非Java定义</span><br></code></pre></td></tr></tbody></table></figure><p>每个包装类中（包括Void），都有一个获取原始类型Class方法，注意，getPrimitiveClass获取的是原始类型，并不是包装类型，只是可以使用包装类来表示。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Class&lt;?&gt; clazz = <span class="hljs-keyword">int</span>.class;<br>    System.out.println(Integer.TYPE == <span class="hljs-keyword">int</span>.class);<br>}<br></code></pre></td></tr></tbody></table></figure><p>通过对比，我们发现实际上包装类型都有一个TYPE，其实也就是基本类型的Class，那么包装类的Class和基本类的Class一样吗？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    System.out.println(Integer.TYPE == Integer.class);<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现，包装类型的Class对象并不是基本类型Class对象。数组类型也是一种类型，只是编程不可见，因此我们可以直接获取数组的Class对象：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Class&lt;String[]&gt; clazz = String[].class;<br>    System.out.println(clazz.getName());  <span class="hljs-comment">//获取类名称（得到的是包名+类名的完整名称）</span><br>    System.out.println(clazz.getSimpleName());<br>    System.out.println(clazz.getTypeName());<br>    System.out.println(clazz.getClassLoader());   <span class="hljs-comment">//获取它的类加载器</span><br>    System.out.println(clazz.cast(<span class="hljs-keyword">new</span> Integer(<span class="hljs-string">"10"</span>)));   <span class="hljs-comment">//强制类型转换</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>下节课，我们将开始对Class对象的使用进行讲解。</p><h3 id="Class对象与多态"><a href="#Class对象与多态" class="headerlink" title="Class对象与多态"></a>Class对象与多态</h3><p>正常情况下，我们使用instanceof进行类型比较：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    String str = <span class="hljs-string">""</span>;<br>    System.out.println(str <span class="hljs-keyword">instanceof</span> String);<br>}<br></code></pre></td></tr></tbody></table></figure><p>它可以判断一个对象是否为此接口或是类的实现或是子类，而现在我们有了更多的方式去判断类型：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    String str = <span class="hljs-string">""</span>;<br>    System.out.println(str.getClass() == String.class);   <span class="hljs-comment">//直接判断是否为这个类型</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>如果需要判断是否为子类或是接口/抽象类的实现，我们可以使用<code>asSubClass()</code>方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Integer i = <span class="hljs-number">10</span>;<br>    i.getClass().asSubclass(Number.class);   <span class="hljs-comment">//当Integer不是Number的子类时，会产生异常</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>通过<code>getSuperclass()</code>方法，我们可以获取到父类的Class对象：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Integer i = <span class="hljs-number">10</span>;<br>    System.out.println(i.getClass().getSuperclass());<br>}<br></code></pre></td></tr></tbody></table></figure><p>也可以通过<code>getGenericSuperclass()</code>获取父类的原始类型的Type：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Integer i = <span class="hljs-number">10</span>;<br>    Type type = i.getClass().getGenericSuperclass();<br>    System.out.println(type);<br>    System.out.println(type <span class="hljs-keyword">instanceof</span> Class);<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现Type实际上是Class类的父接口，但是获取到的Type的实现并不一定是Class。</p><p>同理，我们也可以像上面这样获取父接口：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Integer i = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">for</span> (Class&lt;?&gt; anInterface : i.getClass().getInterfaces()) {<br>        System.out.println(anInterface.getName());<br>    }<br>  <br>  <span class="hljs-keyword">for</span> (Type genericInterface : i.getClass().getGenericInterfaces()) {<br>        System.out.println(genericInterface.getTypeName());<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>是不是感觉反射功能很强大？几乎类的所有信息都可以通过反射获得。</p><h3 id="创建类对象"><a href="#创建类对象" class="headerlink" title="创建类对象"></a>创建类对象</h3><p>既然我们拿到了类的定义，那么是否可以通过Class对象来创建对象、调用方法、修改变量呢？当然是可以的，那我们首先来探讨一下如何创建一个类的对象：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException </span>{<br>    Class&lt;Student&gt; clazz = Student.class;<br>    Student student = clazz.newInstance();<br>    student.test();<br>}<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>{<br>        System.out.println(<span class="hljs-string">"萨日朗"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>通过使用<code>newInstance()</code>方法来创建对应类型的实例，返回泛型T，注意它会抛出InstantiationException和IllegalAccessException异常，那么什么情况下会出现异常呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException </span>{<br>    Class&lt;Student&gt; clazz = Student.class;<br>    Student student = clazz.newInstance();<br>    student.test();<br>}<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String text)</span></span>{<br>        <br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>{<br>        System.out.println(<span class="hljs-string">"萨日朗"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>当类默认的构造方法被带参构造覆盖时，会出现InstantiationException异常，因为<code>newInstance()</code>只适用于默认无参构造。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException </span>{<br>    Class&lt;Student&gt; clazz = Student.class;<br>    Student student = clazz.newInstance();<br>    student.test();<br>}<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>{}<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>{<br>        System.out.println(<span class="hljs-string">"萨日朗"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>当默认无参构造的权限不是<code>public</code>时，会出现IllegalAccessException异常，表示我们无权去调用默认构造方法。在JDK9之后，不再推荐使用<code>newInstance()</code>方法了，而是使用我们接下来要介绍到的，通过获取构造器，来实例化对象：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException </span>{<br>    Class&lt;Student&gt; clazz = Student.class;<br>    Student student = clazz.getConstructor(String.class).newInstance(<span class="hljs-string">"what's up"</span>);<br>    student.test();<br>}<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String str)</span></span>{}<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>{<br>        System.out.println(<span class="hljs-string">"萨日朗"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>通过获取类的构造方法（构造器）来创建对象实例，会更加合理，我们可以使用<code>getConstructor()</code>方法来获取类的构造方法，同时我们需要向其中填入参数，也就是构造方法需要的类型，当然我们这里只演示了。那么，当访问权限不是public的时候呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException </span>{<br>    Class&lt;Student&gt; clazz = Student.class;<br>    Student student = clazz.getConstructor(String.class).newInstance(<span class="hljs-string">"what's up"</span>);<br>    student.test();<br>}<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Student</span><span class="hljs-params">(String str)</span></span>{}<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>{<br>        System.out.println(<span class="hljs-string">"萨日朗"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现，当访问权限不足时，会无法找到此构造方法，那么如何找到非public的构造方法呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;Student&gt; clazz = Student.class;<br>Constructor&lt;Student&gt; constructor = clazz.getDeclaredConstructor(String.class);<br>constructor.setAccessible(<span class="hljs-keyword">true</span>);   <span class="hljs-comment">//修改访问权限</span><br>Student student = constructor.newInstance(<span class="hljs-string">"what's up"</span>);<br>student.test();<br></code></pre></td></tr></tbody></table></figure><p>使用<code>getDeclaredConstructor()</code>方法可以找到类中的非public构造方法，但是在使用之前，我们需要先修改访问权限，在修改访问权限之后，就可以使用非public方法了（这意味着，反射可以无视权限修饰符访问类的内容）</p><h3 id="调用类方法"><a href="#调用类方法" class="headerlink" title="调用类方法"></a>调用类方法</h3><p>我们可以通过反射来调用类的方法（本质上还是类的实例进行调用）只是利用反射机制实现了方法的调用，我们在包下创建一个新的类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String str)</span></span>{<br>        System.out.println(<span class="hljs-string">"萨日朗"</span>+str);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>这次我们通过<code>forName(String)</code>来找到这个类并创建一个新的对象：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ReflectiveOperationException </span>{<br>    Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">"com.test.Student"</span>);<br>    Object instance = clazz.newInstance();   <span class="hljs-comment">//创建出学生对象</span><br>    Method method = clazz.getMethod(<span class="hljs-string">"test"</span>, String.class);   <span class="hljs-comment">//通过方法名和形参类型获取类中的方法</span><br>    <br>    method.invoke(instance, <span class="hljs-string">"what's up"</span>);   <span class="hljs-comment">//通过Method对象的invoke方法来调用方法</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>通过调用<code>getMethod()</code>方法，我们可以获取到类中所有声明为public的方法，得到一个Method对象，我们可以通过Method对象的<code>invoke()</code>方法（返回值就是方法的返回值，因为这里是void，返回值为null）来调用已经获取到的方法，注意传参。</p><p>我们发现，利用反射之后，在一个对象从构造到方法调用，没有任何一处需要引用到对象的实际类型，我们也没有导入Student类，整个过程都是反射在代替进行操作，使得整个过程被模糊了，过多的使用反射，会极大地降低后期维护性。</p><p>同构造方法一样，当出现非public方法时，我们可以通过反射来无视权限修饰符，获取非public方法并调用，现在我们将<code>test()</code>方法的权限修饰符改为private：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ReflectiveOperationException </span>{<br>    Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">"com.test.Student"</span>);<br>    Object instance = clazz.newInstance();   <span class="hljs-comment">//创建出学生对象</span><br>    Method method = clazz.getDeclaredMethod(<span class="hljs-string">"test"</span>, String.class);   <span class="hljs-comment">//通过方法名和形参类型获取类中的方法</span><br>    method.setAccessible(<span class="hljs-keyword">true</span>);<br><br>    method.invoke(instance, <span class="hljs-string">"what's up"</span>);   <span class="hljs-comment">//通过Method对象的invoke方法来调用方法</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>Method和Constructor都和Class一样，他们存储了方法的信息，包括方法的形式参数列表，返回值，方法的名称等内容，我们可以直接通过Method对象来获取这些信息：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ReflectiveOperationException </span>{<br>    Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">"com.test.Student"</span>);<br>    Method method = clazz.getDeclaredMethod(<span class="hljs-string">"test"</span>, String.class);   <span class="hljs-comment">//通过方法名和形参类型获取类中的方法</span><br>    <br>    System.out.println(method.getName());   <span class="hljs-comment">//获取方法名称</span><br>    System.out.println(method.getReturnType());   <span class="hljs-comment">//获取返回值类型</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>当方法的参数为可变参数时，我们该如何获取方法呢？实际上，我们在之前就已经提到过，可变参数实际上就是一个数组，因此我们可以直接使用数组的class对象表示：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Method method = clazz.getDeclaredMethod(<span class="hljs-string">"test"</span>, String[].class);<br></code></pre></td></tr></tbody></table></figure><p>反射非常强大，尤其是我们提到的越权访问，但是请一定谨慎使用，别人将某个方法设置为private一定有他的理由，如果实在是需要使用别人定义为private的方法，就必须确保这样做是安全的，在没有了解别人代码的整个过程就强行越权访问，可能会出现无法预知的错误。</p><h3 id="修改类的属性"><a href="#修改类的属性" class="headerlink" title="修改类的属性"></a>修改类的属性</h3><p>我们还可以通过反射访问一个类中定义的成员字段也可以修改一个类的对象中的成员字段值，通过<code>getField()</code>方法来获取一个类定义的指定字段：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ReflectiveOperationException </span>{<br>    Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">"com.test.Student"</span>);<br>    Object instance = clazz.newInstance();<br><br>    Field field = clazz.getField(<span class="hljs-string">"i"</span>);   <span class="hljs-comment">//获取类的成员字段i</span><br>    field.set(instance, <span class="hljs-number">100</span>);   <span class="hljs-comment">//将类实例instance的成员字段i设置为100</span><br><br>    Method method = clazz.getMethod(<span class="hljs-string">"test"</span>);<br>    method.invoke(instance);<br>}<br></code></pre></td></tr></tbody></table></figure><p>在得到Field之后，我们就可以直接通过<code>set()</code>方法为某个对象，设定此属性的值，比如上面，我们就为instance对象设定值为100，当访问private字段时，同样可以按照上面的操作进行越权访问：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ReflectiveOperationException </span>{<br>    Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">"com.test.Student"</span>);<br>    Object instance = clazz.newInstance();<br><br>    Field field = clazz.getDeclaredField(<span class="hljs-string">"i"</span>);   <span class="hljs-comment">//获取类的成员字段i</span><br>    field.setAccessible(<span class="hljs-keyword">true</span>);<br>    field.set(instance, <span class="hljs-number">100</span>);   <span class="hljs-comment">//将类实例instance的成员字段i设置为100</span><br><br>    Method method = clazz.getMethod(<span class="hljs-string">"test"</span>);<br>    method.invoke(instance);<br>}<br></code></pre></td></tr></tbody></table></figure><p>现在我们已经知道，反射几乎可以把一个类的老底都给扒出来，任何属性，任何内容，都可以被反射修改，无论权限修饰符是什么，那么，如果我的字段被标记为final呢？现在在字段<code>i</code>前面添加<code>final</code>关键字，我们再来看看效果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br></code></pre></td></tr></tbody></table></figure><p>这时，当字段为final时，就修改失败了！当然，通过反射可以直接将final修饰符直接去除，去除后，就可以随意修改内容了，我们来尝试修改Integer的value值：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ReflectiveOperationException </span>{<br>    Integer i = <span class="hljs-number">10</span>;<br><br>    Field field = Integer.class.getDeclaredField(<span class="hljs-string">"value"</span>);<br><br>    Field modifiersField = Field.class.getDeclaredField(<span class="hljs-string">"modifiers"</span>);  <span class="hljs-comment">//这里要获取Field类的modifiers字段进行修改</span><br>    modifiersField.setAccessible(<span class="hljs-keyword">true</span>);<br>    modifiersField.setInt(field,field.getModifiers()&amp;~Modifier.FINAL);  <span class="hljs-comment">//去除final标记</span><br><br>    field.setAccessible(<span class="hljs-keyword">true</span>);<br>    field.set(i, <span class="hljs-number">100</span>);   <span class="hljs-comment">//强行设置值</span><br><br>    System.out.println(i);<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以发现，反射非常暴力，就连被定义为final字段的值都能强行修改，几乎能够无视一切阻拦。我们来试试看修改一些其他的类型：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ReflectiveOperationException </span>{<br>    List&lt;String&gt; i = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    Field field = ArrayList.class.getDeclaredField(<span class="hljs-string">"size"</span>);<br>    field.setAccessible(<span class="hljs-keyword">true</span>);<br>    field.set(i, <span class="hljs-number">10</span>);<br><br>    i.add(<span class="hljs-string">"测试"</span>);   <span class="hljs-comment">//只添加一个元素</span><br>    System.out.println(i.size());  <span class="hljs-comment">//大小直接变成11</span><br>    i.remove(<span class="hljs-number">10</span>);   <span class="hljs-comment">//瞎移除都不带报错的，淦</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>实际上，整个ArrayList体系由于我们的反射操作，导致被破坏，因此它已经无法正常工作了！</p><p>再次强调，在进行反射操作时，必须注意是否安全，虽然拥有了创世主的能力，但是我们不能滥用，我们只能把它当做一个不得已才去使用的工具！</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>我们接着来介绍一下类加载器，实际上类加载器就是用于加载一个类的，但是类加载器并不是只有一个。</p><p><strong>思考：</strong>既然说Class对象和加载的类唯一对应，那如果我们手动创建一个与JDK包名一样，同时类名也保持一致，JVM会加载这个类吗？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span> </span>{    <span class="hljs-comment">//JDK提供的String类也是</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        System.out.println(<span class="hljs-string">"我姓🐴，我叫🐴nb"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现，会出现以下报错：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br></code></pre></td></tr></tbody></table></figure><p>但是我们明明在自己写的String类中定义了main方法啊，为什么会找不到此方法呢？实际上这是ClassLoader的<code>双亲委派机制</code>在保护Java程序的正常运行：</p><p><img src="https://s2.loli.net/2022/10/04/5p6jdXDA8VtCEfN.png" alt="img"></p><p>实际上类最开始是由BootstarpClassLoader进行加载，BootstarpClassLoader用于加载JDK提供的类，而我们自己编写的类实际上是AppClassLoader加载的，只有BootstarpClassLoader都没有加载的类，才会让AppClassLoader来加载，因此我们自己编写的同名包同名类不会被加载，而实际要去启动的是真正的String类，也就自然找不到<code>main</code>方法了。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        System.out.println(Main.class.getClassLoader());   <span class="hljs-comment">//查看当前类的类加载器</span><br>        System.out.println(Main.class.getClassLoader().getParent());  <span class="hljs-comment">//父加载器</span><br>        System.out.println(Main.class.getClassLoader().getParent().getParent());  <span class="hljs-comment">//爷爷加载器</span><br>        System.out.println(String.class.getClassLoader());   <span class="hljs-comment">//String类的加载器</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>由于BootstarpClassLoader是C++编写的，我们在Java中是获取不到的。</p><p>既然通过ClassLoader就可以加载类，那么我们可以自己手动将class文件加载到JVM中吗？先写好我们定义的类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{<br>    <span class="hljs-keyword">public</span> String text;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String str)</span></span>{<br>        System.out.println(text+<span class="hljs-string">" &gt; 我是测试方法！"</span>+str);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>通过javac命令，手动编译一个.class文件：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">nagocoler<span class="hljs-meta">@NagodeMacBook</span>-Pro HelloWorld % javac src/main/java/com/test/Test.java<br></code></pre></td></tr></tbody></table></figure><p>编译后，得到一个class文件，我们把它放到根目录下，然后编写一个我们自己的ClassLoader，因为普通的ClassLoader无法加载二进制文件，因此我们编写一个自定义的来让它支持：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义一个自己的ClassLoader</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span></span>{<br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; defineClass(String name, <span class="hljs-keyword">byte</span>[] b){<br>        <span class="hljs-keyword">return</span> defineClass(name, b, <span class="hljs-number">0</span>, b.length);   <span class="hljs-comment">//调用protected方法，支持载入外部class文件</span><br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>{<br>    MyClassLoader classLoader = <span class="hljs-keyword">new</span> MyClassLoader();<br>    FileInputStream stream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"Test.class"</span>);<br>    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[stream.available()];<br>    stream.read(bytes);<br>    Class&lt;?&gt; clazz = classLoader.defineClass(<span class="hljs-string">"com.test.Test"</span>, bytes);   <span class="hljs-comment">//类名必须和我们定义的保持一致</span><br>    System.out.println(clazz.getName());   <span class="hljs-comment">//成功加载外部class文件</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>现在，我们就将此class文件读取并解析为Class了，现在我们就可以对此类进行操作了（注意，我们无法在代码中直接使用此类型，因为它是我们直接加载的），我们来试试看创建一个此类的对象并调用其方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> {<br>    Object obj = clazz.newInstance();<br>    Method method = clazz.getMethod(<span class="hljs-string">"test"</span>, String.class);   <span class="hljs-comment">//获取我们定义的test(String str)方法</span><br>    method.invoke(obj, <span class="hljs-string">"哥们这瓜多少钱一斤？"</span>);<br>}<span class="hljs-keyword">catch</span> (Exception e){<br>    e.printStackTrace();<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们来试试看修改成员字段之后，再来调用此方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> {<br>    Object obj = clazz.newInstance();<br>    Field field = clazz.getField(<span class="hljs-string">"text"</span>);   <span class="hljs-comment">//获取成员变量 String text;</span><br>    field.set(obj, <span class="hljs-string">"华强"</span>);<br>    Method method = clazz.getMethod(<span class="hljs-string">"test"</span>, String.class);   <span class="hljs-comment">//获取我们定义的test(String str)方法</span><br>    method.invoke(obj, <span class="hljs-string">"哥们这瓜多少钱一斤？"</span>);<br>}<span class="hljs-keyword">catch</span> (Exception e){<br>    e.printStackTrace();<br>}<br></code></pre></td></tr></tbody></table></figure><p>通过这种方式，我们就可以实现外部加载甚至是网络加载一个类，只需要把类文件传递即可，这样就无需再将代码写在本地，而是动态进行传递，不仅可以一定程度上防止源代码被反编译（只是一定程度上，想破解你代码有的是方法），而且在更多情况下，我们还可以对byte[]进行加密，保证在传输过程中的安全性。</p><hr><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p><strong>注意：</strong>注解跟我们之前讲解的注释完全不是一个概念，不要搞混了。</p><p>其实我们在之前就接触到注解了，比如<code>@Override</code>表示重写父类方法（当然不加效果也是一样的，此注解在编译时会被自动丢弃）注解本质上也是一个类，只不过它的用法比较特殊。</p><p>注解可以被标注在任意地方，包括方法上、类名上、参数上、成员属性上、注解定义上等，就像注释一样，它相当于我们对某样东西的一个标记。而与注释不同的是，注解可以通过反射在运行时获取，注解也可以选择是否保留到运行时。</p><h3 id="预设注解"><a href="#预设注解" class="headerlink" title="预设注解"></a>预设注解</h3><p>JDK预设了以下注解，作用于代码：</p><ul><li><a href="">@Override </a>- 检查（仅仅是检查，不保留到运行时）该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。 </li><li><a href="">@Deprecated </a>- 标记过时方法。如果使用该方法，会报编译警告。 </li><li><a href="">@SuppressWarnings </a>- 指示编译器去忽略注解中声明的警告（仅仅编译器阶段，不保留到运行时） </li><li><a href="">@FunctionalInterface </a>- Java 8 开始支持，标识一个匿名函数或函数式接口。 </li><li><a href="">@SafeVarargs </a>- Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。 </li></ul><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解是作用于注解上的注解，用于我们编写自定义的注解：</p><ul><li><a href="">@Retention </a>- 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。 </li><li><a href="">@Documented </a>- 标记这些注解是否包含在用户文档中。 </li><li><a href="">@Target </a>- 标记这个注解应该是哪种 Java 成员。 </li><li><a href="">@Inherited </a>- 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类) </li><li><a href="">@Repeatable </a>- Java 8 开始支持，标识某注解可以在同一个声明上使用多次。 </li></ul><p>看了这么多预设的注解，你们肯定眼花缭乱了，那我们来看看<code>@Override</code>是如何定义的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Override {<br>}<br></code></pre></td></tr></tbody></table></figure><p>该注解由<code>@Target</code>限定为只能作用于方法上，ElementType是一个枚举类型，用于表示此枚举的作用域，一个注解可以有很多个作用域。<code>@Retention</code>表示此注解的保留策略，包括三种策略，在上述中有写到，而这里定义为只在代码中。一般情况下，自定义的注解需要定义1个<code>@Retention</code>和1-n个<code>@Target</code>。</p><p>既然了解了元注解的使用和注解的定义方式，我们就来尝试定义一个自己的注解：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test {<br>}<br></code></pre></td></tr></tbody></table></figure><p>这里我们定义一个Test注解，并将其保留到运行时，同时此注解可以作用于方法或是类上：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>这样，一个最简单的注解就被我们创建了。</p><h3 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h3><p>我们还可以在注解中定义一些属性，注解的属性也叫做成员变量，注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target({ElementType.METHOD, ElementType.TYPE})</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test {<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>默认只有一个属性时，我们可以将其名字设定为value，否则，我们需要在使用时手动指定注解的属性名称，使用value则无需填入：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target({ElementType.METHOD, ElementType.TYPE})</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test {<br>    <span class="hljs-function">String <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{<br>    <span class="hljs-meta">@Test(test = "")</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们也可以使用default关键字来为这些属性指定默认值：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target({ElementType.METHOD, ElementType.TYPE})</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test {<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> "都看到这里了，给个三连吧！"</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>当属性存在默认值时，使用注解的时候可以不用传入属性值。当属性为数组时呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target({ElementType.METHOD, ElementType.TYPE})</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test {<br>    String[] value();<br>}<br></code></pre></td></tr></tbody></table></figure><p>当属性为数组，我们在使用注解传参时，如果数组里面只有一个内容，我们可以直接传入一个值，而不是创建一个数组：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test("关注点了吗")</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br><br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{<br>    <span class="hljs-meta">@Test({"value1", "value2"})</span>   <span class="hljs-comment">//多个值时就使用花括号括起来</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="反射获取注解"><a href="#反射获取注解" class="headerlink" title="反射获取注解"></a>反射获取注解</h3><p>既然我们的注解可以保留到运行时，那么我们来看看，如何获取我们编写的注解，我们需要用到反射机制：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Class&lt;Student&gt; clazz = Student.class;<br>    <span class="hljs-keyword">for</span> (Annotation annotation : clazz.getAnnotations()) {<br>        System.out.println(annotation.annotationType());   <span class="hljs-comment">//获取类型</span><br>        System.out.println(annotation <span class="hljs-keyword">instanceof</span> Test);   <span class="hljs-comment">//直接判断是否为Test</span><br>        Test test = (Test) annotation;<br>        System.out.println(test.value());   <span class="hljs-comment">//获取我们在注解中写入的内容</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>通过反射机制，我们可以快速获取到我们标记的注解，同时还能获取到注解中填入的值，那么我们来看看，方法上的标记是不是也可以通过这种方式获取注解：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException </span>{<br>    Class&lt;Student&gt; clazz = Student.class;<br>    <span class="hljs-keyword">for</span> (Annotation annotation : clazz.getMethod(<span class="hljs-string">"test"</span>).getAnnotations()) {<br>        System.out.println(annotation.annotationType());   <span class="hljs-comment">//获取类型</span><br>        System.out.println(annotation <span class="hljs-keyword">instanceof</span> Test);   <span class="hljs-comment">//直接判断是否为Test</span><br>        Test test = (Test) annotation;<br>        System.out.println(test.value());   <span class="hljs-comment">//获取我们在注解中写入的内容</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>无论是方法、类、还是字段，都可以使用<code>getAnnotations()</code>方法（还有几个同名的）来快速获取我们标记的注解。</p><p>所以说呢，这玩意学来有啥用？丝毫get不到这玩意的用处。其实不是，现阶段作为初学者，还体会不到注解带来的快乐，在接触到Spring和SpringBoot等大型框架后，相信各位就能感受到注解带来的魅力了。</p><hr><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>Java的学习对你来说可能是枯燥的，可能是漫长的，也有可能是有趣的，无论如何，你终于是完成了全部内容的学习，可喜可贺。</p><p>实际上很多人一开始跟着你们一起在进行学习，但是他们因为各种原因，最后还是没有走完这条路。坚持不一定会成功，但坚持到别人坚持不下去，那么你至少已经成功了一半了，坚持到最后的人运气往往都不会太差。</p><p>希望各位小伙伴能够在之后的学习中砥砺前行！</p>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/10/04/aRsN9WoS7BcC3uY.png&quot; alt=&quot;image-20221004132312588&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;多线程与反射&quot;&gt;&lt;a href=&quot;#多线程与反射&quot; class=&quot;headerlink&quot; title=&quot;多线程与反射&quot;&gt;&lt;/a&gt;多线程与反射&lt;/h1&gt;&lt;p&gt;前面我们已经讲解了JavaSE的大部分核心内容，最后一章，我们还将继续学习JavaSE中提供的各种高级特性。这些高级特性对于我们之后的学习，会有着举足轻重的作用。&lt;/p&gt;
&lt;h2 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#多线程&quot; class=&quot;headerlink&quot; title=&quot;多线程&quot;&gt;&lt;/a&gt;多线程&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;本章节会涉及到 &lt;strong&gt;操作系统&lt;/strong&gt; 相关知识。&lt;/p&gt;
&lt;p&gt;在了解多线程之前，让我们回顾一下&lt;code&gt;操作系统&lt;/code&gt;中提到的进程概念：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/10/04/GhrSTfNRsc2jFZM.jpg&quot; alt=&quot;b040eadb-8aa1-4b2a-b587-2c0a6b4efa0b&quot;&gt;&lt;/p&gt;
&lt;p&gt;进程是程序执行的实体，每一个进程都是一个应用程序（比如我们运行QQ、浏览器、LOL、网易云音乐等软件），都有自己的内存空间，CPU一个核心同时只能处理一件事情，当出现多个进程需要同时运行时，CPU一般通过&lt;code&gt;时间片轮转调度&lt;/code&gt;算法，来实现多个进程的同时运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/10/04/hUkGafu7vztB4qR.png&quot; alt=&quot;image-20221004132729868&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://xiaofanshutu.github.io/posts/0.html"/>
    <id>https://xiaofanshutu.github.io/posts/0.html</id>
    <published>2025-09-07T23:26:13.331Z</published>
    <updated>2025-09-07T23:28:25.711Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://s2.loli.net/2022/09/16/ymtrNQlPu9Loh27.png" alt="image-20220916174714019"></p><h1 id="面向过程篇"><a href="#面向过程篇" class="headerlink" title="面向过程篇"></a>面向过程篇</h1><p>前面我们已经认识了Java语言的相关特性，并且已经成功配置好了开发环境，从这节课开始，我们就可以正式进入到Java语言的学习当中了。Java语言是一门面向对象的语言，但是在面向对象之前，我们还得先学会如何面向过程编程。</p><h2 id="Java程序基础"><a href="#Java程序基础" class="headerlink" title="Java程序基础"></a>Java程序基础</h2><p>首先我们还是从最基本的Java程序基础开始讲解。</p><h3 id="程序代码基本结构"><a href="#程序代码基本结构" class="headerlink" title="程序代码基本结构"></a>程序代码基本结构</h3><p>还记得我们之前使用的示例代码吗？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        System.out.println(<span class="hljs-string">"Hello World!"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>这段代码要实现的功能很简单，就是将 Hello World 输出到控制台就行。</p><p>由于我们还没有学习到类的相关性质，所以在第二章之前，各位小伙伴直接记住固定模式即可，首先我们创建的源文件名称需要为<code>Main.java</code>然后编写的代码第一行：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{<br>  <br>}<br></code></pre></td></tr></tbody></table></figure><p>注意需要区分大小写，Java语言严格区分大小写，如果我们没有按照规则来编写，那么就会出现红色波浪线报错：</p><p><img src="https://s2.loli.net/2022/09/16/5mpBD1JyjCMGgnO.png" alt="image-20220916213529426"></p><p>只要源代码中存在报错的地方，就无法正常完成编译得到二进制文件，会提示构建失败：</p><p><img src="https://s2.loli.net/2022/09/16/x5PjR9OAGMCQtS6.png" alt="image-20220916213641899"></p><p>注意最后还有一个花括号，并且此花括号是成对出现的，一一对应。</p><p>所以说各位小伙伴在编写代码时一定要注意大小写。然后第二行，准确的说是最外层花括号内部就是：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <br>}<br></code></pre></td></tr></tbody></table></figure><p>这是我们整个Java程序的入口点，我们称为主方法（如果你学习过C肯定能够联想到主函数，只不过Java中不叫函数，叫方法）最后也会有一个花括号成对出现，而在主方法的花括号中编写的代码，就是按照从上往下的顺序依次执行的。</p><p>比如我们之前编写的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">"Hello World!"</span>);<br></code></pre></td></tr></tbody></table></figure><p>这段代码的意思就是将双引号括起来的内容（字符串，我们会在后面进行讲解）输出（打印）到控制台上，可以看到最后还加上了一个<code>;</code>符号，表示这一句代码结束。我们每一段代码结束时都需要加上一个分号表示这一句的结束，就像我们写作文一样。</p><p>比如下面的代码，我们就可以实现先打印Hello World!，然后再打印YYDS!到控制台。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        System.out.println(<span class="hljs-string">"Hello World!"</span>);<br>        System.out.println(<span class="hljs-string">"YYDS!"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>效果如下：</p><p><img src="https://s2.loli.net/2022/09/16/GLZdxf6B3Agu98N.png" alt="image-20220916214557378"></p><p>如果两段代码没有加上分号分割，那么编译器会认为这两段代码是同一句代码中的，即使出现换行或者是空格：</p><p><img src="https://s2.loli.net/2022/09/16/ErQnpo2DVw7mJks.png" alt="image-20220916214736541"></p><p>这里IDEA很聪明，会提醒我们这里少加了分号，所以说这个IDEA能够在初期尽可能地帮助新手。</p><p>再比如下面的代码：</p><p><img src="https://s2.loli.net/2022/09/16/sDcuan8MJ92l3P1.png" alt="image-20220916214822072"></p><p><img src="https://s2.loli.net/2022/09/16/i1VFk6RUtp8XfMr.png" alt="image-20220916214929651"></p><p>这里我们尝试在中途换行和添加空格，因为没有添加分号，所以说编译器依然会认为是一行代码，因此编译不会出现错误，能够正常通过。当然，为了代码写得工整和规范，我们一般不会随意进行换行编写或者是添加没必要的空格。</p><p>同样的，如果添加了分号，即使在同一行，也会被认为是两句代码：</p><p><img src="https://s2.loli.net/2022/09/16/XopC59keJiMWjmd.png" alt="image-20220916221833145"></p><p>如果在同一行就是从左往右的顺序，得到的结果跟上面是一样的。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>我们在编写代码时，可能有些时候需要标记一下这段代码表示什么意思：</p><p><img src="https://s2.loli.net/2022/09/16/8Mzo36BbYVuRgm9.png" alt="image-20220916221711430"></p><p>但是如果直接写上文字的话，会导致编译不通过，因为这段文字也会被认为是程序的一部分。</p><p>这种情况，我们就可以告诉编译器，这段文字是我们做的笔记，并不是程序的一部分，那么要怎么告诉编译器这不是代码呢？很简单，我们只需要在前面加上双斜杠就可以了：</p><p><img src="https://s2.loli.net/2022/09/16/N4rZHt6onGfXuhg.png" alt="image-20220916222035778"></p><p>添加双斜杠之后（自动变成了灰色），后续的文本内容只要没有发生换行，那么都会被认为是一段注释，并不属于程序，在编译时会被直接忽略，之后这段注释也不会存在于程序中。但是一旦发生换行那就不行了：</p><p><img src="https://s2.loli.net/2022/09/16/GiUMCmXewanWJSN.png" alt="image-20220916222225047"></p><p>那要是此时注释很多，一行写不完，我们想要编写很多行的注释呢？我们可以使用多行注释标记：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            这里面的内容</span><br><span class="hljs-comment">            无论多少行</span><br><span class="hljs-comment">            都可以</span><br><span class="hljs-comment">         */</span><br>        System.out.println(<span class="hljs-string">"Hello World!"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>多行可以使用<code>/*</code>和<code>*/</code>的组合来囊括需要编写的注释内容。</p><p>当然还有一种方式就是使用<code>/**</code>来进行更加详细的文档注释：</p><p><img src="https://s2.loli.net/2022/09/16/sFhkS2ezONjZvMK.png" alt="image-20220916222636943"></p><p>这种注释可以用来自动生成文档，当我们鼠标移动到Main上时，会显示相关的信息，我们可以自由添加一些特殊的注释，比如作者、时间等信息，也可以是普通的文字信息。</p><h3 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h3><p>我们的程序不可能永远都只进行上面那样的简单打印操作，有些时候可能需要计算某些数据，此时我们就需要用到变量了。</p><p>那么，什么是变量呢？我们在数学中其实已经学习过变量了：</p><blockquote><p>变量，指值可以变的量。变量以非<a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%97/6204?fromModule=lemma_inlink">数字</a>的符号来表达，一般用拉丁字母。变量的用处在于能一般化描述指令的方式。结果只能使用真实的值，指令只能应用于某些情况下。变量能够作为某特定种类的值中任何一个的保留器。</p></blockquote><p>比如一个公式 $x^2 + 6 = 22$ 此时<code>x</code>就是一个变量，变量往往代表着某个值，比如这里的<code>x</code>就代表的是4这个值。在Java中，我们也可以让变量去代表一个具体的值，并且变量的值是可以发生变化的。</p><p>要声明一个变量，我们需要使用以下格式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[数据类型] [变量名称];<br></code></pre></td></tr></tbody></table></figure><p>这里的数据类型我们会在下节课开始逐步讲解，比如整数就是<code>int</code>类型，不同类型的变量可以存储不同的类型的值。后面的变量名称顾名思义，就像<code>x</code>一样，这个名称我们可以随便起一个，但是注意要满足以下要求：</p><ul><li>标识符可以由大小写字母、数字、下划线(_)和美元符号($)组成，但是不能以数字开头。</li><li>变量不能重复定义，大小写敏感，比如A和a就是两个不同的变量。</li><li>不能有空格、@、#、+、-、/ 等符号。</li><li>应该使用有意义的名称，达到见名知意的目的（一般我们采用英文单词），最好以小写字母开头。</li><li>不可以是 true 和 false。</li><li>不能与Java语言的关键字或是基本数据类型重名，关键字列表如下：</li></ul><p>![image-20220916224014438](/Users/nagocoler/Library/Application Support/typora-user-images/image-20220916224014438.png)</p><p>当然各位小伙伴没必要刻意去进行记忆，我们会在学习的过程中逐步认识到这些关键字。新手要辨别一个单词是否为关键字，只需要通过IDEA的高亮颜色进行区分即可，比如：</p><p><img src="https://s2.loli.net/2022/09/16/qtsjIhSGQoxBYVM.png" alt="image-20220916224129597"></p><p>深色模式下，关键字会高亮为橙色，浅色模式下会高亮为深蓝色，普通的代码都是正常的灰白色。</p><p> 比如现在我们想要定义一个变量<code>a</code>，那么就可以这样编写：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        <span class="hljs-keyword">int</span> a;    <span class="hljs-comment">//声明一个整数类型变量a</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>但是这个变量一开始没有任何值，比如现在我们要让这个变量表示10，那么就可以将10赋值给这个变量：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;   <span class="hljs-comment">//直接在定义变量后面添加 = 10，表示这个变量的初始值为10，这里的10就是一个常量数字</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>或者我们可以在使用时再对其进行赋值：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a;<br>    a = <span class="hljs-number">10</span>;   <span class="hljs-comment">//使用时再赋值也可以</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>是不是感觉跟数学差不多？这种写法对于我们人来说，实际上是很好理解的，意思表达很清晰。</p><p>我们可以一次性定义多个变量，比如现在我们想定义两个<code>int</code>类型的变量：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a, b;   <span class="hljs-comment">//定义变量a和变量b，中间使用逗号隔开就行了</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>或者两个变量单独声明也可以：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a;   <span class="hljs-comment">//分两句进行声明</span><br>    <span class="hljs-keyword">int</span> b;<br>}<br></code></pre></td></tr></tbody></table></figure><p>为了更直观地查看变量的值，我们可以直接将变量的值也给打印到控制台：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">666</span>;<br>    System.out.println(a);    <span class="hljs-comment">//之前我们在小括号写的是""，现在我们直接将变量给进去就可以打印变量的值了</span><br>  System.out.println(<span class="hljs-number">888</span>);   <span class="hljs-comment">//甚至直接输出一个常量值都可以</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>得到结果：</p><p><img src="https://s2.loli.net/2022/09/16/3nUAHINdXMmlxvJ.png" alt="image-20220916225037221"></p><p>变量的值也可以在中途进行修改：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">666</span>;<br>    a = <span class="hljs-number">777</span>;<br>    System.out.println(a);   <span class="hljs-comment">//这里打印得到的值就是777了</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>变量的值也可以直接指定为其他变量的值：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> b = a;   <span class="hljs-comment">//直接让b等于a，那么a的值就会给到b</span><br>    System.out.println(b);   <span class="hljs-comment">//这里输出的就是10了</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>我们还可以让变量与数值之间做加减法（运算符会在后面详细介绍）：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">9</span>;   <span class="hljs-comment">//a初始值为9</span><br>    a = a + <span class="hljs-number">1</span>;   <span class="hljs-comment">//a = a + 1也就是将a+1的结果赋值给a，跟数学是一样的，很好理解对吧</span><br>    System.out.println(a);   <span class="hljs-comment">//最后得到的结果就是10了</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>有时候我们希望变量的值一直保持不变，我们就可以将其指定为常量，这里我们介绍Java中第一个需要认识的关键字：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">666</span>;   <span class="hljs-comment">//在变量前面添加final关键字，表示这是一个常量</span><br>    a = <span class="hljs-number">777</span>;    <span class="hljs-comment">//常量的值不允许发生修改</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>编译时出现：</p><p><img src="https://s2.loli.net/2022/09/16/kT46yi8KNOLWlp3.png" alt="image-20220916225429474"></p><p>常量的值只有第一次赋值可以修改，其他任何情况下都不行：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a;<br>    a = <span class="hljs-number">777</span>;   <span class="hljs-comment">//第一次赋值</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>至此，Java的基础语法部分介绍完毕，下一部分我们将开始介绍Java中的几大基本数据类型。</p><hr><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>我们的程序中可能需要表示各种各样的数据，比如整数、小数、字符等等，这一部分我们将探索Java中的八大基本数据类型。只不过在开始之前，我们还需要先补充一点简单的计算机小知识。</p><h3 id="计算机中的二进制表示"><a href="#计算机中的二进制表示" class="headerlink" title="计算机中的二进制表示"></a>计算机中的二进制表示</h3><p>在计算机中，所有的内容都是二进制形式表示。十进制是以10为进位，如9+1=10；二进制则是满2进位（因为我们的计算机是电子的，电平信号只有高位和低位，你也可以暂且理解为通电和不通电，高电平代表1，低电平代表0，由于只有0和1，因此只能使用2进制表示我们的数字！）比如1+1=10=2^1+0，一个位也叫一个bit，8个bit称为1字节，16个bit称为一个字，32个bit称为一个双字，64个bit称为一个四字，我们一般采用字节来描述数据大小。</p><p>注意这里的bit跟我们生活中的网速MB/s是不一样的，小b代表的是bit，大B代表的是Byte字节（8bit = 1Byte字节），所以说我们办理宽带的时候，100Mbps这里的b是小写的，所以说实际的网速就是100/8 = 12.5 MB/s了。</p><blockquote><p>十进制的7 -&gt; 在二进制中为 111 = 2^2 + 2^1 + 2^0</p></blockquote><p>现在有4个bit位，最大能够表示多大的数字呢？</p><ul><li>最小：0000 =&gt; 0</li><li>最大：1111 =&gt; 2^3 + 2^2 + 2^1 + 2^0 =&gt; 8 + 4 + 2 + 1 = 15</li></ul><p>在Java中，无论是小数还是整数，他们都要带有符号（和C语言不同，C语言有无符号数）所以，首位就作为我们的符号位，还是以4个bit为例，首位现在作为符号位（1代表负数，0代表正数）：</p><ul><li>最小：1111 =&gt; -(2^2 + 2^1 + 2^0) =&gt; -7</li><li>最大：0111 =&gt; +(2^2 + 2^1 + 2^0) =&gt; +7 =&gt; 7</li></ul><p>现在，我们4bit能够表示的范围变为了-7~+7，这样的表示方式称为<strong>原码</strong>。虽然原码表示简单，但是原码在做加减法的时候，很麻烦！以4bit位为例：</p><blockquote><p>1+(-1) = 0001 + 1001 = 怎么让计算机去计算？（虽然我们知道该去怎么算，但是计算机不知道！）</p></blockquote><p>我们得创造一种更好的表示方式！于是我们引入了<strong>反码</strong>：</p><ul><li>正数的反码是其本身</li><li>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反</li></ul><p>经过上面的定义，我们再来进行加减法：</p><blockquote><p>1+(-1) = 0001 + 1110 = 1111 =&gt; -0 （直接相加，这样就简单多了！）</p></blockquote><p>思考：1111代表-0，0000代表+0，在我们实数的范围内，0有正负之分吗？0既不是正数也不是负数，那么显然这样的表示依然不够合理！根据上面的问题，我们引入了最终的解决方案，那就是<strong>补码</strong>，定义如下：</p><ul><li>正数的补码就是其本身 （不变！）</li><li>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1（即在反码的基础上+1，此时1000表示-8）</li><li>对补码再求一次补码就可得该补码对应的原码。</li></ul><p>比如-7原码为1111，反码为1000，补码就是1001了，-6原码为1110，反码为1001，补码就是1010。所以在补码下，原本的1000就作为新增的最小值-8存在。</p><p>所以现在就已经能够想通，-0已经被消除了！我们再来看上面的运算：</p><blockquote><p>1+(-1) = 0001 + 1111 = (1)0000 =&gt; +0 （现在无论你怎么算，也不会有-0了！）</p></blockquote><p>所以现在，1111代表的不再是-0，而是-1，相应的，由于消除-0，负数多出来一个可以表示的数（1000拿去表示-8了），那么此时4bit位能够表示的范围是：-8~+7（Java使用的就是补码！）在了解了计算机底层的数据表示形式之后，我们再来学习这些基本数据类型就会很轻松了。</p><h3 id="整数类形"><a href="#整数类形" class="headerlink" title="整数类形"></a>整数类形</h3><p>整数类型是最容易理解的类型！既然我们知道了计算机中的二进制数字是如何表示的，那么我们就可以很轻松的以二进制的形式来表达我们十进制的内容了。</p><p>在Java中，整数类型包括以下几个：</p><ul><li>byte 字节型 （8个bit，也就是1个字节）范围：-128~+127</li><li>short 短整形（16个bit，也就是2个字节）范围：-32768~+32767</li><li>int 整形（32个bit，也就是4个字节）最常用的类型：-2147483648 ~ +2147483647</li><li>long 长整形（64个bit，也就是8个字节）范围：-9223372036854775808 ~ +9223372036854775807</li></ul><p>这里我们来使用一下，其实这几种变量都可以正常表示整数：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">short</span> a = <span class="hljs-number">10</span>;<br>    System.out.println(a);<br>}<br></code></pre></td></tr></tbody></table></figure><p>因为都可以表示整数，所以说我们可以将小的整数类型值传递给大的整数类型：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">short</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> b = a;   <span class="hljs-comment">//小的类型可以直接传递给表示范围更大的类型</span><br>    System.out.println(b);<br>}<br></code></pre></td></tr></tbody></table></figure><p>反之会出现报错：</p><p><img src="https://s2.loli.net/2022/09/16/NLZlDgxz3ci5Idr.png" alt="image-20220916231650085"></p><p>这是由于我们在将小的整数类型传递给大的整数类型时发生了<strong>隐式类型转换</strong>，只要是从存储范围小的类型到存储范围大的类型，都支持隐式类型转换，它可以自动将某种类型的值，转换为另一种类型，比如上面就是将short类型的值转换为了int类型的值。</p><p>隐式类型转换不仅可以发生在整数之间，也可以是其他基本数据类型之间，我们后面会逐步介绍。</p><p>实际上我们在为变量赋一个常量数值时，也发生了隐式类型转换，比如：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>   <span class="hljs-keyword">byte</span> b = <span class="hljs-number">10</span>;    <span class="hljs-comment">//这里的整数常量10，实际上默认情况下是int类型，但是由于正好在对应类型可以表示的范围内，所以说直接转换为了byte类型的值</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>由于直接编写的整数常量值默认为<code>int</code>，这里需要特别注意一下，比如下面这种情况：</p><p><img src="https://s2.loli.net/2022/09/16/76GgjWYz4DPBy1p.png" alt="image-20220916232420547"></p><p>按照<code>long</code>类型的规定，实际上是可以表示这么大的数字的，但是为什么这里报错了呢？这是因为我们直接在代码中写的常量数字，默认情况下就是<code>int</code>类型，这么大肯定是表示不下的，如果需要将其表示为一个long类型的常量数字，那么需要在后面添加大写或是小写的<code>L</code>才可以。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">long</span> a = <span class="hljs-number">922337203685477580L</span>;   <span class="hljs-comment">//这样就可以正常编译通过了</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>当然，针对于这种很长的数字，为了提升辨识度，我们可以使用下划线分割每一位：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>   <span class="hljs-keyword">int</span> a = <span class="hljs-number">1_000_000</span>;    <span class="hljs-comment">//当然这里依然表示的是1000000，没什么区别，但是辨识度会更高</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>我们也可以以8进制或是16进制表示一个常量值：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    System.out.println(<span class="hljs-number">0xAF</span>);<br>    System.out.println(<span class="hljs-number">032</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li><strong>十六进制：</strong>以<code>0x</code>开头的都是十六进制表示法，十六进制满16进一，但是由于我们的数学只提供了0-9这十个数字，10、11、12…15该如何表示呢，我们使用英文字母A按照顺序开始表示，A表示10、B表示11…F表示15。比如上面的0xA实际上就是我们十进制中的10。</li><li><strong>八进制：</strong>以0开头的都是八进制表示法，八进制就是满8进一，所以说只能使用0-7这几个数字，比如上面的012实际上就是十进制的10。</li></ul><p>我们最后再来看一个问题：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">2147483647</span>;   <span class="hljs-comment">//int最大值</span><br>    a = a + <span class="hljs-number">1</span>;   <span class="hljs-comment">//继续加</span><br>    System.out.println(a);<br>}<br></code></pre></td></tr></tbody></table></figure><p>此时a的值已经来到了<code>int</code>类型所能表示的最大值了，那么如果此时再继续<code>+1</code>，各位小伙伴觉得会发生什么？可以看到结果很奇怪：</p><p><img src="https://s2.loli.net/2022/09/16/YztefPIvLE6y94u.png" alt="image-20220916234540720"></p><p>什么情况？？？怎么正数加1还变成负数了？请各位小伙伴回想一下我们之前讲解的原码、反码和补码。</p><p>我们先来看看，当int为最大值时，二进制表示形式为什么：</p><ul><li>2147483647 = 01111111 11111111 11111111 11111111（第一个是符号位0，其他的全部为1，就是正数的最大值）</li></ul><p>那么此时如果加1，会进位成：</p><ul><li>10000000 00000000 00000000 00000000</li></ul><p>各位想一想，符号位为1，那么此时表示的不就是一个负数了吗？我们回想一下负数的补码表示规则，瞬间就能明白了，这不就是补码形式下的最小值了吗？</p><p>所以说最后的结果就是<code>int</code>类型的最小值：-2147483648，是不是感觉了解底层原理会更容易理解这是为什么。</p><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>前面我们介绍了整数类型，我们接着来看看浮点类型，在Java中也可以轻松地使用小数。</p><p>首先来看看Java中的小数类型包含哪些：</p><ul><li>float 单精度浮点型 （32bit，4字节）</li><li>double 双精度浮点型（64bit，8字节）</li></ul><p>那么小数在计算机中又是如何存放的呢？相较于整数，要稍微复杂一点：</p><p><img src="https://s2.loli.net/2022/09/17/CpI5jaWgR9nqTbc.png" alt="image-20220917102209246"></p><p>根据国际标准 IEEE 754，任意一个二进制浮点数 V 可以表示成下面的形式：<br>$$<br>V = (-1)^S \times M \times 2^E<br>$$</p><ul><li>$(-1)^S$ 表示符号位，当 S=0，V 为正数；当 S=1，V 为负数。</li><li>M 表示有效数字，大于等于 1，小于 2，但整数部分的 1 不变，因此可以省略。（例如尾数为1111010，那么M实际上就是1.111010，尾数首位必须是1，1后面紧跟小数点，如果出现0001111这样的情况，去掉前面的0，移动1到首位，随着时间的发展，IEEE 754标准默认第一位为1，故为了能够存放更多数据，就舍去了第一位，比如保存1.0101 的时候， 只保存 0101，这样能够多存储一位数据）</li><li>$2^E$ 表示指数位。（用于移动小数点，所以说才称为浮点型）</li></ul><p>比如， 对于十进制的 5.25 对应的二进制为：101.01，相当于：$1.0101 \times 2^2$。所以，S 为 0，M 为 1.0101，E 为 2。因此，对于浮点类型，最大值和最小值不仅取决于符号和尾数，还有它的阶码，所以浮点类型的大致取值范围：</p><ul><li>单精度：$±3.40282347 \times 10^{38}$</li><li>双精度：$±1.79769313486231570 \times 10^{308}$</li></ul><p>我们可以直接创建浮点类型的变量：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">double</span> a = <span class="hljs-number">10.5</span>, b = <span class="hljs-number">66</span>;   <span class="hljs-comment">//整数类型常量也可以隐式转换到浮点类型</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>注意，跟整数类型常量一样，小数类型常量默认都是<code>double</code>类型，所以说如果我们直接给一个float类型赋值：</p><p><img src="https://s2.loli.net/2022/09/17/x7bOzyIacpDowKk.png" alt="image-20220917105141288"></p><p>由于<code>float</code>类型的精度不如<code>double</code>，如果直接给其赋一个double类型的值，会直接出现错误。</p><p>同样的，我们可以给常量后面添加大写或小写的F来表示这是一个<code>float</code>类型的常量值：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">float</span> f = <span class="hljs-number">9.9F</span>;   <span class="hljs-comment">//这样就可以正常编译通过了</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>但是反之，由于<code>double</code>精度更大，所以说可以直接接收<code>float</code>类型的值：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">float</span> f = <span class="hljs-number">9.9F</span>;<br>    <span class="hljs-keyword">double</span> a = f;    <span class="hljs-comment">//隐式类型转换为double值</span><br>    System.out.println(a);<br>}<br></code></pre></td></tr></tbody></table></figure><p>只不过由于精度问题，最后的打印结果：</p><p><img src="https://s2.loli.net/2022/09/17/1JqHY2so6Qwz4WX.png" alt="image-20220917105849862"></p><p>这种情况是正常的，因为浮点类型并不保证能够精确计算，我们会在下一章介绍 BigDecimal 和 BigInteger，其中BigDecimal更适合需要精确计算的场景。</p><p>我们最后来看看下面的例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">long</span> l = <span class="hljs-number">21731371236768L</span>;<br>    <span class="hljs-keyword">float</span> f = l;   <span class="hljs-comment">//这里能编译通过吗？</span><br>    System.out.println(f);<br>}<br></code></pre></td></tr></tbody></table></figure><p>此时我们发现，<code>long</code>类型的值居然可以直接丢给<code>float</code>类型隐式类型转换，很明显<code>float</code>只有32个bit位，而<code>long</code>有足足64个，这是什么情况？怎么大的还可以隐式转换为小的？这是因为虽然<code>float</code>空间没有那么大，但是由于是浮点类型，指数可以变化，最大的数值表示范围实际上是大于<code>long</code>类型的，虽然会丢失精度，但是确实可以表示这么大的数。</p><p>所以说我们来总结一下隐式类型转换规则：byte→short(char)→int→long→float→double</p><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>字符类型也是一个重要的基本数据类型，它可以表示计算机中的任意一个字符（包括中文、英文、标点等一切可以显示出来的字符）</p><ul><li>char 字符型（16个bit，也就是2字节，它不带符号）范围是0 ~ 65535</li></ul><p>可以看到char类型依然存储的是数字，那么它是如何表示每一个字符的呢？实际上每个数字在计算机中都会对应一个字符，首先我们需要介绍ASCII码：</p><p><img src="https://s2.loli.net/2022/09/17/Z7AiBPNO6ylML4z.png" alt="img"></p><p>比如我们的英文字母<code>A</code>要展示出来，那就是一个字符的形式，而其对应的ASCII码值为65，所以说当char为65时，打印出来的结果就是大写的字母A了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">char</span> c = <span class="hljs-number">65</span>;<br>    System.out.println(c);<br>}<br></code></pre></td></tr></tbody></table></figure><p>得到结果为：</p><p><img src="https://s2.loli.net/2022/09/17/dvizHYa2fCOKhA3.png" alt="image-20220917110854266"></p><p>或者我们也可以直接写一个字符常量值赋值：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">char</span> c = <span class="hljs-string">'A'</span>;    <span class="hljs-comment">//字符常量值需要使用单引号囊括，并且内部只能有一个字符</span><br>    System.out.println(c);<br>}<br></code></pre></td></tr></tbody></table></figure><p>这种写法效果与上面是一样的。</p><p>不过，我们回过来想想，这里的字符表里面不就128个字符吗，那<code>char</code>干嘛要两个字节的空间来存放呢？我们发现表中的字符远远没有我们所需要的那么多，这里只包含了一些基础的字符，中文呢？那么多中文字符（差不多有6000多个），用ASCII编码表那128个肯定是没办法全部表示的，但是我们现在需要在电脑中使用中文。这时，我们就需要扩展字符集了。</p><blockquote><p>我们可以使用两个甚至多个字节来表示一个中文字符，这样我们能够表示的数量就大大增加了，GB2132方案规定当连续出现两个大于127的字节时（注意不考虑符号位，此时相当于是第一个bit位一直为1了），表示这是一个中文字符（所以为什么常常有人说一个英文字符占一字节，一个中文字符占两个字节），这样我们就可以表示出超过7000种字符了，不仅仅是中文，甚至中文标点、数学符号等，都可以被正确的表示出来。</p><p>不过这样能够表示的内容还是不太够，除了那些常见的汉字之外，还有很多的生僻字，比如龘、錕、釿、拷这类的汉字，后来干脆直接只要第一个字节大于127，就表示这是一个汉字的开始，无论下一个字节是什么内容（甚至原来的128个字符也被编到新的表中），这就是Windows至今一直在使用的默认GBK编码格式。</p><p>虽然这种编码方式能够很好的解决中文无法表示的问题，但是由于全球还有很多很多的国家以及很多很多种语言，所以我们的最终目标是能够创造一种可以表示全球所有字符的编码方式，整个世界都使用同一种编码格式，这样就可以同时表示全球的语言了。所以这时就出现了一个叫做ISO的（国际标准化组织）组织，来定义一套编码方案来解决所有国家的编码问题，这个新的编码方案就叫做Unicode（准确的说应该是规定的字符集，包含了几乎全世界所有语言的字符），规定每个字符必须使用两个字节，即用16个bit位来表示所有的字符（也就是说原来的那128个字符也要强行用两位来表示）</p><p>但是这样的话实际上是很浪费资源的，因为这样很多字符都不会用到两字节来保存，肯定不能直接就这样去表示，这会导致某些字符浪费了很多空间，我们需要一个更加好用的具体的字符编码方式。所以最后就有了UTF-8编码格式（它是Unicode字符集的一个编码规则），区分每个字符的开始是根据字符的高位字节来区分的，比如用一个字节表示的字符，第一个字节高位以“0”开头；用两个字节表示的字符，第一个字节的高位为以“110”开头，后面一个字节以“10开头”；用三个字节表示的字符，第一个字节以“1110”开头，后面俩字节以“10”开头；用四个字节表示的字符，第一个字节以“11110”开头，后面的三个字节以“10”开头：</p><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">10000011 </span><span class="hljs-number">10000110</span>    //这就是一个连续出现都大于<span class="hljs-number">127</span>的字节（注意这里是不考虑符号位的）<br></code></pre></td></tr></tbody></table></figure><p>所以如果我们的程序需要表示多种语言，最好采用UTF-8编码格式，随着更多的字符加入，实际上两个字节也装不下了，可能需要3个甚至4个字节才能表示某些符号，后来就有了UTF-16编码格式，Java在运行时采用的就是UTF-16，几乎全世界的语言用到的字符都可以表示出来。</p></blockquote><table><thead><tr><th>Unicode符号范围（十六进制）</th><th>UTF-8编码方式(二进制)</th></tr></thead><tbody><tr><td>0000 0000 ~ 0000 007F</td><td>0xxxxxxx</td></tr><tr><td>0000 0080 ~ 0000 07FF</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>0000 0800 ~ 0000 FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>0001 0000 ~ 0010 FFFF</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><p><strong>注意：</strong>Unicode 是“字符集”，也就是有哪些字符，而UTF-8、UTF-16 是“编码规则”，也就是怎么对这些字符编码，怎么以二进制的形式保存，千万不要搞混了。</p><p>简而言之，char实际上需要两个字节才能表示更多种类的字符，所以，<code>char</code>类型可以直接表示一个中文字符：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-string">'淦'</span>;   <span class="hljs-comment">//使用int类型接收字符类型常量值可以直接转换为对应的编码</span><br>    System.out.println(a);<br>}<br></code></pre></td></tr></tbody></table></figure><p>得到结果为：</p><p><img src="https://s2.loli.net/2022/09/17/ZgzMUafmYAKoOXt.png" alt="image-20220917111838629"></p><p>Java程序在编译为<code>.class</code>文件之后，会采用UTF-8的编码格式，支持的字符也非常多，所以你甚至可以直接把变量名写成中文，依然可以编译通过：</p><p><img src="https://s2.loli.net/2022/09/17/vAnPCgx5ThEUBHe.png" alt="image-20220917112033102"></p><p>介绍完了字符之后，我们接着来看看字符串，其实字符串我们在一开始就已经接触到了。字符虽然可以表示一个中文，但是它没办法表示多个字符：</p><p><img src="https://s2.loli.net/2022/09/17/JmdQkSw2qc4ZTuW.png" alt="image-20220917114628564"></p><p>但是实际上我们使用率最高的还是多个字符的情况，我们需要打印一连串的字符。这个时候，我们就可以使用字符串了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    String str = <span class="hljs-string">"啊这"</span>;    <span class="hljs-comment">//字符串需要使用双引号囊括，字符串中可以包含0-N个字符</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>注意，这里使用的类型是<code>String</code>类型，这种类型并<strong>不是基本数据类型</strong>，它是对象类型，我们会在下一章继续对其进行介绍，这里我们只需要简单了解一下就可以了。</p><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>布尔类型是Java中的一个比较特殊的类型，它并不是存放数字的，而是状态，它有下面的两个状态：</p><ul><li>true  -  真</li><li>false  -  假</li></ul><p>布尔类型（boolean）只有<code>true</code>和<code>false</code>两种值，也就是要么为真，要么为假，布尔类型的变量通常用作流程控制判断语句（不同于C语言，C语言中一般使用0表示false，除0以外的所有数都表示true）布尔类型占据的空间大小并未明确定义，而是根据不同的JVM会有不同的实现。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">boolean</span> b = <span class="hljs-keyword">true</span>;   <span class="hljs-comment">//值只能是true或false</span><br>    System.out.println(b);<br>}<br></code></pre></td></tr></tbody></table></figure><p>如果给一个其他的值，会无法编译通过：</p><p><img src="https://s2.loli.net/2022/09/17/1TtJdKcvRWPfAI2.png" alt="image-20220917115424504"></p><p>至此，基本数据类型的介绍就结束了。</p><hr><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>前面我们介绍了多种多样的基本数据类型，但是光有这些基本数据类型还不够，我们还需要让这些数据之间进行运算，才可以真正意义上发挥计算机的作用。</p><p>要完成计算，我们需要借助运算符来完成，实际上我们在数学中就已经接触过多种多样的运算符了。</p><blockquote><p>比如：+   -    ×    ÷</p></blockquote><p>这些运算符都是我们在初等数学中学习的，而使用规则也很简单，我们只需要将需要进行运算的两个数放到运算符的两边就可以了：</p><blockquote><p>比如：10 ÷ 2</p></blockquote><p>上面运算的结果就是5了，而在Java中，我们同样可以使用这样的方式来进行运算。</p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>首先我们还是来回顾一下之前认识的老朋友：赋值运算符。</p><p>赋值运算符可以直接给某个变量赋值：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">666</span>;   <span class="hljs-comment">//使用等号进行赋值运算</span><br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>使用规则为：</strong>赋值运算符的左边必须是一个可以赋值的目标，比如变量，右边可以是任意满足要求的值，包括变量。</p><p>当然，赋值运算符并不只是单纯的赋值，它是有结果的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">int</span> b = a = <span class="hljs-number">777</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>当出现连续使用赋值运算符时，按照从右往左的顺序进行计算，首先是<code>a = 777</code>，计算完成后，a的值就变成了777，计算完成后，会得到计算结果（赋值运算的计算结果就是赋的值本身，就像1 + 1的结果是2一样，a = 1的结果就是1）此时继续进行赋值计算，那么b就被赋值为<code>a = 777</code>的计算结果，同样的也是 777 了。</p><p>所以，使用连等可以将一连串变量都赋值为最右边的值。</p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>算术运算符也就是我们初等数学中认识的这些运算符，包括加减乘除，当然Java还支持取模运算，算术运算同样需要左右两边都有一个拿来计算的目标。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span> + <span class="hljs-number">1</span>;<br>    System.out.println(a);<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以看到a赋值为1+1的结果，所以说最后a就是2了。</p><p>当然变量也是可以参与到算术运算中：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">int</span> b = a - <span class="hljs-number">10</span>;<br>    System.out.println(b);<br>}<br></code></pre></td></tr></tbody></table></figure><p>不同类型之间也可以进行运算：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">short</span> b = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> c = a + b;   <br>  <span class="hljs-comment">//不同类型的整数一起运算，小类型需要转换为大类型，short、byte、char一律转换为int再进行计算（无论算式中有无int，都需要转换），结果也是int；如果算式中出现了long类型，那么全部都需要转换到long类型再进行计算，结果也是long，反正就是依大的来</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>因为运算时会发生隐式类型转换，所以说这里b自动转换为了int类型进行计算，所以说最后得到结果也一定是转换后的类型：</p><p><img src="https://s2.loli.net/2022/09/17/KovME45pl2sPiBN.png" alt="image-20220917141359260"></p><p>小数和整数一起计算同样会发生隐式类型转换：</p><p><img src="https://s2.loli.net/2022/09/17/jxW3KfwBACidyMY.png" alt="image-20220917141955891"></p><p>因为小数表示范围更广，所以说整数会被转换为小数再进行计算，而最后的结果也肯定是小数了。</p><p>我们也可以将加减号作为正负符号使用，比如我们现在需要让a变成自己的相反数：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    a = -a;   <span class="hljs-comment">//减号此时作为负号运算符在使用，会将右边紧跟的目标变成相反数</span><br>    System.out.println(a);   <span class="hljs-comment">//这里就会得到-10了</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>同样的，正号也可以使用，但是似乎没什么卵用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    a = +a;   <span class="hljs-comment">//正号本身在数学中就是可以省略的存在，所以Java中同样如此</span><br>    System.out.println(a);<br>}<br></code></pre></td></tr></tbody></table></figure><p>注意加法支持对字符串的拼接：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    String str = <span class="hljs-string">"伞兵"</span> + <span class="hljs-string">"lbw"</span>;   <span class="hljs-comment">//我们可以使用加号来拼接两个字符串</span><br>    System.out.println(str);<br>}<br></code></pre></td></tr></tbody></table></figure><p>最后这个字符串就变成了拼接后的结果了：</p><p><img src="https://s2.loli.net/2022/09/17/TeUCBM9ZzINuoa8.png" alt="image-20220917145901135"></p><p>字符串不仅可以跟字符串拼接，也可以跟基本数据类型拼接：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    String str = <span class="hljs-string">"伞兵"</span> + <span class="hljs-keyword">true</span> + <span class="hljs-number">1.5</span> + <span class="hljs-string">'A'</span>;<br>    System.out.println(str);<br>}<br></code></pre></td></tr></tbody></table></figure><p>最后就可以得到对应的结果了：</p><p><img src="https://s2.loli.net/2022/09/17/URJxsgXvzYMQh8t.png" alt="image-20220917150010919"></p><p>当然，除了加减法之外乘除法也是支持的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">8</span>, b = <span class="hljs-number">2</span>;<br>    System.out.println(a * b);   <span class="hljs-comment">//乘法使用*表示乘号</span><br>  System.out.println(a / b);   <span class="hljs-comment">//除法就是一个/表示除号</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>注意，两个整数在进行除法运算时，得到的结果也是整数（会直接砍掉小数部分，注意不是四舍五入）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">8</span>, b = <span class="hljs-number">5</span>;<br>    System.out.println(a / b);<br>}<br></code></pre></td></tr></tbody></table></figure><p>上面是两个int类型的值进行的除法运算，正常情况下8除以5应该得到1.6，但是由于结果也是整数，所以说最后小数部分被丢弃：</p><p><img src="https://s2.loli.net/2022/09/17/TdhHPN64UnyFozq.png" alt="image-20220917141816599"></p><p>但是如果是两个小数一起计算的话，因为结果也是小数，所以说就可以准确得到结果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">double</span> a = <span class="hljs-number">8.0</span>, b = <span class="hljs-number">5.0</span>;<br>    System.out.println(a / b);<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/09/17/3zjJoeL6bgdRqNA.png" alt="image-20220917142201392"></p><p>同样的，整数和小数一起计算，由于所有的整数范围都比小数小，根据我们上一部分介绍的转换规则，整数和小数一起计算时，所有的整数都会变成小数参与运算，所以说最后的结果也就是小数了，同样可以得到正确的结果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">double</span> a = <span class="hljs-number">8.0</span>;<br>    <span class="hljs-keyword">int</span> b = <span class="hljs-number">5</span>;<br>    System.out.println(a / b);<br>}<br></code></pre></td></tr></tbody></table></figure><p>那么问题来了，现在我们有两个整数需要进行计算，但是我们就是希望可以得到一个小数的结果该怎么办呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">8</span>, b = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">double</span> c = a;   <span class="hljs-comment">//我们可以将其先隐式转换为小数类型，再那转换后的小数变量去参与计算</span><br>    System.out.println(c / b);   <span class="hljs-comment">//同样可以得到正确结果</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>在下一节，我们将介绍强制类型转换，通过使用强制类型转换，我们可以更轻松地让整数计算出小数的结果。</p><p>除了最基本的加减乘除操作，我们也可以进行取模操作：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    System.out.println(a % <span class="hljs-number">3</span>);   <span class="hljs-comment">//比如这里对a进行取模操作，实际上就是计算除以3的余数</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>比如上面的是 10 % 3 得到的结果就是10除以3最后的余数1，取模操作也是非常好用的。</p><p>比如我们查看某个数是否为双数，只需要将其对2进行取模操作即可，因为如果是双数一定是可以整除的，如果是单数一定会余1：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    System.out.println(<span class="hljs-number">17</span> % <span class="hljs-number">2</span>);   <span class="hljs-comment">//17不是双数，所以说最后会得到1</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>注意，运算符之间是有优先级之分的，比如乘除法优先级高于加减法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    System.out.println(<span class="hljs-number">10</span> + <span class="hljs-number">3</span> * <span class="hljs-number">4</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>上面的算式按照数学中的规则，应该先计算3 * 4，然后再进行加法计算，而Java中同样遵循这样的规律。我们来总结一下到目前为止所有学习到的运算符相关性质：</p><table><thead><tr><th align="center">优先级</th><th align="center">运算符</th><th align="center">结合性（出现同优先级运算符时）</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">-(负号)  +(正号)</td><td align="center">从右向左</td></tr><tr><td align="center">2</td><td align="center">*   /  %</td><td align="center">从左往右</td></tr><tr><td align="center">3</td><td align="center">+(加法，包括字符串)   -(减法)</td><td align="center">从左往右</td></tr><tr><td align="center">4</td><td align="center">=</td><td align="center">从右向左</td></tr></tbody></table><p>比如下面的结果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> b = a = <span class="hljs-number">8</span> * -a + <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        1. 正负号优先级最高，所有首先计算的是-a，得到-10</span><br><span class="hljs-comment">        2. 其次是乘除号优先级更高，所以说这里计算 8 * -10，得到 -80</span><br><span class="hljs-comment">        3. 然后是加减法，-80 + 10 = -70</span><br><span class="hljs-comment">        4. 最后是赋值运算，因为等号运算符从右往左结合，先算a = -70的结果就是 -70</span><br><span class="hljs-comment">        5. 最后b就是 -70</span><br><span class="hljs-comment">     */</span><br>    System.out.println(b);<br>}<br></code></pre></td></tr></tbody></table></figure><p>通过使用这些基本算术运算符，我们就可以更加快速地计算我们想要的结果了。</p><h3 id="括号运算符"><a href="#括号运算符" class="headerlink" title="括号运算符"></a>括号运算符</h3><p>前面我们介绍了算术运算符，我们接着来看括号运算符。</p><p>我们常常在数学中使用括号提升某些运算的优先级，比如：</p><blockquote><p>(1 + 7) × (3 - 6) = -24</p></blockquote><p>虽然加法优先级比乘法要低但是我们给其添加括号之后，相当于提升了内部加法运算的优先级，所以说需要先计算括号中的再去计算括号外的，Java同样满足这个要求。</p><p>我们可以通过添加括号的方式来提升某些运算的优先级：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> b = (a = <span class="hljs-number">8</span>) * (-a + <span class="hljs-number">10</span>);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        1. 括号的优先级是最高的，我们需要先计算括号中的内容，如果存在多个括号，就从左往右计算</span><br><span class="hljs-comment">        2. 首先是 a = 8，计算完成之后a变成8，并且运算结果也为8</span><br><span class="hljs-comment">        3. 然后是后面的加法，-a就是-8，加上10就是2</span><br><span class="hljs-comment">        4. 最后才是乘法，左边此时是8，右边是2，最后结果为16</span><br><span class="hljs-comment">     */</span><br>    System.out.println(b);<br>}<br></code></pre></td></tr></tbody></table></figure><p>所以，通过添加括号，就可以更加灵活的控制计算。</p><p>当然，括号是可以嵌套的，这一点跟数学中也是一样的，只不过我们不需要使用方括号和花括号，一律使用小括号就行了。</p><p>在嵌套的情况下，会优先计算最内层括号中的算式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> b = (<span class="hljs-number">2</span> + (<span class="hljs-number">3</span> + <span class="hljs-number">1</span>) * <span class="hljs-number">3</span>) * <span class="hljs-number">2</span>;<br>    System.out.println(b);<br>}<br></code></pre></td></tr></tbody></table></figure><p>这里会优先计算 3 + 1的结果，然后由于第二层都在一个括号中，所以说按照正常优先级计算，2 + 4 * 3  = 14，最后来到最外层14*2 = 28，计算结束。</p><p>括号除了可以用来提升运算优先级，也可以用作<strong>强制类型转换</strong>，前面我们介绍了隐式类型转换，但是隐式类型转换存在局限性，比如此时我们希望将一个大的类型转换为一个小的类型：</p><p><img src="https://s2.loli.net/2022/09/17/En2uzTl5PFgKeNX.png" alt="image-20220917150256987"></p><p>正常情况下无法编译通过，但是实际上a的值并没有超出<code>short</code>的范围，理论上是可以直接给到b存放的，此时我们就可以使用强制类型转换：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">short</span> b = (<span class="hljs-keyword">short</span>) a;   <span class="hljs-comment">//在括号中填写上强制转换的类型，就可以强制转换到对应的类型了</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>只不过强制类型转换存在一定的风险，比如：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">128</span>;   <span class="hljs-comment">//已经超出byte的范围了</span><br>    <span class="hljs-keyword">byte</span> b = (<span class="hljs-keyword">byte</span>) a;  <span class="hljs-comment">//此时强制类型转换为byte类型，那么只会保留byte能够表示的bit位</span><br>    System.out.println(b);<br>}<br></code></pre></td></tr></tbody></table></figure><p>比如这里的128：</p><ul><li>00000000 00000000 00000000 10000000  -&gt;  byte只有一个字节，所以说只保留最后8位 -&gt; 10000000</li></ul><p>这里的10000000，由于第一个位置是符号位，导致此时直接变成了byte的最小值：</p><p><img src="https://s2.loli.net/2022/09/17/Kt6rfkYE1HSvNnl.png" alt="image-20220917151028191"></p><p>所以说强制类型转换只有在明确不会出现问题的情况下，才可以使用。当然，强制类型转换也可以用在后面的类中，我们将会在下一章继续探讨。</p><p>有了强制类型转换，我们就可以很轻松地让两个整数计算出小数的结果了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">8</span>, b = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">double</span> c = a/(<span class="hljs-keyword">double</span>)b;  <br>  <span class="hljs-comment">//强制类型转换的优先级跟正负号一样</span><br>  <span class="hljs-comment">//计算时，只需要将其中一者转换为double类型，此时按照隐式类型转换规则，全都会变成double参与运算，所以结果也就是小数了</span><br>    System.out.println(c);<br>}<br></code></pre></td></tr></tbody></table></figure><p>各位思考一下下面的这种情况可以正确得到小数的结果吗？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">8</span>, b = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">double</span> c = (<span class="hljs-keyword">double</span>) (a/b);<br>    System.out.println(c);<br>}<br></code></pre></td></tr></tbody></table></figure><p>不能得到，因为括号将a/b的运算优先进行了，此时得到的结果已经是一个整数结果，再转换为double毫无意义。</p><p>最后我们还是来总结一下目前遇到的所有运算符：</p><table><thead><tr><th align="center">优先级</th><th align="center">运算符</th><th align="center">结合性</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">( )</td><td align="center">从左向右</td></tr><tr><td align="center">2</td><td align="center">-  +  (强制类型转换)</td><td align="center">从右向左</td></tr><tr><td align="center">3</td><td align="center">*   /  %</td><td align="center">从左向右</td></tr><tr><td align="center">4</td><td align="center">+(加法，包括字符串)   -(减法)</td><td align="center">从左向右</td></tr><tr><td align="center">5</td><td align="center">=</td><td align="center">从右向左</td></tr></tbody></table><h3 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h3><p><strong>注意：</strong>这一节很容易搞晕，请务必记清楚顺序！</p><p>有时候我们可能需要让变量自己进行增加操作，比如我们现在想要进行跳绳计数，每转动一圈，计数+1，当我们想要对一个变量进行这样的自增操作时，可以：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">8</span>;<br>    a = a + <span class="hljs-number">1</span>;    <span class="hljs-comment">//让a等于a本身+1，相当于自增了1</span><br>    System.out.println(a);   <span class="hljs-comment">//得到9</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>当然，除了这种方式，我们也可以使用自增自减运算符：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">8</span>;<br>    a++;   <span class="hljs-comment">//自增运算符就是两个加号连在一起，效果跟上面是一样的，a都会自增1</span><br>  a--;   <span class="hljs-comment">//自减不用我多说了吧</span><br>    System.out.println(a);<br>}<br></code></pre></td></tr></tbody></table></figure><p>自增自减运算符可以放到操作数的前后：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">8</span>;<br>    ++a;   <span class="hljs-comment">//自增运算符在前在后最终效果都是让a自增1，是一样的</span><br>    System.out.println(a);<br>}<br></code></pre></td></tr></tbody></table></figure><p>自增自减操作同样是有结果的，注意，这两种方式自增操作的结果不一样，我们来看下面的例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">int</span> b = a++;   <span class="hljs-comment">//先出结果，再自增</span><br>    System.out.println(b);  <span class="hljs-comment">//b得到的是a自增前的值</span><br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">int</span> b = ++a;   <span class="hljs-comment">//先自增，再出结果</span><br>    System.out.println(b);   <span class="hljs-comment">//b得到的是a自增之后的结果</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>第一个结果为8，而第二个结果却是9，这是因为，自增运算符放在前面，是先自增再得到结果，而自增运算符放到后面，是先出结果再自增（自减同理），这个新手很容易记混，所以说一定要分清楚。</p><p>自增自减运算符的优先级与正负号等价比如：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">int</span> b = -a++ + ++a; <br>  <span class="hljs-comment">//我们首先来看前面的a，因为正负号和自增是同一个优先级，结合性是从右往左，所以说先计算a++</span><br>  <span class="hljs-comment">//a++的结果还是8，然后是负号，得到-8</span><br>  <span class="hljs-comment">//接着是后面的a，因为此时a已经经过前面变成9了，所以说++a就是先自增，再得到10</span><br>  <span class="hljs-comment">//最后得到的结果为 -8 + 10 = 2</span><br>    System.out.println(b);<br>}<br></code></pre></td></tr></tbody></table></figure><p>一般情况下，除了考试为了考察各位小伙伴对运算符的优先级和结合性的理解，会出现这种恶心人的写法之外，各位小伙伴尽量不要去写这种难以阅读的东西。</p><p>当然，有些时候我们并不是希望以1进行自增，可能希望以其他的数进行自增操作，除了按照之前的方式老老实实写之外：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">8</span>;<br>    a = a + <span class="hljs-number">4</span>;<br>    System.out.println(a);<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以将其缩写：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">8</span>;<br>    a += <span class="hljs-number">4</span>;   <span class="hljs-comment">//加号和等号连在一起，与a = a + 4效果完全一样</span><br>    System.out.println(a);<br>}<br></code></pre></td></tr></tbody></table></figure><p>并且结果也是操作之后的结果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">int</span> b = a += <span class="hljs-number">4</span>;   <span class="hljs-comment">//+=的运算结果就是自增之后的结果</span><br>    System.out.println(b);  <span class="hljs-comment">//所以b就是12</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>不止加法，包括我们前面介绍的全部算术运算符，都是支持这种缩写的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">8</span>;<br>    a *= <span class="hljs-number">9</span>;   <span class="hljs-comment">//跟 a = a * 9 等价</span><br>    System.out.println(a);   <span class="hljs-comment">//得到72</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>是不是感觉能够编写更简洁的代码了？</p><table><thead><tr><th align="center">优先级</th><th align="center">运算符</th><th align="center">结合性</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">( )</td><td align="center">从左向右</td></tr><tr><td align="center">2</td><td align="center">-  +  (强制类型转换)  ++ –</td><td align="center">从右向左</td></tr><tr><td align="center">3</td><td align="center">*   /  %</td><td align="center">从左向右</td></tr><tr><td align="center">4</td><td align="center">+(加法，包括字符串)   -(减法)</td><td align="center">从左向右</td></tr><tr><td align="center">5</td><td align="center">=  +=  -=  *=   /=   %=</td><td align="center">从右向左</td></tr></tbody></table><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>我们接着来看位运算符，它比较偏向于底层，但是只要各位小伙伴前面的计算机二进制表示听明白了，这里就不是问题。</p><p>我们可以使用位运算符直接以二进制形式操作目标，位运算符包括：&amp;    |    ^    ~</p><p>我们先来看按位与&amp;，比如下面的两个数：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">9</span>, b = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">int</span> c = a &amp; b;    <span class="hljs-comment">//进行按位与运算</span><br>    System.out.println(c);<br>}<br></code></pre></td></tr></tbody></table></figure><p>按位与实际上就是让这两个数每一位都进行比较，如果这一位两个数都是1，那么结果就是1，否则就是0：</p><ul><li>a = 9 = 1001</li><li>b = 3 = 0011</li><li>c = 1 = 0001（因为只有最后一位，两个数都是1，所以说结果最后一位是1，其他都是0）</li></ul><p>同样的，按位或，其实就是只要任意一个为1（不能同时为0）那么结果就是1：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">9</span>, b = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">int</span> c = a | b;<br>    System.out.println(c);<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>a = 9 = 1001</li><li>b = 3 = 0011</li><li>c =11= 1011（只要上下有一个是1或者都是1，那结果就是1）</li></ul><p>按位异或符号很多小伙伴会以为是乘方运算，但是Java中并没有乘方运算符，<code>^</code>是按位异或运算符，不要记错了。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">9</span>, b = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">int</span> c = a ^ b;<br>    System.out.println(c);<br>}<br></code></pre></td></tr></tbody></table></figure><p>异或的意思就是只有两边不相同的情况下，结果才是1，也就是说一边是1一边是0的情况：</p><ul><li>a = 9 = 1001</li><li>b = 3 = 0011</li><li>c =10= 1010（从左往右第二位、第四位要么两个都是0，要么两个都是1，所以说结果为0）</li></ul><p>按位取反操作跟前面的正负号一样，只操作一个数，最好理解，如果这一位上是1，变成0，如果是0，变成1：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">byte</span> c = ~<span class="hljs-number">127</span>;<br>    System.out.println(c);<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>127 = 01111111</li><li>-128 = 10000000</li></ul><p>所以说计算的结果就是-128了。</p><p>除了以上的四个运算符之外，还有位移运算符，比如：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">byte</span> c = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>;    <span class="hljs-comment">//两个连续的小于符号，表示左移运算</span><br>    System.out.println(c);<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>1 = 00000001</li><li>4 = 00000100（左移两位之后，1跑到前面去了，尾部使用<strong>0</strong>填充，此时就是4）</li></ul><p>我们发现，左移操作每进行一次，结果就会x2，所以说，除了直接使用<code>*</code>进行乘2的运算之外，我们也可以使用左移操作来完成。</p><p>同样的，右移操作就是向右移动每一位咯：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">byte</span> c = <span class="hljs-number">8</span> &gt;&gt; <span class="hljs-number">2</span>;<br>    System.out.println(c);<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>8 = 00001000</li><li>2 = 00000010（右移两位之后，1跑到后面去了，头部使用<strong>符号位数字</strong>填充，此时变成2）</li></ul><p>跟上面一样，右移操作可以快速进行除以2的计算。</p><p>对于负数来说，左移和右移操作不会改变其符号位上的数字，符号位不受位移操作影响：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">byte</span> c = -<span class="hljs-number">4</span> &gt;&gt; <span class="hljs-number">1</span>;<br>    System.out.println(c);<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>-4   = 11111100</li><li>-2   = 11111110（前面这一长串1都被推到后面一位了，因为是负数，头部需要使用<strong>符号位数字</strong>来进行填充）</li></ul><p>我们来总结一下：</p><ul><li><strong>左移操作&lt;&lt;：</strong>高位直接丢弃，低位补0</li><li><strong>右移操作&gt;&gt;：</strong>低位直接丢弃，符号位是什么高位补什么</li></ul><p>我们也可以使用考虑符号位的右移操作，一旦考虑符号位，那么符号会被移动：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> c = -<span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;   <span class="hljs-comment">//正常的右移操作，高位补1，所以说移了还是-1</span><br>    System.out.println(c);<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> c = -<span class="hljs-number">1</span> &gt;&gt;&gt; <span class="hljs-number">1</span>;   <span class="hljs-comment">//无符号右移是三个大于符号连在一起，移动会直接考虑符号位</span><br>    System.out.println(c);<br>}<br></code></pre></td></tr></tbody></table></figure><p>比如：</p><ul><li>-1    =   11111111 11111111 11111111 11111111</li><li>右移：  01111111 11111111 11111111 11111111（无符号右移使用0填充高位）</li></ul><p>此时得到的结果就是正数的最大值 2147483647 了，注意，不存在无符号左移。</p><p>位移操作也可以缩写：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> c = -<span class="hljs-number">1</span>;<br>    c = c &lt;&lt; <span class="hljs-number">2</span>;<br>    System.out.println(c);<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以缩写为：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> c = -<span class="hljs-number">1</span>;<br>    c &lt;&lt;= <span class="hljs-number">2</span>;    <span class="hljs-comment">//直接运算符连上等号即可，跟上面是一样的</span><br>    System.out.println(c);<br>}<br></code></pre></td></tr></tbody></table></figure><p>最后我们还是来总结一下优先级：</p><table><thead><tr><th align="center">优先级</th><th align="center">运算符</th><th align="center">结合性</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">( )</td><td align="center">从左向右</td></tr><tr><td align="center">2</td><td align="center">~   -   +  (强制类型转换)  ++   –</td><td align="center">从右向左</td></tr><tr><td align="center">3</td><td align="center">*   /  %</td><td align="center">从左向右</td></tr><tr><td align="center">4</td><td align="center">+   -</td><td align="center">从左向右</td></tr><tr><td align="center">5</td><td align="center">&lt;&lt;   &gt;&gt;   &gt;&gt;&gt;</td><td align="center">从左向右</td></tr><tr><td align="center">6</td><td align="center">&amp;</td><td align="center">从左向右</td></tr><tr><td align="center">7</td><td align="center">^</td><td align="center">从左向右</td></tr><tr><td align="center">8</td><td align="center">|</td><td align="center">从左向右</td></tr><tr><td align="center">9</td><td align="center">=  +=  -=  *=   /=   %=   &amp;=   |=   ^=   &lt;&lt;=  &gt;&gt;=  &gt;&gt;&gt;=</td><td align="center">从右向左</td></tr></tbody></table><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>到目前为止，我们发现有一个基本数据类型很低调，在前面的计算中<code>boolean</code>类型一直都没有机会出场，而接下来就是它的主场。</p><p>我们可以对某些事物进行判断，比如我们想判断两个变量谁更大，我们可以使用关系运算符：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">boolean</span> c = a &gt; b;   <span class="hljs-comment">//进行判断，如果a &gt; b那么就会得到true，否则会得到false</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>关系判断的结果只可能是真或是假，所以说得到的结果是一个<code>boolean</code>类型的值。</p><p>关系判断运算符包括：</p><figure class="highlight asciidoc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">&gt;   大于<br>&lt;   小于<br><span class="hljs-section">==  等于（注意是两个等号连在一起，不是一个等号，使用时不要搞混了）</span><br>!=  不等于<br>&gt;=  大于等于<br>&lt;=  小于等于<br></code></pre></td></tr></tbody></table></figure><p>关系运算符的计算还是比较简单的。</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>前面我们介绍了简单的关系运算符，我们可以通过对关系的判断得到真或是假的结果，但是只能进行简单的判断，如果此时我们想要判断a是否小于等于100且大于等于60，就没办法了：</p><p><img src="https://s2.loli.net/2022/09/17/Z1yAPOKe8IVvFUt.png" alt="image-20220917223047110"></p><p>注意不能像这样进行判断，这是错误的语法，同时只能使用其中一种关系判断运算符。</p><p>为了解决这种问题，我们可以使用逻辑运算符，逻辑运算符包括：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&amp;&amp;     与运算，要求两边同时为<span class="hljs-keyword">true</span>才能返回<span class="hljs-keyword">true</span><br>||     或运算，要求两边至少要有一个为<span class="hljs-keyword">true</span>才能返回<span class="hljs-keyword">true</span><br>!      非运算，一般放在表达式最前面，表达式用括号扩起来，表示对表达式的结果进行反转<br></code></pre></td></tr></tbody></table></figure><p>现在，我们就可以使用逻辑运算符进行复杂条件判断：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">boolean</span> b = <span class="hljs-number">100</span> &gt;= a &amp;&amp; a &gt;= <span class="hljs-number">60</span>;   <span class="hljs-comment">//我们可以使用与运算符连接两个判断表达式</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>与运算符要求左右两边同时为真，得到的结果才是真，否则一律为假，上面的判断虽然满足第一个判断表达式，但是不满足第二个，所以说得到的结果就是<code>false</code>。</p><p>我们再来看下面的这个例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">150</span>;<br>    <span class="hljs-keyword">boolean</span> b = <span class="hljs-number">100</span> &gt;= a &amp;&amp; a &gt;= <span class="hljs-number">60</span>;  <span class="hljs-comment">//此时上来就不满足条件</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>这个例子中，第一个判断表达式就得到了<code>false</code>，此时不会再继续运行第二个表达式，而是直接得到结果<code>false</code>（逻辑运算符会出现短路的情况，只要第一个不是真，就算第二个是真也不可能了，所以说为了效率，后续就不用再判断了，在使用时一定要注意这一点）</p><p>同样的，比如我们现在要判断a要么大于10，要么小于0，这种关系就是一个或的关系：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">150</span>;<br>    <span class="hljs-keyword">boolean</span> b = a &lt; <span class="hljs-number">0</span> || a &gt; <span class="hljs-number">10</span>;   <span class="hljs-comment">//或运算要求两边只要有至少一边满足，结果就为true，如果都不满足，那么就是false</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>或运算同样会出现短路的情况，比如下面的例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = -<span class="hljs-number">9</span>;<br>    <span class="hljs-keyword">boolean</span> b = a &lt; <span class="hljs-number">0</span> || a &gt; <span class="hljs-number">10</span>;  <span class="hljs-comment">//此时上来就满足条件</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>因为第一个判断表达式就直接得到了<code>true</code>，那么第二个表达式无论是真还是假，结果都一定是<code>true</code>，所以说没必要继续向后进行判断了，直接得到结果<code>true</code>。</p><p>我们来看看下面的结果是什么：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">boolean</span> b = a++ &gt; <span class="hljs-number">10</span> &amp;&amp; ++a == <span class="hljs-number">12</span>;<br>    System.out.println(<span class="hljs-string">"a = "</span>+a + <span class="hljs-string">", b = "</span>+b);<br>}<br></code></pre></td></tr></tbody></table></figure><p>得到结果为：</p><p><img src="https://s2.loli.net/2022/09/17/tJQxnace7y4VdlY.png" alt="image-20220917224320699"></p><p>这是为什么呢？很明显我们的判断中a进行了两次自增操作，但是最后a的结果却是11，这是因为第一个表达式判断的结果为<code>false</code>，由于此时进行的是与运算，所以说直接短路，不会再继续判断了，因此第二个表达式就不会执行。</p><p>当然，除了与运算和或运算，还有一个非运算，这个就比较简单了，它可以将结果变成相反的样子，比如：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">boolean</span> b = !(a &gt; <span class="hljs-number">5</span>);   <span class="hljs-comment">//对a&gt;5的判断结果，进行非运算</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>因为上面的a &gt; 5判断为真，此时进行非运算会得到相反的结果，所以说最后b就是<code>false</code>了。</p><p>最后我们还需要介绍一个叫做三元运算符的东西，三元运算符可以根据判断条件，返回不同的结果，比如我们想要判断：</p><ul><li>当a &gt; 10时，给b赋值’A’</li><li>当a &lt;= 10时，给b赋值’B’</li></ul><p>我们就可以使用三元运算符来完成：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">char</span> b = a &gt; <span class="hljs-number">10</span> ? <span class="hljs-string">'A'</span> : <span class="hljs-string">'B'</span>;   <span class="hljs-comment">//三元运算符需要三个内容，第一个是判断语句，第二个是满足判断语句的值，第三个是不满足判断语句的值</span><br>    System.out.println(b);<br>}<br></code></pre></td></tr></tbody></table></figure><p>三元运算符：</p><figure class="highlight ada"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">判断语句 ? 结果<span class="hljs-number">1</span> : 结果2<br></code></pre></td></tr></tbody></table></figure><p>因此，上面的判断为假，所以说返回的是结果2，那么最后b得到的就是<code>B</code>这个字符了。</p><p>最后，我们来总结整个运算符板块学习到的所有运算符：</p><table><thead><tr><th align="center">优先级</th><th align="center">运算符</th><th align="center">结合性</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">( )</td><td align="center">从左向右</td></tr><tr><td align="center">2</td><td align="center">~   -   +  (强制类型转换)  ++   –</td><td align="center">从右向左</td></tr><tr><td align="center">3</td><td align="center">*   /  %</td><td align="center">从左向右</td></tr><tr><td align="center">4</td><td align="center">+   -</td><td align="center">从左向右</td></tr><tr><td align="center">5</td><td align="center">&lt;&lt;   &gt;&gt;   &gt;&gt;&gt;</td><td align="center">从左向右</td></tr><tr><td align="center">6</td><td align="center">&gt;   &lt;   &gt;=   &lt;=</td><td align="center">从左向右</td></tr><tr><td align="center">7</td><td align="center">==     !=</td><td align="center">从左向右</td></tr><tr><td align="center">8</td><td align="center">&amp;</td><td align="center">从左向右</td></tr><tr><td align="center">9</td><td align="center">^</td><td align="center">从左向右</td></tr><tr><td align="center">10</td><td align="center">|</td><td align="center">从左向右</td></tr><tr><td align="center">11</td><td align="center">&amp;&amp;</td><td align="center">从左向右</td></tr><tr><td align="center">12</td><td align="center">||</td><td align="center">从左向右</td></tr><tr><td align="center">13</td><td align="center">? :</td><td align="center">从右向左</td></tr><tr><td align="center">14</td><td align="center">=  +=  -=  *=   /=   %=   &amp;=   |=   ^=   &lt;&lt;=  &gt;&gt;=  &gt;&gt;&gt;=</td><td align="center">从右向左</td></tr></tbody></table><p>至此，我们已经学习了Java基础部分中所有的运算符。</p><hr><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>我们的程序都是从上往下依次运行的，但是，仅仅是这样还不够，我们需要更加高级的控制语句来使得程序更加有趣。比如，判断一个整数变量，大于1则输出yes，小于1则输出no，这时我们就需要用到选择结构来帮助我们完成条件的判断和程序的分支走向。学习过C语言就很轻松！</p><p>在前面我们介绍了运算符，我们可以通过逻辑运算符和关系运算符对某些条件进行判断，并得到真或是假的结果。这一部分我们将继续使用这些运算符进行各种判断。</p><h3 id="代码块与作用域"><a href="#代码块与作用域" class="headerlink" title="代码块与作用域"></a>代码块与作用域</h3><p>在开始流程控制语句之前，我们先来介绍一下代码块和作用域。</p><p>不知道各位小伙伴是否在一开始就注意到了，为什么程序中会有一些成对出现的花括号？这些花括号代表什么意思呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{   <span class="hljs-comment">//外层花括号</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{   <span class="hljs-comment">//内层花括号开始</span><br>       <br>    }  <span class="hljs-comment">//内层花括号结束</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以在花括号中编写一句又一句的代码，实际上这些被大括号囊括起来的内容，我们就称为<strong>块</strong>（代码块），一个代码块中可以包含多行代码，我们可以在里面做各种各样的事情，比如定义变量、进行计算等等。</p><p>我们可以自由地创建代码块：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{   <span class="hljs-comment">//现目前这个阶段，我们还是在主方法中编写代码，不要跑去外面写</span><br>    System.out.println(<span class="hljs-string">"外层"</span>);<br>    {   <span class="hljs-comment">//自由创建代码块</span><br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>        System.out.println(a);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>虽然创建了代码块，但实际上程序依然是按照从上到下的顺序在进行的，所以说这里还是在逐行运行，即使使用花括号囊括。那咋一看这不就是没什么卵用吗？我们来看看变量。</p><p>我们创建的变量，实际上是有作用域的，并不是在任何地方都可以使用，比如：</p><p><img src="https://s2.loli.net/2022/09/17/DdvU3aQmE25KbxM.png" alt="image-20220917231014796"></p><p>变量的使用范围，仅限于其定义时所处的代码块，一旦超出对应的代码块区域，那么就相当于没有这个变量了。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;   <span class="hljs-comment">//此时变量在最外层定义</span><br>    {<br>        System.out.println(a);   <span class="hljs-comment">//处于其作用域内部的代码块可以使用</span><br>    }<br>    System.out.println(a);   <span class="hljs-comment">//这里肯定也可以使用</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>我们目前所创建的变量都是局部变量（有范围限制），后面我们会介绍更多种类型的变量，了解了代码块及作用域之后，我们就可以正式开启流程控制语句的学习了。</p><h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><p>某些时候，我们希望进行判断，只有在条件为真时，才执行某些代码，这种情况就需要使用到选择分支语句，首先我们来认识一下<code>if</code>语句：</p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if (条件判断) 判断成功执行的代码<span class="hljs-comment">;</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">15</span>;<br>    <span class="hljs-keyword">if</span>(a == <span class="hljs-number">15</span>)    <span class="hljs-comment">//只有当a判断等于15时，才会执行下面的打印语句</span><br>      System.out.println(<span class="hljs-string">"Hello World!"</span>);<br>  System.out.println(<span class="hljs-string">"我是外层"</span>);   <span class="hljs-comment">//if只会对紧跟着的一行代码生效，后续的内容无效</span><br>}<br></code></pre></td></tr></tbody></table></figure><p><code>if</code>会进行判断，只有判断成功时才会执行紧跟着的语句，否则会直接跳过，注意，如果我们想要在if中执行多行代码，需要使用代码块将这些代码囊括起来（实际上代码块就是将多条语句复合到一起）所以说，我们以后使用if时，如果分支中有多行代码需要执行，就需要添加花括号，如果只有一行代码，花括号可以直接省略，包括我们后面会讲到的else、while、for语句都是这样的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">15</span>;<br>    <span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">10</span>) {    <span class="hljs-comment">//只有判断成功时，才会执行下面的代码块中内容，否则直接跳过</span><br>        System.out.println(<span class="hljs-string">"a大于10"</span>);<br>        System.out.println(<span class="hljs-string">"a的值为："</span>+a);<br>    }<br>  System.out.println(<span class="hljs-string">"我是外层"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>如果我们希望判断条件为真时执行某些代码，条件为假时执行另一些代码，我们可以在后面继续添加else语句：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">15</span>;<br>    <span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">10</span>) {    <span class="hljs-comment">//只有判断成功时，才会执行下面的代码块中内容，否则直接跳过</span><br>        System.out.println(<span class="hljs-string">"a大于10"</span>);<br>        System.out.println(<span class="hljs-string">"a的值为："</span>+a);<br>    } <span class="hljs-keyword">else</span> {   <span class="hljs-comment">//当判断不成功时，会执行else代码块中的代码</span><br>        System.out.println(<span class="hljs-string">"a小于10"</span>);<br>        System.out.println(<span class="hljs-string">"a的值为："</span>+a);<br>    }<br>    System.out.println(<span class="hljs-string">"我是外层"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p><code>if-else</code>语句就像两个分支，跟据不同的判断情况从而决定下一步该做什么，这跟我们之前认识的三元运算符性质比较类似。</p><p>那如果此时我们需要判断多个分支呢？比如我们现在希望判断学生的成绩，不同分数段打印的等级不一样，比如90以上就是优秀，70以上就是良好，60以上是及格，其他的都是不及格，那么这种我们又该如何判断呢？要像这样进行连续判断，我们需要使用<code>else-if</code>来完成：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> score =  <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(score &gt;= <span class="hljs-number">90</span>)    <span class="hljs-comment">//90分以上才是优秀</span><br>        System.out.println(<span class="hljs-string">"优秀"</span>);<br>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">70</span>)    <span class="hljs-comment">//当上一级if判断失败时，会继续判断这一级</span><br>        System.out.println(<span class="hljs-string">"良好"</span>);<br>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">60</span>)<br>        System.out.println(<span class="hljs-string">"及格"</span>);<br>     <span class="hljs-keyword">else</span>    <span class="hljs-comment">//当之前所有的if都判断失败时，才会进入到最后的else语句中</span><br>        System.out.println(<span class="hljs-string">"不及格"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>当然，<code>if</code>分支语句还支持嵌套使用，比如我们现在希望低于60分的同学需要补习，0-30分需要补Java，30-60分需要补C++，这时我们就需要用到嵌套：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> score =  <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(score &lt; <span class="hljs-number">60</span>) {   <span class="hljs-comment">//先判断不及格</span><br>        <span class="hljs-keyword">if</span>(score &gt; <span class="hljs-number">30</span>)    <span class="hljs-comment">//在内层再嵌套一个if语句进行进一步的判断</span><br>            System.out.println(<span class="hljs-string">"学习C++"</span>);<br>        <span class="hljs-keyword">else</span><br>            System.out.println(<span class="hljs-string">"学习Java"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>除了if自己可以进行嵌套使用之外，其他流程控制语句同样可以嵌套使用，也可以与其他流程控制语句混合嵌套使用。这样，我们就可以灵活地使用<code>if</code>来进行各种条件判断了。</p><p>前面我们介绍了if语句，我们可以通过一个if语句轻松地进行条件判断，然后根据对应的条件，来执行不同的逻辑，当然除了这种方式之外，我们也可以使用<code>switch</code>语句来实现，它更适用于多分支的情况：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span> (目标) {   <span class="hljs-comment">//我们需要传入一个目标，比如变量，或是计算表达式等</span><br>  <span class="hljs-keyword">case</span> 匹配值:    <span class="hljs-comment">//如果目标的值等于我们这里给定的匹配值，那么就执行case后面的代码</span><br>    代码...<br>    <span class="hljs-keyword">break</span>;    <span class="hljs-comment">//代码执行结束后需要使用break来结束，否则会溜到下一个case继续执行代码</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>比如现在我们要根据学生的等级进行分班，学生有ABC三个等级：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">char</span> c = <span class="hljs-string">'A'</span>;<br>    <span class="hljs-keyword">switch</span> (c) {  <span class="hljs-comment">//这里目标就是变量c</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'A'</span>:    <span class="hljs-comment">//分别指定ABC三个匹配值，并且执行不同的代码</span><br>            System.out.println(<span class="hljs-string">"去尖子班！准备冲刺985大学！"</span>);<br>            <span class="hljs-keyword">break</span>;   <span class="hljs-comment">//执行完之后一定记得break，否则会继续向下执行下一个case中的代码</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'B'</span>:<br>            System.out.println(<span class="hljs-string">"去平行班！准备冲刺一本！"</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'C'</span>:<br>            System.out.println(<span class="hljs-string">"去职高深造。"</span>);<br>            <span class="hljs-keyword">break</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><code>switch</code>可以精准匹配某个值，但是它不能进行范围判断，比如我们要判断分数段，这时用switch就很鸡肋了。</p><p>当然除了精准匹配之外，其他的情况我们可以用default来表示：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span> (目标) {<br>    <span class="hljs-keyword">case</span>: ...<br>    <span class="hljs-keyword">default</span>:<br>    其他情况下执行的代码<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们还是以刚才那个例子为例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">char</span> c = <span class="hljs-string">'A'</span>;<br>    <span class="hljs-keyword">switch</span> (c) {<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'A'</span>:<br>            System.out.println(<span class="hljs-string">"去尖子班！"</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'B'</span>:<br>            System.out.println(<span class="hljs-string">"去平行班！"</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'C'</span>:<br>            System.out.println(<span class="hljs-string">"去差生班！"</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:   <span class="hljs-comment">//其他情况一律就是下面的代码了</span><br>            System.out.println(<span class="hljs-string">"去读职高，分流"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>当然switch中可以继续嵌套其他的流程控制语句，比如if：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">char</span> c = <span class="hljs-string">'A'</span>;<br>    <span class="hljs-keyword">switch</span> (c) {<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'A'</span>:<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">'A'</span>) {    <span class="hljs-comment">//嵌套一个if语句</span><br>                System.out.println(<span class="hljs-string">"去尖子班！"</span>);<br>            }<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'B'</span>:<br>            System.out.println(<span class="hljs-string">"去平行班！"</span>);<br>            <span class="hljs-keyword">break</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>目前，我们已经认识了两种选择分支结构语句。</p><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><p>通过前面的学习，我们了解了如何使用分支语句来根据不同的条件执行不同的代码，我们接着来看第二种重要的流程控制语句：循环语句。</p><p>我们在某些时候，可能需要批量执行某些代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    System.out.println(<span class="hljs-string">"伞兵一号卢本伟准备就绪！"</span>);   <span class="hljs-comment">//把这句话给我打印三遍</span><br>    System.out.println(<span class="hljs-string">"伞兵一号卢本伟准备就绪！"</span>);<br>    System.out.println(<span class="hljs-string">"伞兵一号卢本伟准备就绪！"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>遇到这种情况，我们由于还没学习循环语句，那么就只能写N次来实现这样的多次执行。但是如果此时要求我们将一句话打印100遍、1000遍、10000遍，那么我们岂不是光CV代码就要搞一下午？</p><p>现在，要解决这种问题，我们可以使用for循环语句来多次执行：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (表达式<span class="hljs-number">1</span>;表达式<span class="hljs-number">2</span>;表达式<span class="hljs-number">3</span>) 循环体;<br></code></pre></td></tr></tbody></table></figure><p>介绍一下详细规则：</p><ul><li>表达式1：在循环开始时仅执行一次。</li><li>表达式2：每次循环开始前会执行一次，要求为判断语句，用于判断是否可以结束循环，若结果为真，那么继续循环，否则结束循环。</li><li>表达式3：每次循环完成后会执行一次。</li><li>循环体：每次循环都会执行一次循环体。</li></ul><p>一个标准的for循环语句写法如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>  <span class="hljs-comment">//比如我们希望让刚刚的打印执行3次</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)    <span class="hljs-comment">//这里我们在for语句中定义一个变量i，然后每一轮i都会自增，直到变成3为止</span><br>        System.out.println(<span class="hljs-string">"伞兵一号卢本伟准备就绪！"</span>);   <span class="hljs-comment">//这样，就会执行三轮循环，每轮循环都会执行紧跟着的这一句打印</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以使用调试来观察每一轮的变化，调试模式跟普通的运行一样，也会执行我们的Java程序，但是我们可以添加断点，也就是说当代码运行到断点位置时，会在这里暂停，我们可以观察当代码执行到这个位置时各个变量的值：</p><p><img src="https://s2.loli.net/2022/09/18/A8lRmNZCqxLStwQ.png" alt="image-20220918112006020"></p><p>调试模式在我们后面的学习中非常重要，影响深远，所以说各位小伙伴一定要学会。调试也很简单，我们只需要点击右上角的调试选项即可（图标像一个小虫子一样，因为调试的英文名称是Debug）</p><p><img src="https://s2.loli.net/2022/09/18/VKMGoJazvXAnh2k.png" alt="image-20220918112101677"></p><p>调试开始时，我们可以看到程序在断点位置暂停了：</p><p><img src="https://s2.loli.net/2022/09/18/Cdq1ifFvHwMuO29.png" alt="image-20220918112227207"></p><p>此时我们可以观察到当前的局部变量<code>i</code>的值，也可以直接在下方的调试窗口中查看：</p><p><img src="https://s2.loli.net/2022/09/18/e6AODRMCgqmGwTy.png" alt="image-20220918112409944"></p><p>随着循环的进行，i的值也会逐渐自增：</p><p><img src="https://s2.loli.net/2022/09/18/bS1DxpgwOfWhujy.png" alt="image-20220918112628585"></p><p>当<code>i</code>增长到2时，此时来到最后一轮循环，再继续向下运行，就不再满足循环条件了，所以说此时就会结束循环。</p><p>当然，如果要执行多条语句的话，只需要使用花括号囊括就行了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {<br>    System.out.println(<span class="hljs-string">"伞兵一号卢本伟准备就绪！"</span>);<br>    System.out.println(<span class="hljs-string">"当前i的值为："</span>+i);<br>}<br></code></pre></td></tr></tbody></table></figure><p>注意这里的<code>i</code>仅仅是for循环语句中创建的变量，所以说其作用域被限制在了循环体中，一旦离开循环体，那么就无法使用了：</p><p><img src="https://s2.loli.net/2022/09/18/2aO9Ro5yfMUvhNc.png" alt="image-20220918112923978"></p><p>但是我们可以将<code>i</code>的创建放到外面：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;   <span class="hljs-comment">//在外面创建变量i，这样全部范围内都可以使用了</span><br>    <span class="hljs-keyword">for</span> (; i &lt; <span class="hljs-number">3</span>; i++) {   <span class="hljs-comment">//for循环的三个表达式并不一定需要编写</span><br>        System.out.println(<span class="hljs-string">"伞兵一号卢本伟准备就绪！"</span>);<br>        System.out.println(<span class="hljs-string">"当前i的值为："</span>+i);<br>    }<br>    System.out.println(<span class="hljs-string">"当前i的值为："</span>+i);<br>}<br></code></pre></td></tr></tbody></table></figure><p>和之前的<code>if</code>一样，for循环同样支持嵌套使用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)    <span class="hljs-comment">//外层循环执行3次</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)    <span class="hljs-comment">//内层循环也执行3次</span><br>            System.out.println(<span class="hljs-string">"1！5！"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>上面的代码中，外层循环会执行3轮，而整个循环体又是一个循环语句，那么也就是说，每一轮循环都会执行里面的整个循环，里面的整个循环会执行3，那么总共就会执行3 x 3次，也就是9次打印语句。</p><p>实际上，for循环的三个表达式并不一定需要编写，我们甚至可以三个都不写：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">for</span> (;;)   <span class="hljs-comment">//如果什么都不写，相当于没有结束条件，这将会导致无限循环</span><br>        System.out.println(<span class="hljs-string">"伞兵一号卢本伟准备就绪！"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>如果没有表达式2，那么整个for循环就没有结束条件，默认会判定为真，此时就会出现无限循环的情况（无限循环是很危险的，因为它会疯狂地消耗CPU资源来执行循环，可能很快你的CPU就满载了，一定要避免）</p><p>当然，我们也可以在循环过程中提前终止或是加速循环的进行，这里我们需要认识两个新的关键字：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {<br>        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;   <span class="hljs-comment">//比如我们希望当i等于1时跳过这一轮，不执行后面的打印</span><br>        System.out.println(<span class="hljs-string">"伞兵一号卢本伟准备就绪！"</span>);<br>        System.out.println(<span class="hljs-string">"当前i的值为："</span>+i);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以使用<code>continue</code>关键字来跳过本轮循环，直接开启下一轮。这里的跳过是指，循环体中，无论后面有没有未执行的代码，一律不执行，比如上面的判断如果成功，那么将执行<code>continue</code>进行跳过，虽然后面还有打印语句，但是不会再去执行了，而是直接结束当前循环，开启下一轮。</p><p>在某些情况下，我们可能希望提前结束循环：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {<br>    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;   <span class="hljs-comment">//我们希望当i等于1时提前结束</span><br>    System.out.println(<span class="hljs-string">"伞兵一号卢本伟准备就绪！"</span>);<br>    System.out.println(<span class="hljs-string">"当前i的值为："</span>+i);<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以使用<code>break</code>关键字来提前终止整个循环，和上面一样，本轮循环中无论后续还有没有未执行的代码，都不会执行了，而是直接结束整个循环，跳出到循环外部。</p><p>虽然使用break和continue关键字能够更方便的控制循环，但是注意在多重循环嵌套下，它只对离它最近的循环生效（就近原则）：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">4</span>; ++i) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">4</span>; ++j) {<br>        <span class="hljs-keyword">if</span>(i == j) <span class="hljs-keyword">continue</span>;    <span class="hljs-comment">//当i == j时加速循环</span><br>        System.out.println(i+<span class="hljs-string">", "</span>+j);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>这里的<code>continue</code>加速的对象并不是外层的for，而是离它最近的内层for循环，<code>break</code>也是同样的规则：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">4</span>; ++i) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">4</span>; ++j) {<br>        <span class="hljs-keyword">if</span>(i == j) <span class="hljs-keyword">break</span>;    <span class="hljs-comment">//当i == j时终止循环</span><br>        System.out.println(i+<span class="hljs-string">", "</span>+j);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>那么，要是我们就是想要终止或者是加速外层循环呢？我们可以为循环语句打上标记：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">outer: <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">4</span>; ++i) {   <span class="hljs-comment">//在循环语句前，添加 标签: 来进行标记</span><br>    inner: <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">4</span>; ++j) {<br>        <span class="hljs-keyword">if</span>(i == j) <span class="hljs-keyword">break</span> outer;    <span class="hljs-comment">//break后紧跟要结束的循环标记，当i == j时终止外层循环</span><br>        System.out.println(i+<span class="hljs-string">", "</span>+j);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>如果一个代码块中存在多个循环，那么直接对当前代码块的标记执行<code>break</code>时会直接跳出整个代码块：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">outer: {    <span class="hljs-comment">//直接对整个代码块打标签</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">7</span>){<br>            System.out.println(<span class="hljs-string">"Test"</span>);<br>            <span class="hljs-keyword">break</span> outer;   <span class="hljs-comment">//执行break时，会直接跳出整个代码块，而不是第一个循环</span><br>        }<br>    }<br><br>    System.out.println(<span class="hljs-string">"？？？"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>虽然效果挺奇特的，但是一般情况下没人这么玩，所以说了解就行了。</p><p>前面我们介绍了for循环语句，我们接着来看第二种while循环，for循环要求我们填写三个表达式，而while相当于是一个简化版本，它只需要我们填写循环的维持条件即可，比如：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(循环条件) 循环体;<br></code></pre></td></tr></tbody></table></figure><p>相比for循环，while循环更多的用在不明确具体的结束时机的情况下，而for循环更多用于明确知道循环的情况，比如我们现在明确要进行循环10次，此时用for循环会更加合适一些，又比如我们现在只知道当<code>i</code>大于10时需要结束循环，但是<code>i</code>在循环多少次之后才不满足循环条件我们并不知道，此时使用while就比较合适了。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">100</span>;   <span class="hljs-comment">//比如现在我们想看看i不断除以2得到的结果会是什么，但是循环次数我们并不明确</span><br>    <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) {   <span class="hljs-comment">//现在唯一知道的是循环条件，只要大于0那么就可以继续除</span><br>        System.out.println(i);<br>        i /= <span class="hljs-number">2</span>;   <span class="hljs-comment">//每次循环都除以2</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>上面的这种情况就非常适合使用while循环。</p><p>和for循环一样，while也支持使用break和continue来进行循环的控制，以及嵌套使用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) {<br>        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">10</span>) <span class="hljs-keyword">break</span>;<br>        System.out.println(i);<br>        i /= <span class="hljs-number">2</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们也可以反转循环判断的时机，可以先执行循环内容，然后再做循环条件判断，这里要用到<code>do-while</code>语句：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;   <span class="hljs-comment">//比如现在我们想看看i不断除以2得到的结果会是什么，但是循环次数我们并不明确</span><br>    <span class="hljs-keyword">do</span> {  <span class="hljs-comment">//无论满不满足循环条件，先执行循环体里面的内容</span><br>        System.out.println(<span class="hljs-string">"Hello World!"</span>);<br>        i++;<br>    } <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">10</span>);   <span class="hljs-comment">//再做判断，如果判断成功，开启下一轮循环，否则结束</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>至此，面向过程相关的内容就讲解完毕了，从下一章开始，我们将进入面向对象编程的学习（类、数组、字符串）</p><hr><h2 id="实战练习"><a href="#实战练习" class="headerlink" title="实战练习"></a>实战练习</h2><p>面向过程的内容全部学习完成，我们来做几个练习题吧！</p><h3 id="寻找水仙花数"><a href="#寻找水仙花数" class="headerlink" title="寻找水仙花数"></a>寻找水仙花数</h3><blockquote><p>“水仙花数（Narcissistic number）也被称为超完全数字不变数（pluperfect digital invariant, PPDI）、自恋数、自幂数、阿姆斯壮数或阿姆斯特朗数（Armstrong number），水仙花数是指<strong>一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身。</strong>例如：1^3 + 5^3+ 3^3 = 153。”</p></blockquote><p>现在请你设计一个Java程序，打印出所有1000以内的水仙花数。</p><h3 id="打印九九乘法表"><a href="#打印九九乘法表" class="headerlink" title="打印九九乘法表"></a>打印九九乘法表</h3><p><img src="https://s2.loli.net/2022/09/18/zy1wuvj6gfHmAZS.jpg" alt="img"></p><p>现在我们要做的是在我们的程序中，也打印出这样的一个乘法表出来，请你设计一个Java程序来实现它。</p><p><img src="https://s2.loli.net/2022/09/18/Iek7OnbRoTw46Cl.jpg" alt="img"></p><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><blockquote><p>斐波那契数列（Fibonacci sequence），又称<a href="https://baike.baidu.com/item/%E9%BB%84%E9%87%91%E5%88%86%E5%89%B2/115896">黄金分割</a>数列，因数学家莱昂纳多·斐波那契（Leonardo Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：<strong>1、1、2、3、5、8、13、21、34、……</strong>在数学上，斐波那契数列以如下被以递推的方法定义：<em>F</em>(0)=0，<em>F</em>(1)=1, <em>F</em>(n)=<em>F</em>(n - 1)+<em>F</em>(n - 2)（<em>n</em> ≥ 2，<em>n</em> ∈ N*）在现代物理、准<a href="https://baike.baidu.com/item/%E6%99%B6%E4%BD%93%E7%BB%93%E6%9E%84/10401467">晶体结构</a>、化学等领域，斐波纳契数列都有直接的应用，为此，美国数学会从 1963 年起出版了以《斐波纳契数列季刊》为名的一份数学杂志，用于专门刊载这方面的研究成果。</p></blockquote><p>斐波那契数列：1，1，2，3，5，8，13，21，34，55，89…，不难发现一个规律，实际上从第三个数开始，每个数字的值都是前两个数字的和，现在请你设计一个Java程序，可以获取斐波那契数列上任意一位的数字，比如获取第5个数，那么就是5。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> target = <span class="hljs-number">7</span>, result;  <span class="hljs-comment">//target是要获取的数，result是结果</span><br><br>    <span class="hljs-comment">//请在这里实现算法</span><br><br>    System.out.println(result);<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/09/16/ymtrNQlPu9Loh27.png&quot; alt=&quot;image-20220916174714019&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;面向过程篇&quot;&gt;&lt;a href=&quot;#面向过程篇&quot; class=&quot;headerlink&quot; title=&quot;面向过程篇&quot;&gt;&lt;/a&gt;面向过程篇&lt;/h1&gt;&lt;p&gt;前面我们已经认识了Java语言的相关特性，并且已经成功配置好了开发环境，从这节课开始，我们就可以正式进入到Java语言的学习当中了。Java语言是一门面向对象的语言，但是在面向对象之前，我们还得先学会如何面向过程编程。&lt;/p&gt;
&lt;h2 id=&quot;Java程序基础&quot;&gt;&lt;a href=&quot;#Java程序基础&quot; class=&quot;headerlink&quot; title=&quot;Java程序基础&quot;&gt;&lt;/a&gt;Java程序基础&lt;/h2&gt;&lt;p&gt;首先我们还是从最基本的Java程序基础开始讲解。&lt;/p&gt;
&lt;h3 id=&quot;程序代码基本结构&quot;&gt;&lt;a href=&quot;#程序代码基本结构&quot; class=&quot;headerlink&quot; title=&quot;程序代码基本结构&quot;&gt;&lt;/a&gt;程序代码基本结构&lt;/h3&gt;&lt;p&gt;还记得我们之前使用的示例代码吗？&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Main&lt;/span&gt; &lt;/span&gt;{&lt;br&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br&gt;        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello World!&quot;&lt;/span&gt;);&lt;br&gt;    }&lt;br&gt;}&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这段代码要实现的功能很简单，就是将 Hello World 输出到控制台就行。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://xiaofanshutu.github.io/posts/0.html"/>
    <id>https://xiaofanshutu.github.io/posts/0.html</id>
    <published>2025-09-07T23:26:13.331Z</published>
    <updated>2025-09-07T23:28:25.711Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://s2.loli.net/2022/09/18/UsqxV8ndNzYmGjy.png" alt="image-20220918121719900"></p><h1 id="面向对象基础篇"><a href="#面向对象基础篇" class="headerlink" title="面向对象基础篇"></a>面向对象基础篇</h1><p>我们在前面已经学习了面向过程编程，也可以自行编写出简单的程序了。我们接着就需要认识 面向对象程序设计（Object Oriented Programming）它是我们在Java语言中要学习的重要内容，面向对象也是高级语言的一大重要特性。</p><blockquote><p>面向对象是新手成长的一道分水岭，有的人秒懂，有的人直到最后都无法理解。</p></blockquote><p>这一章开始难度就上来了，所以说请各位小伙伴一定认真。</p><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><p>类的概念我们在生活中其实已经听说过很多了。</p><p>人类、鸟类、鱼类… 所谓类，就是对一类事物的描述，是抽象的、概念上的定义，比如鸟类，就泛指所有具有鸟类特征的动物。比如人类，不同的人，有着不同的性格、不同的爱好、不同的样貌等等，但是他们根本上都是人，所以说可以将他们抽象描述为人类。</p><p>对象是某一类事物实际存在的每个个体，因而也被称为实例（instance）我们每个人都是人类的一个实际存在的个体。</p><p><img src="https://s2.loli.net/2022/09/19/U2P7qWOtRz5bhFY.png" alt="image-20220919203119479"></p><p>所以说，类就是抽象概念的人，而对象，就是具体的某一个人。</p><ul><li>A：是谁拿走了我的手机？</li><li>B：是个人。（某一个类）</li><li>A：我还知道是个人呢，具体是谁呢？</li><li>B：是XXX。（具体某个对象）</li></ul><p>而我们在Java中，也可以像这样进行编程，我们可以定义一个类，然后进一步创建许多这个类的实例对象。像这种编程方式，我们称为<strong>面向对象编程</strong>。</p><h3 id="类的定义与对象创建"><a href="#类的定义与对象创建" class="headerlink" title="类的定义与对象创建"></a>类的定义与对象创建</h3><p>前面我们介绍了什么是类，什么是对象，首先我们就来看看如何去定义一个类。</p><p>比如现在我们想要定义一个人类，我们可以右键<code>src</code>目录，点击创建新的类：</p><p><img src="https://s2.loli.net/2022/09/19/alOtdE1JNcbpxM8.png" alt="image-20220919204004526"></p><p>我们在对类进行命名时，一般使用英文单词，并且首字母大写，跟变量命名一样，不能出现任何的特殊字符。</p><p><img src="https://s2.loli.net/2022/09/19/n1WuVYRiPeOfHqZ.png" alt="image-20220919204159248"></p><p>可以看到，现在我们的目录下有了两个<code>.java</code>源文件，其中一个是默认创建的Main.java，还有一个是我们刚刚创建的类。</p><p>我们来看看创建好之后，一个类写了哪些内容：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{<br>    <br>}<br></code></pre></td></tr></tbody></table></figure><p>可以发现，这不是跟一开始创建的Main中写的格式一模一样吗？没错，Main也是一个类，只不过我们一直都将其当做主类在使用，也就是编写主方法的类，关于方法我们会在后面进行介绍。</p><p>现在我们就创建好了一个类，既然是人类，那么肯定有人相关的一些属性，比如名字、性别、年龄等等，那么怎么才能给这个类添加一些属性呢？</p><p>我们可以将这些属性直接作为类的成员变量（成员变量相当于是这个类所具有的属性，每个实例创建出来之后，这些属性都可能会各不相同）定义到类中。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{   <span class="hljs-comment">//这里定义的人类具有三个属性，名字、年龄、性别</span><br>    String name;   <span class="hljs-comment">//直接在类中定义变量，表示类具有的属性</span><br>    <span class="hljs-keyword">int</span> age;<br>    String sex;<br>}<br></code></pre></td></tr></tbody></table></figure><p>可能会有小伙伴疑问，这些变量啥时候被赋值呢？实际上这些变量只有在一个具体的对象中才可以使用。</p><p>那么现在人类的属性都规定好了，我们就可以尝试创建一个实例对象了，实例对应的应该是一个具体的人：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 类名();<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">new</span> Person();   <span class="hljs-comment">//我们可以使用new关键字来创建某个类的对象，注意new后面需要跟上 类名()</span><br>  <span class="hljs-comment">//这里创建出来的，就是一个具体的人了</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>实际上整个流程为：</p><p><img src="https://s2.loli.net/2022/09/19/dSM4XDBV7qkIUlb.png" alt="image-20220919205550104"></p><p>只不过这里仅仅是创建出了这样的一个对象，我们目前没有办法去操作这个对象，比如想要修改或是获取这个人的名字等等。</p><h3 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h3><p>既然现在我们知道如何创建对象，那么我们怎么去访问这个对象呢，比如我现在想要去查看或是修改它的名字。</p><p>我们同样可以使用一个变量来指代某个对象，只不过引用类型的变量，存储的是对象的引用，而不是对象本身：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>  <span class="hljs-comment">//这里的a存放的是具体的某个值</span><br>  <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-comment">//创建一个变量指代我们刚刚创建好的对象，变量的类型就是对应的类名</span><br>  <span class="hljs-comment">//这里的p存放的是对象的引用，而不是本体，我们可以通过对象的引用来间接操作对象</span><br>    Person p = <span class="hljs-keyword">new</span> Person();<br>}<br></code></pre></td></tr></tbody></table></figure><p>至于为什么对象类型的变量存放的是对象的引用，比如：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Person p1 = <span class="hljs-keyword">new</span> Person();<br>    Person p2 = p1;<br>}<br></code></pre></td></tr></tbody></table></figure><p>这里，我们将变量p2赋值为p1的值，那么实际上只是传递了对象的引用，而不是对象本身的复制，这跟我们前面的基本数据类型有些不同，p2和p1都指向的是同一个对象（如果你学习过C语言，它就类似于指针一样的存在）</p><p><img src="https://s2.loli.net/2022/09/19/GBPaNZsr2MSKvCq.png" alt="image-20220919211443657"></p><p>我们可以来测试一下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Person p1 = <span class="hljs-keyword">new</span> Person();<br>    Person p2 = p1;<br>    System.out.println(p1 == p2);    <span class="hljs-comment">//使用 == 可以判断两个变量引用的是不是同一个对象</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>但是如果我们像这样去编写：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Person p1 = <span class="hljs-keyword">new</span> Person();   <span class="hljs-comment">//这两个变量分别引用的是不同的两个对象</span><br>    Person p2 = <span class="hljs-keyword">new</span> Person();<br>    System.out.println(p1 == p2);   <span class="hljs-comment">//如果两个变量存放的是不同对象的引用，那么肯定就是不一样的了</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>实际上我们之前使用的String类型，也是一个引用类型，我们会在下一章详细讨论。我们在上一章介绍的都是基本类型，而类使用的都是引用类型。</p><p>现在我们有了对象的引用之后，我们就可以进行操作了：</p><p><img src="https://s2.loli.net/2022/09/19/cEJ1CWshtQFbZzy.png" alt="image-20220919210058797"></p><p>我们可以直接访问对象的一些属性，也就是我们在类中定义好的那些，对于不同的对象，这些属性都具体存放值也会不同。</p><p>比如我们可以修改对象的名字：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Person p = <span class="hljs-keyword">new</span> Person();<br>    p.name = <span class="hljs-string">"小明"</span>;   <span class="hljs-comment">//要访问对象的属性，我们需要使用 . 运算符</span><br>    System.out.println(p.name);   <span class="hljs-comment">//直接打印对象的名字，就是我们刚刚修改好的结果了</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>注意，不同对象的属性是分开独立存放的，每个对象都有一个自己的空间，修改一个对象的属性并不会影响到其他对象：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Person p1 = <span class="hljs-keyword">new</span> Person();<br>    Person p2 = <span class="hljs-keyword">new</span> Person();<br>    p1.name = <span class="hljs-string">"小明"</span>;   <span class="hljs-comment">//这个修改的是第一个对象的属性</span><br>    p2.name = <span class="hljs-string">"大明"</span>;   <span class="hljs-comment">//这里修改的是第二个对象的属性</span><br>    System.out.println(p1.name);  <span class="hljs-comment">//这里我们获取的是第一个对象的属性</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>关于对象类型的变量，我们也可以不对任何对象进行引用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Person p1 = <span class="hljs-keyword">null</span>;  <span class="hljs-comment">//null是一个特殊的值，它表示空，也就是不引用任何的对象</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>注意，如果不引用任何的对象，那肯定是不应该去通过这个变量去操作所引用的对象的（都没有引用对象，我操作谁啊我）</p><p>虽然这样可以编译通过，但是在运行时会出现问题：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Person p = <span class="hljs-keyword">null</span>;   <span class="hljs-comment">//此时变量没有引用任何对象</span><br>    p.name = <span class="hljs-string">"小红"</span>;   <span class="hljs-comment">//我任性，就是要操作</span><br>    System.out.println(p.name);<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们来尝试运行一下这段代码：</p><p><img src="https://s2.loli.net/2022/09/19/hkME1wf58aSdWGZ.png" alt="image-20220919213732810"></p><p>此时程序在运行的过程中，出现了异常，虽然我们还没有学习到异常，但是各位可以将异常理解为程序在运行过程中出现了问题，此时不得不终止程序退出。</p><p>这里出现的是空指针异常，很明显是因为我们去操作一个值为null的变量导致的。在我们以后的学习中，这个异常是出现频率最高的。</p><p>我们来看最后一个问题，对象创建成功之后，它的属性没有进行赋值，但是我们前面说了，变量使用之前需要先赋值，那么创建对象之后能否直接访问呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Person p = <span class="hljs-keyword">new</span> Person();<br>    System.out.println(<span class="hljs-string">"name = "</span>+p.name);<br>    System.out.println(<span class="hljs-string">"age = "</span>+p.age);<br>    System.out.println(<span class="hljs-string">"sex = "</span>+p.sex);<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们来看看运行结果：</p><p><img src="https://s2.loli.net/2022/09/19/zDRdFwhm6nebSJU.png" alt="image-20220919214248053"></p><p>我们可以看到，如果直接创建对象，那么对象的属性都会存在初始值，如果是基本类型，那么默认是统一为<code>0</code>（如果是boolean的话，默认值为false）如果是引用类型，那么默认是<code>null</code>。</p><h3 id="方法创建与使用"><a href="#方法创建与使用" class="headerlink" title="方法创建与使用"></a>方法创建与使用</h3><p>前面我们介绍了类的定义以及对象的创建和使用。</p><p>现在我们的类有了属性，我们可以为创建的这些对象设定不同的属性值，比如每个人的名字都不一样，性别不一样，年龄不一样等等。只不过光有属性还不行，对象还需要具有一定的行为，就像我们人可以行走，可以跳跃，可以思考一样。</p><p>而对象也可以做出一些行为，我们可以通过定义方法来实现（在C语言中叫做函数）</p><p>方法是语句的集合，是为了完成某件事情而存在的。完成某件事情，可以有结果，也可以做了就做了，不返回结果。比如计算两个数字的和，我们需要得到计算后的结果，所以说方法需要有返回值；又比如，我们只想吧数字打印在控制台，只需要打印就行，不用给我结果，所以说方法不需要有返回值。</p><p>方法的定义如下：</p><figure class="highlight dust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">返回值类型 方法名称() </span><span class="hljs-template-variable">{</span><br><span class="hljs-template-variable">方法体...</span><br><span class="hljs-template-variable">}</span><br></code></pre></td></tr></tbody></table></figure><p>首先是返回值类型，也就是说这个方法完成任务之后，得到的结果的数据类型（可以是基本类型，也可以是引用类型）当然，如果没有返回值，只是完成任务，那么可以使用<code>void</code>表示没有返回值，比如我们现在给人类编写一个自我介绍的行为：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{<br>    String name;<br>    <span class="hljs-keyword">int</span> age;<br>    String sex;<br><br>  <span class="hljs-comment">//自我介绍只需要完成就行，没有返回值，所以说使用void</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>{<br>      <span class="hljs-comment">//完成自我介绍需要执行的所有代码就在这个花括号中编写</span><br>      <span class="hljs-comment">//这里编写代码跟我们之前在main中是一样的（实际上main就是一个函数）</span><br>      <span class="hljs-comment">//自我介绍需要用到当前对象的名字和年龄，我们直接使用成员变量即可，变量的值就是当前对象的存放值</span><br>        System.out.println(<span class="hljs-string">"我叫 "</span>+name+<span class="hljs-string">" 今年 "</span>+age+<span class="hljs-string">" 岁了！"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>注意，方法名称同样可以随便起，但是规则跟变量的命名差不多，也是尽量使用小写字母开头的单词，如果是多个单词，一般使用驼峰命名法最规范。</p><p><img src="https://s2.loli.net/2022/09/20/2vmhsCRXpPzojiD.png" alt="image-20220920101033325"></p><p>现在我们给人类定义好了一个方法（行为）那么怎么才能让对象执行这个行为呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Person p = <span class="hljs-keyword">new</span> Person();<br>    p.name = <span class="hljs-string">"小明"</span>;<br>    p.age = <span class="hljs-number">18</span>;<br>    p.hello();    <span class="hljs-comment">//我们只需要使用 . 运算符，就可以执行定义好的方法了，只需要 .方法名称() 即可</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>像这样执行定义好的方法，我们一般称为<strong>方法的调用</strong>，我们来看看效果：</p><p><img src="https://s2.loli.net/2022/09/19/bR2PAWoJ8qUzCfh.png" alt="image-20220919220837991"></p><p>比如现在我们要让人类学会加法运算，我们也可以通过定义一个方法的形式来完成，只不过，要完成加法运算，我们需要别人给人类提供两个参与加法运算的值才可以，所以我们这里就要用到参数了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//我们的方法需要别人提供参与运算的值才可以</span><br><span class="hljs-comment">//我们可以为方法设定参数，在调用方法时，需要外部传入参数才可以</span><br><span class="hljs-comment">//参数的定义需要在小括号内部编写，类似于变量定义，需要填写 类型和参数名称，多个参数用逗号隔开</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>{   <span class="hljs-comment">//这里需要两个int类型的参数进行计算</span><br><br>}<br></code></pre></td></tr></tbody></table></figure><p>那么现在参数从外部传入之后，我们怎么使用呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>{   <span class="hljs-comment">//这里的参数，相当于我们在函数中定义了两个局部变量，我们可以直接在方法中使用</span><br>    <span class="hljs-keyword">int</span> c = a + b;   <span class="hljs-comment">//直接c = a + b</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>那么现在计算完成了，我们该怎么将结果传递到外面呢？首先函数的返回值是int类型，我们只需要使用<code>return</code>关键字来返回一个int类型的结果就可以了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>{<br>    <span class="hljs-keyword">int</span> c = a + b;<br>    <span class="hljs-keyword">return</span> c;   <span class="hljs-comment">//return后面紧跟需要返回的结果，这样就可以将计算结果丢出去了</span><br>  <span class="hljs-comment">//带返回值的方法，是一定要有一个返回结果的！否则无法通过编译！</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>我们来测试一下吧：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Person p = <span class="hljs-keyword">new</span> Person();<br>    p.name = <span class="hljs-string">"小明"</span>;<br>    p.age = <span class="hljs-number">18</span>;<br>    <span class="hljs-keyword">int</span> result = p.sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);    <span class="hljs-comment">//现在我们要让这个对象帮我们计算10 + 20的结果</span><br>    System.out.println(result);    <span class="hljs-comment">//成功得到30，实际上这里的println也是在调用方法进行打印操作</span><br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>注意：</strong>方法定义时编写的参数，我们一般称为形式参数，而调用方法实际传入的参数，我们成为实际参数。</p><p>是不是越来越感觉我们真的在跟一个对象进行交互？只要各位有了这样的体验，基本上就已经摸到面向对象的门路了。</p><p>关于<code>return</code>关键字，我们还需要进行进一步的介绍。</p><p>在我们使用<code>return</code>关键字之后，方法就会直接结束并返回结果，所以说在这之后编写的任何代码，都是不可到达的：</p><p><img src="https://s2.loli.net/2022/09/19/UCcAb9L8lfOzXMZ.png" alt="image-20220919222813469"></p><p>在<code>return</code>后编写代码，会导致编译不通过，因为存在不可达语句。</p><p>如果我们的程序中出现了分支语句，那么必须保证每一个分支都有返回值才可以：</p><p><img src="https://s2.loli.net/2022/09/19/WjUlRrPwA9EXThV.png" alt="image-20220919223037197"></p><p>只要有任何一个分支缺少了<code>return</code>语句，都无法正常通过编译，总之就是必须考虑到所有的情况，任何情况下都必须要有返回值。</p><p>当然，如果方法没有返回值，我们也可以使用<code>return</code>语句，不需要跟上任何内容，只不过这种情况下使用，仅仅是为了快速结束方法的执行：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>{<br>    <span class="hljs-keyword">if</span>(a == <span class="hljs-number">10</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-comment">//当a等于10时直接结束方法，后面无论有没有代码都不会执行了</span><br>    System.out.println(<span class="hljs-string">"Hello World!"</span>);   <span class="hljs-comment">//不是的情况就正常执行</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>最后我们来讨论一下参数的传递问题：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>{   <span class="hljs-comment">//我们可以设置参数来让外部的数据传入到函数内部</span><br>    System.out.println(a);<br>}<br></code></pre></td></tr></tbody></table></figure><p>实际上参数的传递，会在调用方法的时候，对参数的值进行复制，方法中的参数变量，不是我们传入的变量本身，我们来下面的这个例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>{   <span class="hljs-comment">//这个函数的目的很明显，就是为了交换a和b的值</span><br>    <span class="hljs-keyword">int</span> tmp = a;<br>    a = b;<br>    b = a;<br>}<br></code></pre></td></tr></tbody></table></figure><p>那么我们来测试一下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Person p = <span class="hljs-keyword">new</span> Person();<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>, b = <span class="hljs-number">9</span>;   <span class="hljs-comment">//外面也叫a和b</span><br>    p.swap(a, b);<br>    System.out.println(<span class="hljs-string">"a = "</span>+a+<span class="hljs-string">", b = "</span>+b);   <span class="hljs-comment">//最后的结果会变成什么样子呢？</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>我们来看看结果是什么：</p><p><img src="https://s2.loli.net/2022/09/19/wJrLaT7YBeQipNV.png" alt="image-20220919224219071"></p><p>我们发现a和b的值并没有发生交换，但是按照我们的方法逻辑来说，应该是会交换才对，这是为什么呢？实际上这里仅仅是将值复制给了函数里面的变量而已（相当于是变量的赋值）</p><p><img src="https://s2.loli.net/2022/09/19/WdiDToucsCvySNf.png" alt="image-20220919224623727"></p><p>所以说我们交换的仅仅是方法中的a和b，参数传递仅仅是值传递，我们是没有办法直接操作到外面的a和b的。</p><p>那么各位小伙伴看看下面的例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(Person person)</span></span>{<br>    person.name = <span class="hljs-string">"lbwnb"</span>;   <span class="hljs-comment">//修改对象的名称</span><br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Person p = <span class="hljs-keyword">new</span> Person();<br>    p.name = <span class="hljs-string">"小明"</span>;     <span class="hljs-comment">//先在外面修改一次</span><br>    p.modify(p);        <span class="hljs-comment">//调用方法再修改一次</span><br>    System.out.println(p.name);    <span class="hljs-comment">//请问最后name会是什么？</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>我们来看看结果：</p><p><img src="https://s2.loli.net/2022/09/19/sNLjlYP6g3yxpe1.png" alt="image-20220919224957971"></p><p>不对啊，前面不是说只是值传递吗，怎么这里又可以修改成功呢？</p><p>确实，这里同样是进行的值传递，只不过各位小伙伴别忘了，我们前面可是说的清清楚楚，引用类型的变量，仅仅存放的是对象的引用，而不是对象本身。那么这里进行了值传递，相当于将对象的引用复制到了方法内部的变量中，而这个内部的变量，依然是引用的同一个对象，所以说这里在方法内操作，相当于直接操作外面的定义对象。</p><p><img src="https://s2.loli.net/2022/09/19/aXf6AsdLneKxi9V.png" alt="image-20220919225455752"></p><h3 id="方法进阶使用"><a href="#方法进阶使用" class="headerlink" title="方法进阶使用"></a>方法进阶使用</h3><p>有时候我们的方法中可能会出现一些与成员变量重名的变量：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//我们希望使用这个方法，来为当前对象设定名字</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>{<br>   <br>}<br></code></pre></td></tr></tbody></table></figure><p>此时类中定义的变量名称也是<code>name</code>，那么我们是否可以这样编写呢：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>{<br>    name = name;    <span class="hljs-comment">//出现重名时，优先使用作用域最接近的，这里实际上是将方法参数的局部变量name赋值为本身</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>我们来测试一下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Person p = <span class="hljs-keyword">new</span> Person();<br>    p.setName(<span class="hljs-string">"小明"</span>);<br>    System.out.println(p.name);<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现，似乎这样做并没有任何的效果，name依然是没有修改的状态。那么当出现重名的时候，因为默认情况下会优先使用作用域最近的变量，我们怎么才能表示要使用的变量是类的成员变量呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Person p = <span class="hljs-keyword">new</span> Person();<br>p.name = <span class="hljs-string">"小明"</span>;    <span class="hljs-comment">//我们之前在外面使用时，可以直接通过对象.属性的形式访问到</span><br></code></pre></td></tr></tbody></table></figure><p>同样的，我们如果想要在方法中访问到当前对象的属性，那么可以使用<code>this</code>关键字，来明确表示当前类的示例对象本身：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>{<br>    <span class="hljs-keyword">this</span>.name = name;   <span class="hljs-comment">//让当前对象的name变量值等于参数传入的值</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>这样就可以修改成功了，当然，如果方法内没有变量出现重名的情况，那么默认情况下可以不使用<code>this</code>关键字来明确表示当前对象：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">return</span> name;    <span class="hljs-comment">//这里没有使用this，但是当前作用域下只有对象属性的name变量，所以说直接就使用了</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>我们接着来看方法的重载。</p><p>有些时候，参数类型可能会多种多样，我们的方法需要能够同时应对多种情况：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>{<br>    <span class="hljs-keyword">return</span> a + b;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Person p = <span class="hljs-keyword">new</span> Person();<br>    System.out.println(p.sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>));    <span class="hljs-comment">//这里可以正常计算两个整数的和</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>但是要是我们现在不仅要让人类会计算整数，还要会计算小数呢？</p><p><img src="https://s2.loli.net/2022/09/20/m7BvM1RctLznhrA.png" alt="image-20220920102347110"></p><p>当我们使用小数时，可以看到，参数要求的是int类型，那么肯定会出现错误，这个方法只能用于计算整数。此时，为了让这个方法支持使用小数进行计算，我们可以将这个方法进行重载。</p><p>一个类中可以包含多个同名的方法，但是需要的形式参数不一样，方法的返回类型，可以相同，也可以不同，但是仅返回类型不同，是不允许的！</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>{<br>    <span class="hljs-keyword">return</span> a + b;<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a, <span class="hljs-keyword">double</span> b)</span></span>{    <span class="hljs-comment">//为了支持小数加法，我们可以进行一次重载</span><br>    <span class="hljs-keyword">return</span> a + b;<br>}<br></code></pre></td></tr></tbody></table></figure><p>这样就可以正常使用了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Person p = <span class="hljs-keyword">new</span> Person();<br>  <span class="hljs-comment">//当方法出现多个重载的情况，在调用时会自动进行匹配，选择合适的方法进行调用</span><br>    System.out.println(p.sum(<span class="hljs-number">1.5</span>, <span class="hljs-number">2.2</span>));<br>}<br></code></pre></td></tr></tbody></table></figure><p>包括我们之前一直在使用的<code>println</code>方法，其实也是重载了很多次的，因为要支持各种值的打印。</p><p>注意，如果仅仅是返回值的不同，是不支持重载的：</p><p><img src="https://s2.loli.net/2022/09/20/N2TRuqEnxrKbpc8.png" alt="image-20220920102933047"></p><p>当然，方法之间是可以相互调用的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>{<br>    System.out.println(<span class="hljs-string">"我是test"</span>);   <span class="hljs-comment">//实际上这里也是调用另一个方法</span><br>}<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span>{<br>    test();   <span class="hljs-comment">//在一个方法内调用另一个方法</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>如果我们这样写的话：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>{<br>    say();<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span>{<br>    test();<br>}<br></code></pre></td></tr></tbody></table></figure><p>各位猜猜看会出现什么情况？</p><p><img src="https://s2.loli.net/2022/09/21/XPMVa3pdBcFICTE.png" alt="image-20220921001914601"></p><p>此时又出现了一个我们不认识的异常，实际上什么原因导致的我们自己都很清楚，方法之间一直在相互调用，没有一个出口。</p><p>方法自己也可以调用自己：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>{<br>    test();<br>}<br></code></pre></td></tr></tbody></table></figure><p>像这样自己调用自己的行为，我们称为递归调用，如果直接这样编写，会跟上面一样，出现栈溢出错误。但是如果我们给其合理地设置出口，就不会出现这种问题，比如我们想要计算从1加到n的和：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>{<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> test(n - <span class="hljs-number">1</span>) + n;    <span class="hljs-comment">//返回的结果是下一层返回的结果+当前这一层的n</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>是不是感觉很巧妙？实际上递归调用在很多情况下能够快速解决一些很麻烦的问题，我们会在后面继续了解。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>我们接着来看一种比较特殊的方法，构造方法。</p><p>我们前面创建对象，都是直接使用<code>new</code>关键字就能直接搞定了，但是我们发现，对象在创建之后，各种属性都是默认值，那么能否实现在对象创建时就为其指定名字、年龄、性别呢？要在对象创建时进行处理，我们可以使用构造方法（构造器）来完成。</p><p>实际上每个类都有一个默认的构造方法，我们可以来看看反编译的结果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{<br>    String name;<br>    <span class="hljs-keyword">int</span> age;<br>    String sex;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>{    <span class="hljs-comment">//反编译中，多出来了这样一个方法，这其实就是构造方法</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>构造方法不需要填写返回值，并且方法名称与类名相同，默认情况下每个类都会自带一个没有任何参数的无参构造方法（只是不用我们去写，编译出来就自带）当然，我们也可以手动声明，对其进行修改：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{<br>    String name;<br>    <span class="hljs-keyword">int</span> age;<br>    String sex;<br><br>    Person(){    <span class="hljs-comment">//构造方法不需要指定返回值，并且方法名称与类名相同</span><br>        name = <span class="hljs-string">"小明"</span>;   <span class="hljs-comment">//构造方法会在对象创建时执行，我们可以将各种需要初始化的操作都在这里进行处理</span><br>        age = <span class="hljs-number">18</span>;<br>        sex = <span class="hljs-string">"男"</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>构造方法会在new的时候自动执行：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Person p = <span class="hljs-keyword">new</span> Person();   <span class="hljs-comment">//这里的new Person()其实就是在调用无参构造方法</span><br>    System.out.println(p.name);<br>}<br></code></pre></td></tr></tbody></table></figure><p>当然，我们也可以为构造方法设定参数：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{<br>    String name;<br>    <span class="hljs-keyword">int</span> age;<br>    String sex;<br><br>    Person(String name, <span class="hljs-keyword">int</span> age, String sex){   <span class="hljs-comment">//跟普通方法是一样的</span><br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>        <span class="hljs-keyword">this</span>.sex = sex;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>注意，在我们自己定义一个构造方法之后，会覆盖掉默认的那一个无参构造方法，除非我们手动重载一个无参构造，否则要创建这个类的对象，必须调用我们自己定义的构造方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Person p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"小明"</span>, <span class="hljs-number">18</span>, <span class="hljs-string">"男"</span>);   <span class="hljs-comment">//调用自己定义的带三个参数的构造方法</span><br>    System.out.println(p.name);<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以去看看反编译的结果，会发现此时没有无参构造了，而是只剩下我们自己编写的。</p><p>当然，要给成员变量设定初始值，我们不仅可以通过构造方法，也可以直接在定义时赋值：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{<br>    String name = <span class="hljs-string">"未知"</span>;   <span class="hljs-comment">//直接赋值，那么对象构造好之后，属性默认就是这个值</span><br>    <span class="hljs-keyword">int</span> age = <span class="hljs-number">10</span>;<br>    String sex = <span class="hljs-string">"男"</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>这里需要特别注意，成员变量的初始化，并不是在构造方法之前之后，而是在这之前就已经完成了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Person(String name, <span class="hljs-keyword">int</span> age, String sex){<br>    System.out.println(age);    <span class="hljs-comment">//在赋值之前看看是否有初始值</span><br>    <span class="hljs-keyword">this</span>.name = name;<br>    <span class="hljs-keyword">this</span>.age = age;<br>    <span class="hljs-keyword">this</span>.sex = sex;<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们也可以在类中添加代码块，代码块同样会在对象构造之前进行，在成员变量初始化之后执行：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{<br>    String name;<br>    <span class="hljs-keyword">int</span> age;<br>    String sex;<br><br>    {<br>        System.out.println(<span class="hljs-string">"我是代码块"</span>);   <span class="hljs-comment">//代码块中的内容会在对象创建时仅执行一次</span><br>    }<br><br>    Person(String name, <span class="hljs-keyword">int</span> age, String sex){<br>        System.out.println(<span class="hljs-string">"我被构造了"</span>);<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>        <span class="hljs-keyword">this</span>.sex = sex;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>只不过一般情况下使用代码块的频率比较低，标准情况下还是通过构造方法进行进行对象初始化工作，所以说这里做了解就行了。</p><h3 id="静态变量和静态方法"><a href="#静态变量和静态方法" class="headerlink" title="静态变量和静态方法"></a>静态变量和静态方法</h3><p>前面我们已经了解了类的大部分特性，一个类可以具有多种属性、行为，包括对象该如何创建，我们可以通过构造方法进行设定，我们可以通过类创建对象，每个对象都会具有我们在类中设定好的属性，包括我们设定好的行为，所以说类就像是一个模板，我们可以通过这个模板快速捏造出一个又一个的对象。我们接着来看比较特殊的静态特性。</p><p>静态的内容，我们可以理解为是属于这个类的，也可以理解为是所有对象共享的内容。我们通过使用<code>static</code>关键字来声明一个变量或一个方法为静态的，一旦被声明为静态，那么通过这个类创建的所有对象，操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{<br>    String name;<br>    <span class="hljs-keyword">int</span> age;<br>    String sex;<br>    <span class="hljs-keyword">static</span> String info;    <span class="hljs-comment">//这里我们定义一个info静态变量</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>我们来测试一下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Person p1 = <span class="hljs-keyword">new</span> Person();<br>    Person p2 = <span class="hljs-keyword">new</span> Person();<br>    p1.info = <span class="hljs-string">"杰哥你干嘛"</span>;<br>    System.out.println(p2.info);   <span class="hljs-comment">//可以看到，由于静态属性是属于类的，因此无论通过什么方式改变，都改变的是同一个目标</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>所以说一般情况下，我们并不会通过一个具体的对象去修改和使用静态属性，而是通过这个类去使用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Person.info = <span class="hljs-string">"让我看看"</span>;<br>    System.out.println(Person.info);<br>}<br></code></pre></td></tr></tbody></table></figure><p>同样的，我们可以将方法标记为静态：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>{<br>    System.out.println(<span class="hljs-string">"我是静态方法"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>静态方法同样是属于类的，而不是具体的某个对象，所以说，就像下面这样：</p><p><img src="https://s2.loli.net/2022/09/20/cWCrJgnkXFL63y2.png" alt="image-20220920234401275"></p><p>因为静态方法属于类的，所以说我们在静态方法中，无法获取成员变量的值：</p><p><img src="https://s2.loli.net/2022/09/20/XvPjtLm2wOMh4ZK.png" alt="image-20220920235418115"></p><p>成员变量是某个具体对象拥有的属性，就像小明这个具体的人的名字才叫小明，而静态方法是类具有的，并不是具体对象的，肯定是没办法访问到的。同样的，在静态方法中，无法使用<code>this</code>关键字，因为this关键字代表的是当前的对象本身。</p><p>但是静态方法是可以访问到静态变量的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> String info;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>{<br>    System.out.println(<span class="hljs-string">"静态变量的值为："</span>+info);<br>}<br></code></pre></td></tr></tbody></table></figure><p>因为他们都属于类，所以说肯定是可以访问到的。</p><p>我们也可以将代码块变成静态的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> String info;<br><br><span class="hljs-keyword">static</span> {   <span class="hljs-comment">//静态代码块可以用于初始化静态变量</span><br>    info = <span class="hljs-string">"测试"</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>那么，静态变量，是在什么时候进行初始化的呢？</p><p>我们在一开始介绍了，我们实际上是将<code>.class</code>文件丢给JVM去执行的，而每一个<code>.class</code>文件其实就是我们编写的一个类，我们在Java中使用一个类之前，JVM并不会在一开始就去加载它，而是在需要时才会去加载（优化）一般遇到以下情况时才会会加载类：</p><ul><li>访问类的静态变量，或者为静态变量赋值</li><li>new 创建类的实例（隐式加载）</li><li>调用类的静态方法</li><li>子类初始化时</li><li>其他的情况会在讲到反射时介绍</li></ul><p>所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载。</p><p>我们可以来测试一下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{<br>    String name = test();  <span class="hljs-comment">//这里我们用test方法的返回值作为变量的初始值，便于观察</span><br>    <span class="hljs-keyword">int</span> age;<br>    String sex;<br><br>    {<br>        System.out.println(<span class="hljs-string">"我是普通代码块"</span>);<br>    }<br>    <br>    Person(){<br>        System.out.println(<span class="hljs-string">"我是构造方法"</span>);<br>    }<br>    <br>    <span class="hljs-function">String <span class="hljs-title">test</span><span class="hljs-params">()</span></span>{<br>        System.out.println(<span class="hljs-string">"我是成员变量初始化"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"小明"</span>;<br>    }<br><br>    <span class="hljs-keyword">static</span> String info = init();   <span class="hljs-comment">//这里我们用init静态方法的返回值作为变量的初始值，便于观察</span><br><br>    <span class="hljs-keyword">static</span> {<br>        System.out.println(<span class="hljs-string">"我是静态代码块"</span>);<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">init</span><span class="hljs-params">()</span></span>{<br>        System.out.println(<span class="hljs-string">"我是静态变量初始化"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"test"</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>现在我们在主方法中创建一个对象，观察这几步是怎么在执行的：</p><p><img src="https://s2.loli.net/2022/09/21/JxTPk8SWtDmK6IX.png" alt="image-20220921000953525"></p><p>可以看到，确实是静态内容在对象构造之前的就完成了初始化，实际上就是类初始化时完成的。</p><p>当然，如果我们直接访问类的静态变量：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    System.out.println(Person.info);<br>}<br></code></pre></td></tr></tbody></table></figure><p>那么此时同样会使得类初始化，进行加载：</p><p><img src="https://s2.loli.net/2022/09/21/auMJOvNfx9K3mzd.png" alt="image-20220921001222465"></p><p>可以看到，在使用时，确实是先将静态内容初始化之后，才得到值的。当然，如果我们压根就没有去使用这个类，那么也不会被初始化了。</p><p>有关类与对象的基本内容，我们就全部讲解完毕了。</p><hr><h2 id="包和访问控制"><a href="#包和访问控制" class="headerlink" title="包和访问控制"></a>包和访问控制</h2><p>通过前面的学习，我们知道该如何创建和使用类。</p><h3 id="包声明和导入"><a href="#包声明和导入" class="headerlink" title="包声明和导入"></a>包声明和导入</h3><p>包其实就是用来区分类位置的东西，也可以用来将我们的类进行分类（类似于C++中的namespace）随着我们的程序不断变大，可能会创建各种各样的类，他们可能会做不同的事情，那么这些类如果都放在一起的话，有点混乱，我们可以通过包的形式将这些类进行分类存放。</p><p>包的命名规则同样是英文和数字的组合，最好是一个域名的格式，比如我们经常访问的<code>www.baidu.com</code>，后面的baidu.com就是域名，我们的包就可以命名为<code>com.baidu</code>，当然，各位小伙伴现在还没有自己的域名，所以说我们随便起一个名称就可以了。其中的<code>.</code>就是用于分割的，对应多个文件夹，比如<code>com.test</code>：</p><p><img src="https://s2.loli.net/2022/09/21/OZdDi1sGluyjbgr.png" alt="image-20220921120040350"></p><p>我们可以将类放入到包中：</p><p><img src="https://s2.loli.net/2022/09/21/e3GvFsHDhMAtBWR.png" alt="image-20220921115055000"></p><p>我们之前都是直接创建的类，所以说没有包这个概念，但是现在，我们将类放到包中，就需要注意了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;   <span class="hljs-comment">//在放入包中，需要在类的最上面添加package关键字来指明当前类所处的包</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{   <span class="hljs-comment">//将Main类放到com.test这个包中</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>这里又是一个新的关键字<code>package</code>，这个是用于指定当前类所处的包的，注意，所处的包和对应的目录是一一对应的。</p><p>不同的类可以放在不同的包下：</p><p><img src="https://s2.loli.net/2022/09/21/stOGnxaPirZvjLF.png" alt="image-20220921120241184"></p><p>当我们使用同一个包中的类时，直接使用即可（之前就是直接使用的，因为都直接在一个缺省的包中）而当我们需要使用其他包中的类时，需要先进行导入才可以：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">import</span> com.test.entity.Person;   <span class="hljs-comment">//使用import关键字导入其他包中的类</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        Person person = <span class="hljs-keyword">new</span> Person();   <span class="hljs-comment">//只有导入之后才可以使用，否则编译器不知道这个类从哪来的</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>这里使用了<code>import</code>关键字导入我们需要使用的类，当然，只有在类不在同一个包下时才需要进行导入，如果一个包中有多个类，我们可以使用<code>*</code>表示导入这个包中全部的类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.test.entity.*;<br></code></pre></td></tr></tbody></table></figure><p>实际上我们之前一直在使用的<code>System</code>类，也是在一个包中的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Executable;<br><span class="hljs-keyword">import</span> java.lang.annotation.Annotation;<br><span class="hljs-keyword">import</span> java.security.AccessControlContext;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><span class="hljs-keyword">import</span> java.util.PropertyPermission;<br><span class="hljs-keyword">import</span> java.util.StringTokenizer;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.security.AccessController;<br><span class="hljs-keyword">import</span> java.security.PrivilegedAction;<br><span class="hljs-keyword">import</span> java.security.AllPermission;<br><span class="hljs-keyword">import</span> java.nio.channels.Channel;<br><span class="hljs-keyword">import</span> java.nio.channels.spi.SelectorProvider;<br><span class="hljs-keyword">import</span> sun.nio.ch.Interruptible;<br><span class="hljs-keyword">import</span> sun.reflect.CallerSensitive;<br><span class="hljs-keyword">import</span> sun.reflect.Reflection;<br><span class="hljs-keyword">import</span> sun.security.util.SecurityConstants;<br><span class="hljs-keyword">import</span> sun.reflect.annotation.AnnotationType;<br><br><span class="hljs-keyword">import</span> jdk.internal.util.StaticProperty;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The &lt;code&gt;System&lt;/code&gt; class contains several useful class fields</span><br><span class="hljs-comment"> * and methods. It cannot be instantiated.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;Among the facilities provided by the &lt;code&gt;System&lt;/code&gt; class</span><br><span class="hljs-comment"> * are standard input, standard output, and error output streams;</span><br><span class="hljs-comment"> * access to externally defined properties and environment</span><br><span class="hljs-comment"> * variables; a means of loading files and libraries; and a utility</span><br><span class="hljs-comment"> * method for quickly copying a portion of an array.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>  unascribed</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span>   JDK1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">System</span> </span>{<br>  ...<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以看到它是属于<code>java.lang</code>这个包下的类，并且这个类也导入了很多其他包中的类在进行使用。那么，为什么我们在使用这个类时，没有导入呢？实际上Java中会默认导入<code>java.lang</code>这个包下的所有类，因此我们不需要手动指定。</p><p>IDEA非常智能，我们在使用项目中定义的类时，会自动帮我们将导入补全，所以说代码写起来非常高效。</p><p>注意，在不同包下的类，即使类名相同，也是不同的两个类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.entity;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span> </span>{    <span class="hljs-comment">//我们在自己的包中也建一个名为String的类</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>当我们在使用时：</p><p>![image-20220921121404900](/Users/nagocoler/Library/Application Support/typora-user-images/image-20220921121404900.png)</p><p>由于默认导入了系统自带的String类，并且也导入了我们自己定义的String类，那么此时就出现了歧义，编译器不知道到底我们想用的是哪一个String类，所以说我们需要明确指定：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[] args)</span> </span>{   <span class="hljs-comment">//主方法的String参数是java.lang包下的，我们需要明确指定一下，只需要在类名前面添加包名就行了</span><br>com.test.entity.String string = <span class="hljs-keyword">new</span> com.test.entity.String();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们只需要在类名前面把完整的包名也给写上，就可以表示这个是哪一个包里的类了，当然，如果没有出现歧义，默认情况下包名是可以省略的，可写可不写。</p><p>可能各位小伙伴会发现一个问题，为什么对象的属性访问不了了？</p><p><img src="https://s2.loli.net/2022/09/21/UaqMihmIQkzHFtG.png" alt="image-20220921122514457"></p><p>编译器说name属性在这个类中不是public，无法在外部进行访问，这是什么情况呢？这里我们就要介绍的到Java的访问权限控制了。</p><h3 id="访问权限控制"><a href="#访问权限控制" class="headerlink" title="访问权限控制"></a>访问权限控制</h3><p>实际上Java中是有访问权限控制的，就是我们个人的隐私的一样，我不允许别人随便来查看我们的隐私，只有我们自己同意的情况下，才能告诉别人我们的名字、年龄等隐私信息。</p><p>所以说Java中引入了访问权限控制（可见性），我们可以为成员变量、成员方法、静态变量、静态方法甚至是类指定访问权限，不同的访问权限，有着不同程度的访问限制：</p><ul><li><code>private</code>   -   私有，标记为私有的内容无法被除当前类以外的任何位置访问。</li><li><code>什么都不写</code>   -   默认，默认情况下，只能被类本身和同包中的其他类访问。</li><li><code>protected</code>   -   受保护，标记为受保护的内容可以能被类本身和同包中的其他类访问，也可以被子类访问（子类我们会在下一章介绍）</li><li><code>public</code>    -   公共，标记为公共的内容，允许在任何地方被访问。</li></ul><p>这四种访问权限，总结如下表：</p><table><thead><tr><th align="center"></th><th align="center">当前类</th><th align="center">同一个包下的类</th><th align="center">不同包下的子类</th><th align="center">不同包下的类</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td align="center">protected</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td><td align="center">❌</td></tr><tr><td align="center">默认</td><td align="center">✅</td><td align="center">✅</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td align="center">private</td><td align="center">✅</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td></tr></tbody></table><p>比如我们刚刚出现的情况，就是因为是默认的访问权限，所以说在当前包以外的其他包中无法访问，但是我们可以提升它的访问权限，来使得外部也可以访问：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{<br>    <span class="hljs-keyword">public</span> String name;   <span class="hljs-comment">//在name变量前添加public关键字，将其可见性提升为公共等级</span><br>    <span class="hljs-keyword">int</span> age;<br>    String sex;<br>}<br></code></pre></td></tr></tbody></table></figure><p>这样我们就可以在外部正常使用这个属性了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Person person = <span class="hljs-keyword">new</span> Person();<br>    System.out.println(person.name);   <span class="hljs-comment">//正常访问到成员变量</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>实际上如果各位小伙伴观察仔细的话，会发现我们创建出来的类自带的访问等级就是<code>public</code>：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.entity;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{   <span class="hljs-comment">//class前面有public关键字</span><br><br>}<br></code></pre></td></tr></tbody></table></figure><p>也就是说这个类实际上可以在任何地方使用，但是我们也可以将其修改为默认的访问等级：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.entity;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{    <span class="hljs-comment">//去掉public变成默认等级</span><br>  <br>}<br></code></pre></td></tr></tbody></table></figure><p>如果是默认等级的话，那么在外部同样是无法访问的：</p><p><img src="https://s2.loli.net/2022/09/21/ZTRAEItQY6UcqvP.png" alt="image-20220921142724239"></p><p>但是注意，我们创建的普通类不能是<code>protected</code>或是<code>private</code>权限，因为我们目前所使用的普通类要么就是只给当前的包内使用，要么就是给外面都用，如果是<code>private</code>谁都不能用，那这个类定义出来干嘛呢？</p><p>如果某个类中存在静态方法或是静态变量，那么我们可以通过静态导入的方式将其中的静态方法或是静态变量直接导入使用，但是同样需要有访问权限的情况下才可以：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{<br>    String name;<br>    <span class="hljs-keyword">int</span> age;<br>    String sex;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>{<br>        System.out.println(<span class="hljs-string">"我是静态方法！"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们来尝试一下静态导入：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> com.test.entity.Person.test;    <span class="hljs-comment">//静态导入test方法</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        test();    <span class="hljs-comment">//直接使用就可以，就像在这个类定义的方法一样</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>至此，有关包相关的内容，我们就讲解到这里。</p><hr><h2 id="封装、继承和多态"><a href="#封装、继承和多态" class="headerlink" title="封装、继承和多态"></a>封装、继承和多态</h2><p>封装、继承和多态是面向对象编程的三大特性。</p><blockquote><p>封装，把对象的属性和方法结合成一个独立的整体，隐藏实现细节，并提供对外访问的接口。</p><p>继承，从已知的一个类中派生出一个新的类，叫子类。子类实现了父类所有非私有化的属性和方法，并根据实际需求扩展出新的行为。</p><p>多态，多个不同的对象对同一消息作出响应，同一消息根据不同的对象而采用各种不同的方法。</p></blockquote><p>正是这三大特性，让我们的Java程序更加生动形象。</p><h3 id="类的封装"><a href="#类的封装" class="headerlink" title="类的封装"></a>类的封装</h3><p>封装的目的是为了保证变量的安全性，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员，如果不进行封装，类中的实例变量可以直接查看和修改，可能给整个代码带来不好的影响，因此在编写类时一般将成员变量私有化，外部类需要使用Getter和Setter方法来查看和设置变量。</p><p>我们可以将之前的类进行改进：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{<br>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-comment">//现在类的属性只能被自己直接访问</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">private</span> String sex;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, String sex)</span> </span>{   <span class="hljs-comment">//构造方法也要声明为公共，否则对象都构造不了</span><br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>        <span class="hljs-keyword">this</span>.sex = sex;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> name;    <span class="hljs-comment">//想要知道这个对象的名字，必须通过getName()方法来获取，并且得到的只是名字值，外部无法修改</span><br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSex</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> sex;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> age;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以来试一下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Person person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"小明"</span>, <span class="hljs-number">18</span>, <span class="hljs-string">"男"</span>);<br>    System.out.println(person.getName());    <span class="hljs-comment">//只能通过调用getName()方法来获取名字</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>也就是说，外部现在只能通过调用我定义的方法来获取成员属性，而我们可以在这个方法中进行一些额外的操作，比如小明可以修改名字，但是名字中不能包含”小”这个字：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>{<br>    <span class="hljs-keyword">if</span>(name.contains(<span class="hljs-string">"小"</span>)) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">this</span>.name = name;<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们甚至还可以将构造方法改成私有的，需要通过我们的内部的方式来构造对象：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">private</span> String sex;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span></span>{}   <span class="hljs-comment">//不允许外部使用new关键字创建对象</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Person <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{   <span class="hljs-comment">//而是需要使用我们的独特方法来生成对象并返回</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Person();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>通过这种方式，我们可以实现单例模式：</p><blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Test instance;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span></span>{}<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Test <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) <br>            instance = <span class="hljs-keyword">new</span> Test();<br>        <span class="hljs-keyword">return</span> instance;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>单例模式就是全局只能使用这一个对象，不能创建更多的对象，我们就可以封装成这样，关于单例模式的详细介绍，还请各位小伙伴在《Java设计模式》视频教程中再进行学习。</p></blockquote><p>封装思想其实就是把实现细节给隐藏了，外部只需知道这个方法是什么作用，而无需关心实现，要用什么由类自己来做，不需要外面来操作类内部的东西去完成，封装就是通过访问权限控制来实现的。</p><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>前面我们介绍了类的封装，我们接着来看一个非常重要特性：继承。</p><p>在定义不同类的时候存在一些相同属性，为了方便使用可以将这些共同属性抽象成一个父类，在定义其他子类时可以继承自该父类，减少代码的重复定义，子类可以使用父类中<strong>非私有</strong>的成员。</p><p>比如说我们一开始使用的人类，那么实际上人类根据职业划分，所掌握的技能也会不同，比如画家会画画，歌手会唱，舞者会跳，Rapper会rap，运动员会篮球，我们可以将人类这个大类根据职业进一步地细分出来：</p><p><img src="https://s2.loli.net/2022/09/21/zlZ9JXAjvxpawPF.png" alt="image-20220921150139125"></p><p>实际上这些划分出来的类，本质上还是人类，也就是说人类具有的属性，这些划分出来的类同样具有，但是，这些划分出来的类同时也会拥有他们自己独特的技能。在Java中，我们可以创建一个类的子类来实现上面的这种效果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{   <span class="hljs-comment">//先定义一个父类</span><br>    String name;<br>    <span class="hljs-keyword">int</span> age;<br>    String sex;<br>}<br></code></pre></td></tr></tbody></table></figure><p>接着我们可以创建各种各样的子类，想要继承一个类，我们只需要使用<code>extends</code>关键字即可：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>{    <span class="hljs-comment">//工人类</span><br>    <br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>{   <span class="hljs-comment">//学生类</span><br><br>}<br></code></pre></td></tr></tbody></table></figure><p>类的继承可以不断向下，但是同时只能继承一个类，同时，标记为<code>final</code>的类不允许被继承：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{  <span class="hljs-comment">//class前面添加final关键字表示这个类已经是最终形态，不能继承</span><br>  <br>}<br></code></pre></td></tr></tbody></table></figure><p>当一个类继承另一个类时，属性会被继承，可以直接访问父类中定义的属性，除非父类中将属性的访问权限修改为<code>private</code>，那么子类将无法访问（但是依然是继承了这个属性的）：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>{<br>        System.out.println(<span class="hljs-string">"我的名字是 "</span>+name+<span class="hljs-string">"，我在学习！"</span>);   <span class="hljs-comment">//可以直接访问父类中定义的name属性</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>同样的，在父类中定义的方法同样会被子类继承：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{<br>    String name;<br>    <span class="hljs-keyword">int</span> age;<br>    String sex;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>{<br>        System.out.println(<span class="hljs-string">"我叫 "</span>+name+<span class="hljs-string">"，今年 "</span>+age+<span class="hljs-string">" 岁了!"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>子类直接获得了此方法，当我们创建一个子类对象时就可以直接使用这个方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Student student = <span class="hljs-keyword">new</span> Student();<br>    student.study();    <span class="hljs-comment">//子类不仅有自己的独特技能</span><br>    student.hello();    <span class="hljs-comment">//还继承了父类的全部技能</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>是不是感觉非常人性化，子类继承了父类的全部能力，同时还可以扩展自己的独特能力，就像一句话说的： 龙生龙凤生凤，老鼠儿子会打洞。</p><p>如果父类存在一个有参构造方法，子类必须在构造方法中调用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{<br>    <span class="hljs-keyword">protected</span> String name;   <span class="hljs-comment">//因为子类需要用这些属性，所以说我们就将这些变成protected，外部不允许访问</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">protected</span> String sex;<br>    <span class="hljs-keyword">protected</span> String profession;<br><br>  <span class="hljs-comment">//构造方法也改成protected，只能子类用</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, String sex, String profession)</span> </span>{<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>        <span class="hljs-keyword">this</span>.sex = sex;<br>        <span class="hljs-keyword">this</span>.profession = profession;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>{<br>        System.out.println(<span class="hljs-string">"["</span>+profession+<span class="hljs-string">"] 我叫 "</span>+name+<span class="hljs-string">"，今年 "</span>+age+<span class="hljs-string">" 岁了!"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以看到，此时两个子类都报错了：</p><p><img src="https://s2.loli.net/2022/09/21/SgPjRtUN64bmWrX.png" alt="image-20220921153512798"></p><p>因为子类在构造时，不仅要初始化子类的属性，还需要初始化父类的属性，所以说在默认情况下，子类其实是调用了父类的构造方法的，只是在无参的情况下可以省略，但是现在父类构造方法需要参数，那么我们就需要手动指定了：</p><p>既然现在父类需要三个参数才能构造，那么子类需要按照同样的方式调用父类的构造方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, String sex)</span> </span>{    <span class="hljs-comment">//因为学生职业已经确定，所以说学生直接填写就可以了</span><br>        <span class="hljs-keyword">super</span>(name, age, sex, <span class="hljs-string">"学生"</span>);   <span class="hljs-comment">//使用super代表父类，父类的构造方法就是super()</span><br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>{<br>        System.out.println(<span class="hljs-string">"我的名字是 "</span>+name+<span class="hljs-string">"，我在学习！"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Worker</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, String sex)</span> </span>{<br>        <span class="hljs-keyword">super</span>(name, age, sex, <span class="hljs-string">"工人"</span>);    <span class="hljs-comment">//父类构造调用必须在最前面</span><br>        System.out.println(<span class="hljs-string">"工人构造成功！"</span>);    <span class="hljs-comment">//注意，在调用父类构造方法之前，不允许执行任何代码，只能在之后执行</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们在使用子类时，可以将其当做父类来使用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Person person = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"小明"</span>, <span class="hljs-number">18</span>, <span class="hljs-string">"男"</span>);    <span class="hljs-comment">//这里使用父类类型的变量，去引用一个子类对象（向上转型）</span><br>    person.hello();    <span class="hljs-comment">//父类对象的引用相当于当做父类来使用，只能访问父类对象的内容</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>虽然我们这里使用的是父类类型引用的对象，但是这并不代表子类就彻底变成父类了，这里仅仅只是当做父类使用而已。</p><p>我们也可以使用强制类型转换，将一个被当做父类使用的子类对象，转换回子类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Person person = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"小明"</span>, <span class="hljs-number">18</span>, <span class="hljs-string">"男"</span>);<br>    Student student = (Student) person;   <span class="hljs-comment">//使用强制类型转换（向下转型）</span><br>    student.study();<br>}<br></code></pre></td></tr></tbody></table></figure><p>但是注意，这种方式只适用于这个对象本身就是对应的子类才可以，如果本身都不是这个子类，或者说就是父类，那么会出现问题：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Person person = <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">"小明"</span>, <span class="hljs-number">18</span>, <span class="hljs-string">"男"</span>);   <span class="hljs-comment">//实际创建的是Work类型的对象</span><br>    Student student = (Student) person;<br>    student.study();<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/09/21/JdMLt19Yq6KQz4v.png" alt="image-20220921160309835"></p><p>此时直接出现了类型转换异常，因为本身不是这个类型，强转也没用。</p><p>那么如果我们想要判断一下某个变量所引用的对象到底是什么类，那么该怎么办呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Person person = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"小明"</span>, <span class="hljs-number">18</span>, <span class="hljs-string">"男"</span>);<br>    <span class="hljs-keyword">if</span>(person <span class="hljs-keyword">instanceof</span> Student) {   <span class="hljs-comment">//我们可以使用instanceof关键字来对类型进行判断</span><br>        System.out.println(<span class="hljs-string">"对象是 Student 类型的"</span>);<br>    }<br>    <span class="hljs-keyword">if</span>(person <span class="hljs-keyword">instanceof</span> Person) {<br>        System.out.println(<span class="hljs-string">"对象是 Person 类型的"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>如果变量所引用的对象是对应类型或是对应类型的子类，那么<code>instanceof</code>都会返回<code>true</code>，否则返回<code>false</code>。</p><p>最后我们需要来特别说明一下，子类是可以定义和父类同名的属性的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>{<br>    <span class="hljs-keyword">protected</span> String name;   <span class="hljs-comment">//子类中同样可以定义name属性</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Worker</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, String sex)</span> </span>{<br>        <span class="hljs-keyword">super</span>(name, age, sex, <span class="hljs-string">"工人"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>此时父类的name属性和子类的name属性是同时存在的，那么当我们在子类中直接使用时：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>{<br>    System.out.println(<span class="hljs-string">"我是 "</span>+name+<span class="hljs-string">"，我在工作！"</span>);   <span class="hljs-comment">//这里的name，依然是作用域最近的哪一个，也就是在当前子类中定义的name属性，而不是父类的name属性</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>所以说，我们在使用时，实际上这里得到的结果为<code>null</code>：</p><p><img src="https://s2.loli.net/2022/09/21/nKDaTJZ2LhEX3Hs.png" alt="image-20220921160742714"></p><p>那么，在子类存在同名变量的情况下，怎么去访问父类的呢？我们同样可以使用<code>super</code>关键字来表示父类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>{<br>    System.out.println(<span class="hljs-string">"我是 "</span>+<span class="hljs-keyword">super</span>.name+<span class="hljs-string">"，我在工作！"</span>);   <span class="hljs-comment">//这里使用super.name来表示需要的是父类的name变量</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>这样得到的结果就不一样了：</p><p><img src="https://s2.loli.net/2022/09/21/DobHL2CWRMIif3z.png" alt="image-20220921160851193"></p><p>但是注意，没有<code>super.super</code>这种用法，也就是说如果存在多级继承的话，那么最多只能通过这种方法访问到父类的属性（包括继承下来的属性）</p><h3 id="顶层Object类"><a href="#顶层Object类" class="headerlink" title="顶层Object类"></a>顶层Object类</h3><p>实际上所有类都默认继承自Object类，除非手动指定继承的类型，但是依然改变不了最顶层的父类是Object类。所有类都包含Object类中的方法，比如：</p><p><img src="https://s2.loli.net/2022/09/21/FCHDEI4rTAQquas.png" alt="image-20220921214642969"></p><p>我们发现，除了我们自己在类中编写的方法之外，还可以调用一些其他的方法，那么这些方法不可能无缘无故地出现，肯定同样是因为继承得到的，那么这些方法是继承谁得到的呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Object</span></span>{   <br><span class="hljs-comment">//除非我们手动指定要继承的类是什么，实际上默认情况下所有的类都是继承自Object的，只是可以省略</span><br><br>}<br></code></pre></td></tr></tbody></table></figure><p>所以说我们的继承结构差不多就是：</p><p><img src="https://s2.loli.net/2022/09/21/hkapOYVHBrjy7UC.png" alt="image-20220921214944267"></p><p>既然所有的类都默认继承自Object，我们来看看这个类里面有哪些内容：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Object</span> </span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerNatives</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">//标记为native的方法是本地方法，底层是由C++实现的</span><br>    <span class="hljs-keyword">static</span> {<br>        registerNatives();   <span class="hljs-comment">//这个类在初始化时会对类中其他本地方法进行注册，本地方法不是我们SE中需要学习的内容，我们会在JVM篇视频教程中进行介绍</span><br>    }<br><br>    <span class="hljs-comment">//获取当前的类型Class对象，这个我们会在最后一章的反射中进行讲解，目前暂时不会用到</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass();<br><br>    <span class="hljs-comment">//获取对象的哈希值，我们会在第五章集合类中使用到，目前各位小伙伴就暂时理解为会返回对象存放的内存地址</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-comment">//判断当前对象和给定对象是否相等，默认实现是直接用等号判断，也就是直接判断是否为同一个对象</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>{<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span> == obj);<br>    }<br>  <br>    <span class="hljs-comment">//克隆当前对象，可以将复制一个完全一样的对象出来，包括对象的各个属性</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException</span>;<br><br>    <span class="hljs-comment">//将当前对象转换为String的形式，默认情况下格式为 完整类名@十六进制哈希值</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">"@"</span> + Integer.toHexString(hashCode());<br>    }<br><br>    <span class="hljs-comment">//唤醒一个等待当前对象锁的线程，有关锁的内容，我们会在第六章多线程部分中讲解，目前暂时不会用到</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//唤醒所有等待当前对象锁的线程，同上</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyAll</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//使得持有当前对象锁的线程进入等待状态，同上</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br><br>    <span class="hljs-comment">//同上</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, <span class="hljs-keyword">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br>        ...<br>    }<br><br>    <span class="hljs-comment">//同上</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br>        ...<br>    }<br><br>    <span class="hljs-comment">//当对象被判定为已经不再使用的“垃圾”时，在回收之前，会由JVM来调用一次此方法进行资源释放之类的操作，这同样不是SE中需要学习的内容，这个方法我们会在JVM篇视频教程中详细介绍，目前暂时不会用到</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>{ }<br>}<br></code></pre></td></tr></tbody></table></figure><p>这里我们可以尝试调用一下Object为我们提供的<code>toString()</code>方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Person person = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"小明"</span>, <span class="hljs-number">18</span>, <span class="hljs-string">"男"</span>);<br>    String str = person.toString();<br>    System.out.println(str);<br>}<br></code></pre></td></tr></tbody></table></figure><p>这里就是按照上面说的格式进行打印：</p><p><img src="https://s2.loli.net/2022/09/21/hpBOjqf4iwJW1Pr.png" alt="image-20220921221053801"></p><p>当然，我们直接可以给<code>println</code>传入一个Object类型的对象：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">println</span><span class="hljs-params">(Object x)</span> </span>{<br>    String s = String.valueOf(x);   <span class="hljs-comment">//这里同样会调用对象的toString方法，所以说跟上面效果是一样的</span><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) {<br>        print(s);<br>        newLine();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>有小伙伴肯定会好奇，这里不是接受的一个Object类型的值的，为什么任意类型都可以传入呢？因为所有类型都是继承自Object，如果方法接受的参数是一个引用类型的值，那只要是这个类的对象或是这个类的子类的对象，都可以作为参数传入。</p><p>我们也可以试试看默认提供的<code>equals</code>方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Person p1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"小明"</span>, <span class="hljs-number">18</span>, <span class="hljs-string">"男"</span>);<br>    Person p2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"小明"</span>, <span class="hljs-number">18</span>, <span class="hljs-string">"男"</span>);<br>    System.out.println(p1.equals(p2));<br>}<br></code></pre></td></tr></tbody></table></figure><p>因为默认比较的是两个对象是否为同一个对象，所以说这里得到的肯定是false，但是有些情况下，实际上我们所希望的情况是如果名字、年龄、性别都完全相同，那么这肯定是同一个人，但是这里却做不到这样的判断，我们需要修改一下<code>equals</code>方法的默认实现来完成，这就要用到方法的重写了。</p><h3 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h3><p>注意，方法的重写不同于之前的方法重载，不要搞混了，方法的重载是为某个方法提供更多种类，而方法的重写是覆盖原有的方法实现，比如我们现在不希望使用Object类中提供的<code>equals</code>方法，那么我们就可以将其重写了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>{<br>    ...<br><br>    <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//重写方法可以添加 @Override 注解，有关注解我们会在最后一章进行介绍，这个注解默认情况下可以省略</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>{   <span class="hljs-comment">//重写方法要求与父类的定义完全一致</span><br>        <span class="hljs-keyword">if</span>(obj == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;   <span class="hljs-comment">//如果传入的对象为null，那肯定不相等</span><br>        <span class="hljs-keyword">if</span>(obj <span class="hljs-keyword">instanceof</span> Person) {     <span class="hljs-comment">//只有是当前类型的对象，才能进行比较，要是都不是这个类型还比什么</span><br>            Person person = (Person) obj;   <span class="hljs-comment">//先转换为当前类型，接着我们对三个属性挨个进行比较</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name.equals(person.name) &amp;&amp;    <span class="hljs-comment">//字符串内容的比较，不能使用==，必须使用equals方法</span><br>                    <span class="hljs-keyword">this</span>.age == person.age &amp;&amp;       <span class="hljs-comment">//基本类型的比较跟之前一样，直接==</span><br>                    <span class="hljs-keyword">this</span>.sex.equals(person.sex);<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>在重写Object提供的<code>equals</code>方法之后，就会按照我们的方式进行判断了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Person p1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"小明"</span>, <span class="hljs-number">18</span>, <span class="hljs-string">"男"</span>);<br>    Person p2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"小明"</span>, <span class="hljs-number">18</span>, <span class="hljs-string">"男"</span>);<br>    System.out.println(p1.equals(p2));   <span class="hljs-comment">//此时由于三个属性完全一致，所以说判断结果为真，即使是两个不同的对象</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>有时候为了方便查看对象的各个属性，我们可以将Object类提供的<code>toString</code>方法重写了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{    <span class="hljs-comment">//使用IDEA可以快速生成</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"Person{"</span> +<br>            <span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +<br>            <span class="hljs-string">", age="</span> + age +<br>            <span class="hljs-string">", sex='"</span> + sex + <span class="hljs-string">'\''</span> +<br>            <span class="hljs-string">", profession='"</span> + profession + <span class="hljs-string">'\''</span> +<br>            <span class="hljs-string">'}'</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>这样，我们直接打印对象时，就会打印出对象的各个属性值了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Person person = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"小明"</span>, <span class="hljs-number">18</span>, <span class="hljs-string">"男"</span>);<br>    System.out.println(person);<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/09/21/FCAnxSUjhaLuXW8.png" alt="image-20220921223249343"></p><p>注意，静态方法不支持重写，因为它是属于类本身的，但是它可以被继承。</p><p>基于这种方法可以重写的特性，对于一个类定义的行为，不同的子类可以出现不同的行为，比如考试，学生考试可以得到A，而工人去考试只能得到D：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{<br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exam</span><span class="hljs-params">()</span></span>{<br>        System.out.println(<span class="hljs-string">"我是考试方法"</span>);<br>    }<br>  <br>  ...<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>{<br>    ...<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exam</span><span class="hljs-params">()</span> </span>{<br>        System.out.println(<span class="hljs-string">"我是学生，我就是小镇做题家，拿个 A 轻轻松松"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>{<br>    ...<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exam</span><span class="hljs-params">()</span> </span>{<br>        System.out.println(<span class="hljs-string">"我是工人，做题我并不擅长，只能得到 D"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>这样，不同的子类，对于同一个方法会产生不同的结果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Person person = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"小明"</span>, <span class="hljs-number">18</span>, <span class="hljs-string">"男"</span>);<br>    person.exam();<br><br>    person = <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">"小强"</span>, <span class="hljs-number">18</span>, <span class="hljs-string">"男"</span>);<br>    person.exam();<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/09/21/zogT67B91tJaHLD.png" alt="image-20220921224525855"></p><p>这其实就是面向对象编程中多态特性的一种体现。</p><p>注意，我们如果不希望子类重写某个方法，我们可以在方法前添加<code>final</code>关键字，表示这个方法已经是最终形态：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exam</span><span class="hljs-params">()</span></span>{<br>    System.out.println(<span class="hljs-string">"我是考试方法"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/09/21/zpKfDlGTLwx5iy8.png" alt="image-20220921224907373"></p><p>或者，如果父类中方法的可见性为<code>private</code>，那么子类同样无法访问，也就不能重写，但是可以定义同名方法：</p><p><img src="https://s2.loli.net/2022/09/21/d9k21hyGL6WExZ3.png" alt="image-20220921225651487"></p><p>虽然这里可以编译通过，但是并不是对父类方法的重写，仅仅是子类自己创建的一个新方法。</p><p>还有，我们在重写父类方法时，如果希望调用父类原本的方法实现，那么同样可以使用<code>super</code>关键字：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exam</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">super</span>.exam();   <span class="hljs-comment">//调用父类的实现</span><br>    System.out.println(<span class="hljs-string">"我是工人，做题我并不擅长，只能得到 D"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>然后就是访问权限的问题，子类在重写父类方法时，不能降低父类方法中的可见性：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exam</span><span class="hljs-params">()</span></span>{<br>    System.out.println(<span class="hljs-string">"我是考试方法"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/09/21/zfhZ3YdFeCgJu89.png" alt="image-20220921225234226"></p><p>因为子类实际上可以当做父类使用，如果子类的访问权限比父类还低，那么在被当做父类使用时，就可能出现无视访问权限调用的情况，这样肯定是不行的，但是相反的，我们可以在子类中提升权限：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exam</span><span class="hljs-params">()</span></span>{<br>    System.out.println(<span class="hljs-string">"我是考试方法"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exam</span><span class="hljs-params">()</span> </span>{   <span class="hljs-comment">//将可见性提升为public </span><br>    System.out.println(<span class="hljs-string">"我是工人，做题我并不擅长，只能得到 D"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/09/21/igvGNTQs2xKOZrI.png" alt="image-20220921225840122"></p><p>可以看到作为子类时就可以正常调用，但是如果将其作为父类使用，因为访问权限不足所有就无法使用，总之，子类重写的方法权限不能比父类还低。</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>在我们学习了类的继承之后，实际上我们会发现，越是处于顶层定义的类，实际上可以进一步地进行抽象，比如我们前面编写的考试方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exam</span><span class="hljs-params">()</span></span>{<br>    System.out.println(<span class="hljs-string">"我是考试方法"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>这个方法再子类中一定会被重写，所以说除非子类中调用父类的实现，否则一般情况下永远都不会被调用，就像我们说一个人会不会考试一样，实际上人怎么考试是一个抽象的概念，而学生怎么考试和工人怎么考试，才是具体的一个实现，所以说，我们可以将人类进行进一步的抽象，让某些方法完全由子类来实现，父类中不需要提供实现。</p><p>要实现这样的操作，我们可以将人类变成抽象类，抽象类比类还要抽象：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{   <span class="hljs-comment">//通过添加abstract关键字，表示这个类是一个抽象类</span><br>    <span class="hljs-keyword">protected</span> String name;   <span class="hljs-comment">//大体内容其实普通类差不多</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">protected</span> String sex;<br>    <span class="hljs-keyword">protected</span> String profession;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, String sex, String profession)</span> </span>{<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>        <span class="hljs-keyword">this</span>.sex = sex;<br>        <span class="hljs-keyword">this</span>.profession = profession;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exam</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">//抽象类中可以具有抽象方法，也就是说这个方法只有定义，没有方法体</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>而具体的实现，需要由子类来完成，而且如果是子类，必须要实现抽象类中所有抽象方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Worker</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, String sex)</span> </span>{<br>        <span class="hljs-keyword">super</span>(name, age, sex, <span class="hljs-string">"工人"</span>);<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exam</span><span class="hljs-params">()</span> </span>{   <span class="hljs-comment">//子类必须要实现抽象类所有的抽象方法，这是强制要求的，否则会无法通过编译</span><br>        System.out.println(<span class="hljs-string">"我是工人，做题我并不擅长，只能得到 D"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>抽象类由于不是具体的类定义（它是类的抽象）可能会存在某些方法没有实现，因此无法直接通过new关键字来直接创建对象：</p><p><img src="https://s2.loli.net/2022/09/21/GLQU8hANw36P5J7.png" alt="image-20220921231744420"></p><p>要使用抽象类，我们只能去创建它的子类对象。</p><p>抽象类一般只用作继承使用，当然，抽象类的子类也可以是一个抽象类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>{   <span class="hljs-comment">//如果抽象类的子类也是抽象类，那么可以不用实现父类中的抽象方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, String sex)</span> </span>{<br>        <span class="hljs-keyword">super</span>(name, age, sex, <span class="hljs-string">"学生"</span>);<br>    }<br><br>    <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//抽象类中并不是只能有抽象方法，抽象类中也可以有正常方法的实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exam</span><span class="hljs-params">()</span> </span>{<br>        System.out.println(<span class="hljs-string">"我是学生，我就是小镇做题家，拿个 A 轻轻松松"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>注意，抽象方法的访问权限不能为<code>private</code>：</p><p><img src="https://s2.loli.net/2022/09/21/1ZJSRU2Aj5K9Ikv.png" alt="image-20220921232435056"></p><p>因为抽象方法一定要由子类实现，如果子类都访问不了，那么还有什么意义呢？所以说不能为私有。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口甚至比抽象类还抽象，他只代表某个确切的功能！也就是只包含方法的定义，甚至都不是一个类！接口一般只代表某些功能的抽象，接口包含了一些列方法的定义，类可以实现这个接口，表示类支持接口代表的功能（类似于一个插件，只能作为一个附属功能加在主体上，同时具体实现还需要由主体来实现）</p><p>咋一看，这啥意思啊，什么叫支持接口代表的功能？实际上接口的目标就是将类所具有某些的行为抽象出来。</p><p>比如说，对于人类的不同子类，学生和老师来说，他们都具有学习这个能力，既然都有，那么我们就可以将学习这个能力，抽象成接口来进行使用，只要是实现这个接口的类，都有学习的能力：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Study</span> </span>{    <span class="hljs-comment">//使用interface表示这是一个接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//接口中只能定义访问权限为public抽象方法，其中public和abstract关键字可以省略</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以让类实现这个接口：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Study</span> </span>{   <span class="hljs-comment">//使用implements关键字来实现接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, String sex)</span> </span>{<br>        <span class="hljs-keyword">super</span>(name, age, sex, <span class="hljs-string">"学生"</span>);<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span> </span>{    <span class="hljs-comment">//实现接口时，同样需要将接口中所有的抽象方法全部实现</span><br>        System.out.println(<span class="hljs-string">"我会学习！"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Study</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">Teacher</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, String sex)</span> </span>{<br>        <span class="hljs-keyword">super</span>(name, age, sex, <span class="hljs-string">"教师"</span>);<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span> </span>{<br>        System.out.println(<span class="hljs-string">"我会加倍学习！"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>接口不同于继承，接口可以同时实现多个：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Study</span>, <span class="hljs-title">A</span>, <span class="hljs-title">B</span>, <span class="hljs-title">C</span> </span>{  <span class="hljs-comment">//多个接口的实现使用逗号隔开</span><br>  <br>}<br></code></pre></td></tr></tbody></table></figure><p>所以说有些人说接口其实就是Java中的多继承，但是我个人认为这种说法是错的，实际上实现接口更像是一个类的功能列表，作为附加功能存在，一个类可以附加很多个功能，接口的使用和继承的概念有一定的出入，顶多说是多继承的一种替代方案。</p><p>接口跟抽象类一样，不能直接创建对象，但是我们也可以将接口实现类的对象以接口的形式去使用：</p><p><img src="https://s2.loli.net/2022/09/21/VJfhzYKuF38tRq4.png" alt="image-20220921234735828"></p><p>当做接口使用时，只有接口中定义的方法和Object类的方法，无法使用类本身的方法和父类的方法。</p><p>接口同样支持向下转型：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Study study = <span class="hljs-keyword">new</span> Teacher(<span class="hljs-string">"小王"</span>, <span class="hljs-number">27</span>, <span class="hljs-string">"男"</span>);<br>    <span class="hljs-keyword">if</span>(study <span class="hljs-keyword">instanceof</span> Teacher) {   <span class="hljs-comment">//直接判断引用的对象是不是Teacher类型</span><br>        Teacher teacher = (Teacher) study;   <span class="hljs-comment">//强制类型转换</span><br>        teacher.study();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>这里的使用其实跟之前的父类是差不多的。</p><p>从Java8开始，接口中可以存在方法的默认实现：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Study</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{   <span class="hljs-comment">//使用default关键字为接口中的方法添加默认实现</span><br>        System.out.println(<span class="hljs-string">"我是默认实现"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>如果方法在接口中存在默认实现，那么实现类中不强制要求进行实现。</p><p>接口不同于类，接口中不允许存在成员变量和成员方法，但是可以存在静态变量和静态方法，在接口中定义的变量只能是：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Study</span> </span>{<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;   <span class="hljs-comment">//接口中定义的静态变量只能是public static final的</span><br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>{    <span class="hljs-comment">//接口中定义的静态方法也只能是public的</span><br>        System.out.println(<span class="hljs-string">"我是静态方法"</span>);<br>    }<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>跟普通的类一样，我们可以直接通过接口名.的方式使用静态内容：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    System.out.println(Study.a);<br>    Study.test();<br>}<br></code></pre></td></tr></tbody></table></figure><p>接口是可以继承自其他接口的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> <span class="hljs-title">exetnds</span> <span class="hljs-title">B</span> </span>{<br>  <br>}<br></code></pre></td></tr></tbody></table></figure><p>并且接口没有继承数量限制，接口支持多继承：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> <span class="hljs-title">exetnds</span> <span class="hljs-title">B</span>, <span class="hljs-title">C</span>, <span class="hljs-title">D</span> </span>{<br>  <br>}<br></code></pre></td></tr></tbody></table></figure><p>接口的继承相当于是对接口功能的融合罢了。</p><p>最后我们来介绍一下Object类中提供的克隆方法，为啥要留到这里才来讲呢？因为它需要实现接口才可以使用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Cloneable</span> </span>{    <span class="hljs-comment">//这个接口中什么都没定义</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>实现接口后，我们还需要将克隆方法的可见性提升一下，不然还用不了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Study</span>, <span class="hljs-title">Cloneable</span> </span>{   <span class="hljs-comment">//首先实现Cloneable接口，表示这个类具有克隆的功能</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, String sex)</span> </span>{<br>        <span class="hljs-keyword">super</span>(name, age, sex, <span class="hljs-string">"学生"</span>);<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>{   <span class="hljs-comment">//提升clone方法的访问权限</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.clone();   <span class="hljs-comment">//因为底层是C++实现，我们直接调用父类的实现就可以了</span><br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span> </span>{<br>        System.out.println(<span class="hljs-string">"我会学习！"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>接着我们来尝试一下，看看是不是会得到一个一模一样的对象：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>{  <span class="hljs-comment">//这里向上抛出一下异常，还没学异常，所以说照着写就行了</span><br>    Student student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"小明"</span>, <span class="hljs-number">18</span>, <span class="hljs-string">"男"</span>);<br>    Student clone = (Student) student.clone();   <span class="hljs-comment">//调用clone方法，得到一个克隆的对象</span><br>    System.out.println(student);<br>    System.out.println(clone);<br>    System.out.println(student == clone);<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以发现，原对象和克隆对象，是两个不同的对象，但是他们的各种属性都是完全一样的：</p><p><img src="https://s2.loli.net/2022/09/22/E3dNFYT5sWaS8Rx.png" alt="image-20220922110044636"></p><p>通过实现接口，我们就可以很轻松地完成对象的克隆了，在我们之后的学习中，还会经常遇到接口的使用。</p><p><strong>注意：</strong>以下内容为选学内容，在设计模式篇视频教程中有详细介绍。</p><blockquote><p>克隆操作可以完全复制一个对象的所有属性，但是像这样的拷贝操作其实也分为浅拷贝和深拷贝。</p><ul><li><strong>浅拷贝：</strong>对于类中基本数据类型，会直接复制值给拷贝对象；对于引用类型，只会复制对象的地址，而实际上指向的还是原来的那个对象，拷贝个基莫。 </li><li><strong>深拷贝：</strong>无论是基本类型还是引用类型，深拷贝会将引用类型的所有内容，全部拷贝为一个新的对象，包括对象内部的所有成员变量，也会进行拷贝。</li></ul><p>那么clone方法出来的克隆对象，是深拷贝的结果还是浅拷贝的结果呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>{<br>    Student student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"小明"</span>, <span class="hljs-number">18</span>, <span class="hljs-string">"男"</span>);<br>    Student clone = (Student) student.clone();<br>    System.out.println(student.name == clone.name);<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/09/22/gpM1iukyoSdn2RE.png" alt="image-20220922110750697"></p><p>可以看到，虽然Student对象成功拷贝，但是其内层对象并没有进行拷贝，依然只是对象引用的复制，所以Java为我们提供的<code>clone</code>方法只会进行浅拷贝。</p></blockquote><hr><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>假设现在我们想给小明添加一个状态（跑步、学习、睡觉），外部可以实时获取小明的状态：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Study</span> </span>{<br><br>    <span class="hljs-keyword">private</span> String status;   <span class="hljs-comment">//状态，可以是跑步、学习、睡觉这三个之中的其中一种</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getStatus</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> status;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(String status)</span> </span>{<br>        <span class="hljs-keyword">this</span>.status = status;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>但是这样会出现一个问题，如果我们仅仅是存储字符串，似乎外部可以不按照我们规则，传入一些其他的字符串。这显然是不够严谨的，有没有一种办法，能够更好地去实现这样的状态标记呢？我们希望开发者拿到使用的就是我们预先定义好的状态，所以，我们可以使用枚举类来完成：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Status</span> </span>{   <span class="hljs-comment">//enum表示这是一个枚举类，枚举类的语法稍微有一些不一样</span><br>    RUNNING, STUDY, SLEEP;    <span class="hljs-comment">//直接写每个状态的名字即可，最后面分号可以不打，但是推荐打上</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>使用枚举类也非常方便，就像使用普通类型那样：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Status status;   <span class="hljs-comment">//类型变成刚刚定义的枚举类</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">getStatus</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">return</span> status;<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(Status status)</span> </span>{<br>    <span class="hljs-keyword">this</span>.status = status;<br>}<br></code></pre></td></tr></tbody></table></figure><p>这样，别人在使用时，就能很清楚地知道我们支持哪些了：</p><p><img src="https://s2.loli.net/2022/09/22/6SDXckyIfFoCZWg.png" alt="image-20220922111426974"></p><p>枚举类型使用起来就非常方便了，其实枚举类型的本质就是一个普通的类，但是它继承自<code>Enum</code>类，我们定义的每一个状态其实就是一个<code>public static final</code>的Status类型成员变量：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这里使用javap命令对class文件进行反编译得到 Compiled from "Status.java"</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">test</span>.<span class="hljs-title">Status</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Enum</span>&lt;<span class="hljs-title">com</span>.<span class="hljs-title">test</span>.<span class="hljs-title">Status</span>&gt; </span>{<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> com.test.Status RUNNING;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> com.test.Status STUDY;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> com.test.Status SLEEP;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> com.test.Status[] values();<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> com.test.<span class="hljs-function">Status <span class="hljs-title">valueOf</span><span class="hljs-params">(java.lang.String)</span></span>;<br>  <span class="hljs-keyword">static</span> {};<br>}<br></code></pre></td></tr></tbody></table></figure><p>既然枚举类型是普通的类，那么我们也可以给枚举类型添加独有的成员方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Status</span> </span>{<br>    RUNNING(<span class="hljs-string">"睡觉"</span>), STUDY(<span class="hljs-string">"学习"</span>), SLEEP(<span class="hljs-string">"睡觉"</span>);   <span class="hljs-comment">//无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法）</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;    <span class="hljs-comment">//枚举的成员变量</span><br>    Status(String name){    <span class="hljs-comment">//覆盖原有构造方法（默认private，只能内部使用！）</span><br>        <span class="hljs-keyword">this</span>.name = name;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{   <span class="hljs-comment">//获取封装的成员变量</span><br>        <span class="hljs-keyword">return</span> name;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>这样，枚举就可以按照我们想要的中文名称打印了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Student student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"小明"</span>, <span class="hljs-number">18</span>, <span class="hljs-string">"男"</span>);<br>    student.setStatus(Status.RUNNING);<br>    System.out.println(student.getStatus().getName());<br>}<br></code></pre></td></tr></tbody></table></figure><p>枚举类还自带一些继承下来的实用方法，比如获取枚举类中的所有枚举，只不过这里用到了数组，我们会在下一章进行介绍。</p><p>至此，面向对象基础内容就全部讲解完成了，下一章我们还将继续讲解面向对象的其他内容。</p>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/09/18/UsqxV8ndNzYmGjy.png&quot; alt=&quot;image-20220918121719900&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;面向对象基础篇&quot;&gt;&lt;a href=&quot;#面向对象基础篇&quot; class=&quot;headerlink&quot; title=&quot;面向对象基础篇&quot;&gt;&lt;/a&gt;面向对象基础篇&lt;/h1&gt;&lt;p&gt;我们在前面已经学习了面向过程编程，也可以自行编写出简单的程序了。我们接着就需要认识 面向对象程序设计（Object Oriented Programming）它是我们在Java语言中要学习的重要内容，面向对象也是高级语言的一大重要特性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;面向对象是新手成长的一道分水岭，有的人秒懂，有的人直到最后都无法理解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这一章开始难度就上来了，所以说请各位小伙伴一定认真。&lt;/p&gt;
&lt;h2 id=&quot;类与对象&quot;&gt;&lt;a href=&quot;#类与对象&quot; class=&quot;headerlink&quot; title=&quot;类与对象&quot;&gt;&lt;/a&gt;类与对象&lt;/h2&gt;&lt;p&gt;类的概念我们在生活中其实已经听说过很多了。&lt;/p&gt;
&lt;p&gt;人类、鸟类、鱼类… 所谓类，就是对一类事物的描述，是抽象的、概念上的定义，比如鸟类，就泛指所有具有鸟类特征的动物。比如人类，不同的人，有着不同的性格、不同的爱好、不同的样貌等等，但是他们根本上都是人，所以说可以将他们抽象描述为人类。&lt;/p&gt;
&lt;p&gt;对象是某一类事物实际存在的每个个体，因而也被称为实例（instance）我们每个人都是人类的一个实际存在的个体。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://xiaofanshutu.github.io/posts/0.html"/>
    <id>https://xiaofanshutu.github.io/posts/0.html</id>
    <published>2025-09-07T23:26:13.331Z</published>
    <updated>2025-09-07T23:28:25.714Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://s2.loli.net/2022/10/04/SkAn9RQpqC4tVW5.png" alt="image-20221004131436371"></p><h1 id="集合类与IO"><a href="#集合类与IO" class="headerlink" title="集合类与IO"></a>集合类与IO</h1><p>前面我们已经把基础介绍完了，从这节课开始，我们就正式进入到集合类的讲解中。</p><h2 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h2><p>集合类是Java中非常重要的存在，使用频率极高。集合其实与我们数学中的集合是差不多的概念，集合表示一组对象，每一个对象我们都可以称其为元素。不同的集合有着不同的性质，比如一些集合允许重复的元素，而另一些则不允许，一些集合是有序的，而其他则是无序的。</p><p><img src="https://s2.loli.net/2022/09/30/ZWxPduaYGgRzmNO.png" alt="image-20220930233059528"></p><p>集合类其实就是为了更好地组织、管理和操作我们的数据而存在的，包括列表、集合、队列、映射等数据结构。从这一块开始，我们会从源码角度给大家讲解（先从接口定义对于集合需要实现哪些功能开始说起，包括这些集合类的底层机制是如何运作的）不仅仅是教会大家如何去使用。</p><p>集合跟数组一样，可以表示同样的一组元素，但是他们的相同和不同之处在于：</p><ol><li>它们都是容器，都能够容纳一组元素。</li></ol><p>不同之处：</p><ol><li>数组的大小是固定的，集合的大小是可变的。</li><li>数组可以存放基本数据类型，但集合只能存放对象。</li><li>数组存放的类型只能是一种，但集合可以有不同种类的元素。</li></ol><h3 id="集合根接口"><a href="#集合根接口" class="headerlink" title="集合根接口"></a>集合根接口</h3><p>Java中已经帮我们将常用的集合类型都实现好了，我们只需要直接拿来用就行了，比如我们之前学习的顺序表：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;   <span class="hljs-comment">//集合类基本都是在java.util包下定义的</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-string">"树脂666"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>当然，我们会在这一部分中认识大部分Java为我们提供的集合类。所有的集合类最终都是实现自集合根接口的，比如我们下面就会讲到的ArrayList类，它的祖先就是Collection接口：</p><p><img src="https://s2.loli.net/2022/09/30/U9DdJinhCp6BITe.png" alt="image-20220930232759715"></p><p>这个接口定义了集合类的一些基本操作，我们来看看有哪些方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">E</span>&gt; </span>{<br>    <span class="hljs-comment">//-------这些是查询相关的操作----------</span><br><br>   <span class="hljs-comment">//获取当前集合中的元素数量</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//查看当前集合是否为空</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//查询当前集合中是否包含某个元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span></span>;<br><br>    <span class="hljs-comment">//返回当前集合的迭代器，我们会在后面介绍</span><br>    <span class="hljs-function">Iterator&lt;E&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//将集合转换为数组的形式</span><br>    Object[] toArray();<br><br>    <span class="hljs-comment">//支持泛型的数组转换，同上</span><br>    &lt;T&gt; T[] toArray(T[] a);<br><br>    <span class="hljs-comment">//-------这些是修改相关的操作----------</span><br><br>    <span class="hljs-comment">//向集合中添加元素，不同的集合类具体实现可能会对插入的元素有要求，</span><br>  <span class="hljs-comment">//这个操作并不是一定会添加成功，所以添加成功返回true，否则返回false</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-comment">//从集合中移除某个元素，同样的，移除成功返回true，否则false</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span></span>;<br><br><br>    <span class="hljs-comment">//-------这些是批量执行的操作----------</span><br><br>    <span class="hljs-comment">//查询当前集合是否包含给定集合中所有的元素</span><br>  <span class="hljs-comment">//从数学角度来说，就是看给定集合是不是当前集合的子集</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span></span>;<br><br>    <span class="hljs-comment">//添加给定集合中所有的元素</span><br>  <span class="hljs-comment">//从数学角度来说，就是将当前集合变成当前集合与给定集合的并集</span><br>  <span class="hljs-comment">//添加成功返回true，否则返回false</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span></span>;<br><br>    <span class="hljs-comment">//移除给定集合中出现的所有元素，如果某个元素在当前集合中不存在，那么忽略这个元素</span><br>  <span class="hljs-comment">//从数学角度来说，就是求当前集合与给定集合的差集</span><br>  <span class="hljs-comment">//移除成功返回true，否则false</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">removeAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span></span>;<br><br>    <span class="hljs-comment">//Java8新增方法，根据给定的Predicate条件进行元素移除操作</span><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeIf</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> E&gt; filter)</span> </span>{<br>        Objects.requireNonNull(filter);<br>        <span class="hljs-keyword">boolean</span> removed = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">final</span> Iterator&lt;E&gt; each = iterator();   <span class="hljs-comment">//这里用到了迭代器，我们会在后面进行介绍</span><br>        <span class="hljs-keyword">while</span> (each.hasNext()) {<br>            <span class="hljs-keyword">if</span> (filter.test(each.next())) {<br>                each.remove();<br>                removed = <span class="hljs-keyword">true</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> removed;<br>    }<br><br>    <span class="hljs-comment">//只保留当前集合中在给定集合中出现的元素，其他元素一律移除</span><br>  <span class="hljs-comment">//从数学角度来说，就是求当前集合与给定集合的交集</span><br>  <span class="hljs-comment">//移除成功返回true，否则false</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">retainAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span></span>;<br><br>    <span class="hljs-comment">//清空整个集合，删除所有元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br><br><br>    <span class="hljs-comment">//-------这些是比较以及哈希计算相关的操作----------</span><br><br>    <span class="hljs-comment">//判断两个集合是否相等</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span></span>;<br><br>    <span class="hljs-comment">//计算当前整个集合对象的哈希值</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//与迭代器作用相同，但是是并行执行的，我们会在下一章多线程部分中进行介绍</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> Spliterator&lt;E&gt; <span class="hljs-title">spliterator</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> Spliterators.spliterator(<span class="hljs-keyword">this</span>, <span class="hljs-number">0</span>);<br>    }<br><br>    <span class="hljs-comment">//生成当前集合的流，我们会在后面进行讲解</span><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title">stream</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(), <span class="hljs-keyword">false</span>);<br>    }<br><br>    <span class="hljs-comment">//生成当前集合的并行流，我们会在下一章多线程部分中进行介绍</span><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title">parallelStream</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(), <span class="hljs-keyword">true</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以看到，在这个接口中对于集合相关的操作，还是比较齐全的，那么我们接着就来看看它的实现类。</p><h3 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h3><p>首先我们需要介绍的是List列表（线性表），线性表支持随机访问，相比之前的Collection接口定义，功能还会更多一些。首先介绍ArrayList，我们已经知道，它的底层是用数组实现的，内部维护的是一个可动态进行扩容的数组，也就是我们之前所说的顺序表，跟我们之前自己写的ArrayList相比，它更加的规范，并且功能更加强大，同时实现自List接口。</p><p><img src="https://s2.loli.net/2022/09/30/U9DdJinhCp6BITe.png" alt="image-20220930232759715"></p><p>List是集合类型的一个分支，它的主要特性有：</p><ul><li>是一个有序的集合，插入元素默认是插入到尾部，按顺序从前往后存放，每个元素都有一个自己的下标位置</li><li>列表中允许存在重复元素</li></ul><p>在List接口中，定义了列表类型需要支持的全部操作，List直接继承自前面介绍的Collection接口，其中很多地方重新定义了一次Collection接口中定义的方法，这样做是为了更加明确方法的具体功能，当然，为了直观，我们这里就省略掉：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//List是一个有序的集合类，每个元素都有一个自己的下标位置</span><br><span class="hljs-comment">//List中可插入重复元素</span><br><span class="hljs-comment">//针对于这些特性，扩展了Collection接口中一些额外的操作</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">E</span>&gt; </span>{<br>    ...<br>   <br>    <span class="hljs-comment">//将给定集合中所有元素插入到当前结合的给定位置上（后面的元素就被挤到后面去了，跟我们之前顺序表的插入是一样的）</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, Collection&lt;? extends E&gt; c)</span></span>;<br><br>    ...<br><br>   <span class="hljs-comment">//Java 8新增方法，可以对列表中每个元素都进行处理，并将元素替换为处理之后的结果</span><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">replaceAll</span><span class="hljs-params">(UnaryOperator&lt;E&gt; operator)</span> </span>{<br>        Objects.requireNonNull(operator);<br>        <span class="hljs-keyword">final</span> ListIterator&lt;E&gt; li = <span class="hljs-keyword">this</span>.listIterator();  <span class="hljs-comment">//这里同样用到了迭代器</span><br>        <span class="hljs-keyword">while</span> (li.hasNext()) {<br>            li.set(operator.apply(li.next()));<br>        }<br>    }<br><br>    <span class="hljs-comment">//对当前集合按照给定的规则进行排序操作，这里同样只需要一个Comparator就行了</span><br>    <span class="hljs-meta">@SuppressWarnings({"unchecked", "rawtypes"})</span><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> E&gt; c)</span> </span>{<br>        Object[] a = <span class="hljs-keyword">this</span>.toArray();<br>        Arrays.sort(a, (Comparator) c);<br>        ListIterator&lt;E&gt; i = <span class="hljs-keyword">this</span>.listIterator();<br>        <span class="hljs-keyword">for</span> (Object e : a) {<br>            i.next();<br>            i.set((E) e);<br>        }<br>    }<br><br>    ...<br><br>    <span class="hljs-comment">//-------- 这些是List中独特的位置直接访问操作 --------</span><br><br>   <span class="hljs-comment">//获取对应下标位置上的元素</span><br>    <span class="hljs-function">E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>;<br><br>    <span class="hljs-comment">//直接将对应位置上的元素替换为给定元素</span><br>    <span class="hljs-function">E <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span></span>;<br><br>    <span class="hljs-comment">//在指定位置上插入元素，就跟我们之前的顺序表插入是一样的</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span></span>;<br><br>    <span class="hljs-comment">//移除指定位置上的元素</span><br>    <span class="hljs-function">E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>;<br><br><br>    <span class="hljs-comment">//------- 这些是List中独特的搜索操作 -------</span><br><br>    <span class="hljs-comment">//查询某个元素在当前列表中的第一次出现的下标位置</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(Object o)</span></span>;<br><br>    <span class="hljs-comment">//查询某个元素在当前列表中的最后一次出现的下标位置</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(Object o)</span></span>;<br><br><br>    <span class="hljs-comment">//------- 这些是List的专用迭代器 -------</span><br><br>    <span class="hljs-comment">//迭代器我们会在下一个部分讲解</span><br>    <span class="hljs-function">ListIterator&lt;E&gt; <span class="hljs-title">listIterator</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//迭代器我们会在下一个部分讲解</span><br>    <span class="hljs-function">ListIterator&lt;E&gt; <span class="hljs-title">listIterator</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>;<br><br>    <span class="hljs-comment">//------- 这些是List的特殊转换 -------</span><br><br>    <span class="hljs-comment">//返回当前集合在指定范围内的子集</span><br>    <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">subList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fromIndex, <span class="hljs-keyword">int</span> toIndex)</span></span>;<br><br>    ...<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以看到，在List接口中，扩展了大量列表支持的操作，其中最突出的就是直接根据下标位置进行的增删改查操作。而在ArrayList中，底层就是采用数组实现的，跟我们之前的顺序表思路差不多：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">RandomAccess</span>, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><br><span class="hljs-class"></span>{<br><br>    <span class="hljs-comment">//默认的数组容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;<br><br>    ...<br><br>    <span class="hljs-comment">//存放数据的底层数组，这里的transient关键字我们会在后面I/O中介绍用途</span><br>    <span class="hljs-keyword">transient</span> Object[] elementData;<br><br>    <span class="hljs-comment">//记录当前数组元素数的</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br><br>   <span class="hljs-comment">//这是ArrayList的其中一个构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>{<br>        <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[initialCapacity];   <span class="hljs-comment">//根据初始化大小，创建当前列表</span><br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal Capacity: "</span>+<br>                                               initialCapacity);<br>        }<br>    }<br>  <br>  ...<br>      <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>{<br>        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 这里会判断容量是否充足，不充足需要扩容</span><br>        elementData[size++] = e;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    }<br>  <br>  ...<br>    <br>    <span class="hljs-comment">//默认的列表最大长度为Integer.MAX_VALUE - 8</span><br>    <span class="hljs-comment">//JVM都C++实现中，在数组的对象头中有一个_length字段，用于记录数组的长</span><br>    <span class="hljs-comment">//度，所以这个8就是存了数组_length字段（这个只做了解就行）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>{<br>        <span class="hljs-keyword">int</span> oldCapacity = elementData.length;<br>        <span class="hljs-keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);   <span class="hljs-comment">//扩容规则跟我们之前的是一样的，也是1.5倍</span><br>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)    <span class="hljs-comment">//要是扩容之后的大小还没最小的大小大，那么直接扩容到最小的大小</span><br>            newCapacity = minCapacity;<br>        <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)   <span class="hljs-comment">//要是扩容之后比最大的大小还大，需要进行大小限制</span><br>            newCapacity = hugeCapacity(minCapacity);  <span class="hljs-comment">//调整为限制的大小</span><br>        elementData = Arrays.copyOf(elementData, newCapacity);   <span class="hljs-comment">//使用copyOf快速将内容拷贝到扩容后的新数组中并设定为新的elementData底层数组</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>一般的，如果我们要使用一个集合类，我们会使用接口的引用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();   <span class="hljs-comment">//使用接口的引用来操作具体的集合类实现，是为了方便日后如果我们想要更换不同的集合类实现，而且接口中本身就已经定义了主要的方法，所以说没必要直接用实现类</span><br>    list.add(<span class="hljs-string">"科技与狠活"</span>);   <span class="hljs-comment">//使用add添加元素</span><br>  list.add(<span class="hljs-string">"上头啊"</span>);<br>    System.out.println(list);   <span class="hljs-comment">//打印集合类，可以得到一个非常规范的结果</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>可以看到，打印集合类的效果，跟我们使用Arrays工具类是一样的：</p><p><img src="https://s2.loli.net/2022/10/01/v3uzfnhamXV5St8.png" alt="image-20221001002151164"></p><p>集合的各种功能我们都可以来测试一下，特别注意一下，我们在使用Integer时，要注意传参问题：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.add(<span class="hljs-number">10</span>);   <span class="hljs-comment">//添加Integer的值10</span><br>    list.remove((Integer) <span class="hljs-number">10</span>);   <span class="hljs-comment">//注意，不能直接用10，默认情况下会认为传入的是int类型值，删除的是下标为10的元素，我们这里要删除的是刚刚传入的值为10的Integer对象</span><br>    System.out.println(list);   <span class="hljs-comment">//可以看到，此时元素成功被移除</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>那要是这样写呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.add(<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">10</span>));   <span class="hljs-comment">//添加的是一个对象</span><br>    list.remove(<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">10</span>));   <span class="hljs-comment">//删除的是另一个对象</span><br>    System.out.println(list);<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以看到，结果依然是删除成功，这是因为集合类在删除元素时，只会调用<code>equals</code>方法进行判断是否为指定元素，而不是进行等号判断，所以说一定要注意，如果两个对象使用<code>equals</code>方法相等，那么集合中就是相同的两个对象：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ArrayList源码部分</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>{<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) {<br>        ...<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; size; index++)<br>            <span class="hljs-keyword">if</span> (o.equals(elementData[index])) {   <span class="hljs-comment">//这里只是对两个对象进行equals判断</span><br>                fastRemove(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  <span class="hljs-comment">//只要判断成功，直接认为就是要删除的对象，删除就完事</span><br>            }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>列表中允许存在相同元素，所以说我们可以添加两个一模一样的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    String str = <span class="hljs-string">"哟唉嘛干你"</span>;<br>    list.add(str);<br>    list.add(str);<br>    System.out.println(list);<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/10/01/paeKLsGntNVfHPT.png" alt="image-20221001231509926"></p><p>那要是此时我们删除对象呢，是一起删除还是只删除一个呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    String str = <span class="hljs-string">"哟唉嘛干你"</span>;<br>    list.add(str);<br>    list.add(str);<br>    list.remove(str);<br>    System.out.println(list);<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/10/01/5HdFh74wlqbMoj6.png" alt="image-20221001231619391"></p><p>可以看到，这种情况下，只会删除排在前面的第一个元素。</p><p>集合类是支持嵌套使用的，一个集合中可以存放多个集合，套娃嘛，谁不会：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    List&lt;List&lt;String&gt;&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    list.add(<span class="hljs-keyword">new</span> LinkedList&lt;&gt;());   <span class="hljs-comment">//集合中的每一个元素就是一个集合，这个套娃是可以一直套下去的</span><br>    System.out.println(list.get(<span class="hljs-number">0</span>).isEmpty());<br>}<br></code></pre></td></tr></tbody></table></figure><p>在Arrays工具类中，我们可以快速生成一个只读的List：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>);   <span class="hljs-comment">//非常方便</span><br>    System.out.println(list);<br>}<br></code></pre></td></tr></tbody></table></figure><p>注意，这个生成的List是只读的，不能进行修改操作，只能使用获取内容相关的方法，否则抛出 UnsupportedOperationException 异常。要生成正常使用的，我们可以将这个只读的列表作为参数传入：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>));<br>    System.out.println(list);<br>}<br></code></pre></td></tr></tbody></table></figure><p>当然，也可以利用静态代码块：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;() {{   <span class="hljs-comment">//使用匿名内部类（匿名内部类在Java8无法使用钻石运算符，但是之后的版本可以）</span><br>            add(<span class="hljs-string">"A"</span>);<br>            add(<span class="hljs-string">"B"</span>);<br>            add(<span class="hljs-string">"C"</span>);<br>    }};<br>    System.out.println(list);<br>}<br></code></pre></td></tr></tbody></table></figure><p>这里我们接着介绍另一个列表实现类，LinkedList同样是List的实现类，只不过它是采用的链式实现，也就是我们之前讲解的链表，只不过它是一个双向链表，也就是同时保存两个方向：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSequentialList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><br><span class="hljs-class"></span>{<br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//引用首结点</span><br>    <span class="hljs-keyword">transient</span> Node&lt;E&gt; first;<br><br>    <span class="hljs-comment">//引用尾结点</span><br>    <span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br><br>    <span class="hljs-comment">//构造方法，很简单，直接创建就行了</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedList</span><span class="hljs-params">()</span> </span>{<br>    }<br>  <br>  ...<br>      <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>{   <span class="hljs-comment">//内部使用的结点类</span><br>        E item;<br>        Node&lt;E&gt; next;   <span class="hljs-comment">//不仅保存指向下一个结点的引用，还保存指向上一个结点的引用</span><br>        Node&lt;E&gt; prev;<br><br>        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {<br>            <span class="hljs-keyword">this</span>.item = element;<br>            <span class="hljs-keyword">this</span>.next = next;<br>            <span class="hljs-keyword">this</span>.prev = prev;<br>        }<br>    }<br>  <br>    ...<br>}<br></code></pre></td></tr></tbody></table></figure><p>LinkedList的使用和ArrayList的使用几乎相同，各项操作的结果也是一样的，在什么使用使用ArrayList和LinkedList，我们需要结合具体的场景来决定，尽可能的扬长避短。</p><p>只不过LinkedList不仅可以当做List来使用，也可以当做双端队列使用，我们会在后面进行详细介绍。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>我们接着来介绍迭代器，实际上我们的集合类都是支持使用<code>foreach</code>语法的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>);<br>    <span class="hljs-keyword">for</span> (String s : list) {   <span class="hljs-comment">//集合类同样支持这种语法</span><br>        System.out.println(s);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>但是由于仅仅是语法糖，实际上编译之后：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>);<br>    Iterator var2 = list.iterator();   <span class="hljs-comment">//这里使用的是List的迭代器在进行遍历操作</span><br><br>    <span class="hljs-keyword">while</span>(var2.hasNext()) {<br>        String s = (String)var2.next();<br>        System.out.println(s);<br>    }<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>那么这个迭代器是一个什么东西呢？我们来研究一下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>);<br>  <span class="hljs-comment">//通过调用iterator方法快速获取当前集合的迭代器</span><br>  <span class="hljs-comment">//Iterator迭代器本身也是一个接口，由具体的集合实现类来根据情况实现</span><br>    Iterator&lt;String&gt; iterator = list.iterator();<br>}<br></code></pre></td></tr></tbody></table></figure><p>通过使用迭代器，我们就可以实现对集合中的元素的进行遍历，就像我们遍历数组那样，它的运作机制大概是：</p><p><img src="https://s2.loli.net/2022/10/02/8KS5jbTv7LoAVOs.png" alt="image-20221002150914323"></p><p>一个新的迭代器就像上面这样，默认有一个指向集合中第一个元素的指针：</p><p><img src="https://s2.loli.net/2022/10/02/HxjfipVB9TlEbz5.png" alt="image-20221002151110991"></p><p>每一次<code>next</code>操作，都会将指针后移一位，直到完成每一个元素的遍历，此时再调用<code>next</code>将不能再得到下一个元素。至于为什么要这样设计，是因为集合类的实现方案有很多，可能是链式存储，也有可能是数组存储，不同的实现有着不同的遍历方式，而迭代器则可以将多种多样不同的集合类遍历方式进行统一，只需要各个集合类根据自己的情况进行对应实现就行了。</p><p>我们来看看这个接口的源码定义了哪些操作：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>{<br>    <span class="hljs-comment">//看看是否还有下一个元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//遍历当前元素，并将下一个元素作为待遍历元素</span><br>    <span class="hljs-function">E <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//移除上一个被遍历的元素（某些集合不支持这种操作）</span><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">"remove"</span>);<br>    }<br><br>    <span class="hljs-comment">//对剩下的元素进行自定义遍历操作</span><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEachRemaining</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> E&gt; action)</span> </span>{<br>        Objects.requireNonNull(action);<br>        <span class="hljs-keyword">while</span> (hasNext())<br>            action.accept(next());<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>在ArrayList和LinkedList中，迭代器的实现也不同，比如ArrayList就是直接按下标访问：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>{<br>    ...<br>    cursor = i + <span class="hljs-number">1</span>;   <span class="hljs-comment">//移动指针</span><br>    <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];  <span class="hljs-comment">//直接返回指针所指元素</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>LinkedList就是不断向后寻找结点：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>{<br>    ...<br>    next = next.next;   <span class="hljs-comment">//向后继续寻找结点</span><br>    nextIndex++;<br>    <span class="hljs-keyword">return</span> lastReturned.item;  <span class="hljs-comment">//返回结点内部存放的元素</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>虽然这两种列表的实现不同，遍历方式也不同，但是都是按照迭代器的标准进行了实现，所以说，我们想要遍历一个集合中所有的元素，那么就可以直接使用迭代器来完成，而不需要关心集合类是如何实现，我们该怎么去遍历：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>);<br>    Iterator&lt;String&gt; iterator = list.iterator();<br>    <span class="hljs-keyword">while</span> (iterator.hasNext()) {    <span class="hljs-comment">//每次循环一定要判断是否还有元素剩余</span><br>        System.out.println(iterator.next());  <span class="hljs-comment">//如果有就可以继续获取到下一个元素</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>注意，迭代器的使用是一次性的，用了之后就不能用了，如果需要再次进行遍历操作，那么需要重新生成一个迭代器对象。为了简便，我们可以直接使用<code>foreach</code>语法来快速遍历集合类，效果是完全一样的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>);<br>    <span class="hljs-keyword">for</span> (String s : list) {<br>        System.out.println(s);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>在Java8提供了一个支持Lambda表达式的forEach方法，这个方法接受一个Consumer，也就是对遍历的每一个元素进行的操作：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>);<br>    list.forEach(System.out::println);<br>}<br></code></pre></td></tr></tbody></table></figure><p>这个效果跟上面的写法是完全一样的，因为forEach方法内部本质上也是迭代器在处理，这个方法是在Iterable接口中定义的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; action)</span> </span>{<br>    Objects.requireNonNull(action);<br>    <span class="hljs-keyword">for</span> (T t : <span class="hljs-keyword">this</span>) {   <span class="hljs-comment">//foreach语法遍历每一个元素</span><br>        action.accept(t);   <span class="hljs-comment">//调用Consumer的accept来对每一个元素进行消费</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>那么我们来看一下，Iterable这个接口又是是什么东西？</p><p><img src="https://s2.loli.net/2022/10/02/4ShtiO6kdIcwZ85.png" alt="image-20221002152713622"></p><p>我们来看看定义了哪些内容：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注意这个接口是集合接口的父接口，不要跟之前的迭代器接口搞混了</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">T</span>&gt; </span>{<br>    <span class="hljs-comment">//生成当前集合的迭代器，在Collection接口中重复定义了一次</span><br>    <span class="hljs-function">Iterator&lt;T&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//Java8新增方法，因为是在顶层接口中定义的，因此所有的集合类都有这个方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; action)</span> </span>{<br>        Objects.requireNonNull(action);<br>        <span class="hljs-keyword">for</span> (T t : <span class="hljs-keyword">this</span>) {<br>            action.accept(t);<br>        }<br>    }<br><br>    <span class="hljs-comment">//这个方法会在多线程部分中进行介绍，暂时不做讲解</span><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> Spliterator&lt;T&gt; <span class="hljs-title">spliterator</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="hljs-number">0</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>得益于Iterable提供的迭代器生成方法，实际上只要是实现了迭代器接口的类（我们自己写的都行），都可以使用<code>foreach</code>语法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">String</span>&gt;</span>{   <span class="hljs-comment">//这里我们随便写一个类，让其实现Iterable接口</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;String&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Iterator&lt;String&gt;() {   <span class="hljs-comment">//生成一个匿名的Iterator对象</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>{   <span class="hljs-comment">//这里随便写的，直接返回true，这将会导致无限循环</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            }<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>{   <span class="hljs-comment">//每次就直接返回一个字符串吧</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-string">"测试"</span>;<br>            }<br>        };<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以看到，直接就支持这种语法了，虽然我们这个是自己写的，并不是集合类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Test test = <span class="hljs-keyword">new</span> Test();<br>    <span class="hljs-keyword">for</span> (String s : test) {<br>        System.out.println(s);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/10/02/KejcFB8TChE5z4o.png" alt="image-20221002154018319"></p><p>是不是感觉集合类的设计非常巧妙？</p><p>我们这里再来介绍一下ListIterator，这个迭代器是针对于List的强化版本，增加了更多方便的操作，因为List是有序集合，所以它支持两种方向的遍历操作，不仅能从前向后，也可以从后向前：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ListIterator</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>{<br>    <span class="hljs-comment">//原本就有的</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//原本就有的</span><br>    <span class="hljs-function">E <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//查看前面是否有已经遍历的元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPrevious</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//跟next相反，这里是倒着往回遍历</span><br>    <span class="hljs-function">E <span class="hljs-title">previous</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//返回下一个待遍历元素的下标</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nextIndex</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//返回上一个已遍历元素的下标</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">previousIndex</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//原本就有的</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//将上一个已遍历元素修改为新的元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-comment">//在遍历过程中，插入新的元素到当前待遍历元素之前</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们来测试一下吧：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>));<br>    ListIterator&lt;String&gt; iterator = list.listIterator();<br>    iterator.next();   <span class="hljs-comment">//此时得到A</span><br>    iterator.set(<span class="hljs-string">"X"</span>);  <span class="hljs-comment">//将A原本位置的上的元素设定为成新的</span><br>    System.out.println(list);<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/10/02/C3xNDTEWGaPLfO6.png" alt="image-20221002154844743"></p><p>这种迭代器因为能够双向遍历，所以说可以反复使用。</p><h3 id="Queue和Deque"><a href="#Queue和Deque" class="headerlink" title="Queue和Deque"></a>Queue和Deque</h3><p>通过前面的学习，我们已经了解了List的使用，其中LinkedList除了可以直接当做列表使用之外，还可以当做其他的数据结构使用，可以看到它不仅仅实现了List接口：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSequentialList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><br><span class="hljs-class"></span>{<br></code></pre></td></tr></tbody></table></figure><p>这个Deque接口是干嘛的呢？我们先来看看它的继承结构：</p><p><img src="https://s2.loli.net/2022/10/02/sCMgv9rl5b743BE.png" alt="image-20221002162108279"></p><p>我们先来看看队列接口，它扩展了大量队列相关操作：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">E</span>&gt; </span>{<br>    <span class="hljs-comment">//队列的添加操作，是在队尾进行插入（只不过List也是一样的，默认都是尾插）</span><br>  <span class="hljs-comment">//如果插入失败，会直接抛出异常</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-comment">//同样是添加操作，但是插入失败不会抛出异常</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-comment">//移除队首元素，但是如果队列已经为空，那么会抛出异常</span><br>    <span class="hljs-function">E <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>;<br><br>   <span class="hljs-comment">//同样是移除队首元素，但是如果队列为空，会返回null</span><br>    <span class="hljs-function">E <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//仅获取队首元素，不进行出队操作，但是如果队列已经为空，那么会抛出异常</span><br>    <span class="hljs-function">E <span class="hljs-title">element</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//同样是仅获取队首元素，但是如果队列为空，会返回null</span><br>    <span class="hljs-function">E <span class="hljs-title">peek</span><span class="hljs-params">()</span></span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以直接将一个LinkedList当做一个队列来使用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();   <span class="hljs-comment">//当做队列使用，还是很方便的</span><br>    queue.offer(<span class="hljs-string">"AAA"</span>);<br>    queue.offer(<span class="hljs-string">"BBB"</span>);<br>    System.out.println(queue.poll());<br>    System.out.println(queue.poll());<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/10/02/veHxlUkKyVYErgm.png" alt="image-20221002163512442"></p><p>我们接着来看双端队列，实际上双端队列就是队列的升级版，我们一个普通的队列就是：</p><p><img src="https://s2.loli.net/2022/07/25/xBuZckTNtR54AEq.png" alt="image-20220725103600318"></p><p>普通队列中从队尾入队，队首出队，而双端队列允许在队列的两端进行入队和出队操作：</p><p><img src="https://s2.loli.net/2022/10/02/gn8i3teclAKbhQS.png" alt="image-20221002164302507"></p><p><img src="https://s2.loli.net/2022/10/02/in8IX3QkwtsLgWN.png" alt="image-20221002164431746"></p><p>利用这种特性，双端队列既可以当做普通队列使用，也可以当做栈来使用，我们来看看Java中是如何定义的Deque双端队列接口的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在双端队列中，所有的操作都有分别对应队首和队尾的</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; </span>{<br>    <span class="hljs-comment">//在队首进行插入操作</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addFirst</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-comment">//在队尾进行插入操作</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addLast</span><span class="hljs-params">(E e)</span></span>;<br><br>  <span class="hljs-comment">//不用多说了吧？</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offerFirst</span><span class="hljs-params">(E e)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offerLast</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-comment">//在队首进行移除操作</span><br>    <span class="hljs-function">E <span class="hljs-title">removeFirst</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//在队尾进行移除操作</span><br>    <span class="hljs-function">E <span class="hljs-title">removeLast</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//不用多说了吧？</span><br>    <span class="hljs-function">E <span class="hljs-title">pollFirst</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">E <span class="hljs-title">pollLast</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//获取队首元素</span><br>    <span class="hljs-function">E <span class="hljs-title">getFirst</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//获取队尾元素</span><br>    <span class="hljs-function">E <span class="hljs-title">getLast</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">//不用多说了吧？</span><br>    <span class="hljs-function">E <span class="hljs-title">peekFirst</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">E <span class="hljs-title">peekLast</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//从队列中删除第一个出现的指定元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">removeFirstOccurrence</span><span class="hljs-params">(Object o)</span></span>;<br><br>    <span class="hljs-comment">//从队列中删除最后一个出现的指定元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">removeLastOccurrence</span><span class="hljs-params">(Object o)</span></span>;<br><br>    <span class="hljs-comment">// *** 队列中继承下来的方法操作是一样的，这里就不列出了 ***</span><br><br>    ...<br><br>    <span class="hljs-comment">// *** 栈相关操作已经帮助我们定义好了 ***</span><br><br>    <span class="hljs-comment">//将元素推向栈顶</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-comment">//将元素从栈顶出栈</span><br>    <span class="hljs-function">E <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;<br><br><br>    <span class="hljs-comment">// *** 集合类中继承的方法这里也不多种介绍了 ***</span><br><br>    ...<br><br>    <span class="hljs-comment">//生成反向迭代器，这个迭代器也是单向的，但是是next方法是从后往前进行遍历的</span><br>    <span class="hljs-function">Iterator&lt;E&gt; <span class="hljs-title">descendingIterator</span><span class="hljs-params">()</span></span>;<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以来测试一下，比如我们可以直接当做栈来进行使用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Deque&lt;String&gt; deque = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    deque.push(<span class="hljs-string">"AAA"</span>);<br>    deque.push(<span class="hljs-string">"BBB"</span>);<br>    System.out.println(deque.pop());<br>    System.out.println(deque.pop());<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/10/02/92woGL5MiBsTcKe.png" alt="image-20221002165618791"></p><p>可以看到，得到的顺序和插入顺序是完全相反的，其实只要各位理解了前面讲解的数据结构，就很简单了。我们来测试一下反向迭代器和正向迭代器：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Deque&lt;String&gt; deque = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    deque.addLast(<span class="hljs-string">"AAA"</span>);<br>    deque.addLast(<span class="hljs-string">"BBB"</span>);<br>    <br>    Iterator&lt;String&gt; descendingIterator = deque.descendingIterator();<br>    System.out.println(descendingIterator.next());<br><br>    Iterator&lt;String&gt; iterator = deque.iterator();<br>    System.out.println(iterator.next());<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以看到，正向迭代器和反向迭代器的方向是完全相反的。</p><p>当然，除了LinkedList实现了队列接口之外，还有其他的实现类，但是并不是很常用，这里做了解就行了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Deque&lt;String&gt; deque = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();   <span class="hljs-comment">//数组实现的栈和队列</span><br>    Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();  <span class="hljs-comment">//优先级队列</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>这里需要介绍一下优先级队列，优先级队列可以根据每一个元素的优先级，对出队顺序进行调整，默认情况按照自然顺序：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();<br>    queue.offer(<span class="hljs-number">10</span>);<br>    queue.offer(<span class="hljs-number">4</span>);<br>    queue.offer(<span class="hljs-number">5</span>);<br>    System.out.println(queue.poll());<br>    System.out.println(queue.poll());<br>    System.out.println(queue.poll());<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/10/03/bmEP9fgCS1Ksaqw.png" alt="image-20221003210253093"></p><p>可以看到，我们的插入顺序虽然是10/4/5，但是出队顺序是按照优先级来的，类似于VIP用户可以优先结束排队。我们也可以自定义比较规则，同样需要给一个Comparator的实现：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; b - a);   <span class="hljs-comment">//按照从大到小顺序出队</span><br>    queue.offer(<span class="hljs-number">10</span>);<br>    queue.offer(<span class="hljs-number">4</span>);<br>    queue.offer(<span class="hljs-number">5</span>);<br>    System.out.println(queue.poll());<br>    System.out.println(queue.poll());<br>    System.out.println(queue.poll());<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/10/03/G5SZgKxvUJyPABD.png" alt="image-20221003210436684"></p><p>只不过需要注意的是，优先级队列并不是队列中所有的元素都是按照优先级排放的，优先级队列<strong>只能保证出队顺序是按照优先级</strong>进行的，我们可以打印一下：</p><p><img src="https://s2.loli.net/2022/10/03/9dSheG4xqFoXB5i.png" alt="image-20221003210545678"></p><p>想要了解优先级队列的具体是原理，可以在《数据结构与算法》篇视频教程中学习大顶堆和小顶堆。</p><h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><p>前面我们已经介绍了列表，我们接着来看Set集合，这种集合类型比较特殊，我们先来看看Set的定义：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Set</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">E</span>&gt; </span>{<br>    <span class="hljs-comment">// Set集合中基本都是从Collection直接继承过来的方法，只不过对这些方法有更加特殊的定义</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span></span>;<br>    <span class="hljs-function">Iterator&lt;E&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>;<br>    Object[] toArray();<br>    &lt;T&gt; T[] toArray(T[] a);<br><br>    <span class="hljs-comment">//添加元素只有在当前Set集合中不存在此元素时才会成功，如果插入重复元素，那么会失败</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-comment">//这个同样是删除指定元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span></span>;<br><br>    <span class="hljs-comment">//同样是只能插入那些不重复的元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span></span>;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">retainAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">removeAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//这个方法我们同样会放到多线程中进行介绍</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> Spliterator&lt;E&gt; <span class="hljs-title">spliterator</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> Spliterators.spliterator(<span class="hljs-keyword">this</span>, Spliterator.DISTINCT);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现接口中定义的方法都是Collection中直接继承的，因此，Set支持的功能其实也就和Collection中定义的差不多，只不过：</p><ul><li>不允许出现重复元素</li><li>不支持随机访问（不允许通过下标访问）</li></ul><p>首先认识一下HashSet，它的底层就是采用哈希表实现的（我们在这里先不去探讨实现原理，因为底层实质上是借用的一个HashMap在实现，这个需要我们学习了Map之后再来讨论）我们可以非常高效的从HashSet中存取元素，我们先来测试一下它的特性：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    System.out.println(set.add(<span class="hljs-string">"AAA"</span>));   <span class="hljs-comment">//这里我们连续插入两个同样的字符串</span><br>    System.out.println(set.add(<span class="hljs-string">"AAA"</span>));<br>    System.out.println(set);   <span class="hljs-comment">//可以看到，最后实际上只有一个成功插入了</span><br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/10/03/y5AoUG1iuWzhOSj.png" alt="image-20221003211330129"></p><p>在Set接口中并没有定义支持指定下标位置访问的添加和删除操作，我们只能简单的删除Set中的某个对象：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    System.out.println(set.add(<span class="hljs-string">"AAA"</span>));<br>    System.out.println(set.remove(<span class="hljs-string">"AAA"</span>));<br>    System.out.println(set);<br>}<br></code></pre></td></tr></tbody></table></figure><p>由于底层采用哈希表实现，所以说无法维持插入元素的顺序：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    set.addAll(Arrays.asList(<span class="hljs-string">"A"</span>, <span class="hljs-string">"0"</span>, <span class="hljs-string">"-"</span>, <span class="hljs-string">"+"</span>));<br>    System.out.println(set);<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/10/03/OekDqMlpVbxImsK.png" alt="image-20221003211635759"></p><p>那要是我们就是想要使用维持顺序的Set集合呢？我们可以使用LinkedHashSet，LinkedHashSet底层维护的不再是一个HashMap，而是LinkedHashMap，它能够在插入数据时利用链表自动维护顺序，因此这样就能够保证我们插入顺序和最后的迭代顺序一致了。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Set&lt;String&gt; set = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();<br>    set.addAll(Arrays.asList(<span class="hljs-string">"A"</span>, <span class="hljs-string">"0"</span>, <span class="hljs-string">"-"</span>, <span class="hljs-string">"+"</span>));<br>    System.out.println(set);<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/10/03/TpczL2Zi1OkaHWI.png" alt="image-20221003212147700"></p><p>还有一种Set叫做TreeSet，它会在元素插入时进行排序：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    TreeSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;();<br>    set.add(<span class="hljs-number">1</span>);<br>    set.add(<span class="hljs-number">3</span>);<br>    set.add(<span class="hljs-number">2</span>);<br>    System.out.println(set);<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/10/03/3VwDQzRxUTGrOZb.png" alt="image-20221003212233263"></p><p>可以看到最后得到的结果并不是我们插入顺序，而是按照数字的大小进行排列。当然，我们也可以自定义排序规则：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    TreeSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;((a, b) -&gt; b - a);  <span class="hljs-comment">//同样是一个Comparator</span><br>    set.add(<span class="hljs-number">1</span>);<br>    set.add(<span class="hljs-number">3</span>);<br>    set.add(<span class="hljs-number">2</span>);<br>    System.out.println(set);<br>}<br></code></pre></td></tr></tbody></table></figure><p>目前，Set集合只是粗略的进行了讲解，但是学习Map之后，我们还会回来看我们Set的底层实现，所以说最重要的还是Map。本节只需要记住Set的性质、使用即可。</p><h3 id="Map映射"><a href="#Map映射" class="headerlink" title="Map映射"></a>Map映射</h3><p>什么是映射？我们在高中阶段其实已经学习过映射（Mapping）了，映射指两个元素的之间相互“对应”的关系，也就是说，我们的元素之间是两两对应的，是以键值对的形式存在。</p><p><img src="https://s2.loli.net/2022/10/03/QSxqJLwiNM1nZlO.jpg" alt="39e19f3e-04e8-4c43-8fb5-6d5288a7cdf8"></p><p>而Map就是为了实现这种数据结构而存在的，我们通过保存键值对的形式来存储映射关系，就可以轻松地通过键找到对应的映射值，比如现在我们要保存很多学生的信息，而这些学生都有自己的ID，我们可以将其以映射的形式保存，将ID作为键，学生详细信息作为值，这样我们就可以通过学生的ID快速找到对应学生的信息了。</p><p><img src="https://s2.loli.net/2022/10/03/i2x6m3hzFC5GIAd.png" alt="image-20221003213157956"></p><p>在Map中，这些映射关系被存储为键值对，我们先来看看Map接口中定义了哪些操作：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Map并不是Collection体系下的接口，而是单独的一个体系，因为操作特殊</span><br><span class="hljs-comment">//这里需要填写两个泛型参数，其中K就是键的类型，V就是值的类型，比如上面的学生信息，ID一般是int，那么键就是Integer类型的，而值就是学生信息，所以说值是学生对象类型的</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>{<br>    <span class="hljs-comment">//-------- 查询相关操作 --------</span><br>  <br>  <span class="hljs-comment">//获取当前存储的键值对数量</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//是否为空</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//查看Map中是否包含指定的键</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsKey</span><span class="hljs-params">(Object key)</span></span>;<br><br>    <span class="hljs-comment">//查看Map中是否包含指定的值</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsValue</span><span class="hljs-params">(Object value)</span></span>;<br><br>    <span class="hljs-comment">//通过给定的键，返回其映射的值</span><br>    <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span></span>;<br><br>    <span class="hljs-comment">//-------- 修改相关操作 --------</span><br><br>    <span class="hljs-comment">//向Map中添加新的映射关系，也就是新的键值对</span><br>    <span class="hljs-function">V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span></span>;<br><br>    <span class="hljs-comment">//根据给定的键，移除其映射关系，也就是移除对应的键值对</span><br>    <span class="hljs-function">V <span class="hljs-title">remove</span><span class="hljs-params">(Object key)</span></span>;<br><br><br>    <span class="hljs-comment">//-------- 批量操作 --------</span><br><br>    <span class="hljs-comment">//将另一个Map中的所有键值对添加到当前Map中</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">putAll</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span></span>;<br><br>    <span class="hljs-comment">//清空整个Map</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br><br><br>    <span class="hljs-comment">//-------- 其他视图操作 --------</span><br><br>    <span class="hljs-comment">//返回Map中存放的所有键，以Set形式返回</span><br>    <span class="hljs-function">Set&lt;K&gt; <span class="hljs-title">keySet</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//返回Map中存放的所有值</span><br>    <span class="hljs-function">Collection&lt;V&gt; <span class="hljs-title">values</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//返回所有的键值对，这里用的是内部类Entry在表示</span><br>    Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();<br><br>    <span class="hljs-comment">//这个是内部接口Entry，表示一个键值对</span><br>    <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>{<br>        <span class="hljs-comment">//获取键值对的键</span><br>        <span class="hljs-function">K <span class="hljs-title">getKey</span><span class="hljs-params">()</span></span>;<br><br>        <span class="hljs-comment">//获取键值对的值</span><br>        <span class="hljs-function">V <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>;<br><br>        <span class="hljs-comment">//修改键值对的值</span><br>        <span class="hljs-function">V <span class="hljs-title">setValue</span><span class="hljs-params">(V value)</span></span>;<br><br>        <span class="hljs-comment">//判断两个键值对是否相等</span><br>        <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span></span>;<br><br>        <span class="hljs-comment">//返回当前键值对的哈希值</span><br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>;<br><br>        ...<br>    }<br><br>    ...<br>}<br></code></pre></td></tr></tbody></table></figure><p>当然，Map中定义了非常多的方法，尤其是在Java 8之后新增的大量方法，我们会在后面逐步介绍的。</p><p>我们可以来尝试使用一下Map，实际上非常简单，这里我们使用最常见的HashMap，它的底层采用哈希表实现：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">"小明"</span>);   <span class="hljs-comment">//使用put方法添加键值对，返回值我们会在后面讨论</span><br>    map.put(<span class="hljs-number">2</span>, <span class="hljs-string">"小红"</span>);<br>    System.out.println(map.get(<span class="hljs-number">2</span>)); <span class="hljs-comment">//使用get方法根据键获取对应的值</span><br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/10/03/8Fl6YizINQP9dmX.png" alt="image-20221003214807048"></p><p>注意，Map中无法添加相同的键，同样的键只能存在一个，即使值不同。如果出现键相同的情况，那么会覆盖掉之前的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">"小明"</span>);<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">"小红"</span>);   <span class="hljs-comment">//这里的键跟之前的是一样的，这样会导致将之前的键值对覆盖掉</span><br>    System.out.println(map.get(<span class="hljs-number">1</span>));<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/10/03/8Fl6YizINQP9dmX.png" alt="image-20221003214807048"></p><p>为了防止意外将之前的键值对覆盖掉，我们可以使用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">"小明"</span>);<br>    map.putIfAbsent(<span class="hljs-number">1</span>, <span class="hljs-string">"小红"</span>);   <span class="hljs-comment">//Java8新增操作，只有在不存在相同键的键值对时才会存放</span><br>    System.out.println(map.get(<span class="hljs-number">1</span>));<br>}<br></code></pre></td></tr></tbody></table></figure><p>还有，我们在获取一个不存在的映射时，默认会返回null作为结果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">"小明"</span>);   <span class="hljs-comment">//Map中只有键为1的映射</span><br>    System.out.println(map.get(<span class="hljs-number">3</span>));  <span class="hljs-comment">//此时获取键为3的值，那肯定是没有的，所以说返回null</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>我们也可以为这种情况添加一个预备方案，当Map中不存在时，可以返回一个备选的返回值：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">"小明"</span>);<br>    System.out.println(map.getOrDefault(<span class="hljs-number">3</span>, <span class="hljs-string">"备胎"</span>));   <span class="hljs-comment">//Java8新增操作，当不存在对应的键值对时，返回备选方案</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>同样的，因为HashMap底层采用哈希表实现，所以不维护顺序，我们在获取所有键和所有值时，可能会是乱序的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Map&lt;String , String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-string">"0"</span>, <span class="hljs-string">"十七张"</span>);<br>    map.put(<span class="hljs-string">"+"</span>, <span class="hljs-string">"牌"</span>);<br>    map.put(<span class="hljs-string">"P"</span>, <span class="hljs-string">"你能秒我"</span>);<br>    System.out.println(map);<br>    System.out.println(map.keySet());<br>    System.out.println(map.values());<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/10/03/DNXqwk3UOPnMmlc.png" alt="image-20221003220156062"></p><p>如果需要维护顺序，我们同样可以使用LinkedHashMap，它的内部对插入顺序进行了维护：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Map&lt;String , String&gt; map = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();<br>    map.put(<span class="hljs-string">"0"</span>, <span class="hljs-string">"十七张"</span>);<br>    map.put(<span class="hljs-string">"+"</span>, <span class="hljs-string">"牌"</span>);<br>    map.put(<span class="hljs-string">"P"</span>, <span class="hljs-string">"你能秒我"</span>);<br>    System.out.println(map);<br>    System.out.println(map.keySet());<br>    System.out.println(map.values());<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/10/03/QHkWZsFvzASpxqL.png" alt="image-20221003220458539"></p><p>实际上Map的使用还是挺简单的，我们接着来看看Map的底层是如何实现的，首先是最简单的HashMap，我们前面已经说过了，它的底层采用的是哈希表，首先回顾我们之前学习的哈希表，我们当时说了，哈希表可能会出现哈希冲突，这样保存的元素数量就会存在限制，而我们可以通过连地址法解决这种问题，最后哈希表就长这样了：</p><p><img src="https://s2.loli.net/2022/09/30/kr4CcVEwI72AiDU.png" alt="image-20220820221104298"></p><p>实际上这个表就是一个存放头结点的数组+若干结点，而HashMap也是这样的，我们来看看这里面是怎么定义的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Serializable</span> </span>{<br>  <br>  ...<br>    <br>  <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>{   <span class="hljs-comment">//内部使用结点，实际上就是存放的映射关系</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;<br>        <span class="hljs-keyword">final</span> K key;   <span class="hljs-comment">//跟我们之前不一样，我们之前一个结点只有键，而这里的结点既存放键也存放值，当然计算哈希还是使用键</span><br>        V value;<br>        Node&lt;K,V&gt; next;<br>...<br>    }<br>  <br>  ...<br>  <br>  <span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;   <span class="hljs-comment">//这个就是哈希表本体了，可以看到跟我们之前的写法是一样的，也是头结点数组，只不过HashMap中没有设计头结点（相当于没有头结点的链表）</span><br>  <br>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;   <span class="hljs-comment">//负载因子，这个东西决定了HashMap的扩容效果</span><br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">//当我们创建对象时，会使用默认的负载因子，值为0.75</span><br>    }<br>  <br>  ...     <br>}<br></code></pre></td></tr></tbody></table></figure><p>可以看到，实际上底层大致结构跟我们之前学习的差不多，只不过多了一些特殊的东西：</p><ul><li>HashMap支持自动扩容，哈希表的大小并不是一直不变的，否则太过死板</li><li>HashMap并不是只使用简单的链地址法，当链表长度到达一定限制时，会转变为效率更高的红黑树结构</li></ul><p>我们来研究一下它的put方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>{<br>  <span class="hljs-comment">//这里计算完键的哈希值之后，调用的另一个方法进行映射关系存放</span><br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,</span></span><br><span class="hljs-function"><span class="hljs-params">               <span class="hljs-keyword">boolean</span> evict)</span> </span>{<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;<br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)  <span class="hljs-comment">//如果底层哈希表没初始化，先初始化</span><br>        n = (tab = resize()).length;   <span class="hljs-comment">//通过resize方法初始化底层哈希表，初始容量为16，后续会根据情况扩容，底层哈希表的长度永远是2的n次方</span><br>  <span class="hljs-comment">//因为传入的哈希值可能会很大，这里同样是进行取余操作</span><br>  <span class="hljs-comment">//(n - 1) &amp; hash 等价于 hash % n 这里的i就是最终得到的下标位置了</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);   <span class="hljs-comment">//如果这个位置上什么都没有，那就直接放一个新的结点</span><br>    <span class="hljs-keyword">else</span> {   <span class="hljs-comment">//这种情况就是哈希冲突了</span><br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;   <span class="hljs-comment">//如果上来第一个结点的键的哈希值跟当前插入的键的哈希值相同，键也相同，说明已经存放了相同键的键值对了，那就执行覆盖操作</span><br>            ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>            e = p;   <span class="hljs-comment">//这里直接将待插入结点等于原本冲突的结点，一会直接覆盖</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)   <span class="hljs-comment">//如果第一个结点是TreeNode类型的，说明这个链表已经升级为红黑树了</span><br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);  <span class="hljs-comment">//在红黑树中插入新的结点</span><br>        <span class="hljs-keyword">else</span> {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) {  <span class="hljs-comment">//普通链表就直接在链表尾部插入</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) {<br>                    p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);  <span class="hljs-comment">//找到尾部，直接创建新的结点连在后面</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">//如果当前链表的长度已经很长了，达到了阈值</span><br>                        treeifyBin(tab, hash);<span class="hljs-comment">//那么就转换为红黑树来存放</span><br>                    <span class="hljs-keyword">break</span>;   <span class="hljs-comment">//直接结束</span><br>                }<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))  <span class="hljs-comment">//同样的，如果在向下找的过程中发现已经存在相同键的键值对了，直接结束，让p等于e一会覆盖就行了</span><br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            }<br>        }<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) { <span class="hljs-comment">// 如果e不为空，只有可能是前面出现了相同键的情况，其他情况e都是null，所有直接覆盖就行</span><br>            V oldValue = e.value;<br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)<br>                e.value = value;<br>            afterNodeAccess(e);<br>            <span class="hljs-keyword">return</span> oldValue;   <span class="hljs-comment">//覆盖之后，会返回原本的被覆盖值</span><br>        }<br>    }<br>    ++modCount;<br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)   <span class="hljs-comment">//键值对size计数自增，如果超过阈值，会对底层哈希表数组进行扩容</span><br>        resize();   <span class="hljs-comment">//调用resize进行扩容</span><br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;  <span class="hljs-comment">//正常插入键值对返回值为null</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>是不是感觉只要前面的数据结构听懂了，这里简直太简单。根据上面的推导，我们在正常插入一个键值对时，会得到null返回值，而冲突时会得到一个被覆盖的值：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Map&lt;String , String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    System.out.println(map.put(<span class="hljs-string">"0"</span>, <span class="hljs-string">"十七张"</span>));<br>    System.out.println(map.put(<span class="hljs-string">"0"</span>, <span class="hljs-string">"慈善家"</span>));<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/10/03/A2rXocbU9StlDOC.png" alt="image-20221003224137177"></p><p>现在我们知道，当HashMap的一个链表长度过大时，会自动转换为红黑树：</p><p><img src="https://s2.loli.net/2022/10/03/E7GnIVjPAwf8Fol.jpg" alt="710c1c38-95a8-493d-8645-067b991af908"></p><p>但是这样始终治标不治本，受限制的始终是底层哈希表的长度，我们还需要进一步对底层的这个哈希表进行扩容才可以从根本上解决问题，我们来看看<code>resize()</code>方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() {<br>    Node&lt;K,V&gt;[] oldTab = table;   <span class="hljs-comment">//先把下面这几个旧的东西保存一下</span><br>    <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-keyword">int</span> oldThr = threshold;<br>    <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;  <span class="hljs-comment">//这些是新的容量和扩容阈值</span><br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) {  <span class="hljs-comment">//如果旧容量大于0，那么就开始扩容</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) {  <span class="hljs-comment">//如果旧的容量已经大于最大限制了，那么直接给到 Integer.MAX_VALUE</span><br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;  <span class="hljs-comment">//这种情况不用扩了</span><br>        }<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)   <span class="hljs-comment">//新的容量等于旧容量的2倍，同样不能超过最大值</span><br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">//新的阈值也提升到原来的两倍</span><br>    }<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 旧容量不大于0只可能是还没初始化，这个时候如果阈值大于0，直接将新的容量变成旧的阈值</span><br>        newCap = oldThr;<br>    <span class="hljs-keyword">else</span> {               <span class="hljs-comment">// 默认情况下阈值也是0，也就是我们刚刚无参new出来的时候</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;   <span class="hljs-comment">//新的容量直接等于默认容量16</span><br>        newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); <span class="hljs-comment">//阈值为负载因子乘以默认容量，负载因子默认为0.75，也就是说只要整个哈希表用了75%的容量，那么就进行扩容，至于为什么默认是0.75，原因很多，这里就不解释了，反正作为新手，这些都是大佬写出来的，我们用就完事。</span><br>    }<br>    ...<br>    threshold = newThr;<br>    <span class="hljs-meta">@SuppressWarnings({"rawtypes","unchecked"})</span><br>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];<br>    table = newTab;   <span class="hljs-comment">//将底层数组变成新的扩容之后的数组</span><br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) {  <span class="hljs-comment">//如果旧的数组不为空，那么还需要将旧的数组中所有元素全部搬到新的里面去</span><br>      ...   <span class="hljs-comment">//详细过程就不介绍了</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>是不是感觉自己有点了解HashMap的运作机制了，其实并不是想象中的那么难，因为这些东西再怎么都是人写的。</p><p>而LinkedHashMap是直接继承自HashMap，具有HashMap的全部性质，同时得益于每一个节点都是一个双向链表，在插入键值对时，同时保存了插入顺序：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">HashMap</span>.<span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>{   <span class="hljs-comment">//LinkedHashMap中的结点实现</span><br>    Entry&lt;K,V&gt; before, after;   <span class="hljs-comment">//这里多了一个指向前一个结点和后一个结点的引用</span><br>    Entry(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) {<br>        <span class="hljs-keyword">super</span>(hash, key, value, next);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>这样我们在遍历LinkedHashMap时，顺序就同我们的插入顺序一致。当然，也可以使用访问顺序，也就是说对于刚访问过的元素，会被排到最后一位。</p><p>当然还有一种比较特殊的Map叫做TreeMap，就像它的名字一样，就是一个Tree，它的内部直接维护了一个红黑树（没有使用哈希表）因为它会将我们插入的结点按照规则进行排序，所以说直接采用红黑树会更好，我们在创建时，直接给予一个比较规则即可，跟之前的TreeSet是一样的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Map&lt;Integer , String&gt; map = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;((a, b) -&gt; b - a);<br>    map.put(<span class="hljs-number">0</span>, <span class="hljs-string">"单走"</span>);<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">"一个六"</span>);<br>    map.put(<span class="hljs-number">3</span>, <span class="hljs-string">"**"</span>);<br>    System.out.println(map);<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/10/03/2oJXBui5aD8q1Gh.png" alt="image-20221003231135805"></p><p>现在我们倒回来看之前讲解的HashSet集合，实际上它的底层很简单：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashSet</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSet</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">Set</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><br><span class="hljs-class"></span>{<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HashMap&lt;E,Object&gt; map;   <span class="hljs-comment">//对，你没看错，底层直接用map来做事</span><br><br>    <span class="hljs-comment">// 因为Set只需要存储Key就行了，所以说这个对象当做每一个键值对的共享Value</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object PRESENT = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-comment">//直接构造一个默认大小为16负载因子0.75的HashMap</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashSet</span><span class="hljs-params">()</span> </span>{<br>        map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    }<br><br>  ...<br>      <br>    <span class="hljs-comment">//你会发现所有的方法全是替身攻击</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> map.keySet().iterator();<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> map.size();<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> map.isEmpty();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>通过观察HashSet的源码发现，HashSet几乎都在操作内部维护的一个HashMap，也就是说，HashSet只是一个表壳，而内部维护的HashMap才是灵魂！就像你进了公司，在外面花钱请别人帮你写公司的业务，你只需要坐着等别人写好然后你自己拿去交差就行了。所以说，HashSet利用了HashMap内部的数据结构，轻松地就实现了Set定义的全部功能！</p><p>再来看TreeSet，实际上用的就是我们的TreeMap：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeSet</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSet</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">NavigableSet</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><br><span class="hljs-class"></span>{<br>    <span class="hljs-comment">//底层需要一个NavigableMap，就是自动排序的Map</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> NavigableMap&lt;E,Object&gt; m;<br><br>    <span class="hljs-comment">//不用我说了吧</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object PRESENT = <span class="hljs-keyword">new</span> Object();<br><br>    ...<br><br>    <span class="hljs-comment">//直接使用TreeMap解决问题</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeSet</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">this</span>(<span class="hljs-keyword">new</span> TreeMap&lt;E,Object&gt;());<br>    }<br><br>  ...<br>}<br></code></pre></td></tr></tbody></table></figure><p>同理，这里就不多做阐述了。</p><p>我们接着来看看Map中定义的哪些杂七杂八的方法，首先来看看<code>compute</code>方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">"A"</span>);<br>    map.put(<span class="hljs-number">2</span>, <span class="hljs-string">"B"</span>);<br>    map.compute(<span class="hljs-number">1</span>, (k, v) -&gt; {   <span class="hljs-comment">//compute会将指定Key的值进行重新计算，若Key不存在，v会返回null</span><br>        <span class="hljs-keyword">return</span> v+<span class="hljs-string">"M"</span>;     <span class="hljs-comment">//这里返回原来的value+M</span><br>    });<br>  map.computeIfPresent(<span class="hljs-number">1</span>, (k, v) -&gt; {   <span class="hljs-comment">//当Key存在时存在则计算并赋予新的值</span><br>      <span class="hljs-keyword">return</span> v+<span class="hljs-string">"M"</span>;     <span class="hljs-comment">//这里返回原来的value+M</span><br>    });<br>    System.out.println(map);<br>}<br></code></pre></td></tr></tbody></table></figure><p>也可以使用<code>computeIfAbsent</code>，当不存在Key时，计算并将键值对放入Map中：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">"A"</span>);<br>    map.put(<span class="hljs-number">2</span>, <span class="hljs-string">"B"</span>);<br>    map.computeIfAbsent(<span class="hljs-number">0</span>, (k) -&gt; {   <span class="hljs-comment">//若不存在则计算并插入新的值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"M"</span>;     <span class="hljs-comment">//这里返回M</span><br>    });<br>    System.out.println(map);<br>}<br></code></pre></td></tr></tbody></table></figure><p>merge方法用于处理数据：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    List&lt;Student&gt; students = Arrays.asList(<br>            <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"yoni"</span>, <span class="hljs-string">"English"</span>, <span class="hljs-number">80</span>),<br>            <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"yoni"</span>, <span class="hljs-string">"Chiness"</span>, <span class="hljs-number">98</span>),<br>            <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"yoni"</span>, <span class="hljs-string">"Math"</span>, <span class="hljs-number">95</span>),<br>            <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"taohai.wang"</span>, <span class="hljs-string">"English"</span>, <span class="hljs-number">50</span>),<br>            <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"taohai.wang"</span>, <span class="hljs-string">"Chiness"</span>, <span class="hljs-number">72</span>),<br>            <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"taohai.wang"</span>, <span class="hljs-string">"Math"</span>, <span class="hljs-number">41</span>),<br>            <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"Seely"</span>, <span class="hljs-string">"English"</span>, <span class="hljs-number">88</span>),<br>            <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"Seely"</span>, <span class="hljs-string">"Chiness"</span>, <span class="hljs-number">89</span>),<br>            <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"Seely"</span>, <span class="hljs-string">"Math"</span>, <span class="hljs-number">92</span>)<br>    );<br>    Map&lt;String, Integer&gt; scoreMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>  <span class="hljs-comment">//merge方法可以对重复键的值进行特殊操作，比如我们想计算某个学生的所有科目分数之后，那么就可以像这样：</span><br>    students.forEach(student -&gt; scoreMap.merge(student.getName(), student.getScore(), Integer::sum));<br>    scoreMap.forEach((k, v) -&gt; System.out.println(<span class="hljs-string">"key:"</span> + k + <span class="hljs-string">"总分"</span> + <span class="hljs-string">"value:"</span> + v));<br>}<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>{<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String type;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> score;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, String type, <span class="hljs-keyword">int</span> score)</span> </span>{<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.type = type;<br>        <span class="hljs-keyword">this</span>.score = score;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> name;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getScore</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> score;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getType</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> type;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><code>replace</code>方法可以快速替换某个映射的值：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Map&lt;Integer , String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-number">0</span>, <span class="hljs-string">"单走"</span>);<br>    map.replace(<span class="hljs-number">0</span>, <span class="hljs-string">"&gt;&gt;&gt;"</span>);   <span class="hljs-comment">//直接替换为新的</span><br>    System.out.println(map);<br>}<br></code></pre></td></tr></tbody></table></figure><p>也可以精准匹配：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Map&lt;Integer , String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-number">0</span>, <span class="hljs-string">"单走"</span>);<br>    map.replace(<span class="hljs-number">0</span>, <span class="hljs-string">"巴卡"</span>, <span class="hljs-string">"玛卡"</span>);   <span class="hljs-comment">//只有键和值都匹配时，才进行替换</span><br>    System.out.println(map);<br>}<br></code></pre></td></tr></tbody></table></figure><p>包括remove方法，也支持键值同时匹配：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Map&lt;Integer , String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-number">0</span>, <span class="hljs-string">"单走"</span>);<br>    map.remove(<span class="hljs-number">0</span>, <span class="hljs-string">"单走"</span>);  <span class="hljs-comment">//只有同时匹配时才移除</span><br>    System.out.println(map);<br>}<br></code></pre></td></tr></tbody></table></figure><p>是不是感觉学习了Map之后，涨了不少姿势？</p><h3 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h3><p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。</p><p><img src="https://s2.loli.net/2022/10/03/r4AtmVRZ51y7uxd.png" alt="image-20221003232832897"></p><p>它看起来就像一个工厂的流水线一样！我们就可以把一个Stream当做流水线处理：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.add(<span class="hljs-string">"A"</span>);<br>    list.add(<span class="hljs-string">"B"</span>);<br>    list.add(<span class="hljs-string">"C"</span>);<br>  <br>  <span class="hljs-comment">//移除为B的元素</span><br>  Iterator&lt;String&gt; iterator = list.iterator();<br>    <span class="hljs-keyword">while</span> (iterator.hasNext()){<br>        <span class="hljs-keyword">if</span>(iterator.next().equals(<span class="hljs-string">"B"</span>)) iterator.remove();<br>    }<br>  <br>  <span class="hljs-comment">//Stream操作</span><br>    list = list     <span class="hljs-comment">//链式调用</span><br>            .stream()    <span class="hljs-comment">//获取流</span><br>            .filter(e -&gt; !e.equals(<span class="hljs-string">"B"</span>))   <span class="hljs-comment">//只允许所有不是B的元素通过流水线</span><br>            .collect(Collectors.toList());   <span class="hljs-comment">//将流水线中的元素重新收集起来，变回List</span><br>    System.out.println(list);<br>}<br></code></pre></td></tr></tbody></table></figure><p>可能从上述例子中还不能感受到流处理带来的便捷，我们通过下面这个例子来感受一下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.add(<span class="hljs-number">1</span>);<br>    list.add(<span class="hljs-number">2</span>);<br>    list.add(<span class="hljs-number">3</span>);<br>  list.add(<span class="hljs-number">3</span>);<br><br>    list = list<br>            .stream()<br>      .distinct()   <span class="hljs-comment">//去重（使用equals判断）</span><br>            .sorted((a, b) -&gt; b - a)    <span class="hljs-comment">//进行倒序排列</span><br>            .map(e -&gt; e+<span class="hljs-number">1</span>)    <span class="hljs-comment">//每个元素都要执行+1操作</span><br>            .limit(<span class="hljs-number">2</span>)    <span class="hljs-comment">//只放行前两个元素</span><br>            .collect(Collectors.toList());<br><br>    System.out.println(list);<br>}<br></code></pre></td></tr></tbody></table></figure><p>当遇到大量的复杂操作时，我们就可以使用Stream来快速编写代码，这样不仅代码量大幅度减少，而且逻辑也更加清晰明了（如果你学习过SQL的话，你会发现它更像一个Sql语句）</p><p><strong>注意</strong>：不能认为每一步是直接依次执行的！我们可以断点测试一下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list.add(<span class="hljs-number">1</span>);<br>list.add(<span class="hljs-number">2</span>);<br>list.add(<span class="hljs-number">3</span>);<br>list.add(<span class="hljs-number">3</span>);<br><br>list = list<br>        .stream()<br>        .distinct()   <span class="hljs-comment">//断点</span><br>        .sorted((a, b) -&gt; b - a)<br>        .map(e -&gt; {<br>            System.out.println(<span class="hljs-string">"&gt;&gt;&gt; "</span>+e);   <span class="hljs-comment">//断点</span><br>            <span class="hljs-keyword">return</span> e+<span class="hljs-number">1</span>;<br>        })<br>        .limit(<span class="hljs-number">2</span>)   <span class="hljs-comment">//断点</span><br>        .collect(Collectors.toList());<br></code></pre></td></tr></tbody></table></figure><p>实际上，stream会先记录每一步操作，而不是直接开始执行内容，当整个链式调用完成后，才会依次进行，也就是说需要的时候，工厂的机器才会按照预定的流程启动。</p><p>接下来，我们用一堆随机数来进行更多流操作的演示：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Random random = <span class="hljs-keyword">new</span> Random();  <span class="hljs-comment">//没想到吧，Random支持直接生成随机数的流</span><br>    random<br>            .ints(-<span class="hljs-number">100</span>, <span class="hljs-number">100</span>)   <span class="hljs-comment">//生成-100~100之间的，随机int型数字（本质上是一个IntStream）</span><br>            .limit(<span class="hljs-number">10</span>)   <span class="hljs-comment">//只获取前10个数字（这是一个无限制的流，如果不加以限制，将会无限进行下去！）</span><br>            .filter(i -&gt; i &lt; <span class="hljs-number">0</span>)   <span class="hljs-comment">//只保留小于0的数字</span><br>            .sorted()    <span class="hljs-comment">//默认从小到大排序</span><br>            .forEach(System.out::println);   <span class="hljs-comment">//依次打印</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以生成一个统计实例来帮助我们快速进行统计：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Random random = <span class="hljs-keyword">new</span> Random();  <span class="hljs-comment">//Random是一个随机数工具类</span><br>    IntSummaryStatistics statistics = random<br>            .ints(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)<br>            .limit(<span class="hljs-number">100</span>)<br>            .summaryStatistics();    <span class="hljs-comment">//获取语法统计实例</span><br>    System.out.println(statistics.getMax());  <span class="hljs-comment">//快速获取最大值</span><br>    System.out.println(statistics.getCount());  <span class="hljs-comment">//获取数量</span><br>    System.out.println(statistics.getAverage());   <span class="hljs-comment">//获取平均值</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>普通的List只需要一个方法就可以直接转换到方便好用的IntStream了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.add(<span class="hljs-number">1</span>);<br>    list.add(<span class="hljs-number">1</span>);<br>    list.add(<span class="hljs-number">2</span>);<br>    list.add(<span class="hljs-number">3</span>);<br>    list.add(<span class="hljs-number">4</span>);<br>    list.stream()<br>            .mapToInt(i -&gt; i)    <span class="hljs-comment">//将每一个元素映射为Integer类型（这里因为本来就是Integer）</span><br>            .summaryStatistics();<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们还可以通过<code>flat</code>来对整个流进行进一步细分：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.add(<span class="hljs-string">"A,B"</span>);<br>    list.add(<span class="hljs-string">"C,D"</span>);<br>    list.add(<span class="hljs-string">"E,F"</span>);   <span class="hljs-comment">//我们想让每一个元素通过,进行分割，变成独立的6个元素</span><br>    list = list<br>            .stream()    <span class="hljs-comment">//生成流</span><br>            .flatMap(e -&gt; Arrays.stream(e.split(<span class="hljs-string">","</span>)))    <span class="hljs-comment">//分割字符串并生成新的流</span><br>            .collect(Collectors.toList());   <span class="hljs-comment">//汇成新的List</span><br>    System.out.println(list);   <span class="hljs-comment">//得到结果</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>我们也可以只通过Stream来完成所有数字的和，使用<code>reduce</code>方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.add(<span class="hljs-number">1</span>);<br>    list.add(<span class="hljs-number">2</span>);<br>    list.add(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">int</span> sum = list<br>            .stream()<br>            .reduce((a, b) -&gt; a + b)   <span class="hljs-comment">//计算规则为：a是上一次计算的值，b是当前要计算的参数，这里是求和</span><br>            .get();    <span class="hljs-comment">//我们发现得到的是一个Optional类实例，通过get方法返回得到的值</span><br>    System.out.println(sum);<br>}<br></code></pre></td></tr></tbody></table></figure><p>可能，作为新手来说，一次性无法接受这么多内容，但是在各位以后的开发中，就会慢慢使用到这些东西了。</p><h3 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h3><p>我们在前面介绍了Arrays，它是一个用于操作数组的工具类，它给我们提供了大量的工具方法。</p><p>既然数组操作都这么方便了，集合操作能不能也安排点高级的玩法呢？那必须的，JDK为我们准备的Collocations类就是专用于集合的工具类，比如我们想快速求得List中的最大值和最小值：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    Collections.max(list);<br>    Collections.min(list);<br>}<br></code></pre></td></tr></tbody></table></figure><p>同样的，我们可以对一个集合进行二分搜索（注意，集合的具体类型，必须是实现Comparable接口的类）：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">13</span>);<br>    System.out.println(Collections.binarySearch(list, <span class="hljs-number">8</span>));<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们也可以对集合的元素进行快速填充，注意这个填充是对集合中已有的元素进行覆盖：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>));<br>    Collections.fill(list, <span class="hljs-number">6</span>);<br>    System.out.println(list);<br>}<br></code></pre></td></tr></tbody></table></figure><p>如果集合中本身没有元素，那么<code>fill</code>操作不会生效。</p><p>有些时候我们可能需要生成一个空的集合类返回，那么我们可以使用<code>emptyXXX</code>来快速生成一个只读的空集合：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    List&lt;Integer&gt; list = Collections.emptyList();<br>  <span class="hljs-comment">//Collections.singletonList() 会生成一个只有一个元素的List</span><br>    list.add(<span class="hljs-number">10</span>);   <span class="hljs-comment">//不支持，会直接抛出异常</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>我们也可以将一个可修改的集合变成只读的集合：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>));<br>    List&lt;Integer&gt; newList = Collections.unmodifiableList(list);<br>    newList.add(<span class="hljs-number">10</span>);   <span class="hljs-comment">//不支持，会直接抛出异常</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>我们也可以寻找子集合的位置：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>));<br>    System.out.println(Collections.indexOfSubList(list, Arrays.asList(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)));<br>}<br></code></pre></td></tr></tbody></table></figure><p>得益于泛型的类型擦除机制，实际上最后只要是Object的实现类都可以保存到集合类中，那么就会出现这种情况：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>  <span class="hljs-comment">//使用原始类型接收一个Integer类型的ArrayList</span><br>    List list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>));<br>    list.add(<span class="hljs-string">"aaa"</span>);   <span class="hljs-comment">//我们惊奇地发现，这玩意居然能存字符串进去</span><br>    System.out.println(list);<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/10/04/FP5z3X8SEMkGYtT.png" alt="image-20221004001007854"></p><p>没错，由于泛型机制上的一些漏洞，实际上对应类型的集合类有可能会存放其他类型的值，泛型的类型检查只存在于编译阶段，只要我们绕过这个阶段，在实际运行时，并不会真的进行类型检查，要解决这种问题很简单，就是在运行时进行类型检查：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    List list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>));<br>    list = Collections.checkedList(list, Integer.class);   <span class="hljs-comment">//这里的.class关键字我们会在后面反射中介绍，表示Integer这个类型</span><br>  list.add(<span class="hljs-string">"aaa"</span>);<br>    System.out.println(list);<br>}<br></code></pre></td></tr></tbody></table></figure><p><code>checkedXXX</code>可以将给定集合类进行包装，在运行时同样会进行类型检查，如果通过上面的漏洞插入一个本不应该是当前类型集合支持的类型，那么会直接抛出类型转换异常：</p><p><img src="https://s2.loli.net/2022/10/04/5BHq1u9JU3bhdI6.png" alt="image-20221004001409799"></p><p>是不是感觉这个工具类好像还挺好用的？实际上在我们的开发中，这个工具类也经常被使用到。</p><hr><h2 id="Java-I-O"><a href="#Java-I-O" class="headerlink" title="Java I/O"></a>Java I/O</h2><p><strong>注意：</strong>这块会涉及到<strong>操作系统</strong>和<strong>计算机组成原理</strong>相关内容。</p><p>I/O简而言之，就是输入输出，那么为什么会有I/O呢？其实I/O无时无刻都在我们的身边，比如读取硬盘上的文件，网络文件传输，鼠标键盘输入，也可以是接受单片机发回的数据，而能够支持这些操作的设备就是I/O设备。</p><p>我们可以大致看一下整个计算机的总线结构：</p><p><img src="https://s2.loli.net/2022/10/04/Q8JGeMprkgHsnPY.png" alt="image-20221004002405375"></p><p>常见的I/O设备一般是鼠标、键盘这类通过USB进行传输的外设或者是通过Sata接口或是M.2连接的硬盘。一般情况下，这些设备是由CPU发出指令通过南桥芯片间接进行控制，而不是由CPU直接操作。</p><p>而我们在程序中，想要读取这些外部连接的I/O设备中的内容，就需要将数据传输到内存中。而需要实现这样的操作，单单凭借一个小的程序是无法做到的，而操作系统（如：Windows/Linux/MacOS）就是专门用于控制和管理计算机硬件和软件资源的软件，我们需要读取一个IO设备的内容时，就可以向操作系统发出请求，由操作系统帮助我们来和底层的硬件交互以完成我们的读取/写入请求。</p><p>从读取硬盘文件的角度来说，不同的操作系统有着不同的文件系统（也就是文件在硬盘中的存储排列方式，如Windows就是NTFS、MacOS就是APFS），硬盘只能存储一个个0和1这样的二进制数据，至于0和1如何排列，各自又代表什么意思，就是由操作系统的文件系统来决定的。从网络通信角度来说，网络信号通过网卡等设备翻译为二进制信号，再交给系统进行读取，最后再由操作系统来给到程序。</p><p><img src="https://s2.loli.net/2022/10/04/13h7yTekm2FfnRw.png" alt="image-20221004002733950"></p><p>（传统的SATA硬盘就是通过SATA线与电脑主板相连，这样才可以读取到数据）</p><p>JDK提供了一套用于IO操作的框架，为了方便我们开发者使用，就定义了一个像水流一样，根据流的传输方向和读取单位，分为字节流InputStream和OutputStream以及字符流Reader和Writer的IO框架，当然，这里的Stream并不是前面集合框架认识的Stream，这里的流指的是数据流，通过流，我们就可以一直从流中读取数据，直到读取到尽头，或是不断向其中写入数据，直到我们写入完成，而这类IO就是我们所说的BIO，</p><p>字节流一次读取一个字节，也就是一个<code>byte</code>的大小，而字符流顾名思义，就是一次读取一个字符，也就是一个<code>char</code>的大小（在读取纯文本文件的时候更加适合），有关这两种流，会在后面详细介绍，这个章节我们需要学习16个关键的流。</p><h3 id="文件字节流"><a href="#文件字节流" class="headerlink" title="文件字节流"></a>文件字节流</h3><p>要学习和使用IO，首先就要从最易于理解的读取文件开始说起。</p><p>首先介绍一下FileInputStream，我们可以通过它来获取文件的输入流：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span> {   <span class="hljs-comment">//注意，IO相关操作会有很多影响因素，有可能出现异常，所以需要明确进行处理</span><br>        FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"路径"</span>);<br>        <span class="hljs-comment">//路径支持相对路径和绝对路径</span><br>    } <span class="hljs-keyword">catch</span> (FileNotFoundException e) {<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>相对路径是在当前运行目录（就是你在哪个目录运行java命令启动Java程序的）的路径下寻找文件，而绝对路径，是从根目录开始寻找。路径分割符支持使用<code>/</code>或是<code>\\</code>，但是不能写为<code>\</code>因为它是转义字符！比如在Windows下：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">C:<span class="hljs-regexp">//</span>User<span class="hljs-regexp">/lbw/</span>nb    这个就是一个绝对路径，因为是从盘符开始的<br>test/test          这个就是一个相对路径，因为并不是从盘符开始的，而是一个直接的路径<br></code></pre></td></tr></tbody></table></figure><p>在Linux和MacOS下：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/root/</span>tmp       这个就是一个绝对路径，绝对路径以/开头<br>test<span class="hljs-regexp">/test       这个就是一个相对路径，不是以/</span>开头的<br></code></pre></td></tr></tbody></table></figure><p>当然，这个其实还是很好理解的，我们在使用时注意一下就行了。</p><p>在使用完成一个流之后，必须关闭这个流来完成对资源的释放，否则资源会被一直占用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    FileInputStream inputStream = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">//定义可以先放在try外部</span><br>    <span class="hljs-keyword">try</span> {<br>        inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"路径"</span>);<br>    } <span class="hljs-keyword">catch</span> (FileNotFoundException e) {<br>        e.printStackTrace();<br>    } <span class="hljs-keyword">finally</span> {<br>        <span class="hljs-keyword">try</span> {    <span class="hljs-comment">//建议在finally中进行，因为关闭流是任何情况都必须要执行的！</span><br>            <span class="hljs-keyword">if</span>(inputStream != <span class="hljs-keyword">null</span>) inputStream.close();<br>        } <span class="hljs-keyword">catch</span> (IOException e) {<br>            e.printStackTrace();<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>虽然这样的写法才是最保险的，但是显得过于繁琐了，尤其是finally中再次嵌套了一个try-catch块，因此在JDK1.7新增了try-with-resource语法，用于简化这样的写法（本质上还是和这样的操作一致，只是换了个写法）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br><br>    <span class="hljs-comment">//注意，这种语法只支持实现了AutoCloseable接口的类！</span><br>    <span class="hljs-keyword">try</span>(FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"路径"</span>)) {   <span class="hljs-comment">//直接在try()中定义要在完成之后释放的资源</span><br><br>    } <span class="hljs-keyword">catch</span> (IOException e) {   <span class="hljs-comment">//这里变成IOException是因为调用close()可能会出现，而FileNotFoundException是继承自IOException的</span><br>        e.printStackTrace();<br>    }<br>    <span class="hljs-comment">//无需再编写finally语句块，因为在最后自动帮我们调用了close()</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>之后为了方便，我们都使用此语法进行教学。</p><p>现在我们拿到了文件的输入流，那么怎么才能读取文件里面的内容呢？我们可以使用<code>read</code>方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-comment">//test.txt：a</span><br>    <span class="hljs-keyword">try</span>(FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"test.txt"</span>)) {<br>        <span class="hljs-comment">//使用read()方法进行字符读取</span><br>        System.out.println((<span class="hljs-keyword">char</span>) inputStream.read());  <span class="hljs-comment">//读取一个字节的数据（英文字母只占1字节，中文占2字节）</span><br>        System.out.println(inputStream.read());   <span class="hljs-comment">//唯一一个字节的内容已经读完了，再次读取返回-1表示没有内容了</span><br>    }<span class="hljs-keyword">catch</span> (IOException e){<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>使用read可以直接读取一个字节的数据，注意，流的内容是有限的，读取一个少一个。我们如果想一次性全部读取的话，可以直接使用一个while循环来完成：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-comment">//test.txt：abcd</span><br>    <span class="hljs-keyword">try</span>(FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"test.txt"</span>)) {<br>        <span class="hljs-keyword">int</span> tmp;<br>        <span class="hljs-keyword">while</span> ((tmp = inputStream.read()) != -<span class="hljs-number">1</span>){   <span class="hljs-comment">//通过while循环来一次性读完内容</span><br>            System.out.println((<span class="hljs-keyword">char</span>)tmp);<br>        }<br>    }<span class="hljs-keyword">catch</span> (IOException e){<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>使用<code>available</code>方法能查看当前可读的剩余字节数量（注意：并不一定真实的数据量就是这么多，尤其是在网络I/O操作时，这个方法只能进行一个预估也可以说是暂时能一次性可以读取的数量，当然在磁盘IO下，一般情况都是真实的数据量）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>(FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"test.txt"</span>)) {<br>    System.out.println(inputStream.available());  <span class="hljs-comment">//查看剩余数量</span><br>}<span class="hljs-keyword">catch</span> (IOException e){<br>    e.printStackTrace();<br>}<br></code></pre></td></tr></tbody></table></figure><p>当然，一个一个读取效率太低了，那能否一次性全部读取呢？我们可以预置一个合适容量的byte[]数组来存放：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-comment">//test.txt：abcd</span><br>    <span class="hljs-keyword">try</span>(FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"test.txt"</span>)) {<br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[inputStream.available()];   <span class="hljs-comment">//我们可以提前准备好合适容量的byte数组来存放</span><br>        System.out.println(inputStream.read(bytes));   <span class="hljs-comment">//一次性读取全部内容（返回值是读取的字节数）</span><br>        System.out.println(<span class="hljs-keyword">new</span> String(bytes));   <span class="hljs-comment">//通过String(byte[])构造方法得到字符串</span><br>    }<span class="hljs-keyword">catch</span> (IOException e){<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>也可以控制要读取数量：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(inputStream.read(bytes, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>));   <span class="hljs-comment">//第二个参数是从给定数组的哪个位置开始放入内容，第三个参数是读取流中的字节数</span><br></code></pre></td></tr></tbody></table></figure><p><strong>注意</strong>：一次性读取同单个读取一样，当没有任何数据可读时，依然会返回-1</p><p>通过<code>skip()</code>方法可以跳过指定数量的字节：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-comment">//test.txt：abcd</span><br>    <span class="hljs-keyword">try</span>(FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"test.txt"</span>)) {<br>        System.out.println(inputStream.skip(<span class="hljs-number">1</span>));<br>        System.out.println((<span class="hljs-keyword">char</span>) inputStream.read());   <span class="hljs-comment">//跳过了一个字节</span><br>    }<span class="hljs-keyword">catch</span> (IOException e){<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>注意：FileInputStream是不支持<code>reset()</code>的，虽然有这个方法，但是这里先不提及。</p><p>既然有输入流，那么文件输出流也是必不可少的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-comment">//输出流也需要在最后调用close()方法，并且同样支持try-with-resource</span><br>    <span class="hljs-keyword">try</span>(FileOutputStream outputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"output.txt"</span>)) {<br>        <span class="hljs-comment">//注意：若此文件不存在，会直接创建这个文件！</span><br>    }<span class="hljs-keyword">catch</span> (IOException e){<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>输出流没有<code>read()</code>操作而是<code>write()</code>操作，使用方法同输入流一样，只不过现在的方向变为我们向文件里写入内容：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span>(FileOutputStream outputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"output.txt"</span>)) {<br>        outputStream.write(<span class="hljs-string">'c'</span>);   <span class="hljs-comment">//同read一样，可以直接写入内容</span><br>      outputStream.write(<span class="hljs-string">"lbwnb"</span>.getBytes());   <span class="hljs-comment">//也可以直接写入byte[]</span><br>      outputStream.write(<span class="hljs-string">"lbwnb"</span>.getBytes(), <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">//同上输入流</span><br>      outputStream.flush();  <span class="hljs-comment">//建议在最后执行一次刷新操作（强制写入）来保证数据正确写入到硬盘文件中</span><br>    }<span class="hljs-keyword">catch</span> (IOException e){<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>那么如果是我只想在文件尾部进行追加写入数据呢？我们可以调用另一个构造方法来实现：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span>(FileOutputStream outputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"output.txt"</span>, <span class="hljs-keyword">true</span>)) {  <span class="hljs-comment">//true表示开启追加模式</span><br>        outputStream.write(<span class="hljs-string">"lb"</span>.getBytes());   <span class="hljs-comment">//现在只会进行追加写入，而不是直接替换原文件内容</span><br>        outputStream.flush();<br>    }<span class="hljs-keyword">catch</span> (IOException e){<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>利用输入流和输出流，就可以轻松实现文件的拷贝了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span>(FileOutputStream outputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"output.txt"</span>);<br>        FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"test.txt"</span>)) {   <span class="hljs-comment">//可以写入多个</span><br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10</span>];    <span class="hljs-comment">//使用长度为10的byte[]做传输媒介</span><br>        <span class="hljs-keyword">int</span> tmp;   <span class="hljs-comment">//存储本地读取字节数</span><br>        <span class="hljs-keyword">while</span> ((tmp = inputStream.read(bytes)) != -<span class="hljs-number">1</span>){   <span class="hljs-comment">//直到读取完成为止</span><br>            outputStream.write(bytes, <span class="hljs-number">0</span>, tmp);    <span class="hljs-comment">//写入对应长度的数据到输出流</span><br>        }<br>    }<span class="hljs-keyword">catch</span> (IOException e){<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="文件字符流"><a href="#文件字符流" class="headerlink" title="文件字符流"></a>文件字符流</h3><p>字符流不同于字节，字符流是以一个具体的字符进行读取，因此它只适合读纯文本的文件，如果是其他类型的文件不适用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span>(FileReader reader = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">"test.txt"</span>)){<br>      reader.skip(<span class="hljs-number">1</span>);   <span class="hljs-comment">//现在跳过的是一个字符</span><br>        System.out.println((<span class="hljs-keyword">char</span>) reader.read());   <span class="hljs-comment">//现在是按字符进行读取，而不是字节，因此可以直接读取到中文字符</span><br>    }<span class="hljs-keyword">catch</span> (IOException e){<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>同理，字符流只支持<code>char[]</code>类型作为存储：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span>(FileReader reader = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">"test.txt"</span>)){<br>        <span class="hljs-keyword">char</span>[] str = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">10</span>];<br>        reader.read(str);<br>        System.out.println(str);   <span class="hljs-comment">//直接读取到char[]中</span><br>    }<span class="hljs-keyword">catch</span> (IOException e){<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>既然有了Reader肯定也有Writer：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span>(FileWriter writer = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">"output.txt"</span>)){<br>      writer.getEncoding();   <span class="hljs-comment">//支持获取编码（不同的文本文件可能会有不同的编码类型）</span><br>       writer.write(<span class="hljs-string">'牛'</span>);<br>       writer.append(<span class="hljs-string">'牛'</span>);   <span class="hljs-comment">//其实功能和write一样</span><br>      writer.flush();   <span class="hljs-comment">//刷新</span><br>    }<span class="hljs-keyword">catch</span> (IOException e){<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现不仅有<code>write()</code>方法，还有一个<code>append()</code>方法，但是实际上他们效果是一样的，看源码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Writer <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> <span class="hljs-keyword">throws</span> IOException </span>{<br>    write(c);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>append支持像StringBuilder那样的链式调用，返回的是Writer对象本身。</p><p><strong>练习</strong>：尝试一下用Reader和Writer来拷贝纯文本文件。</p><p>这里需要额外介绍一下File类，它是专门用于表示一个文件或文件夹，只不过它只是代表这个文件，但并不是这个文件本身。通过File对象，可以更好地管理和操作硬盘上的文件。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"test.txt"</span>);   <span class="hljs-comment">//直接创建文件对象，可以是相对路径，也可以是绝对路径</span><br>    System.out.println(file.exists());   <span class="hljs-comment">//此文件是否存在</span><br>    System.out.println(file.length());   <span class="hljs-comment">//获取文件的大小</span><br>    System.out.println(file.isDirectory());   <span class="hljs-comment">//是否为一个文件夹</span><br>    System.out.println(file.canRead());   <span class="hljs-comment">//是否可读</span><br>    System.out.println(file.canWrite());   <span class="hljs-comment">//是否可写</span><br>    System.out.println(file.canExecute());   <span class="hljs-comment">//是否可执行</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>通过File对象，我们就能快速得到文件的所有信息，如果是文件夹，还可以获取文件夹内部的文件列表等内容：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"/"</span>);<br>System.out.println(Arrays.toString(file.list()));   <span class="hljs-comment">//快速获取文件夹下的文件名称列表</span><br><span class="hljs-keyword">for</span> (File f : file.listFiles()){   <span class="hljs-comment">//所有子文件的File对象</span><br>    System.out.println(f.getAbsolutePath());   <span class="hljs-comment">//获取文件的绝对路径</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>如果我们希望读取某个文件的内容，可以直接将File作为参数传入字节流或是字符流：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"test.txt"</span>);<br><span class="hljs-keyword">try</span> (FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(file)){   <span class="hljs-comment">//直接做参数</span><br>    System.out.println(inputStream.available());<br>}<span class="hljs-keyword">catch</span> (IOException e){<br>    e.printStackTrace();<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>练习</strong>：尝试拷贝文件夹下的所有文件到另一个文件夹</p><h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><p>虽然普通的文件流读取文件数据非常便捷，但是每次都需要从外部I/O设备去获取数据，由于外部I/O设备的速度一般都达不到内存的读取速度，很有可能造成程序反应迟钝，因此性能还不够高，而缓冲流正如其名称一样，它能够提供一个缓冲，提前将部分内容存入内存（缓冲区）在下次读取时，如果缓冲区中存在此数据，则无需再去请求外部设备。同理，当向外部设备写入数据时，也是由缓冲区处理，而不是直接向外部设备写入。</p><p><img src="https://s2.loli.net/2022/10/04/S8O61JP2lqKTzjd.png" alt="image-20221004125755217"></p><p>要创建一个缓冲字节流，只需要将原本的流作为构造参数传入BufferedInputStream即可：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span> (BufferedInputStream bufferedInputStream = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"test.txt"</span>))){   <span class="hljs-comment">//传入FileInputStream</span><br>        System.out.println((<span class="hljs-keyword">char</span>) bufferedInputStream.read());   <span class="hljs-comment">//操作和原来的流是一样的</span><br>    }<span class="hljs-keyword">catch</span> (IOException e){<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>实际上进行I/O操作的并不是BufferedInputStream，而是我们传入的FileInputStream，而BufferedInputStream虽然有着同样的方法，但是进行了一些额外的处理然后再调用FileInputStream的同名方法，这样的写法称为<code>装饰者模式</code>，我们会在设计模式篇中详细介绍。我们可以来观察一下它的<code>close</code>方法源码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>{<br>    <span class="hljs-keyword">byte</span>[] buffer;<br>    <span class="hljs-keyword">while</span> ( (buffer = buf) != <span class="hljs-keyword">null</span>) {<br>        <span class="hljs-keyword">if</span> (bufUpdater.compareAndSet(<span class="hljs-keyword">this</span>, buffer, <span class="hljs-keyword">null</span>)) {  <span class="hljs-comment">//CAS无锁算法，并发会用到，暂时不需要了解</span><br>            InputStream input = in;<br>            in = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">if</span> (input != <span class="hljs-keyword">null</span>)<br>                input.close();<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-comment">// Else retry in case a new buf was CASed in fill()</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>实际上这种模式是父类FilterInputStream提供的规范，后面我们还会讲到更多FilterInputStream的子类。</p><p>我们可以发现在BufferedInputStream中还存在一个专门用于缓存的数组：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The internal buffer array where the data is stored. When necessary,</span><br><span class="hljs-comment"> * it may be replaced by another array of</span><br><span class="hljs-comment"> * a different size.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">byte</span> buf[];<br></code></pre></td></tr></tbody></table></figure><p>I/O操作一般不能重复读取内容（比如键盘发送的信号，主机接收了就没了），而缓冲流提供了缓冲机制，一部分内容可以被暂时保存，BufferedInputStream支持<code>reset()</code>和<code>mark()</code>操作，首先我们来看看<code>mark()</code>方法的介绍：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Marks the current position in this input stream. A subsequent</span><br><span class="hljs-comment"> * call to the &lt;code&gt;reset&lt;/code&gt; method repositions this stream at</span><br><span class="hljs-comment"> * the last marked position so that subsequent reads re-read the same bytes.</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * The &lt;code&gt;readlimit&lt;/code&gt; argument tells this input stream to</span><br><span class="hljs-comment"> * allow that many bytes to be read before the mark position gets</span><br><span class="hljs-comment"> * invalidated.</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * This method simply performs &lt;code&gt;in.mark(readlimit)&lt;/code&gt;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>   readlimit   the maximum limit of bytes that can be read before</span><br><span class="hljs-comment"> *                      the mark position becomes invalid.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span>     java.io.FilterInputStream#in</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span>     java.io.FilterInputStream#reset()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mark</span><span class="hljs-params">(<span class="hljs-keyword">int</span> readlimit)</span> </span>{<br>    in.mark(readlimit);<br>}<br></code></pre></td></tr></tbody></table></figure><p>当调用<code>mark()</code>之后，输入流会以某种方式保留之后读取的<code>readlimit</code>数量的内容，当读取的内容数量超过<code>readlimit</code>则之后的内容不会被保留，当调用<code>reset()</code>之后，会使得当前的读取位置回到<code>mark()</code>调用时的位置。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span> (BufferedInputStream bufferedInputStream = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"test.txt"</span>))){<br>        bufferedInputStream.mark(<span class="hljs-number">1</span>);   <span class="hljs-comment">//只保留之后的1个字符</span><br>        System.out.println((<span class="hljs-keyword">char</span>) bufferedInputStream.read());<br>        System.out.println((<span class="hljs-keyword">char</span>) bufferedInputStream.read());<br>        bufferedInputStream.reset();   <span class="hljs-comment">//回到mark时的位置</span><br>        System.out.println((<span class="hljs-keyword">char</span>) bufferedInputStream.read());<br>        System.out.println((<span class="hljs-keyword">char</span>) bufferedInputStream.read());<br>    }<span class="hljs-keyword">catch</span> (IOException e) {<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现虽然后面的部分没有保存，但是依然能够正常读取，其实<code>mark()</code>后保存的读取内容是取<code>readlimit</code>和BufferedInputStream类的缓冲区大小两者中的最大值，而并非完全由<code>readlimit</code>确定。因此我们限制一下缓冲区大小，再来观察一下结果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span> (BufferedInputStream bufferedInputStream = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"test.txt"</span>), <span class="hljs-number">1</span>)){  <span class="hljs-comment">//将缓冲区大小设置为1</span><br>        bufferedInputStream.mark(<span class="hljs-number">1</span>);   <span class="hljs-comment">//只保留之后的1个字符</span><br>        System.out.println((<span class="hljs-keyword">char</span>) bufferedInputStream.read());<br>        System.out.println((<span class="hljs-keyword">char</span>) bufferedInputStream.read());   <span class="hljs-comment">//已经超过了readlimit，继续读取会导致mark失效</span><br>        bufferedInputStream.reset();   <span class="hljs-comment">//mark已经失效，无法reset()</span><br>        System.out.println((<span class="hljs-keyword">char</span>) bufferedInputStream.read());<br>        System.out.println((<span class="hljs-keyword">char</span>) bufferedInputStream.read());<br>    }<span class="hljs-keyword">catch</span> (IOException e) {<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>了解完了BufferedInputStream之后，我们再来看看BufferedOutputStream，其实和BufferedInputStream原理差不多，只是反向操作：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span> (BufferedOutputStream outputStream = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"output.txt"</span>))){<br>        outputStream.write(<span class="hljs-string">"lbwnb"</span>.getBytes());<br>        outputStream.flush();<br>    }<span class="hljs-keyword">catch</span> (IOException e) {<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>操作和FileOutputStream一致，这里就不多做介绍了。</p><p>既然有缓冲字节流，那么肯定也有缓冲字符流，缓冲字符流和缓冲字节流一样，也有一个专门的缓冲区，BufferedReader构造时需要传入一个Reader对象：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span> (BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">"test.txt"</span>))){<br>        System.out.println((<span class="hljs-keyword">char</span>) reader.read());<br>    }<span class="hljs-keyword">catch</span> (IOException e) {<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>使用和reader也是一样的，内部也包含一个缓存数组：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span> cb[];<br></code></pre></td></tr></tbody></table></figure><p>相比Reader更方便的是，它支持按行读取：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span> (BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">"test.txt"</span>))){<br>        System.out.println(reader.readLine());   <span class="hljs-comment">//按行读取</span><br>    }<span class="hljs-keyword">catch</span> (IOException e) {<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>读取后直接得到一个字符串，当然，它还能把每一行内容依次转换为集合类提到的Stream流：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span> (BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">"test.txt"</span>))){<br>        reader<br>                .lines()<br>                .limit(<span class="hljs-number">2</span>)<br>                .distinct()<br>                .sorted()<br>                .forEach(System.out::println);<br>    }<span class="hljs-keyword">catch</span> (IOException e) {<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>它同样也支持<code>mark()</code>和<code>reset()</code>操作：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span> (BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">"test.txt"</span>))){<br>        reader.mark(<span class="hljs-number">1</span>);<br>        System.out.println((<span class="hljs-keyword">char</span>) reader.read());<br>        reader.reset();<br>        System.out.println((<span class="hljs-keyword">char</span>) reader.read());<br>    }<span class="hljs-keyword">catch</span> (IOException e) {<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>BufferedReader处理纯文本文件时就更加方便了，BufferedWriter在处理时也同样方便：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span> (BufferedWriter reader = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">"output.txt"</span>))){<br>        reader.newLine();   <span class="hljs-comment">//使用newLine进行换行</span><br>        reader.write(<span class="hljs-string">"汉堡做滴彳亍不彳亍"</span>);   <span class="hljs-comment">//可以直接写入一个字符串</span><br>      reader.flush();   <span class="hljs-comment">//清空缓冲区</span><br>    }<span class="hljs-keyword">catch</span> (IOException e) {<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>合理使用缓冲流，可以大大提高我们程序的运行效率，只不过现在初学阶段，很少会有机会接触到实际的应用场景。</p><h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><p>有时会遇到这样一个很麻烦的问题：我这里读取的是一个字符串或是一个个字符，但是我只能往一个OutputStream里输出，但是OutputStream又只支持byte类型，如果要往里面写入内容，进行数据转换就会很麻烦，那么能否有更加简便的方式来做这样的事情呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span>(OutputStreamWriter writer = <span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"test.txt"</span>))){  <span class="hljs-comment">//虽然给定的是FileOutputStream，但是现在支持以Writer的方式进行写入</span><br>        writer.write(<span class="hljs-string">"lbwnb"</span>);   <span class="hljs-comment">//以操作Writer的样子写入OutputStream</span><br>    }<span class="hljs-keyword">catch</span> (IOException e){<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>同样的，我们现在只拿到了一个InputStream，但是我们希望能够按字符的方式读取，我们就可以使用InputStreamReader来帮助我们实现：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span>(InputStreamReader reader = <span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"test.txt"</span>))){  <span class="hljs-comment">//虽然给定的是FileInputStream，但是现在支持以Reader的方式进行读取</span><br>        System.out.println((<span class="hljs-keyword">char</span>) reader.read());<br>    }<span class="hljs-keyword">catch</span> (IOException e){<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>InputStreamReader和OutputStreamWriter本质也是Reader和Writer，因此可以直接放入BufferedReader来实现更加方便的操作。</p><h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><p>打印流其实我们从一开始就在使用了，比如<code>System.out</code>就是一个PrintStream，PrintStream也继承自FilterOutputStream类因此依然是装饰我们传入的输出流，但是它存在自动刷新机制，例如当向PrintStream流中写入一个字节数组后自动调用<code>flush()</code>方法。PrintStream也永远不会抛出异常，而是使用内部检查机制<code>checkError()</code>方法进行错误检查。最方便的是，它能够格式化任意的类型，将它们以字符串的形式写入到输出流。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> PrintStream out = <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></tbody></table></figure><p>可以看到<code>System.out</code>也是PrintStream，不过默认是向控制台打印，我们也可以让它向文件中打印：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span>(PrintStream stream = <span class="hljs-keyword">new</span> PrintStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"test.txt"</span>))){<br>        stream.println(<span class="hljs-string">"lbwnb"</span>);   <span class="hljs-comment">//其实System.out就是一个PrintStream</span><br>    }<span class="hljs-keyword">catch</span> (IOException e){<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们平时使用的<code>println</code>方法就是PrintStream中的方法，它会直接打印基本数据类型或是调用对象的<code>toString()</code>方法得到一个字符串，并将字符串转换为字符，放入缓冲区再经过转换流输出到给定的输出流上。</p><p><img src="https://s2.loli.net/2022/10/04/w8RKJxLm6Ik5usn.png" alt="img"></p><p>因此实际上内部还包含这两个内容：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Track both the text- and character-output streams, so that their buffers</span><br><span class="hljs-comment"> * can be flushed without flushing the entire stream.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> BufferedWriter textOut;<br><span class="hljs-keyword">private</span> OutputStreamWriter charOut;<br></code></pre></td></tr></tbody></table></figure><p>与此相同的还有一个PrintWriter，不过他们的功能基本一致，PrintWriter的构造方法可以接受一个Writer作为参数，这里就不再做过多阐述了。</p><p>而我们之前使用的Scanner，使用的是系统提供的输入流：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);   <span class="hljs-comment">//系统输入流，默认是接收控制台输入</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>我们也可以使用Scanner来扫描其他的输入流：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>{<br>    Scanner scanner = <span class="hljs-keyword">new</span> Scanner(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"秘制小汉堡.txt"</span>));  <span class="hljs-comment">//将文件内容作为输入流进行扫描</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>相当于直接扫描文件中编写的内容，同样可以读取。</p><h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>数据流DataInputStream也是FilterInputStream的子类，同样采用装饰者模式，最大的不同是它支持基本数据类型的直接读取：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span> (DataInputStream dataInputStream = <span class="hljs-keyword">new</span> DataInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"test.txt"</span>))){<br>        System.out.println(dataInputStream.readBoolean());   <span class="hljs-comment">//直接将数据读取为任意基本数据类型</span><br>    }<span class="hljs-keyword">catch</span> (IOException e) {<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>用于写入基本数据类型：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span> (DataOutputStream dataOutputStream = <span class="hljs-keyword">new</span> DataOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"output.txt"</span>))){<br>        dataOutputStream.writeBoolean(<span class="hljs-keyword">false</span>);<br>    }<span class="hljs-keyword">catch</span> (IOException e) {<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>注意，写入的是二进制数据，并不是写入的字符串，使用DataInputStream可以读取，一般他们是配合一起使用的。</p><h3 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h3><p>既然基本数据类型能够读取和写入基本数据类型，那么能否将对象也支持呢？ObjectOutputStream不仅支持基本数据类型，通过对对象的序列化操作，以某种格式保存对象，来支持对象类型的IO，注意：它不是继承自FilterInputStream的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span> (ObjectOutputStream outputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"output.txt"</span>));<br>         ObjectInputStream inputStream = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"output.txt"</span>))){<br>        People people = <span class="hljs-keyword">new</span> People(<span class="hljs-string">"lbw"</span>);<br>        outputStream.writeObject(people);<br>      outputStream.flush();<br>        people = (People) inputStream.readObject();<br>        System.out.println(people.name);<br>    }<span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) {<br>        e.printStackTrace();<br>    }<br>}<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>{   <span class="hljs-comment">//必须实现Serializable接口才能被序列化</span><br>    String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">People</span><span class="hljs-params">(String name)</span></span>{<br>        <span class="hljs-keyword">this</span>.name = name;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>在我们后续的操作中，有可能会使得这个类的一些结构发生变化，而原来保存的数据只适用于之前版本的这个类，因此我们需要一种方法来区分类的不同版本：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>{<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">123456</span>;   <span class="hljs-comment">//在序列化时，会被自动添加这个属性，它代表当前类的版本，我们也可以手动指定版本。</span><br><br>    String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">People</span><span class="hljs-params">(String name)</span></span>{<br>        <span class="hljs-keyword">this</span>.name = name;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>当发生版本不匹配时，会无法反序列化为对象：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">java.io.InvalidClassException: com.test.Main$People; local class incompatible: stream classdesc serialVersionUID = 123456, local class serialVersionUID = 1234567<br>at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:<span class="hljs-number">699</span>)<br>at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:<span class="hljs-number">2003</span>)<br>at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:<span class="hljs-number">1850</span>)<br>at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:<span class="hljs-number">2160</span>)<br>at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:<span class="hljs-number">1667</span>)<br>at java.io.ObjectInputStream.readObject(ObjectInputStream.java:<span class="hljs-number">503</span>)<br>at java.io.ObjectInputStream.readObject(ObjectInputStream.java:<span class="hljs-number">461</span>)<br>at com.test.Main.main(Main.java:<span class="hljs-number">27</span>)<br></code></pre></td></tr></tbody></table></figure><p>如果我们不希望某些属性参与到序列化中进行保存，我们可以添加<code>transient</code>关键字：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span> (ObjectOutputStream outputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"output.txt"</span>));<br>         ObjectInputStream inputStream = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"output.txt"</span>))){<br>        People people = <span class="hljs-keyword">new</span> People(<span class="hljs-string">"lbw"</span>);<br>        outputStream.writeObject(people);<br>        outputStream.flush();<br>        people = (People) inputStream.readObject();<br>        System.out.println(people.name);  <span class="hljs-comment">//虽然能得到对象，但是name属性并没有保存，因此为null</span><br>    }<span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) {<br>        e.printStackTrace();<br>    }<br>}<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>{<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1234567</span>;<br><br>    <span class="hljs-keyword">transient</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">People</span><span class="hljs-params">(String name)</span></span>{<br>        <span class="hljs-keyword">this</span>.name = name;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>其实我们可以看到，在一些JDK内部的源码中，也存在大量的transient关键字，使得某些属性不参与序列化，取消这些不必要保存的属性，可以节省数据空间占用以及减少序列化时间。</p><hr><h2 id="实战：图书管理系统"><a href="#实战：图书管理系统" class="headerlink" title="实战：图书管理系统"></a>实战：图书管理系统</h2><p>要求实现一个图书管理系统（控制台），支持以下功能：保存书籍信息（要求持久化），查询、添加、删除、修改书籍信息。</p>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/10/04/SkAn9RQpqC4tVW5.png&quot; alt=&quot;image-20221004131436371&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;集合类与IO&quot;&gt;&lt;a href=&quot;#集合类与IO&quot; class=&quot;headerlink&quot; title=&quot;集合类与IO&quot;&gt;&lt;/a&gt;集合类与IO&lt;/h1&gt;&lt;p&gt;前面我们已经把基础介绍完了，从这节课开始，我们就正式进入到集合类的讲解中。&lt;/p&gt;
&lt;h2 id=&quot;集合类&quot;&gt;&lt;a href=&quot;#集合类&quot; class=&quot;headerlink&quot; title=&quot;集合类&quot;&gt;&lt;/a&gt;集合类&lt;/h2&gt;&lt;p&gt;集合类是Java中非常重要的存在，使用频率极高。集合其实与我们数学中的集合是差不多的概念，集合表示一组对象，每一个对象我们都可以称其为元素。不同的集合有着不同的性质，比如一些集合允许重复的元素，而另一些则不允许，一些集合是有序的，而其他则是无序的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/09/30/ZWxPduaYGgRzmNO.png&quot; alt=&quot;image-20220930233059528&quot;&gt;&lt;/p&gt;
&lt;p&gt;集合类其实就是为了更好地组织、管理和操作我们的数据而存在的，包括列表、集合、队列、映射等数据结构。从这一块开始，我们会从源码角度给大家讲解（先从接口定义对于集合需要实现哪些功能开始说起，包括这些集合类的底层机制是如何运作的）不仅仅是教会大家如何去使用。&lt;/p&gt;
&lt;p&gt;集合跟数组一样，可以表示同样的一组元素，但是他们的相同和不同之处在于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它们都是容器，都能够容纳一组元素。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://xiaofanshutu.github.io/posts/0.html"/>
    <id>https://xiaofanshutu.github.io/posts/0.html</id>
    <published>2025-09-07T23:26:13.331Z</published>
    <updated>2025-09-07T23:28:25.714Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://s2.loli.net/2022/09/22/lmKBNFc5wPEgjaS.png" alt="image-20220922170926093"></p><h1 id="面向对象高级篇"><a href="#面向对象高级篇" class="headerlink" title="面向对象高级篇"></a>面向对象高级篇</h1><p>经过前面的学习，我们已经了解了面向对象编程的大部分基础内容，这一部分，我们将继续探索面向对象编程过程中一些常用的东西。</p><h2 id="基本类型包装类"><a href="#基本类型包装类" class="headerlink" title="基本类型包装类"></a>基本类型包装类</h2><p>Java并不是纯面向对象的语言，虽然Java语言是一个面向对象的语言，但是Java中的基本数据类型却不是面向对象的。Java中的基本类型，如果想通过对象的形式去使用他们，Java提供的基本类型包装类，使得Java能够更好的体现面向对象的思想，同时也使得基本类型能够支持对象操作！</p><h3 id="包装类介绍"><a href="#包装类介绍" class="headerlink" title="包装类介绍"></a>包装类介绍</h3><p>所有的包装类层次结构如下：</p><p><img src="https://s2.loli.net/2022/09/22/mulb5VdvBLiWNe2.png" alt="5c3a6a27-6370-4c60-9bbc-8039e11e752d"></p><p>其中能够表示数字的基本类型包装类，继承自Number类，对应关系如下表：</p><ul><li>byte  -&gt;  Byte</li><li>boolean  -&gt;  Boolean</li><li>short  -&gt;  Short</li><li>char  -&gt;  Character</li><li>int -&gt; Integer</li><li>long -&gt;  Long</li><li>float -&gt; Float</li><li>double -&gt; Double</li></ul><p>我们可以直接使用，这里我们以Integer类为例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Integer i = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">10</span>);    <span class="hljs-comment">//将10包装为一个Integer类型的变量</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>包装类实际上就是将我们的基本数据类型，封装成一个类（运用了封装的思想）我们可以来看看Integer类中是怎么写的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> value;  <span class="hljs-comment">//类中实际上就靠这个变量在存储包装的值</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Integer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>{<br>    <span class="hljs-keyword">this</span>.value = value;<br>}<br></code></pre></td></tr></tbody></table></figure><p>包装类型支持自动装箱，我们可以直接将一个对应的基本类型值作为对应包装类型引用变量的值：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Integer i = <span class="hljs-number">10</span>;    <span class="hljs-comment">//将int类型值作为包装类型使用</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>这是怎么做到的？为什么一个对象类型的值可以直接接收一个基本类类型的值？实际上这里就是自动装箱：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Integer i = Integer.valueOf(<span class="hljs-number">10</span>);    <span class="hljs-comment">//上面的写法跟这里是等价的</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>这里本质上就是被自动包装成了一个Integer类型的对象，只是语法上为了简单，就支持像这样编写。既然能装箱，也是支持拆箱的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Integer i = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> a = i;<br>}<br></code></pre></td></tr></tbody></table></figure><p>实际上上面的写法本质上就是：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Integer i = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> a = i.intValue();   <span class="hljs-comment">//通过此方法变成基本类型int值</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>这里就是自动拆箱，得益于包装类型的自动装箱和拆箱机制，我们可以让包装类型轻松地参与到基本类型的运算中：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Integer a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">int</span> c = a * b;    <span class="hljs-comment">//直接自动拆箱成基本类型参与到计算中</span><br>    System.out.println(c);<br>}<br></code></pre></td></tr></tbody></table></figure><p>因为包装类是一个类，不是基本类型，所以说两个不同的对象，那么是不相等的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Integer a = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">10</span>);<br>    Integer b = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">10</span>);<br><br>    System.out.println(a == b);    <span class="hljs-comment">//虽然a和b的值相同，但是并不是同一个对象，所以说==判断为假</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>那么自动装箱的呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Integer a = <span class="hljs-number">10</span>, b = <span class="hljs-number">10</span>;<br>    System.out.println(a == b);<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现，通过自动装箱转换的Integer对象，如果值相同，得到的会是同一个对象，这是因为：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>{<br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)   <span class="hljs-comment">//这里会有一个IntegerCache，如果在范围内，那么会直接返回已经提前创建好的对象</span><br>        <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(i);<br>}<br></code></pre></td></tr></tbody></table></figure><p>IntegerCache会默认缓存-128<del>127之间的所有值，将这些值提前做成包装类放在数组中存放，虽然我们目前还没有学习数组，但是各位小伙伴只需要知道，我们如果直接让 -128</del>127之间的值自动装箱为Integer类型的对象，那么始终都会得到同一个对象，这是为了提升效率，因为小的数使用频率非常高，有些时候并不需要创建那么多对象，创建对象越多，内存也会消耗更多。</p><p>但是如果超出这个缓存范围的话，就会得到不同的对象了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Integer a = <span class="hljs-number">128</span>, b = <span class="hljs-number">128</span>;<br>    System.out.println(a == b);<br>}<br></code></pre></td></tr></tbody></table></figure><p>这样就不会得到同一个对象了，因为超出了缓存的范围。同样的，Long、Short、Byte类型的包装类也有类似的机制，感兴趣的小伙伴可以自己点进去看看。</p><p>我们来看看包装类中提供了哪些其他的方法，包装类支持字符串直接转换：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Integer i = <span class="hljs-keyword">new</span> Integer(<span class="hljs-string">"666"</span>);   <span class="hljs-comment">//直接将字符串的666，转换为数字666</span><br>    System.out.println(i);<br>}<br></code></pre></td></tr></tbody></table></figure><p>当然，字符串转Integer有多个方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Integer i = Integer.valueOf(<span class="hljs-string">"5555"</span>);<br>    <span class="hljs-comment">//Integer i = Integer.parseInt("5555");</span><br>    System.out.println(i);<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们甚至可以对十六进制和八进制的字符串进行解码，得到对应的int值：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Integer i = Integer.decode(<span class="hljs-string">"0xA6"</span>);<br>    System.out.println(i);<br>}<br></code></pre></td></tr></tbody></table></figure><p>也可以将十进制的整数转换为其他进制的字符串：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    System.out.println(Integer.toHexString(<span class="hljs-number">166</span>));<br>}<br></code></pre></td></tr></tbody></table></figure><p>当然，Integer中提供的方法还有很多，这里就不一一列出了。</p><h3 id="特殊包装类"><a href="#特殊包装类" class="headerlink" title="特殊包装类"></a>特殊包装类</h3><p>除了我们上面认识的这几种基本类型包装类之外，还有两个比较特殊的包装类型。</p><p>其中第一个是用于计算超大数字的BigInteger，我们知道，即使是最大的long类型，也只能表示64bit的数据，无法表示一个非常大的数，但是BigInteger没有这些限制，我们可以让他等于一个非常大的数字：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    BigInteger i = BigInteger.valueOf(Long.MAX_VALUE);    <span class="hljs-comment">//表示Long的最大值，轻轻松松</span><br>    System.out.println(i);<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以通过调用类中的方法，进行运算操作：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    BigInteger i = BigInteger.valueOf(Long.MAX_VALUE);<br>    i = i.multiply(BigInteger.valueOf(Long.MAX_VALUE));   <span class="hljs-comment">//即使是long的最大值乘以long的最大值，也能给你算出来</span><br>    System.out.println(i);<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们来看看结果：</p><p><img src="https://s2.loli.net/2022/09/22/FTPGhgnAEm1QKkV.png" alt="image-20220922211414392"></p><p>可以看到，此时数值已经非常大了，也可以轻松计算出来。咱们来点更刺激的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    BigInteger i = BigInteger.valueOf(Long.MAX_VALUE);<br>    i = i.pow(<span class="hljs-number">100</span>);   <span class="hljs-comment">//long的最大值来个100次方吧</span><br>    System.out.println(i);<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以看到，这个数字已经大到一排显示不下了：</p><p><img src="https://s2.loli.net/2022/09/22/w1OoFmbLiJ4rlcV.png" alt="image-20220922211651719"></p><p>一般情况，对于非常大的整数计算，我们就可以使用BigInteger来完成。</p><p>我们接着来看第二种，前面我们说了，浮点类型精度有限，对于需要精确计算的场景，就没办法了，而BigDecimal可以实现小数的精确计算。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    BigDecimal i = BigDecimal.valueOf(<span class="hljs-number">10</span>);<br>    i = i.divide(BigDecimal.valueOf(<span class="hljs-number">3</span>), <span class="hljs-number">100</span>, RoundingMode.CEILING);<br>  <span class="hljs-comment">//计算10/3的结果，精确到小数点后100位</span><br>  <span class="hljs-comment">//RoundingMode是舍入模式，就是精确到最后一位时，该怎么处理，这里CEILING表示向上取整</span><br>    System.out.println(i);<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以看到，确实可以精确到这种程度：</p><p><img src="https://s2.loli.net/2022/09/22/IUJ5rwzxonCBMT4.png" alt="image-20220922212222762"></p><p>但是注意，对于这种结果没有终点的，无限循环的小数，我们必须要限制长度，否则会出现异常。</p><hr><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>我们接着来看一个比较特殊的类型，数组。</p><p>假设出现一种情况，我们想记录100个数字，要是采用定义100个变量的方式可以吗？是不是有点太累了？这种情况我们就可以使用数组来存放一组相同类型的数据。</p><p><img src="https://s2.loli.net/2022/09/22/y4ISWZLrYE3Pdig.png" alt="image-20220922214604430"></p><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>数组是相同类型数据的有序集合，数组可以代表任何相同类型的一组内容（包括引用类型和基本类型）其中存放的每一个数据称为数组的一个元素，我们来看看如何去定义一个数组变量：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span>[] array;   <span class="hljs-comment">//类型[]就表示这个是一个数组类型</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>注意，数组类型比较特殊，它本身也是类，但是编程不可见（底层C++写的，在运行时动态创建）即使是基本类型的数组，也是以对象的形式存在的，并不是基本数据类型。所以，我们要创建一个数组，同样需要使用<code>new </code>关键字：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];   <span class="hljs-comment">//在创建数组时，需要指定数组长度，也就是可以容纳多个int变量的值</span><br>  Object obj = array;   <span class="hljs-comment">//因为同样是类，肯定是继承自Object的，所以说可以直接向上转型</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>除了上面这种方式之外，我们也可以使用其他方式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">类型[] 变量名称 = <span class="hljs-keyword">new</span> 类型[数组大小];<br>类型 变量名称[] = <span class="hljs-keyword">new</span> 类型[数组大小];  <span class="hljs-comment">//支持C语言样式，但不推荐！</span><br><br>类型[] 变量名称 = <span class="hljs-keyword">new</span> 类型[]{...};  <span class="hljs-comment">//静态初始化（直接指定值和大小）</span><br>类型[] 变量名称 = {...};   <span class="hljs-comment">//同上，但是只能在定义时赋值</span><br></code></pre></td></tr></tbody></table></figure><p>创建出来的数组每个位置上都有默认值，如果是引用类型，就是null，如果是基本数据类型，就是0，或者是false，跟对象成员变量的默认值是一样的，要访问数组的某一个元素，我们可以：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>    System.out.println(<span class="hljs-string">"数组的第一个元素为："</span>+array[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//使用 变量名[下标] 的方式访问</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>注意，数组的下标是从0开始的，不是从1开始的，所以说第一个元素的下标就是0，我们要访问第一个元素，那么直接输入0就行了，但是注意千万别写成负数或是超出范围了，否则会出现异常。</p><p>我们也可以使用这种方式为数组的元素赋值：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>    array[<span class="hljs-number">0</span>] = <span class="hljs-number">888</span>;   <span class="hljs-comment">//就像使用变量一样，是可以放在赋值运算符左边的，我们可以直接给对应下标位置的元素赋值</span><br>    System.out.println(<span class="hljs-string">"数组的第一个元素为："</span>+array[<span class="hljs-number">0</span>]);<br>}<br></code></pre></td></tr></tbody></table></figure><p>因为数组本身也是一个对象，数组对象也是具有属性的，比如长度：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>    System.out.println(<span class="hljs-string">"当前数组长度为："</span>+array.length);   <span class="hljs-comment">//length属性是int类型的值，表示当前数组长度，长度是在一开始创建数组的时候就确定好的</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>注意，这个<code>length</code>是在一开始就确定的，而且是<code>final</code>类型的，不允许进行修改，也就是说数组的长度一旦确定，不能随便进行修改，如果需要使用更大的数组，只能重新创建。</p><p>当然，既然是类型，那么肯定也是继承自Object类的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>    System.out.println(array.toString());<br>    System.out.println(array.equals(array));<br>}<br></code></pre></td></tr></tbody></table></figure><p>但是，很遗憾，除了clone()之外，这些方法并没有被重写，也就是说依然是采用的Object中的默认实现：</p><p><img src="https://s2.loli.net/2022/09/22/UfTGu9sZheW21jB.png" alt="image-20220922220403391"></p><p>所以说通过<code>toString()</code>打印出来的结果，好丑，只不过我们可以发现，数组类型的类名很奇怪，是<code>[</code>开头的。</p><p>因此，如果我们要打印整个数组中所有的元素，得一个一个访问：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array.length; i++) {<br>        System.out.print(array[i] + <span class="hljs-string">" "</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>有时候为了方便，我们可以使用简化版的for语句<code>foreach</code>语法来遍历数组中的每一个元素：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : array) {    <span class="hljs-comment">//int i就是每一个数组中的元素，array就是我们要遍历的数组</span><br>        System.out.print(i+<span class="hljs-string">" "</span>);   <span class="hljs-comment">//每一轮循环，i都会更新成数组中下一个元素</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>是不是感觉这种写法更加简洁？只不过这仅仅是语法糖而已，编译之后依然是跟上面一样老老实实在遍历的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{   <span class="hljs-comment">//反编译的结果</span><br>    <span class="hljs-keyword">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">int</span>[] var2 = array;<br>    <span class="hljs-keyword">int</span> var3 = array.length;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> var4 = <span class="hljs-number">0</span>; var4 &lt; var3; ++var4) {<br>        <span class="hljs-keyword">int</span> i = var2[var4];<br>        System.out.print(i + <span class="hljs-string">" "</span>);<br>    }<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>对于这种普通的数组，其实使用还是挺简单的。这里需要特别说一下，对于基本类型的数组来说，是不支持自动装箱和拆箱的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>    Integer[] test = arr;<br>}<br></code></pre></td></tr></tbody></table></figure><p>还有，由于基本数据类型和引用类型不同，所以说int类型的数组时不能被Object类型的数组变量接收的：</p><p><img src="https://s2.loli.net/2022/09/24/XbfZ9YHkqjv7613.png" alt="image-20220924114859252"></p><p>但是如果是引用类型的话，是可以的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    String[] arr = <span class="hljs-keyword">new</span> String[<span class="hljs-number">10</span>];<br>    Object[] array = arr;    <span class="hljs-comment">//数组同样支持向上转型</span><br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Object[] arr = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">10</span>];<br>    String[] array = (String[]) arr;   <span class="hljs-comment">//也支持向下转型</span><br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>前面我们介绍了简单的数组（一维数组）既然数组可以是任何类型的，那么我们能否创建数组类型的数组呢？答案是可以的，套娃嘛，谁不会：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span>[][] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>][<span class="hljs-number">10</span>];    <span class="hljs-comment">//数组类型数组那么就要写两个[]了</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>存放数组的数组，相当于将维度进行了提升，比如上面的就是一个2x10的数组：</p><p><img src="https://s2.loli.net/2022/09/22/kRcO1aGY6fMBiu9.png" alt="image-20220922221557130"></p><p>这个中数组一共有2个元素，每个元素都是一个存放10个元素的数组，所以说最后看起来就像一个矩阵一样。甚至可以继续套娃，将其变成一个三维数组，也就是存放数组的数组的数组。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span>[][] arr = { {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>},<br>                    {<span class="hljs-number">3</span>, <span class="hljs-number">4</span>},<br>                    {<span class="hljs-number">5</span>, <span class="hljs-number">6</span>}};   <span class="hljs-comment">//一个三行两列的数组</span><br>    System.out.println(arr[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]);   <span class="hljs-comment">//访问第三行第二列的元素</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>在访问多维数组时，我们需要使用多次<code>[]</code>运算符来得到对应位置的元素。如果我们要遍历多维数组话，那么就需要多次嵌套循环：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]{{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>},<br>            {<span class="hljs-number">3</span>, <span class="hljs-number">4</span>},<br>            {<span class="hljs-number">5</span>, <span class="hljs-number">6</span>}};<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {    <span class="hljs-comment">//要遍历一个二维数组，那么我们得一列一列一行一行地来</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++) {<br>            System.out.println(arr[i][j]);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h3><p>我们接着来看数组的延伸应用，实际上我们的方法是支持可变长参数的，什么是可变长参数？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{<br>    String name;<br>    <span class="hljs-keyword">int</span> age;<br>    String sex;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String... strings)</span></span>{<br><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们在使用时，可以传入0 - N个对应类型的实参：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Person person = <span class="hljs-keyword">new</span> Person();<br>    person.test(<span class="hljs-string">"1！"</span>, <span class="hljs-string">"5！"</span>, <span class="hljs-string">"哥们在这跟你说唱"</span>); <span class="hljs-comment">//这里我们可以自由传入任意数量的字符串</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>那么我们在方法中怎么才能得到这些传入的参数呢，实际上可变长参数本质就是一个数组：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String... strings)</span></span>{   <span class="hljs-comment">//strings这个变量就是一个String[]类型的</span><br>    <span class="hljs-keyword">for</span> (String string : strings) {<br>        System.out.println(string);   <span class="hljs-comment">//遍历打印数组中每一个元素</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>注意，如果同时存在其他参数，那么可变长参数只能放在最后：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, String... strings)</span></span>{<br>    <br>}<br></code></pre></td></tr></tbody></table></figure><p>这里最后我们再来说一个从开始到现在一直都没有说的东西：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{   <span class="hljs-comment">//这个String[] args到底是个啥？？？</span><br>    <br>}<br></code></pre></td></tr></tbody></table></figure><p>实际上这个是我们在执行Java程序时，输入的命令行参数，我们可以来打印一下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">for</span> (String arg : args) {<br>        System.out.println(arg);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以看到，默认情况下直接运行什么都没有，但是如果我们在运行时，添加点内容的话：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">java com/<span class="hljs-built_in">test</span>/Main lbwnb aaaa xxxxx   <span class="hljs-comment">#放在包中需要携带主类完整路径才能运行</span><br></code></pre></td></tr></tbody></table></figure><p>可以看到，我们在后面随意添加的三个参数，都放到数组中了：</p><p><img src="https://s2.loli.net/2022/09/22/DL3WTMdRwrSYJIl.png" alt="image-20220922223152648"></p><p>这个东西我们作为新手一般也不会用到，只做了解就行了。</p><hr><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串类是一个比较特殊的类，它用于保存字符串。我们知道，基本类型<code>char</code>可以保存一个2字节的Unicode字符，而字符串则是一系列字符的序列（在C中就是一个字符数组）Java中没有字符串这种基本类型，因此只能使用类来进行定义。注意，字符串中的字符一旦确定，无法进行修改，只能重新创建。</p><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>String本身也是一个类，只不过它比较特殊，每个用双引号括起来的字符串，都是String类型的一个实例对象：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    String str = <span class="hljs-string">"Hello World!"</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们也可以象征性地使用一下new关键字：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"Hello World!"</span>);  <span class="hljs-comment">//这种方式就是创建一个新的对象</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>注意，如果是直接使用双引号创建的字符串，如果内容相同，为了优化效率，那么始终都是同一个对象：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    String str1 = <span class="hljs-string">"Hello World"</span>;<br>    String str2 = <span class="hljs-string">"Hello World"</span>;<br>    System.out.println(str1 == str2);<br>}<br></code></pre></td></tr></tbody></table></figure><p>但是如果我们使用构造方法主动创建两个新的对象，那么就是不同的对象了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    String str1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"Hello World"</span>);<br>    String str2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"Hello World"</span>);<br>    System.out.println(str1 == str2);<br>}<br></code></pre></td></tr></tbody></table></figure><p>至于为什么会出现这种情况，我们在JVM篇视频教程中会进行详细的介绍，这里各位小伙伴只需要记住就行了。因此，如果我们仅仅是想要判断两个字符串的内容是否相同，不要使用<code>==</code>，String类重载了<code>equals</code>方法用于判断和比较内容是否相同：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    String str1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"Hello World"</span>);<br>    String str2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"Hello World"</span>);<br>    System.out.println(str1.equals(str2));   <span class="hljs-comment">//字符串的内容比较，一定要用equals</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>既然String也是一个类，那么肯定是具有一些方法的，我们可以来看看：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    String str = <span class="hljs-string">"Hello World"</span>;<br>    System.out.println(str.length());   <span class="hljs-comment">//length方法可以求字符串长度，这个长度是字符的数量</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>因为双引号括起来的字符串本身就是一个实例对象，所以说我们也可以直接用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    System.out.println(<span class="hljs-string">"Hello World"</span>.length());   <span class="hljs-comment">//虽然看起来挺奇怪的，但是确实支持这种写法</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>字符串类中提供了很多方便我们操作的方法，比如字符串的裁剪、分割操作：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    String str = <span class="hljs-string">"Hello World"</span>;<br>    String sub = str.substring(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);   <span class="hljs-comment">//分割字符串，并返回一个新的子串对象</span><br>    System.out.println(sub);<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    String str = <span class="hljs-string">"Hello World"</span>;<br>    String[] strings = str.split(<span class="hljs-string">" "</span>);   <span class="hljs-comment">//使用split方法进行字符串分割，比如这里就是通过空格分隔，得到一个字符串数组</span><br>    <span class="hljs-keyword">for</span> (String string : strings) {<br>        System.out.println(string);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>字符数组和字符串之间是可以快速进行相互转换的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    String str = <span class="hljs-string">"Hello World"</span>;<br>    <span class="hljs-keyword">char</span>[] chars = str.toCharArray();<br>    System.out.println(chars);<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[]{<span class="hljs-string">'奥'</span>, <span class="hljs-string">'利'</span>, <span class="hljs-string">'给'</span>};<br>    String str = <span class="hljs-keyword">new</span> String(chars);<br>    System.out.println(str);<br>}<br></code></pre></td></tr></tbody></table></figure><p>当然，String类还有很多其他的一些方法，这里就不一一介绍了。</p><h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><p>我们在之前的学习中已经了解，字符串支持使用<code>+</code>和<code>+=</code>进行拼接操作。</p><p>但是拼接字符串实际上底层需要进行很多操作，如果程序中大量进行字符串的拼接似乎不太好，编译器是很聪明的，String的拼接会在编译时进行各种优化：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    String str = <span class="hljs-string">"杰哥"</span> + <span class="hljs-string">"你干嘛"</span>;    <span class="hljs-comment">//我们在写代码时使用的是拼接的形式</span><br>    System.out.println(str);<br>}<br></code></pre></td></tr></tbody></table></figure><p>编译之后就变成这样了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    String str = <span class="hljs-string">"杰哥你干嘛"</span>;<br>    System.out.println(str);<br>}<br></code></pre></td></tr></tbody></table></figure><p>对于变量来说，也有优化，比如下面这种情况：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    String str1 = <span class="hljs-string">"你看"</span>;<br>    String str2 = <span class="hljs-string">"这"</span>;<br>    String str3 = <span class="hljs-string">"汉堡"</span>;<br>    String str4 = <span class="hljs-string">"做滴"</span>;<br>    String str5 = <span class="hljs-string">"行不行"</span>;<br>    String result = str1 + str2 + str3 + str4 + str5;   <span class="hljs-comment">//5个变量连续加</span><br>    System.out.println(result);<br>}<br></code></pre></td></tr></tbody></table></figure><p>如果直接使用加的话，每次运算都会生成一个新的对象，这里进行4次加法运算，那么中间就需要产生4个字符串对象出来，是不是有点太浪费了？这种情况实际上会被优化为下面的写法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    String str1 = <span class="hljs-string">"你看"</span>;<br>    String str2 = <span class="hljs-string">"这"</span>;<br>    String str3 = <span class="hljs-string">"汉堡"</span>;<br>    String str4 = <span class="hljs-string">"做滴"</span>;<br>    String str5 = <span class="hljs-string">"行不行"</span>;<br>    StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();<br>    builder.append(str1).append(str2).append(str3).append(str4).append(str5);<br>    System.out.println(builder.toString());<br>}<br></code></pre></td></tr></tbody></table></figure><p>这里创建了一个StringBuilder的类型，这个类型是干嘛的呢？实际上它就是专门用于构造字符串的，我们可以使用它来对字符串进行拼接、裁剪等操作，它就像一个字符串编辑器，弥补了字符串不能修改的不足：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();   <span class="hljs-comment">//一开始创建时，内部什么都没有</span><br>    builder.append(<span class="hljs-string">"AAA"</span>);   <span class="hljs-comment">//我们可以使用append方法来讲字符串拼接到后面</span><br>    builder.append(<span class="hljs-string">"BBB"</span>);<br>    System.out.println(builder.toString());   <span class="hljs-comment">//当我们字符串编辑完成之后，就可以使用toString转换为字符串了</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>它还支持裁剪等操作：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">"AAABBB"</span>);   <span class="hljs-comment">//在构造时也可以指定初始字符串</span><br>    builder.delete(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>);   <span class="hljs-comment">//删除2到4这个范围内的字符</span><br>    System.out.println(builder.toString());<br>}<br></code></pre></td></tr></tbody></table></figure><p>当然，StringBuilder类的编辑操作也非常多，这里就不一一列出了。</p><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>我们现在想要实现这样一个功能，对于给定的字符串进行判断，如果字符串符合我们的规则，那么就返回真，否则返回假，比如现在我们想要判断字符串是不是邮箱的格式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    String str = <span class="hljs-string">"aaaa731341@163.com"</span>;<br>  <span class="hljs-comment">//假设邮箱格式为 数字/字母@数字/字母.com</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>那么现在请你设计一个Java程序用于判断，你该怎么做？是不是感觉很麻烦，但是我们使用正则表达式就可以很轻松解决这种字符串格式匹配问题。</p><blockquote><p>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。</p></blockquote><p>我们先来看看下面的这个例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    String str = <span class="hljs-string">"oooo"</span>;<br>  <span class="hljs-comment">//matches方法用于对给定正则表达式进行匹配，匹配成功返回true，否则返回false</span><br>    System.out.println(str.matches(<span class="hljs-string">"o+"</span>));   <span class="hljs-comment">//+表示对前面这个字符匹配一次或多次，这里字符串是oooo，正好可以匹配</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>用于规定给定组件必须要出现多少次才能满足匹配的，我们一般称为限定符，限定符表如下：</p><table><thead><tr><th align="center">字符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">*</td><td align="center">匹配前面的子表达式零次或多次。例如，<strong>zo*</strong> 能匹配 <strong>“z”</strong> 以及 *<em>“zoo”<strong>。**</strong></em> 等价于 **{0,}**。</td></tr><tr><td align="center">+</td><td align="center">匹配前面的子表达式一次或多次。例如，<strong>zo+</strong> 能匹配 <strong>“zo”</strong> 以及 “<strong>zoo”**，但不能匹配 **”z”**。</strong>+** 等价于 **{1,}**。</td></tr><tr><td align="center">?</td><td align="center">匹配前面的子表达式零次或一次。例如，<strong>do(es)?</strong> 可以匹配 <strong>“do”</strong> 、 <strong>“does”**、 **”doxy”</strong> 中的 <strong>“do”</strong> 。**?** 等价于 **{0,1}**。</td></tr><tr><td align="center">{n}</td><td align="center">n 是一个非负整数。匹配确定的 <strong>n</strong> 次。例如，<strong>o{2}</strong> 不能匹配 <strong>“Bob”</strong> 中的 <strong>o</strong>，但是能匹配 <strong>“food”</strong> 中的两个 <strong>o</strong>。</td></tr><tr><td align="center">{n,}</td><td align="center">n 是一个非负整数。至少匹配n 次。例如，<strong>o{2,}</strong> 不能匹配 <strong>“Bob”</strong> 中的 <strong>o</strong>，但能匹配 <strong>“foooood”</strong> 中的所有 <strong>o</strong>。<strong>o{1,}</strong> 等价于 <strong>o+**。</strong>o{0,}** 则等价于 <strong>o*</strong>。</td></tr><tr><td align="center">{n,m}</td><td align="center">m 和 n 均为非负整数，其中 n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，<strong>o{1,3}</strong> 将匹配 <strong>“fooooood”</strong> 中的前三个 <strong>o</strong>。<strong>o{0,1}</strong> 等价于 **o?**。请注意在逗号和两个数之间不能有空格。</td></tr></tbody></table><p>如果我们想要表示一个范围内的字符，可以使用方括号：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    String str = <span class="hljs-string">"abcabccaa"</span>;<br>    System.out.println(str.matches(<span class="hljs-string">"[abc]*"</span>));   <span class="hljs-comment">//表示abc这几个字符可以出现 0 - N 次</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>对于普通字符来说，我们可以下面的方式实现多种字符匹配：</p><table><thead><tr><th align="center">字符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>[ABC]</strong></td><td align="center">匹配 <strong>[…]</strong> 中的所有字符，例如 <strong>[aeiou]</strong> 匹配字符串 “google runoob taobao” 中所有的 e o u a 字母。</td></tr><tr><td align="center"><strong>[^ABC]</strong></td><td align="center">匹配除了 <strong>[…]</strong> 中字符的所有字符，例如 <strong>[^aeiou]</strong> 匹配字符串 “google runoob taobao” 中除了 e o u a 字母的所有字母。</td></tr><tr><td align="center"><strong>[A-Z]</strong></td><td align="center">[A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。</td></tr><tr><td align="center"><strong>.</strong></td><td align="center">匹配除换行符（\n、\r）之外的任何单个字符，相等于 [^\n\r]</td></tr><tr><td align="center"><strong>[\s\S]</strong></td><td align="center">匹配所有。\s 是匹配所有空白符，包括换行，\S 非空白符，不包括换行。</td></tr><tr><td align="center"><strong>\w</strong></td><td align="center">匹配字母、数字、下划线。等价于 [A-Za-z0-9_]</td></tr></tbody></table><p>当然，这里仅仅是对正则表达式的简单使用，实际上正则表达式内容非常多，如果需要完整学习正则表达式，可以到：<a href="https://www.runoob.com/regexp/regexp-syntax.html">https://www.runoob.com/regexp/regexp-syntax.html</a></p><p>正则表达式并不是只有Java才支持，其他很多语言比如JavaScript、Python等等都是支持正则表达式的。</p><hr><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>上一章我们详细介绍了类，我们现在已经知道该如何创建类、使用类了。当然，类的创建其实可以有多种多样的方式，并不仅仅局限于普通的创建。内部类顾名思义，就是创建在内部的类，那么具体是什么的内部呢，我们接着就来讨论一下。</p><p><strong>注意：</strong>内部类很多地方都很绕，所以说一定要仔细思考。</p><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>我们可以直接在类的内部定义成员内部类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{<br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>{   <span class="hljs-comment">//内部类也是类，所以说里面也可以有成员变量、方法等，甚至还可以继续套娃一个成员内部类</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>{<br>            System.out.println(<span class="hljs-string">"我是成员内部类！"</span>);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>成员内部类和成员方法、成员变量一样，是对象所有的，而不是类所有的，如果我们要使用成员内部类，那么就需要：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Test test = <span class="hljs-keyword">new</span> Test();   <span class="hljs-comment">//我们首先需要创建对象</span><br>    Test.Inner inner = test.<span class="hljs-function">new <span class="hljs-title">Inner</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">//成员内部类的类型名称就是 外层.内部类名称</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>虽然看着很奇怪，但是确实是这样使用的。我们同样可以使用成员内部类中的方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Test test = <span class="hljs-keyword">new</span> Test();<br>    Test.Inner inner = test.n<span class="hljs-function">ew <span class="hljs-title">Inner</span><span class="hljs-params">()</span></span>;<br>    inner.test();<br>}<br></code></pre></td></tr></tbody></table></figure><p>注意，成员内部类也可以使用访问权限控制，如果我们我们将其权限改为<code>private</code>，那么就像我们把成员变量访问权限变成私有一样，外部是无法访问到这个内部类的：</p><p><img src="https://s2.loli.net/2022/09/24/HklipN4uOfK9JrG.png" alt="image-20220924122217070"></p><p>可以看到这里直接不认识了。</p><p>这里我们需要特别注意一下，在成员内部类中，是可以访问到外层的变量的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test</span><span class="hljs-params">(String name)</span></span>{<br>        <span class="hljs-keyword">this</span>.name = name;<br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>{<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>{<br>            System.out.println(<span class="hljs-string">"我是成员内部类："</span>+name);<br>         <span class="hljs-comment">//成员内部类可以访问到外部的成员变量</span><br>          <span class="hljs-comment">//因为成员内部类本身就是某个对象所有的，每个对象都有这样的一个类定义，这里的name是其所依附对象的</span><br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/09/24/aQPow8piljRCs2d.png" alt="image-20220924123600217"></p><p>每个类可以创建一个对象，每个对象中都有一个单独的类定义，可以通过这个成员内部类又创建出更多对象，套娃了属于是。</p><p>所以说我们在使用时：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Test a = <span class="hljs-keyword">new</span> Test(<span class="hljs-string">"小明"</span>);<br>    Test.Inner inner1 = a.n<span class="hljs-function">ew <span class="hljs-title">Inner</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">//依附于a创建的对象，那么就是a的</span><br>    inner1.test();<br><br>    Test b = <span class="hljs-keyword">new</span> Test(<span class="hljs-string">"小红"</span>);<br>    Test.Inner inner2 = b.n<span class="hljs-function">ew <span class="hljs-title">Inner</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//依附于b创建的对象，那么就是b的</span><br>    inner2.test();<br>}<br></code></pre></td></tr></tbody></table></figure><p>那现在问大家一个问题，外部能访问内部类里面的成员变量吗？</p><p>那么如果内部类中也定义了同名的变量，此时我们怎么去明确要使用的是哪一个呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test</span><span class="hljs-params">(String name)</span></span>{<br>        <span class="hljs-keyword">this</span>.name = name;<br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>{<br><br>        String name;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String name)</span></span>{<br>            System.out.println(<span class="hljs-string">"方法参数的name = "</span>+name);    <span class="hljs-comment">//依然是就近原则，最近的是参数，那就是参数了</span><br>            System.out.println(<span class="hljs-string">"成员内部类的name = "</span>+<span class="hljs-keyword">this</span>.name);   <span class="hljs-comment">//在内部类中使用this关键字，只能表示内部类对象</span><br>            System.out.println(<span class="hljs-string">"成员内部类的name = "</span>+Test.<span class="hljs-keyword">this</span>.name);<br>          <span class="hljs-comment">//如果需要指定为外部的对象，那么需要在前面添加外部类型名称</span><br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>包括对方法的调用和super关键字的使用，也是一样的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>{<br><br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String name)</span></span>{<br>        <span class="hljs-keyword">this</span>.toString();<span class="hljs-comment">//内部类自己的toString方法</span><br>        <span class="hljs-keyword">super</span>.toString();    <span class="hljs-comment">//内部类父类的toString方法</span><br>        Test.<span class="hljs-keyword">this</span>.toString();   <span class="hljs-comment">//外部类的toSrting方法</span><br>        Test.<span class="hljs-keyword">super</span>.toString();  <span class="hljs-comment">//外部类父类的toString方法</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>所以说成员内部类其实在某些情况下使用起来比较麻烦，对于这种成员内部类，我们一般只会在类的内部自己使用。</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>前面我们介绍了成员内部类，它就像成员变量和成员方法一样，是属于对象的，同样的，静态内部类就像静态方法和静态变量一样，是属于类的，我们可以直接创建使用。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test</span><span class="hljs-params">(String name)</span></span>{<br>        <span class="hljs-keyword">this</span>.name = name;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>{<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>{<br>            System.out.println(<span class="hljs-string">"我是静态内部类！"</span>);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>不需要依附任何对象，我们可以直接创建静态内部类的对象：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Test.Inner inner = <span class="hljs-keyword">new</span> Test.Inner();   <span class="hljs-comment">//静态内部类的类名同样是之前的格式，但是可以直接new了</span><br>  inner.test();<br>}<br></code></pre></td></tr></tbody></table></figure><p>静态内部类由于是静态的，所以相对外部来说，整个内部类中都处于静态上下文（注意只是相当于外部来说）是无法访问到外部类的非静态内容的：</p><p><img src="https://s2.loli.net/2022/09/24/cZapwgeATlG2FHn.png" alt="image-20220924124919135"></p><p>只不过受影响的只是外部内容的使用，内部倒是不受影响，还是跟普通的类一样：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>{<br><br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>{<br>        System.out.println(<span class="hljs-string">"我是静态内部类："</span>+name);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>其实也很容易想通，因为静态内部类是属于外部类的，不依附任何对象，那么我要是直接访问外部类的非静态属性，那到底访问哪个对象的呢？这样肯定是说不通的。</p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>局部内部类就像局部变量一样，可以在方法中定义。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test</span><span class="hljs-params">(String name)</span></span>{<br>        <span class="hljs-keyword">this</span>.name = name;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>{<br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>{    <span class="hljs-comment">//直接在方法中创建局部内部类</span><br>            <br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>既然是在方法中声明的类，那作用范围也就只能在方法中了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>{<br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>{   <span class="hljs-comment">//局部内部类跟局部变量一样，先声明后使用</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>{<br>                System.out.println(<span class="hljs-string">"我是局部内部类"</span>);<br>            }<br>        }<br>        <br>        Inner inner = <span class="hljs-keyword">new</span> Inner();   <span class="hljs-comment">//局部内部类直接使用类名就行</span><br>        inner.test();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>只不过这种局部内部类的形式，使用频率很低，基本上不会用到，所以说了解就行了。</p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类是我们使用频率非常高的一种内部类，它是局部内部类的简化版。</p><p>还记得我们在之前学习的抽象类和接口吗？在抽象类和接口中都会含有某些抽象方法需要子类去实现，我们当时已经很明确地说了不能直接通过new的方式去创建一个抽象类或是接口对象，但是我们可以使用匿名内部类。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>正常情况下，要创建一个抽象类的实例对象，只能对其进行继承，先实现未实现的方法，然后创建子类对象。</p><p>而我们可以在方法中使用匿名内部类，将其中的抽象方法实现，并直接创建实例对象：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Student student = <span class="hljs-keyword">new</span> Student() {   <span class="hljs-comment">//在new的时候，后面加上花括号，把未实现的方法实现了</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{<br>            System.out.println(<span class="hljs-string">"我是匿名内部类的实现!"</span>);<br>        }<br>    };<br>    student.test();<br>}<br></code></pre></td></tr></tbody></table></figure><p>此时这里创建出来的Student对象，就是一个已经实现了抽象方法的对象，这个抽象类直接就定义好了，甚至连名字都没有，就可以直接就创出对象。</p><p>匿名内部类中同样可以使用类中的属性（因为它本质上就相当于是对应类型的子类）所以说：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Student student = <span class="hljs-keyword">new</span> Student() {<br>    <span class="hljs-keyword">int</span> a;   <span class="hljs-comment">//因为本质上就相当于是子类，所以说子类定义一些子类的属性完全没问题</span><br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{<br>        System.out.println(name + <span class="hljs-string">"我是匿名内部类的实现!"</span>);   <span class="hljs-comment">//直接使用父类中的name变量</span><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>同样的，接口也可以通过这种匿名内部类的形式，直接创建一个匿名的接口实现类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Study study = <span class="hljs-keyword">new</span> Study() {<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span> </span>{<br>            System.out.println(<span class="hljs-string">"我是学习方法！"</span>);<br>        }<br>    };<br>    study.study();<br>}<br></code></pre></td></tr></tbody></table></figure><p>当然，并不是说只有抽象类和接口才可以像这样创建匿名内部类，普通的类也可以，只不过意义不大，一般情况下只是为了进行一些额外的初始化工作而已。</p><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>前面我们介绍了匿名内部类，我们可以通过这种方式创建一个临时的实现子类。</p><p>特别的，<strong>如果一个接口中有且只有一个待实现的抽象方法</strong>，那么我们可以将匿名内部类简写为Lambda表达式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Study study = () -&gt; System.out.println(<span class="hljs-string">"我是学习方法！"</span>);   <span class="hljs-comment">//是不是感觉非常简洁！</span><br>  study.study();<br>}<br></code></pre></td></tr></tbody></table></figure><p>在初学阶段，为了简化学习，各位小伙伴就认为Lambda表达式就是匿名内部类的简写就行了（Lambda表达式的底层其实并不只是简简单单的语法糖替换，感兴趣的可以在新特性篇视频教程中了解）</p><p>那么它是一个怎么样的简写规则呢？我们来看一下Lambda表达式的具体规范：</p><ul><li>标准格式为：<code>([参数类型 参数名称,]...) ‐&gt; { 代码语句，包括返回值 }</code></li><li>和匿名内部类不同，Lambda仅支持接口，不支持抽象类</li><li>接口内部必须有且仅有一个抽象方法（可以有多个方法，但是必须保证其他方法有默认实现，必须留一个抽象方法出来）</li></ul><p>比如我们之前写的Study接口，只要求实现一个无参无返回值的方法，所以说直接就是最简单的形式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">() -&gt; System.out.println(<span class="hljs-string">"我是学习方法！"</span>);   <span class="hljs-comment">//跟之前流程控制一样，如果只有一行代码花括号可省略</span><br></code></pre></td></tr></tbody></table></figure><p>当然，如果有一个参数和返回值的话：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Study study = (a) -&gt; {<br>        System.out.println(<span class="hljs-string">"我是学习方法"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"今天学会了"</span>+a;    <span class="hljs-comment">//实际上这里面就是方法体，该咋写咋写</span><br>    };<br>    System.out.println(study.study(<span class="hljs-number">10</span>));<br>}<br></code></pre></td></tr></tbody></table></figure><p>注意，如果方法体中只有一个返回语句，可以直接省去花括号和<code>return</code>关键字：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Study study = (a) -&gt; {<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"今天学会了"</span>+a;   <span class="hljs-comment">//这种情况是可以简化的</span><br>};<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Study study = (a) -&gt; <span class="hljs-string">"今天学会了"</span>+a;<br></code></pre></td></tr></tbody></table></figure><p>如果参数只有一个，那么可以省去小括号：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Study study = a -&gt; <span class="hljs-string">"今天学会了"</span>+a;<br></code></pre></td></tr></tbody></table></figure><p>是不是感觉特别简洁，实际上我们程序员追求的就是写出简洁高效的代码，而Java也在朝这个方向一直努力，近年来从Java 9开始出现的一些新语法基本都是各种各样的简写版本。</p><p>如果一个方法的参数需要的是一个接口的实现：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    test(a -&gt; <span class="hljs-string">"今天学会了"</span>+a);   <span class="hljs-comment">//参数直接写成lambda表达式</span><br>}<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Study study)</span></span>{<br>    study.study(<span class="hljs-number">10</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>当然，这还只是一部分，对于已经实现的方法，如果我们想直接作为接口抽象方法的实现，我们还可以使用方法引用。</p><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>方法引用就是将一个已实现的方法，直接作为接口中抽象方法的实现（当然前提是方法定义得一样才行）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Study</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;   <span class="hljs-comment">//待实现的求和方法</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>那么使用时候，可以直接使用Lambda表达式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Study study = (a, b) -&gt; a + b;<br>}<br></code></pre></td></tr></tbody></table></figure><p>只不过还能更简单，因为Integer类中默认提供了求两个int值之和的方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Integer类中就已经有对应的实现了</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{<br>    <span class="hljs-keyword">return</span> a + b;<br>}<br></code></pre></td></tr></tbody></table></figure><p>此时，我们可以直接将已有方法的实现作为接口的实现：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Study study = (a, b) -&gt; Integer.sum(a, b);   <span class="hljs-comment">//直接使用Integer为我们通过好的求和方法</span><br>    System.out.println(study.sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>));<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现，Integer.sum的参数和返回值，跟我们在Study中定义的完全一样，所以说我们可以直接使用方法引用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Study study = Integer::sum;    <span class="hljs-comment">//使用双冒号来进行方法引用，静态方法使用 类名::方法名 的形式</span><br>    System.out.println(study.sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>));<br>}<br></code></pre></td></tr></tbody></table></figure><p>方法引用其实本质上就相当于将其他方法的实现，直接作为接口中抽象方法的实现。任何方法都可以通过方法引用作为实现：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Study</span> </span>{<br>    <span class="hljs-function">String <span class="hljs-title">study</span><span class="hljs-params">()</span></span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>如果是普通从成员方法，我们同样需要使用对象来进行方法引用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Main main = <span class="hljs-keyword">new</span> Main();<br>    Study study = main::lbwnb;   <span class="hljs-comment">//成员方法因为需要具体对象使用，所以说只能使用 对象::方法名 的形式</span><br>}<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">lbwnb</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"卡布奇诺今犹在，不见当年倒茶人。"</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>因为现在只需要一个String类型的返回值，由于String的构造方法在创建对象时也会得到一个String类型的结果，所以说：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Study study = String::<span class="hljs-keyword">new</span>;    <span class="hljs-comment">//没错，构造方法也可以被引用，使用new表示</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>反正只要是符合接口中方法的定义的，都可以直接进行方法引用，对于Lambda表达式和方法引用，在Java新特性介绍篇视频教程中还有详细的讲解，这里就不多说了。</p><hr><h2 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h2><p>在理想的情况下，我们的程序会按照我们的思路去运行，按理说是不会出现问题的，但是，代码实际编写后并不一定是完美的，可能会有我们没有考虑到的情况，如果这些情况能够正常得到一个错误的结果还好，但是如果直接导致程序运行出现问题了呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    test(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);   <span class="hljs-comment">//当b为0的时候，还能正常运行吗？</span><br>}<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>{<br>    <span class="hljs-keyword">return</span> a/b;   <span class="hljs-comment">//没有任何的判断而是直接做计算</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>此时我们可以看到，出现了运算异常：</p><p><img src="https://s2.loli.net/2022/09/24/5PxTJv7M2YFzfg4.png" alt="image-20220924164357033"></p><p>那么这个异常到底是什么样的一种存在呢？当程序运行出现我们没有考虑到的情况时，就有可能出现异常或是错误！</p><h3 id="异常的类型"><a href="#异常的类型" class="headerlink" title="异常的类型"></a>异常的类型</h3><p>我们在之前其实已经接触过一些异常了，比如数组越界异常，空指针异常，算术异常等，他们其实都是异常类型，我们的每一个异常也是一个类，他们都继承自<code>Exception</code>类！异常类型本质依然类的对象，但是异常类型支持在程序运行出现问题时抛出（也就是上面出现的红色报错）也可以提前声明，告知使用者需要处理可能会出现的异常！</p><p>异常的第一种类型是运行时异常，如上述的列子，在编译阶段无法感知代码是否会出现问题，只有在运行的时候才知道会不会出错（正常情况下是不会出错的），这样的异常称为运行时异常，异常也是由类定义的，所有的运行时异常都继承自<code>RuntimeException</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Object object = <span class="hljs-keyword">null</span>;<br>    object.toString();   <span class="hljs-comment">//这种情况就会出现运行时异常</span><br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/09/24/cTAqbZ93HidRIGW.png" alt="image-20220924164637887"></p><p>又比如下面的这种情况：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Object object = <span class="hljs-keyword">new</span> Object();<br>    Main main = (Main) object;<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/09/24/QxMimbjZk19C25d.png" alt="image-20220924164844005"></p><p>异常的另一种类型是编译时异常，编译时异常明确指出可能会出现的异常，在编译阶段就需要进行处理（捕获异常）必须要考虑到出现异常的情况，如果不进行处理，将无法通过编译！默认继承自<code>Exception</code>类的异常都是编译时异常。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException</span>;<br></code></pre></td></tr></tbody></table></figure><p>比如Object类中定义的<code>clone</code>方法，就明确指出了在运行的时候会出现的异常。</p><p>还有一种类型是错误，错误比异常更严重，异常就是不同寻常，但不一定会导致致命的问题，而错误是致命问题，一般出现错误可能JVM就无法继续正常运行了，比如<code>OutOfMemoryError</code>就是内存溢出错误（内存占用已经超出限制，无法继续申请内存了）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    test();<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>{<br>    test();<br>}<br></code></pre></td></tr></tbody></table></figure><p>比如这样的一个无限递归的方法，会导致运行过程中无限制地向下调用方法，导致栈溢出：</p><p><img src="https://s2.loli.net/2022/09/24/9YEZV2L73ROQTuA.png" alt="image-20220924165500108"></p><p>这种情况就是错误了，已经严重到整个程序都无法正常运行了。又比如：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Object[] objects = <span class="hljs-keyword">new</span> Object[Integer.MAX_VALUE];   <span class="hljs-comment">//这里申请一个超级大数组</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>实际上我们电脑的内存是有限的，不可能无限制地使用内存来存放变量，所以说如果内存不够用了，会直接：</p><p><img src="https://s2.loli.net/2022/09/24/qj8zJnGxdS5IybX.png" alt="image-20220924165657392"></p><p>此时没有更多的可用内存供我们的程序使用，那么程序也就没办法继续运行下去了，这同样是一个很严重的错误。</p><p>当然，我们这一块主要讨论的目录依然是异常。</p><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>异常其实就两大类，一个是编译时异常，一个是运行时异常，我们先来看编译时异常。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span></span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TestException</span><span class="hljs-params">(String message)</span></span>{<br>        <span class="hljs-keyword">super</span>(message);   <span class="hljs-comment">//这里我们选择使用父类的带参构造，这个参数就是异常的原因</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>编译时异常只需要继承Exception就行了，编译时异常的子类有很多很多，仅仅是SE中就有700多个。</p><p><img src="https://s2.loli.net/2022/09/24/TzUu5Sk6NycB9An.png" alt="image-20220924202450589"></p><p>异常多种多样，不同的异常对应着不同的情况，比如在类型转换时出错那么就是类型转换异常，如果是使用一个值为null的变量调用方法，那么就会出现空指针异常。</p><p>运行时异常只需要继承RuntimeException就行了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RuntimeException</span></span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TestException</span><span class="hljs-params">(String message)</span></span>{<br>        <span class="hljs-keyword">super</span>(message);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>RuntimeException继承自Exception，Exception继承自Throwable：</p><p><img src="https://s2.loli.net/2022/09/24/RjzWnNDc6TZeSoJ.png" alt="image-20220924203130042"></p><p>运行时异常同同样也有很多，只不过运行时异常和编译型异常在使用时有一些不同，我们会在后面的学习中慢慢认识。</p><p>当然还有一种类型是Error，它是所有错误的父类，同样是继承自Throwable的。</p><h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>当别人调用我们的方法时，如果传入了错误的参数导致程序无法正常运行，这时我们就可以手动抛出一个异常来终止程序继续运行下去，同时告知上一级方法执行出现了问题：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{<br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"被除数不能为0"</span>);  <span class="hljs-comment">//使用throw关键字来抛出异常</span><br>    <span class="hljs-keyword">return</span> a / b;<br>}<br></code></pre></td></tr></tbody></table></figure><p>异常的抛出同样需要创建一个异常对象出来，我们抛出异常实际上就是将这个异常对象抛出，异常对象携带了我们抛出异常时的一些信息，比如是因为什么原因导致的异常，在RuntimeException的构造方法中我们可以写入原因。</p><p>当出现异常时：</p><p><img src="https://s2.loli.net/2022/09/24/Ttr4kZSyodKi3M8.png" alt="image-20220924200817314"></p><p>程序会终止，并且会打印栈追踪信息，因为各位小伙伴才初学，还不知道什么是栈，我们这里就简单介绍一下，实际上方法之间的调用是有层级关系的，而当异常发生时，方法调用的每一层都会在栈追踪信息中打印出来，比如这里有两个<code>at</code>，实际上就是在告诉我们程序运行到哪个位置时出现的异常，位于最上面的就是发生异常的最核心位置，我们代码的第15行。</p><p>并且这里会打印出当前抛出的异常类型和我们刚刚自定义异常信息。</p><p>注意，如果我们在方法中抛出了一个非运行时异常，那么必须告知函数的调用方我们会抛出某个异常，函数调用方必须要对抛出的这个异常进行对应的处理才可以：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{    <span class="hljs-comment">//使用throws关键字告知调用方此方法会抛出哪些异常，请调用方处理好</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"我是编译时异常！"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>注意，如果不同的分支条件会出现不同的异常，那么所有在方法中可能会抛出的异常都需要注明：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> <span class="hljs-keyword">throws</span> FileNotFoundException, ClassNotFoundException </span>{  <span class="hljs-comment">//多个异常使用逗号隔开</span><br>    <span class="hljs-keyword">if</span>(a == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileNotFoundException();<br>    <span class="hljs-keyword">else</span> <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassNotFoundException();<br>}<br></code></pre></td></tr></tbody></table></figure><p>当然，并不是只有非运行时异常可以像这样明确指出，运行时异常也可以，只不过不强制要求：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> <span class="hljs-keyword">throws</span> RuntimeException </span>{<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException();<br>}<br></code></pre></td></tr></tbody></table></figure><p>至于如何处理明确抛出的异常，我们会下一个部分中进行讲解。</p><p>最后再提一下，我们在重写方法时，如果父类中的方法表明了会抛出某个异常，只要重写的内容中不会抛出对应的异常我们可以直接省去：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Object();<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h3><p>当程序没有按照我们理想的样子运行而出现异常时（默认会交给JVM来处理，JVM发现任何异常都会立即终止程序运行，并在控制台打印栈追踪信息）现在我们希望能够自己处理出现的问题，让程序继续运行下去，就需要对异常进行捕获，比如：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span> {    <span class="hljs-comment">//使用try-catch语句进行异常捕获</span><br>        Object object = <span class="hljs-keyword">null</span>;<br>        object.toString();<br>    } <span class="hljs-keyword">catch</span> (NullPointerException e){   <span class="hljs-comment">//因为异常本身也是一个对象，catch中实际上就是用一个局部变量去接收异常</span><br><br>    }<br>    System.out.println(<span class="hljs-string">"程序继续正常运行！"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以将代码编写到<code>try</code>语句块中，只要是在这个范围内发生的异常，都可以被捕获，使用<code>catch</code>关键字对指定的异常进行捕获，这里我们捕获的是NullPointerException空指针异常：</p><p><img src="https://s2.loli.net/2022/09/24/7Ek5A46QHNKtWoJ.png" alt="image-20220924195434572"></p><p>可以看到，当我们捕获异常之后，程序可以继续正常运行，并不会像之前一样直接结束掉。</p><p>注意，catch中捕获的类型只能是Throwable的子类，也就是说要么是抛出的异常，要么是错误，不能是其他的任何类型。</p><p>我们可以在<code>catch</code>语句块中对捕获到的异常进行处理：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span> {<br>        Object object = <span class="hljs-keyword">null</span>;<br>        object.toString();<br>    } <span class="hljs-keyword">catch</span> (NullPointerException e){<br>        e.printStackTrace();   <span class="hljs-comment">//打印栈追踪信息</span><br>        System.out.println(<span class="hljs-string">"异常错误信息："</span>+e.getMessage());   <span class="hljs-comment">//获取异常的错误信息</span><br>    }<br>    System.out.println(<span class="hljs-string">"程序继续正常运行！"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/09/24/d15ns6hQblU8TAS.png" alt="image-20220924201405697"></p><p>如果某个方法明确指出会抛出哪些异常，除非抛出的异常是一个运行时异常，否则我们必须要使用try-catch语句块进行异常的捕获，不然就无法通过编译：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    test(<span class="hljs-number">10</span>);    <span class="hljs-comment">//必须要进行异常的捕获，否则报错</span><br>}<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> <span class="hljs-keyword">throws</span> IOException </span>{  <span class="hljs-comment">//明确会抛出IOException</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException();<br>}<br></code></pre></td></tr></tbody></table></figure><p>当然，如果我们确实不想在当前这个方法中进行处理，那么我们可以继续踢皮球，抛给上一级：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>{  <span class="hljs-comment">//继续编写throws往上一级抛</span><br>    test(<span class="hljs-number">10</span>);<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> <span class="hljs-keyword">throws</span> IOException </span>{<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException();<br>}<br></code></pre></td></tr></tbody></table></figure><p>注意，如果已经是主方法了，那么就相当于到顶层了，此时发生异常再往上抛出的话，就会直接交给JVM进行处理，默认会让整个程序终止并打印栈追踪信息。</p><p>注意，如果我们要捕获的异常，是某个异常的父类，那么当发生这个异常时，同样可以捕获到：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>{<br>    <span class="hljs-keyword">try</span> {<br>        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">1</span>];<br>        arr[<span class="hljs-number">1</span>] = <span class="hljs-number">100</span>;    <span class="hljs-comment">//这里发生的是数组越界异常，它是运行时异常的子类</span><br>    } <span class="hljs-keyword">catch</span> (RuntimeException e){  <span class="hljs-comment">//使用运行时异常同样可以捕获到</span><br>        System.out.println(<span class="hljs-string">"捕获到异常"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>当代码可能出现多种类型的异常时，我们希望能够分不同情况处理不同类型的异常，就可以使用多重异常捕获：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> {<br>  <span class="hljs-comment">//....</span><br>} <span class="hljs-keyword">catch</span> (NullPointerException e) {<br>            <br>} <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException e){<br><br>} <span class="hljs-keyword">catch</span> (RuntimeException e){<br>            <br>}<br></code></pre></td></tr></tbody></table></figure><p>但是要注意一下顺序：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> {<br>  <span class="hljs-comment">//....</span><br>} <span class="hljs-keyword">catch</span> (RuntimeException e){  <span class="hljs-comment">//父类型在前，会将子类的也捕获</span><br><br>} <span class="hljs-keyword">catch</span> (NullPointerException e) {   <span class="hljs-comment">//永远都不会被捕获</span><br><br>} <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException e){   <span class="hljs-comment">//永远都不会被捕获</span><br><br>}<br></code></pre></td></tr></tbody></table></figure><p>只不过这样写好像有点丑，我们也可以简写为：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> {<br>     <span class="hljs-comment">//....</span><br>} <span class="hljs-keyword">catch</span> (NullPointerException | IndexOutOfBoundsException e) {  <span class="hljs-comment">//用|隔开每种类型即可</span><br><br>}<br></code></pre></td></tr></tbody></table></figure><p>如果简写的话，那么发生这些异常的时候，都会采用统一的方式进行处理了。</p><p>最后，当我们希望，程序运行时，无论是否出现异常，都会在最后执行任务，可以交给<code>finally</code>语句块来处理：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> {<br>    <span class="hljs-comment">//....</span><br>}<span class="hljs-keyword">catch</span> (Exception e){<br>            <br>}<span class="hljs-keyword">finally</span> {<br>  System.out.println(<span class="hljs-string">"lbwnb"</span>);   <span class="hljs-comment">//无论是否出现异常，都会在最后执行</span><br>}<br></code></pre></td></tr></tbody></table></figure><p><code>try</code>语句块至少要配合<code>catch</code>或<code>finally</code>中的一个：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> {<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    a /= <span class="hljs-number">0</span>;<br>} <span class="hljs-keyword">finally</span> {  <span class="hljs-comment">//不捕获异常，程序会终止，但在最后依然会执行下面的内容</span><br>    System.out.println(<span class="hljs-string">"lbwnb"</span>); <br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>思考：</strong><code>try</code>、<code>catch</code>和<code>finally</code>执行顺序？</p><h3 id="断言表达式"><a href="#断言表达式" class="headerlink" title="断言表达式"></a>断言表达式</h3><p>我们可以使用断言表达式来对某些东西进行判断，如果判断失败会抛出错误，只不过默认情况下没有开启断言，我们需要在虚拟机参数中手动开启一下：</p><p><img src="https://s2.loli.net/2022/09/24/cAG8kY395fOuTLg.png" alt="image-20220924220327591"></p><p>开启断言之后，我们就可以开始使用了。</p><p>断言表达式需要使用到<code>assert</code>关键字，如果assert后面的表达式判断结果为false，将抛出AssertionError错误。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">assert</span> <span class="hljs-keyword">false</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>比如我们可以判断变量的值，如果大于10就抛出错误：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">assert</span> a &gt; <span class="hljs-number">10</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/09/24/12b6zRAL3evQ9ZB.png" alt="image-20220924220704026"></p><p>我们可以在表达式的后面添加错误信息：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">assert</span> a &gt; <span class="hljs-number">10</span> : <span class="hljs-string">"我是自定义的错误信息"</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>这样就会显示到错误后面了：</p><p><img src="https://s2.loli.net/2022/09/24/NaYk5pFiBPLXVIr.png" alt="image-20220924220813609"></p><p>断言表达式一般只用于测试，我们正常的程序中一般不会使用，这里只做了解就行了。</p><hr><h2 id="常用工具类介绍"><a href="#常用工具类介绍" class="headerlink" title="常用工具类介绍"></a>常用工具类介绍</h2><p>前面我们学习了包装类、数组和字符串，我们接着来看看常用的一些工具类。工具类就是专门为一些特定场景编写的，便于我们去使用的类，工具类一般都会内置大量的静态方法，我们可以通过类名直接使用。</p><h3 id="数学工具类"><a href="#数学工具类" class="headerlink" title="数学工具类"></a>数学工具类</h3><p>Java提供的运算符实际上只能进行一些在小学数学中出现的运算，但是如果我们想要进行乘方、三角函数之类的高级运算，就没有对应的运算符能够做到，而此时我们就可以使用数学工具类来完成。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>  <span class="hljs-comment">//Math也是java.lang包下的类，所以说默认就可以直接使用</span><br>    System.out.println(Math.pow(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>));   <span class="hljs-comment">//我们可以使用pow方法直接计算a的b次方</span><br>  <br>  Math.abs(-<span class="hljs-number">1</span>);    <span class="hljs-comment">//abs方法可以求绝对值</span><br>  Math.max(<span class="hljs-number">19</span>, <span class="hljs-number">20</span>);    <span class="hljs-comment">//快速取最大值</span><br>  Math.min(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>);   <span class="hljs-comment">//快速取最小值</span><br>  Math.sqrt(<span class="hljs-number">9</span>);    <span class="hljs-comment">//求一个数的算术平方根</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>当然，三角函数肯定也是安排上了的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Math.sin(Math.PI / <span class="hljs-number">2</span>);     <span class="hljs-comment">//求π/2的正弦值，这里我们可以使用预置的PI进行计算</span><br>Math.cos(Math.PI);       <span class="hljs-comment">//求π的余弦值</span><br>Math.tan(Math.PI / <span class="hljs-number">4</span>);    <span class="hljs-comment">//求π/4的正切值</span><br><br>Math.asin(<span class="hljs-number">1</span>);     <span class="hljs-comment">//三角函数的反函数也是有的，这里是求arcsin1的值</span><br>Math.acos(<span class="hljs-number">1</span>);<br>Math.atan(<span class="hljs-number">0</span>);<br></code></pre></td></tr></tbody></table></figure><p>可能在某些情况下，计算出来的浮点数会得到一个很奇怪的结果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    System.out.println(Math.sin(Math.PI));   <span class="hljs-comment">//计算 sinπ 的结果</span><br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/09/23/fZ6OVRejDXWSalC.png" alt="image-20220923231536032"></p><p>正常来说，sinπ的结果应该是0才对，为什么这里得到的是一个很奇怪的数？这个E是干嘛的，这其实是科学计数法的10，后面的数就是指数，上面的结果其实就是：</p><ul><li>$1.2246467991473532 \times 10^{-16}$</li></ul><p>其实这个数是非常接近于0，这是因为精度问题导致的，所以说实际上结果就是0。</p><p>我们也可以快速计算对数函数：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Math.log(Math.E);    <span class="hljs-comment">//e为底的对数函数，其实就是ln，我们可以直接使用Math中定义好的e</span><br>    Math.log10(<span class="hljs-number">100</span>);     <span class="hljs-comment">//10为底的对数函数</span><br>    <span class="hljs-comment">//利用换底公式，我们可以弄出来任何我们想求的对数函数</span><br>    <span class="hljs-keyword">double</span> a = Math.log(<span class="hljs-number">4</span>) / Math.log(<span class="hljs-number">2</span>);   <span class="hljs-comment">//这里是求以2为底4的对数，log(2)4 = ln4 / ln2</span><br>    System.out.println(a);<br>}<br></code></pre></td></tr></tbody></table></figure><p>还有一些比较特殊的计算：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Math.ceil(<span class="hljs-number">4.5</span>);    <span class="hljs-comment">//通过使用ceil来向上取整</span><br>    Math.floor(<span class="hljs-number">5.6</span>);   <span class="hljs-comment">//通过使用floor来向下取整</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>向上取整就是找一个大于当前数字的最小整数，向下取整就是砍掉小数部分。注意，如果是负数的话，向上取整就是去掉小数部分，向下取整就是找一个小于当前数字的最大整数。</p><p>这里我们再介绍一下随机数的生成，Java中想要生成一个随机数其实也很简单，我们需要使用Random类来生成（这个类时java.util包下的，需要手动导入才可以）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Random random = <span class="hljs-keyword">new</span> Random();   <span class="hljs-comment">//创建Random对象</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) {<br>        System.out.print(random.nextInt(<span class="hljs-number">100</span>)+<span class="hljs-string">" "</span>);  <span class="hljs-comment">//nextInt方法可以指定创建0 - x之内的随机数</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>结果为，可以看到确实是一堆随机数：</p><p><img src="https://s2.loli.net/2022/09/23/fM8J7zO2qHXhvst.png" alt="image-20220923234642670"></p><p>只不过，程序中的随机并不是真随机，而是根据某些东西计算出来的，只不过计算过程非常复杂，能够在一定程度上保证随机性（根据爱因斯坦理论，宏观物质世界不存在真随机，看似随机的事物只是现目前无法计算而已，唯物主义的公理之一就是任何事物都有因果关系）</p><h3 id="数组工具类"><a href="#数组工具类" class="headerlink" title="数组工具类"></a>数组工具类</h3><p>前面我们介绍了数组，但是我们发现，想要操作数组实在是有点麻烦，比如我们要打印一个数组，还得一个一个元素遍历才可以，那么有没有一个比较方便的方式去使用数组呢？我们可以使用数组工具类Arrays。</p><p>这个类也是<code>java.util</code>包下类，它用于便捷操作数组，比如我们想要打印数组，可以直接通过toString方法转换字符串：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>};<br>    System.out.println(Arrays.toString(arr));<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/09/23/fx61nKT7LjdMv5q.png" alt="image-20220923235747731"></p><p>是不是感觉非常方便？这样我们直接就可以打印数组了！</p><p>除了这个方法，它还支持将数组进行排序：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>};<br>    Arrays.sort(arr);    <span class="hljs-comment">//可以对数组进行排序，将所有的元素按照从小到大的顺序排放</span><br>    System.out.println(Arrays.toString(arr));<br>}<br></code></pre></td></tr></tbody></table></figure><p>感兴趣的小伙伴可以在数据结构与算法篇视频教程中了解多种多样的排序算法，这里的排序底层实现实际上用到了多种排序算法。</p><p>数组中的内容也可以快速进行填充：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>    Arrays.fill(arr, <span class="hljs-number">66</span>);<br>    System.out.println(Arrays.toString(arr));<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以快速地对一个数组进行拷贝：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};<br>    <span class="hljs-keyword">int</span>[] target = Arrays.copyOf(arr, <span class="hljs-number">5</span>);<br>    System.out.println(Arrays.toString(target));   <span class="hljs-comment">//拷贝数组的全部内容，并生成一个新的数组对象</span><br>    System.out.println(arr == target);<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};<br>    <span class="hljs-keyword">int</span>[] target = Arrays.copyOfRange(arr, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>);   <span class="hljs-comment">//也可以只拷贝某个范围内的内容</span><br>    System.out.println(Arrays.toString(target));<br>    System.out.println(arr == target);<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们也可以将一个数组中的内容拷贝到其他数组中：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};<br>    <span class="hljs-keyword">int</span>[] target = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>    System.arraycopy(arr, <span class="hljs-number">0</span>, target, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>);   <span class="hljs-comment">//使用System.arraycopy进行搬运</span><br>    System.out.println(Arrays.toString(target));<br>}<br></code></pre></td></tr></tbody></table></figure><p>对于一个有序的数组（从小到大排列）我们可以使用二分搜索快速找到对应的元素在哪个位置：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};<br>    System.out.println(Arrays.binarySearch(arr, <span class="hljs-number">5</span>));   <span class="hljs-comment">//二分搜索仅适用于有序数组</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>这里提到了二分搜索算法，我们会在后面的实战练习中进行讲解。</p><p>那要是现在我们使用的是多维数组呢？因为现在数组里面的每个元素就是一个数组，所以说toString会出现些问题：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span>[][] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]{{<span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>}, {<span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>}};<br>    System.out.println(Arrays.toString(array));<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/09/24/L2at7HJi3BKf6jF.png" alt="image-20220924114142785"></p><p>只不过别担心，Arrays也支持对多维数组进行处理：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span>[][] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]{{<span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>}, {<span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>}};<br>    System.out.println(Arrays.deepToString(array));    <span class="hljs-comment">//deepToString方法可以对多维数组进行打印</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>同样的，因为数组本身没有重写equals方法，所以说无法判断两个不同的数组对象中的每一个元素是否相同，Arrays也为一维数组和多维数组提供了相等判断的方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span>[][] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]{{<span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>}, {<span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>}};<br>    <span class="hljs-keyword">int</span>[][] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]{{<span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>}, {<span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>}};<br>    System.out.println(Arrays.equals(a, b));   <span class="hljs-comment">//equals仅适用于一维数组</span><br>    System.out.println(Arrays.deepEquals(a, b));   <span class="hljs-comment">//对于多维数组，需要使用deepEquals来进行深层次判断</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>这里肯定有小伙伴疑问了，不是说基本类型的数组不能转换为引用类型的数组吗？为什么这里的deepEquals接受的是<code>Object[]</code>也可以传入参数呢？这是因为现在是二维数组，二维数组每个元素都是一个数组，而数组本身的话就是一个引用类型了，所以说可以转换为Object类型，但是如果是一维数组的话，就报错：</p><p><img src="https://s2.loli.net/2022/09/24/ab94eNcJPERlOYA.png" alt="image-20220924115440998"></p><p>总体来说，这个工具类对于我们数组的使用还是很方便的。</p><hr><h2 id="实战练习"><a href="#实战练习" class="headerlink" title="实战练习"></a>实战练习</h2><p>到目前为止，关于面向对象相关的内容我们已经学习了非常多了，接着依然是练习题。</p><h3 id="冒泡排序算法"><a href="#冒泡排序算法" class="headerlink" title="冒泡排序算法"></a>冒泡排序算法</h3><p>有一个int数组，但是数组内的数据是打乱的，现在我们需要将数组中的数据按<strong>从小到大</strong>的顺序进行排列：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>};<br>}<br></code></pre></td></tr></tbody></table></figure><p>请你设计一个Java程序将这个数组中的元素按照顺序排列。</p><h3 id="二分搜索算法"><a href="#二分搜索算法" class="headerlink" title="二分搜索算法"></a>二分搜索算法</h3><p>现在有一个从小到大排序的数组，给你一个目标值<code>target</code>，现在我们想要找到这个值在数组中的对应下标，如果数组中没有这个数，请返回<code>-1</code>：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span>[] arr = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">15</span>};<br>    <span class="hljs-keyword">int</span> target = <span class="hljs-number">3</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>请你设计一个Java程序实现这个功能。</p><h3 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a>青蛙跳台阶问题</h3><p>现在一共有n个台阶，一只青蛙每次只能跳一阶或是两阶，那么一共有多少种跳到顶端的方案？</p><p>例如n=2，那么一共有两种方案，一次性跳两阶或是每次跳一阶。</p><p>现在请你设计一个Java程序，计算当台阶数为n的情况下，能够有多少种方案到达顶端。</p><h3 id="回文串判断"><a href="#回文串判断" class="headerlink" title="回文串判断"></a>回文串判断</h3><p>“回文串”是一个正读和反读都一样的字符串，请你实现一个Java程序，判断用户输入的字符串（仅出现英文字符）是否为“回文”串。</p><blockquote><p> ABCBA   就是一个回文串，因为正读反读都是一样的</p><p>ABCA   就不是一个回文串，因为反着读不一样</p></blockquote><h3 id="汉诺塔求解"><a href="#汉诺塔求解" class="headerlink" title="汉诺塔求解"></a>汉诺塔求解</h3><p>什么是汉诺塔？</p><blockquote><p><strong>汉诺塔</strong>（Tower of Hanoi），又称<strong>河内塔</strong>，是一个源于<a href="https://baike.baidu.com/item/%E5%8D%B0%E5%BA%A6/121904">印度</a>古老传说的<a href="https://baike.baidu.com/item/%E7%9B%8A%E6%99%BA%E7%8E%A9%E5%85%B7/223159">益智玩具</a>。<a href="https://baike.baidu.com/item/%E5%A4%A7%E6%A2%B5%E5%A4%A9/711550">大梵天</a>创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令<a href="https://baike.baidu.com/item/%E5%A9%86%E7%BD%97%E9%97%A8/1796550">婆罗门</a>把圆盘从下面开始</p><p><strong>按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</strong></p></blockquote><p><img src="https://s2.loli.net/2022/09/24/mMpDNwrKk6z3CIo.png" alt="img"></p><p>这三根柱子我们就依次命名为A、B、C，现在请你设计一个Java程序，计算N阶（n片圆盘）汉诺塔移动操作的每一步。</p>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/09/22/lmKBNFc5wPEgjaS.png&quot; alt=&quot;image-20220922170926093&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;面向对象高级篇&quot;&gt;&lt;a href=&quot;#面向对象高级篇&quot; class=&quot;headerlink&quot; title=&quot;面向对象高级篇&quot;&gt;&lt;/a&gt;面向对象高级篇&lt;/h1&gt;&lt;p&gt;经过前面的学习，我们已经了解了面向对象编程的大部分基础内容，这一部分，我们将继续探索面向对象编程过程中一些常用的东西。&lt;/p&gt;
&lt;h2 id=&quot;基本类型包装类&quot;&gt;&lt;a href=&quot;#基本类型包装类&quot; class=&quot;headerlink&quot; title=&quot;基本类型包装类&quot;&gt;&lt;/a&gt;基本类型包装类&lt;/h2&gt;&lt;p&gt;Java并不是纯面向对象的语言，虽然Java语言是一个面向对象的语言，但是Java中的基本数据类型却不是面向对象的。Java中的基本类型，如果想通过对象的形式去使用他们，Java提供的基本类型包装类，使得Java能够更好的体现面向对象的思想，同时也使得基本类型能够支持对象操作！&lt;/p&gt;
&lt;h3 id=&quot;包装类介绍&quot;&gt;&lt;a href=&quot;#包装类介绍&quot; class=&quot;headerlink&quot; title=&quot;包装类介绍&quot;&gt;&lt;/a&gt;包装类介绍&lt;/h3&gt;&lt;p&gt;所有的包装类层次结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/09/22/mulb5VdvBLiWNe2.png&quot; alt=&quot;5c3a6a27-6370-4c60-9bbc-8039e11e752d&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中能够表示数字的基本类型包装类，继承自Number类，对应关系如下表：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://xiaofanshutu.github.io/posts/0.html"/>
    <id>https://xiaofanshutu.github.io/posts/0.html</id>
    <published>2025-09-07T23:26:13.327Z</published>
    <updated>2025-09-07T23:28:25.711Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://s2.loli.net/2022/09/16/XZGlpWmeO7T8ft2.png" alt="image-20220916142151904"></p><h1 id="新手入门篇"><a href="#新手入门篇" class="headerlink" title="新手入门篇"></a>新手入门篇</h1><p><strong>注意：</strong>开始学习JavaSE之前建议学习的前置课程《C语言程序设计》《数据结构》《操作系统》《计算机组成原理》</p><p>欢迎各位小伙伴来到JavaSE视频教程，期待与各位小伙伴共度这一旅程！视频中所有的文档、资料，都可以直接在视频下方简介中找到，视频非培训机构出品，纯个人录制，不需要加任何公众号、小程序，直接自取即可。</p><p>教程开始之前，提醒各位小伙伴：</p><ul><li>如果你对某样东西不熟悉，请务必保证跟视频中使用一模一样的环境、一模一样的操作方式去使用，不要自作主张，否则出现某些奇怪的问题又不知道怎么办，就会浪费很多时间。</li><li>视频依然是基于Java 8进行讲解，不要自己去安装一个其他的版本，想要了解新版本特性可以在另一个视频里面观看。</li><li>在学习过程中，尽可能避免出现中文文件夹，包括后面的环境安装、项目创建，都尽量不要放在中文路径下（因为使用中文常常出现奇奇怪怪的问题）建议使用对应的英文单词代替，或者是用拼音都可以，最好只出现英文字母和数字。</li><li>本系列教程使用 IDEA社区版（免费）即可，不需要申请终极版。</li></ul><p>如果觉得本视频对你有帮助，请一键三连支持一下UP主！</p><h2 id="计算机思维导论"><a href="#计算机思维导论" class="headerlink" title="计算机思维导论"></a>计算机思维导论</h2><p>计算机自1946年问世以来，几乎改变了整个世界。</p><p>现在我们可以通过电脑来做很多事情，比如我们常常听到的什么人工智能、电子竞技、大数据等等，都和计算机息息相关，包括我们现在的手机、平板等智能设备，也是计算机转变而来的。</p><p>也许你没有接触过计算机，也许你唯一接触计算机就是用来打游戏，也有可能你曾经捣鼓过计算机，在学习Java之前，先让我们来了解一下计算机的世界。</p><h3 id="计算机的世界"><a href="#计算机的世界" class="headerlink" title="计算机的世界"></a>计算机的世界</h3><p><strong>注意：</strong>如果你已经完成了《C语言程序设计》视频教程的学习，可以直接跳过此部分。</p><p>计算机虽然名字听着很高级，不过它也是由一个个简单电路组成的。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rd1x1rtgj21dy0cw74r.jpg" alt="img"></p><p>这是我们在初中就学习过的电路图，不过这种电路太过简单，只能完成一些很基础的的操作，比如点亮小灯泡等。</p><p>很明显想要实现计算机怎么高级的运算机器，肯定是做不到的，这时我们就需要引入更加强大的数字电路了。</p><blockquote><p>用数字信号完成对数字量进行<a href="https://baike.baidu.com/item/%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97/3118202">算术运算</a>和<a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97/7224729">逻辑运算</a>的电路称为数字电路，或数字系统。由于它具有逻辑运算和逻辑处理功能，所以又称数字逻辑电路。现代的数字电路由半导体工艺制成的若干数字集成器件构造而成。逻辑门是数字逻辑电路的<a href="https://baike.baidu.com/item/%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83/5246264">基本单元</a>。</p></blockquote><p>计算机专业一般会在大一开放《数字电路》这门课程，会对计算机底层的数字电路实现原理进行详细介绍。</p><p>数字电路引入了逻辑判断，我们来看看简单的数字电路：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rdj1916aj21iq0dygm4.jpg" alt="img"></p><p>数字电路中，用电压的高低来区分出两种信号，低电压表示0，高电压表示1，由于只能通过这种方式表示出两种类型的信号，所以计算机采用的是二进制。</p><blockquote><p><a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6/361457">二进制</a>是计算技术中广泛采用的一种<a href="https://baike.baidu.com/item/%E6%95%B0%E5%88%B6/217113">数制</a>。二进制数据是用0和1两个数码来表示的数。它的<a href="https://baike.baidu.com/item/%E5%9F%BA%E6%95%B0/4260">基数</a>为2，进位规则是“逢二进一”，借位规则是“借一当二”。</p><p>比如我们一般采用的都是十进制表示，比如9再继续加1的话，就需要进位了，变成10，在二进制中，因为只有0和1，所以当1继续加1时，就需要进位了，就变成10了（注意这不是十，读成一零就行了）</p></blockquote><p>当然，仅仅有两种信号还不够，我们还需要逻辑门来辅助我们完成更多的计算，最基本的逻辑关系是与、或、非，而逻辑门就有相应的是<a href="https://baike.baidu.com/item/%E4%B8%8E%E9%97%A8">与门</a>、<a href="https://baike.baidu.com/item/%E6%88%96%E9%97%A8">或门</a>和<a href="https://baike.baidu.com/item/%E9%9D%9E%E9%97%A8">非门</a>，可以用电阻、电容、二极管、三极管等分立原件构成（具体咋构成的咱这里就不说了）</p><p>比如与操作，因为只有两种类型，我们一般将1表示为真，0表示为假，与操作（用&amp;表示）要求两个数参与进来，比如：</p><ul><li><p>1 &amp; 1 = 1   必须两边都是真，结果才为真。</p></li><li><p>1 &amp; 0 = 0   两边任意一个或者都不是真，结果为假。</p></li></ul><p>或运算（用 | 表示）：</p><ul><li><p>1 | 0 = 1   两边只要有一个为真，结果就为真</p></li><li><p>0 | 0 = 0   两边同时为假，结果才是假</p></li></ul><p>非运算实际上就是取反操作（可以是 ! 表示）</p><ul><li><p>!1 = 0</p></li><li><p>!0 = 1   非运算会将真变成假，假变成真</p></li></ul><p>有了这些运算之后，我们的电路不仅仅可以实现计算，也可以实现各种各样的逻辑判断，最终才能发展成我们的计算机。</p><p>前面我们大概介绍一下计算机的底层操作原理，接着我们来看看计算机的基本组成。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2reca0cgoj20x60b40uu.jpg" alt="img"></p><p>相信各位熟知的计算机都是一个屏幕+一个主机的形式，然后配上我们的键盘鼠标，就可以开始使用了，但是实际上标准的计算机结构并没有这么简单，我们来看看：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2reersjdmj21k20fqdhl.jpg" alt="img"></p><p>我们电脑最核心的部件，当属CPU，因为几乎所有的运算都是依靠CPU进行（各种各样的计算电路已经在CPU中安排好了，我们只需要发送对应的指令就可以进行对应的运算），它就像我们人的大脑一样，有了大脑才能进行思考。不过光有大脑还不行，还要有一些其他的部分来辅助工作，比如我们想向电脑里面打字，那么就需要连接一个键盘才能输入，我们想要点击桌面上的图标，那么就需要一个鼠标来操作光标，这些都是输入设备。我们的电脑开机之后显示器上会显示出画面，实际上显示器就是输出设备。</p><p>当然除了这些内容之外，我们的电脑还需要内存来保存运行时的一些数据，以及外存来保存文件（比如硬盘）等。我们常说的iPhone14 512G，这个512G并不是指的内存，而是指的外存，准确的说是用于存放文件硬盘大小，而真正的内存是我们常说的4G/6G/8G运行内存，内存的速度远高于外存的速度，所以1G内存的价格远超1G硬盘的价格。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2riw9u06uj21bs0b4jso.jpg" alt="img"></p><p>计算机包括五大部件：运算器、控制器、存储器、输入和输出设备。有了这一套完整的硬件环境，我们的电脑才算是有了一个完整的身体。</p><h3 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h3><p><strong>注意：</strong>如果你已经完成了《C语言程序设计》视频教程的学习，可以直接跳过此部分。</p><p>前面我们了解了一下计算机的大致原理和组成结构，但是光有这一套硬件可不行，如何让这一套硬件按照我们想要的方式运作起来，也是非常重要的，这时我们就需要介绍操作系统了。</p><blockquote><p>操作系统（operating system，简称OS）是管理<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/5459592">计算机硬件</a>与<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6/12053">软件</a>资源的<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F/3220205">计算机程序</a>。操作系统需要处理如管理与<a href="https://baike.baidu.com/item/%E9%85%8D%E7%BD%AE/2394679">配置</a><a href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98/103614">内存</a>、决定<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90/974435">系统资源</a>供需的优先次序、控制<a href="https://baike.baidu.com/item/%E8%BE%93%E5%85%A5%E8%AE%BE%E5%A4%87/10823368">输入设备</a>与<a href="https://baike.baidu.com/item/%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87/10823333">输出设备</a>、操作网络与管理<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/4827215">文件系统</a>等基本事务。操作系统也提供一个让用户与系统<a href="https://baike.baidu.com/item/%E4%BA%A4%E4%BA%92/6964417">交互</a>操作的界面。</p><p>一般在计算机专业大二，会开放《操作系统》课程，会详细讲解操作系统的底层运作机制和调度。</p></blockquote><p>一般我们电脑上都安装了Windows操作系统（苹果笔记本安装的是MacOS操作系统），现在主流的电脑都已经预装Windows11了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rjnis7lkj21ew0e041a.jpg" alt="img"></p><p>有了操作系统，我们的电脑才能真正运行起来，我们就可以轻松地通过键盘和鼠标来操作电脑了。</p><p>不过操作系统最开始并不是图形化界面，它类似于Windows中的命令提示符：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rkezow9dj21v60ew40f.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rkjitqqnj21kc08475e.jpg" alt="img"></p><p>没有什么图标这些概念，只有一个简简单单的黑框让我们进行操作，通过输入命令来进行一些简单的使用，程序的运行结果也会在黑框框（命令行）中打印出来，不过虽然仅仅是一个黑框，但是能运行的程序可是非常非常多的，只需要运行我们编写好的程序，就能完成各种各样复杂的计算任务，并且计算机的计算速度远超我们的人脑。</p><blockquote><p> 中国超级计算机系统天河二号，计算速度达到每秒5.49亿亿次。</p></blockquote><p>当然，除了我们常见的Windows和MacOS系统之外，还有我们以后需要经常打交道的Linux操作系统，这种操作系统是开源的，意思是所有的人都可以拿到源代码进行修改，于是就出现了很多发行版：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rkm3bo7sj21gk0b4dh3.jpg" alt="img"></p><p>这些发行版有带图形化界面的，也有不带图形化界面的，不带图形化界面的Linux将是我们以后学习的重点。</p><p>不同操作系统之间的软件并不是通用的，比如Windows下我们的软件一般是.exe后缀名称，而MacOS下则不是，并且也无法直接运行.exe文件，这是因为不同操作系统的具体实现会存在一些不同，程序编译（我们之后会介绍到）之后的格式也会不同，所以是无法做到软件通用的。</p><p>正是因为有了操作系统，才能够组织我们计算机的底层硬件（包括CPU、内存、输入输出设备等）进行有序工作，没有操作系统电脑就如同一堆废铁，只有躯壳没有灵魂。</p><h3 id="计算机编程语言"><a href="#计算机编程语言" class="headerlink" title="计算机编程语言"></a>计算机编程语言</h3><p><strong>注意：</strong>如果你已经完成了《C语言程序设计》视频教程的学习，可以直接跳过此部分。</p><p>现在我们大致了解了我们的电脑的运作原理，实际上是一套完整的硬件+一个成形的操作系统共同存在的。接着我们就可以开始了解一下计算机的编程语言了。我们前面介绍的操作系统也是由编程语言写出来的，操作系统本身也算是一个软件。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rl228014j21eq0a2gnf.jpg" alt="img"></p><p>那么操作系统是如何让底层硬件进行工作的呢？实际上就是通过向CPU发送指令来完成的。</p><blockquote><p>计算机指令就是指挥机器工作的指示和命令，程序就是一系列按一定顺序排列的指令，执行程序的过程就是计算机的工作过程。指令集，就是CPU中用来计算和控制计算机系统的一套指令的集合，而每一种新型的CPU在设计时就规定了一系列与其他硬件电路相配合的指令系统。而指令集的先进与否，也关系到CPU的性能发挥，它也是CPU性能体现的一个重要标志。</p></blockquote><p>我们电脑中的CPU有多种多样的，不同的CPU之间可能也会存在不同的架构，比如现在最常用的是x86架构，还有我们手机平板这样的移动设备使用的arm架构，不同的架构指令集也会有不同。</p><p>我们知道，计算机底层硬件都是采用的0和1这样的二进制表示，所以指令也是一样的，比如（这里随便写的）：</p><ul><li><p>000001  -  代表开机</p></li><li><p>000010  -  代表关机</p></li><li><p>000011  -  代表进行加法运算</p></li></ul><p>当我们通过电路发送给CPU这样的二进制指令，CPU就能够根据我们的指令执行对应的任务，而我们编写的程序保存在硬盘中也是这样的二进制形式，我们只需要将这些指令组织好，按照我们的思路一条一条执行对应的命令，就能够让计算机计算任何我们需要的内容了，这其实就是机器语言。</p><p>不过随着时代的进步，指令集越来越大，CPU支持的运算类型也越来越多，这样的纯二进制编写实在是太累了，并且越来越多的命令我们根本记不住，于是就有了汇编语言。汇编语言将这些二进制的操作码通过助记符来替换：</p><ul><li><p>MOV  传送字或字节。</p></li><li><p>MOVSX  先符号扩展,再传送。</p></li><li><p>MOVZX  先零扩展,再传送。</p></li><li><p>PUSH  把字压入堆栈。</p></li></ul><p>把这些原有的二进制命令通过一个单词来代替，这样是不是就好记多了，在程序编写完成后，我们只需要最后将这些单词转换回二进制指令就可以了，这也是早期出现的低级编程语言。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rlmjqp3dj217e09agmz.jpg" alt="img"></p><p>不过虽然通过这些助记符就能够很轻松地记住命令，但是还是不够方便，因为可能我们的程序需要完成一个很庞大的任务，但是如果还是这样一条一条指令进行编写，是不是太慢了点，有时候可能做一个简单的计算，都需要好几条指令来完成。于是，高级编程语言——C语言，终于诞生了。</p><blockquote><p>C语言诞生于美国的<a href="https://baike.baidu.com/item/%E8%B4%9D%E5%B0%94%E5%AE%9E%E9%AA%8C%E5%AE%A4/686816">贝尔实验室</a>，由<a href="https://baike.baidu.com/item/%E4%B8%B9%E5%B0%BC%E6%96%AF%C2%B7%E9%87%8C%E5%A5%87/7267171">丹尼斯·里奇</a>（Dennis MacAlistair Ritchie）以肯尼斯·蓝·汤普森（Kenneth Lane Thompson）设计的<a href="https://baike.baidu.com/item/B%E8%AF%AD%E8%A8%80/1845842">B语言</a>为基础发展而来，在它的主体设计完成后，汤普森和里奇用它完全重写了UNIX操作系统，且随着UNIX操作系统的发展，C语言也得到了不断的完善。</p></blockquote><p>高级语言不同于低级语言，低级语言的主要操作对象是指令本身，而高级语言却更加符合我们人脑的认知，更像是通过我们人的思维，去告诉计算机你需要做什么，包括语法也会更加的简单易懂。下面是一段简单的C语言代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>  <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;   <span class="hljs-comment">//定义一个a等于10</span><br>  <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;   <span class="hljs-comment">//定义一个b等于10</span><br>  <span class="hljs-keyword">int</span> c = a + b;   <span class="hljs-comment">//语义非常明确，c就是a加上b计算出来的结果。</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>不过现在看不懂没关系，我们后面慢慢学。</p><p>C语言虽然支持按照我们更容易理解的方式去进行编程，但是最后还是会编译成汇编指令最后变成计算机可以直接执行的指令，不过具体的编译过程，我们不需要再关心了，我们只需要去写就可以了，而对我们代码进行编译的东西，称为编译器。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2uzn81nwsj21qk07mdhd.jpg" alt="img"></p><p>当然，除了C语言之外，还有很多其他的高级语言，比如Java、Python、C#、PHP等等，相比其他编程语言，C算是比较古老的一种了，但是时隔多年直至今日，其他编程语言也依然无法撼动它的王者地位：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rlw7fvhmj20xo0b0wf4.jpg" alt="img"></p><p>可以看到在2021年9月，依然排在编程语言排行榜的<strong>第一名</strong>（Python和Java紧随其后），可见这门语言是多么的不可撼动，很多操作系统、高级编程语言底层实现，几乎都是依靠C语言去编写的（包括Java的底层也是C/C++实现的）所以学习这一门语言，对于理工科尤其是计算机专业极为重要，学好C语言你甚至可以融汇贯通到其他语言，学起来也会轻松很多。</p><h3 id="走进Java语言"><a href="#走进Java语言" class="headerlink" title="走进Java语言"></a>走进Java语言</h3><p>前面我们介绍了C语言，它实际上就是通过编译，将我们可以看懂的代码，翻译为计算机能够直接执行的指令，这样计算机就可以按照我们想要的方式去进行计算了。当然，除了C语言之外，也有其他的语言，比如近几年也很火的Python，它跟C语言不同，它并不会先进行编译，而是直接交给解释器解释执行：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">print(<span class="hljs-string">"Hello World!"</span>)<br></code></pre></td></tr></tbody></table></figure><p><img src="https://s2.loli.net/2022/09/16/xAe9TspMDtlz8SE.png" alt="image-20220916150119407"></p><p>可见，这种方式也可以让计算机按照我们的想法去进行工作。</p><p>一般来说，编程语言就分为两大类：</p><ul><li><strong>编译型语言：</strong>需要先编译为计算机可以直接执行的命令才可以运行。优点是计算机直接运行，性能高；缺点是与平台密切相关，在一种操作系统上编译的程序，无法在其他非同类操作系统上运行，比如Windows下的exe程序在Mac上就无法运行。</li><li><strong>解释型语言：</strong>只需要通过解释器代为执行即可，不需要进行编译。优点是可以跨平台，因为解释是解释器的事情，只需要在各个平台上安装对应的解释器，代码不需要任何修改就可以直接运行；缺点是需要依靠解释器解释执行，效率肯定没直接编译成机器指令运行的快，并且会产生额外的资源占用。</li></ul><p><img src="https://s2.loli.net/2022/09/16/phfUjyuXLIbR3gJ.png" alt="image-20220916151925672"></p><p>那么我们来看看我们今天要介绍的主角，Java语言（Java之父：James Gosling，詹姆斯·高斯林）</p><blockquote><p>Write Once, Run Anywhere.</p></blockquote><p>这是Java语言的标语，它的目标很明确：一次编写，到处运行，它旨在打破平台的限制，让Java语言可以运行在任何平台上，并且不需要重新编译，实现跨平台运行。</p><p>Java自1995年正式推出以来，已经度过了快28个春秋，而基于Java语言，我们的生活中也有了各种各样的应用：</p><p><img src="https://s2.loli.net/2022/09/16/8SWeCjp6M4ufBk2.png" alt="image-20220916151604563"></p><ul><li>诺基亚手机上的很多游戏都是使用Java编写的。</li><li>安卓系统中的各种应用程序也是使用Java编写的。</li><li>著名沙盒游戏《Minecraft》也有对应的Java版本，得益于Java跨平台特性，无论在什么操作系统上都可以玩到这款游戏。</li><li>…</li></ul><p>（有关Java的详细发展历程，可以参考《Java核心技术·卷I》第一章）</p><p>可见，Java实际上早已在我们生活中的各个地方扎根。那么，Java语言是什么样的一个运行机制呢？</p><p>实际上我们的Java程序也是需要进行编译才可以运行的，这一点与C语言是一样的，Java程序编译之后会变成<code>.class</code>结尾的二进制文件：</p><p><img src="https://s2.loli.net/2022/09/16/5z2OWQb3B9AhwSZ.png" alt="image-20220916153102763"></p><p>不过不同的是，这种二进制文件计算机并不能直接运行，而是需要交给JVM（Java虚拟机）执行。</p><p><img src="https://s2.loli.net/2022/09/16/6HnkcSIfPdVZEpM.png" alt="image-20220916152514450"></p><p>JVM是个什么东西呢？简单来说，它就像我们前面介绍的解释器一样，我们可以将编译完成的<code>.class</code>文件直接交给JVM去运行，而程序中要做的事情，也都是由它来告诉计算机该如何去执行。</p><p>在不同的操作系统下，都有着对应的JVM实现，我们只需要安装好就可以了，而我们程序员只需要将Java程序编译为<code>.class</code>文件就可以直接交给JVM运行，无论是什么操作系统，JVM都采用的同一套标准读取和执行<code>.class</code>文件，所以说我们编译之后，在任何平台都可以运行，实现跨平台。</p><p>由于Java又需要编译同时还需要依靠JVM解释执行，所以说Java<strong>既是编译型语言，也是解释型语言。</strong></p><p>Java分为很多个版本：</p><ul><li><strong>JavaSE：</strong>是我们本教程的主要学习目标，它是标准版的Java，也是整个Java的最核心内容，在开始后续课程之前，这是我们不得不越过的一道坎，这个阶段一定要认真扎实地将Java学好，不然到了后面的高级部分，会很头疼。</li><li><strong>JavaME：</strong>微缩版Java，已经基本没人用了。</li><li><strong>JavaEE：</strong>企业级Java，比如网站开发，它是JavaSE阶段之后的主要学习方向。</li></ul><p>从下节课开始，我们就正式地进行Java环境的安装和IDE的使用学习。</p><hr><h2 id="环境安装与IDE使用"><a href="#环境安装与IDE使用" class="headerlink" title="环境安装与IDE使用"></a>环境安装与IDE使用</h2><p>前面我们介绍了Java语言，以及其本身的一些性质，这一部分我们就开始进行学习环境安装（这一部分请务必跟着操作，不要自作主张地去操作，一开始就出问题其实是最劝退新手的）</p><h3 id="JDK下载与安装"><a href="#JDK下载与安装" class="headerlink" title="JDK下载与安装"></a>JDK下载与安装</h3><p>首先我们来介绍一下JDK和JRE，各位小伙伴一定要能够区分这两者才可以。</p><ul><li><strong>JRE（Java Runtime Environment）</strong>：Java的运行环境，安装了运行环境之后，Java程序才可以运行，一般不做开发，只是需要运行Java程序直接安装JRE即可。</li><li><strong>JDK（Java Development Kit）</strong>：包含JRE，并且还附带了大量开发者工具，我们学习Java程序开发就使用JDK即可。</li></ul><p>它们的关系如下：</p><p><img src="https://s2.loli.net/2022/09/16/MpGWrh5xZdI3bCJ.png" alt="image-20220916154906732"></p><p>那么现在我们就去下载JDK吧，这里推荐安装免费的ZuluJDK：<a href="https://www.azul.com/downloads/?version=java-8-lts&amp;package=jdk">https://www.azul.com/downloads/?version=java-8-lts&amp;package=jdk</a></p><p>在这里选择自己的操作系统对应的安装包：</p><p><img src="https://s2.loli.net/2022/09/16/thaGoKI8pXA7Vl6.png" alt="image-20220916155142546"></p><p>比如Windows下，我们就选择<code>.msi</code>的安装包即可（MacOS、Linux下同样选择对应的即可）</p><p><img src="https://s2.loli.net/2022/09/16/vjc62OFaqmAegCh.png" alt="image-20220916155242814"></p><p>下载完成后，我们直接双击安装：</p><p><img src="https://s2.loli.net/2022/09/16/Loi3Ru7FAWHP6vN.png" alt="image-20220916160027645"></p><p><strong>注意，这里不建议各位小伙伴去修改安装的位置！</strong>新手只建议安装到默认位置（不要总担心C盘不够，该装的还是要装，尤其是这种环境，实在装不下就去将其他磁盘的空间分到C盘一部分）如果是因为没有安装到默认位置出现了任何问题，你要是找不到大佬问的话，又得重新来一遍，就很麻烦。</p><p>剩下的我们只需要一路点击Next即可，安装完成之后，我们打开CMD命令窗口（MacOS下直接打开“终端”）来验证一下（要打开CMD命令窗口，Windows11可以直接在下面的搜索框搜索cmd即可，或者直接在文件资源管理器路径栏输入cmd也可以）</p><p>我们直接输入java命令即可：</p><p><img src="https://s2.loli.net/2022/09/16/ROD3vkzwT8yFqrc.png" alt="image-20220916160756046"></p><p>如果能够直接输出内容，说明环境已经安装成功了，正常情况下已经配置好了，我们不需要手动去配置什么环境变量，所以说安装好就别管了。</p><p>输入<code>java -version</code>可以查看当前安装的JDK版本：</p><p><img src="https://s2.loli.net/2022/09/16/cPpCTOf9zZsWSw8.png" alt="image-20220916161050161"></p><p>只要是1.8.0就没问题了，后面的小版本号可能你们会比我的还要新。</p><p>这样我们就完成了Java环境的安装，我们可以来体验一下编写并且编译运行一个简单的Java程序，我们新建一个文本文档，命名为<code>Main.txt</code>（如果没有显示后缀名，需要在文件资源管理器中开启一下）然后用记事本打开，输入以下内容：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>{<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>{<br>System.out.println(<span class="hljs-string">"Hello World!"</span>);<br>}<br>}<br></code></pre></td></tr></tbody></table></figure><p>现在看不懂没关系，直接用就行，我们后面会一点一点讲解的。</p><p>编辑好之后，保存退出，接着我们将文件的后缀名称修改为<code>.java</code>这是Java源程序文件的后缀名称：</p><p><img src="https://s2.loli.net/2022/09/16/MAPh4aLSwHuRNlU.png" alt="image-20220916161607822"></p><p>此时我们打开CMD，注意要先进入到对应的路径下，比如我们现在的路径：</p><p><img src="https://s2.loli.net/2022/09/16/8A4oq7XdeLthpmg.png" alt="image-20220916161720722"></p><p>我们使用<code>cd</code>命令先进入到这个目录下：</p><p><img src="https://s2.loli.net/2022/09/16/HifR7pVSmqbP4Kh.png" alt="image-20220916161802753"></p><p>要编译一个Java程序，我们需要使用<code>javac</code>命令来进行：</p><p><img src="https://s2.loli.net/2022/09/16/IPofZRshyuwgciU.png" alt="image-20220916161857278"></p><p>执行后，可以看到目录下多出来了一个<code>.class</code>文件：</p><p><img src="https://s2.loli.net/2022/09/16/UdEJQL6WvIBFXf1.png" alt="image-20220916161923814"></p><p>这样我们就成功编译了一个Java程序，然后我们就可以将其交给JVM运行了，我们直接使用<code>java</code>命令即可：</p><p><img src="https://s2.loli.net/2022/09/16/esLwPFcOj87MrWo.png" alt="image-20220916162048405"></p><p>注意不要加上后缀名称，直接输入文件名字即可，可以看到打印了一个 Hello World! 字样，我们的第一个Java程序就可以运行了。</p><h3 id="IDEA安装与使用"><a href="#IDEA安装与使用" class="headerlink" title="IDEA安装与使用"></a>IDEA安装与使用</h3><p>前面我们介绍了JDK开发环境的安装以及成功编译运行了我们的第一个Java程序。</p><p>但是我们发现，如果我们以后都使用记事本来进行Java程序开发的话，是不是效率太低了点？我们还要先编辑，然后要改后缀，还要敲命令来编译，有没有更加方便一点的写代码的工具呢？这里我们要介绍的是：<strong>IntelliJ IDEA</strong>（这里不推荐各位小伙伴使用Eclipse，因为操作上没有IDEA这么友好）</p><p>IDEA准确来说是一个集成开发环境（IDE），它集成了大量的开发工具，编写代码的错误检测、代码提示、一键完成编译运行等，非常方便。</p><p>下载地址：<a href="https://www.jetbrains.com.cn/idea/">IntelliJ IDEA：JetBrains 功能强大、符合人体工程学的 Java IDE</a>（如果你之前学习C语言程序设计篇使用过CLion，你会发现界面一模一样，这样就能方便你快速上手）</p><p><img src="https://s2.loli.net/2022/09/16/UfIQzAXBS7TePm9.png" alt="image-20220916162544360"></p><p>我们直接点击下载即可：</p><p><img src="https://s2.loli.net/2022/09/16/sifjSGwLxYhHgKR.png" alt="image-20220916162830260"></p><p>这个软件本身是付费的，比较贵，而且最近还涨价了，不过这里我们直接下载面的社区版本就行了（JavaSE学习阶段不需要终极版，但是建议有条件的还是申请一个，因为后面JavaWeb开始就需要终极版了，学生和教师可以直接免费申请一年的使用许可，并且每个学期都可以续一年）</p><p>下载好之后，直接按照即可，这个不强制要求安装到C盘，自己随意，但是注意路径中不要出现中文！</p><p><img src="https://s2.loli.net/2022/09/16/jd64AxEfmQXWTNl.png" alt="image-20220916163329410"></p><p>这里勾选一下创建桌面快捷方式就行：</p><p><img src="https://s2.loli.net/2022/09/16/buv9QmapGCENcXn.png" alt="image-20220916163401880"></p><p>安装完成后，我们直接打开就可以了：</p><p><img src="https://s2.loli.net/2022/09/16/rihpxBbQz9jlZWU.png" alt="image-20220916163726690"></p><p>此时界面是全英文，如果各位小伙伴看得惯，可以直接使用全英文的界面（使用英文界面可以认识更多的专业术语词汇，但是可能看起来没中文那么直观，而且IDEA本身功能就比较多，英语不好的小伙伴就很头疼）这里还是建议英语不好的小伙伴使用中文界面，要使用中文只需要安装中文插件即可：</p><p><img src="https://s2.loli.net/2022/09/16/tW4UPnpaFsfDB9r.png" alt="image-20220916164025426"></p><p>我们打开Plugins插件这一栏，然后直接在插件市场里面搜索Chinese，可以找到一个中文语言包的插件，我们直接Install安装即可，安装完成后点击重启，现在就是中文页面了：</p><p><img src="https://s2.loli.net/2022/09/16/UFka83Se97COoJK.png" alt="image-20220916164235648"></p><p>如果各位小伙伴不喜欢黑色主题，也可以修改为白色主题，只需要在自定义中进行修改即可，一共四种主题。</p><p>如果你之前使用过其他IDE编写代码，这里还支持按键映射（采用其他IDE的快捷键方案）有需要的可以自己修改一下：</p><p><img src="https://s2.loli.net/2022/09/16/3wbt7QhZmq9EKgY.png" alt="image-20220916164415447"></p><p>接下来，我们来看看如何使用IDEA编写Java程序，IDEA是以项目的形式对一个Java程序进行管理的，所以说我们直接创建一个新的项目，点击新建项目：</p><p><img src="https://s2.loli.net/2022/09/16/4qvjxmozBaJgOuH.png" alt="image-20220916164906998"></p><p>此时来到创建页面：</p><p><img src="https://s2.loli.net/2022/09/16/ldzGSmYBkr7uO3c.png" alt="image-20220916164941663"></p><ul><li><strong>名称：</strong>你的Java项目的名称，随便起就行，尽量只带英文字母和数字，不要出现特殊字符和中文。</li><li><strong>位置：</strong>项目的存放位置，可以自己根据情况修改，同样的，路径中不要出现中文。</li><li><strong>语言：</strong>IDEA支持编写其他语言的项目，但是这里我们直接选择Java就行了。</li><li><strong>构建系统：</strong>在JavaSE阶段一律选择IntelliJ就行了，Maven我们会在JavaWeb之后进行讲解，Gradle会在安卓开发教程中介绍。</li><li><strong>JDK：</strong>就是我们之前安装好的JDK，如果是默认路径安装，这里会自动识别（所以说不要随便去改，不然这些地方就很麻烦）</li></ul><p>当然，如果JDK这里没有自动识别到，那么就手动添加一下：</p><p><img src="https://s2.loli.net/2022/09/16/fDJKB6M3TlWizoQ.png" alt="image-20220916165351016"></p><p>没问题之后，我们直接创建项目：</p><p><img src="https://s2.loli.net/2022/09/16/aQDnYVx6cZhlRUv.png" alt="image-20220916165926205"></p><p>进入之后，可以看到已经自动帮助我们创建好了一个<code>java</code>源文件，跟我们之前的例子是一样的。要编译运行我们的Java程序，只需要直接点击左边的三角形（启动按钮）即可：</p><p><img src="https://s2.loli.net/2022/09/16/nyWCev6SNkH9oMm.png" alt="image-20220916170119203"></p><p>点击之后，会在下方自动开始构建：</p><p><img src="https://s2.loli.net/2022/09/16/3791Nedvu8RQxSc.png" alt="image-20220916170201943"></p><p>完成之后，就可以在控制台看到输出的内容了：</p><p><img src="https://s2.loli.net/2022/09/16/l8G5MwfLJHq3eQD.png" alt="image-20220916170231090"></p><p>我们可以看到新增加了一个<code>out</code>目录，这里面就是刚刚编译好的<code>.class</code>文件：</p><p><img src="https://s2.loli.net/2022/09/16/49ywZ8bEQtYdLBP.png" alt="image-20220916170358904"></p><p>IDEA非常强大，即使是编译之后的二进制文件，也可以反编译回原代码的样子：</p><p><img src="https://s2.loli.net/2022/09/16/DeaO9P8mLRA2uHb.png" alt="image-20220916170442922"></p><p>如果我们想写一个新的Java项目，可以退出当前项目重新创建：</p><p><img src="https://s2.loli.net/2022/09/16/sIw3ZcarNuA4TS8.png" alt="image-20220916170558720"></p><p>此时项目列表中就有我们刚刚创建的Java项目了：</p><p><img src="https://s2.loli.net/2022/09/16/urQkEzWw5JOAGLo.png" alt="image-20220916170654353"></p><p>如果你还想探索IDEA的其他功能，可以点击欢迎页最下方的学习：</p><p><img src="https://s2.loli.net/2022/09/16/MdGZgaBPyqfeIxX.png" alt="image-20220916164837599"></p><p>会有一个专门的引导教程项目，来教你如何使用各项功能：</p><p><img src="https://s2.loli.net/2022/09/16/I1PcHasEzyxw8eL.png" alt="image-20220916164703111"></p><h3 id="IDEA新UI介绍和外观设置"><a href="#IDEA新UI介绍和外观设置" class="headerlink" title="IDEA新UI介绍和外观设置"></a>IDEA新UI介绍和外观设置</h3><p>IDEA在2022年开启了界面新UI的测试，并将在年底前实装，所以说我们将老UI界面改为新的UI界面进行介绍（如果已经是新UI的样式，那么就不需要像下面一样开启了）</p><p>我们随便进入一个项目，然后双击Shift出现搜索框（这个搜索框很好用，什么都能搜）输入<code>registry</code></p><p><img src="https://s2.loli.net/2022/09/16/gXNG9fqzHJiWtlU.png" alt="image-20220916171015360"></p><p>找到<code>ide.experimental.ui</code>，将其勾选上，然后重启IDEA就变成新的UI样式了（你不说这是IDEA我还以为是VS呢）</p><p><img src="https://s2.loli.net/2022/09/16/4urncqfwQFG3pCT.png" alt="image-20220916171139281"></p><p>这里介绍一下新UI的各个功能，首先是运行项目，依然是点击左侧三角形：</p><p><img src="https://s2.loli.net/2022/09/16/MwEkSagiTDZIL3y.png" alt="image-20220916171251054"></p><p>在第一次运行后，会自动生成一个运行配置，我们也可以直接点击右上角的运行：</p><p><img src="https://s2.loli.net/2022/09/16/gtVmywzIBP5io1X.png" alt="image-20220916171324195"></p><p>效果是一样的，都可以编译运行Java项目。上面一排工具栏被丢到了一个菜单里面：</p><p><img src="https://s2.loli.net/2022/09/16/UvednOgYZ3MEhBH.png" alt="image-20220916171421975"></p><p>如果各位小伙伴觉得代码字体太小了，可以在设置中进行调整：</p><p><img src="https://s2.loli.net/2022/09/16/3zbAx94vJ5NihtY.png" alt="image-20220916171604891"></p><p>IDEA的所有通知都可以在通知中查看：</p><p><img src="https://s2.loli.net/2022/09/16/18aOSWXMhZnwPeq.png" alt="image-20220916171736462"></p><p>我们来看右下角，第一个三角形图标是运行的结果：</p><p><img src="https://s2.loli.net/2022/09/16/4IdVS8mrxnezkqE.png" alt="image-20220916171806992"></p><p>第二栏是终端（其实就是内嵌的一个CMD命令窗口）可以自由敲命令，默认是位于项目根目录下：</p><p><img src="https://s2.loli.net/2022/09/16/CN9YwJ4LyxWGOIE.png" alt="image-20220916171854171"></p><p>至此，学习前准备就完成了，从下节课开始，我们将正式进入到Java语言的学习中。</p>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/09/16/XZGlpWmeO7T8ft2.png&quot; alt=&quot;image-20220916142151904&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;新手入门篇&quot;&gt;&lt;a href=&quot;#新手入门篇&quot; class=&quot;headerlink&quot; title=&quot;新手入门篇&quot;&gt;&lt;/a&gt;新手入门篇&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;开始学习JavaSE之前建议学习的前置课程《C语言程序设计》《数据结构》《操作系统》《计算机组成原理》&lt;/p&gt;
&lt;p&gt;欢迎各位小伙伴来到JavaSE视频教程，期待与各位小伙伴共度这一旅程！视频中所有的文档、资料，都可以直接在视频下方简介中找到，视频非培训机构出品，纯个人录制，不需要加任何公众号、小程序，直接自取即可。&lt;/p&gt;
&lt;p&gt;教程开始之前，提醒各位小伙伴：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你对某样东西不熟悉，请务必保证跟视频中使用一模一样的环境、一模一样的操作方式去使用，不要自作主张，否则出现某些奇怪的问题又不知道怎么办，就会浪费很多时间。&lt;/li&gt;
&lt;li&gt;视频依然是基于Java 8进行讲解，不要自己去安装一个其他的版本，想要了解新版本特性可以在另一个视频里面观看。&lt;/li&gt;
&lt;li&gt;在学习过程中，尽可能避免出现中文文件夹，包括后面的环境安装、项目创建，都尽量不要放在中文路径下（因为使用中文常常出现奇奇怪怪的问题）建议使用对应的英文单词代替，或者是用拼音都可以，最好只出现英文字母和数字。&lt;/li&gt;
&lt;li&gt;本系列教程使用 IDEA社区版（免费）即可，不需要申请终极版。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果觉得本视频对你有帮助，请一键三连支持一下UP主！&lt;/p&gt;
&lt;h2 id=&quot;计算机思维导论&quot;&gt;&lt;a href=&quot;#计算机思维导论&quot; class=&quot;headerlink&quot; title=&quot;计算机思维导论&quot;&gt;&lt;/a&gt;计算机思维导论&lt;/h2&gt;&lt;p&gt;计算机自1946年问世以来，几乎改变了整个世界。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://xiaofanshutu.github.io/posts/0.html"/>
    <id>https://xiaofanshutu.github.io/posts/0.html</id>
    <published>2025-08-31T15:29:05.027Z</published>
    <updated>2025-08-31T15:31:22.572Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java网络编程"><a href="#Java网络编程" class="headerlink" title="Java网络编程"></a>Java网络编程</h1><p>在JavaSE阶段，我们学习了I/O流，既然I/O流如此强大，那么能否跨越不同的主机进行I/O操作呢？这就要提到Java的网络编程了。</p><p><strong>注意：</strong>本章会涉及到<code>计算机网络</code>相关内容（只会讲解大致内容，不会完整的讲解计算机网络知识）</p><h2 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h2><p>利用通信线路和通信设备，将地理位置不同的、功能独立的多台计算机互连起来，以功能完善的网络软件来实现资源共享和信息传递，就构成了计算机网络系统。</p><p><img src="https://pics2.baidu.com/feed/503d269759ee3d6d1356774cd59afe244e4ade3c.jpeg?token=f256bfddbd14418f8f3d3d4964ed4cf5" alt="img"></p><p>比如我们家里的路由器，通过将我们的设备（手机、平板、电脑、电视剧）连接到路由器，来实现对互联网的访问。实际上，我们的路由器连接在互联网上，而我们的设备又连接了路由器，这样我们的设备就可以通过路由器访问到互联网了。通过网络，我们可以直接访问互联网上的另一台主机，比如我们要把QQ的消息发送给我们的朋友，或是通过远程桌面管理来操作另一台电脑，也可以是连接本地网络上的打印机。</p><p>既然我们可以通过网络访问其他计算机，那么如何区别不同的计算机呢？通过IP地址，我们就可以区分不同的计算机了：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.it610.com%2Fimage%2Finfo5%2Facf4321f34144b69811bdde9bec045c8.jpg&amp;refer=http%3A%2F%2Fimg.it610.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1637820816&amp;t=955be58edb486e7a69cdea2381714252" alt="img"></p><p>每一台电脑在同一个网络上都有一个自己的IP地址，用于区别于其他的电脑，我们可以通过对方主机的IP地址对其进行访问。那么我手机连接的移动流量，能访问到连接家里路由器的电脑吗？（不能，因为他们不属于同一个网络）</p><p>而我们的电脑上可能运行着大量的程序，每一个程序可能都需要通过网络来访问其他计算机，那这时该如何区分呢？我们可以通过端口号来区分：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F2068098%2F202008%2F2068098-20200808153937940-609503998.png&amp;refer=http%3A%2F%2Fimg2020.cnblogs.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1637821431&amp;t=9dfd5db6c6f75f843d1663f54b2ccb6c" alt="img"></p><p>因此，我们一般看到的是这样的：<code>192.168.0.11:8080</code>，通过<code>IP:端口</code>的形式来访问目标主机上的一个应用程序服务。注意端口号只能是0-65535之间的值！</p><p>IP地址分为IPv4和IPv6，IPv4类似于<code>192.168.0.11</code>，我们上面提到的例子都是使用的IPv4，它一共有四组数字，每组数字占8个bit位，IPv4地址<code>0.0.0.0</code>表示为2进制就是：00000000.00000000.00000000.00000000，共32个bit，最大为<code>255.255.255.255</code>，实际上，IPv4能够表示的所有地址，早就已经被用完了。IPv6能够保存128个bit位，因此它也可以表示更多的IP地址，一个IPv6地址看起来像这样：<code>1030::C9B4:FF12:48AA:1A2B</code>，目前也正在向IPv6的阶段过度。</p><p>TCP和UDP是两种不同的传输层协议：</p><ul><li>TCP：当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠（会进行三次握手，断开也会进行四次挥手），这样才能保证正确收发数据，因此TCP更适合一些可靠的数据传输场景。</li><li>UDP：它是一种无连接协议，数据想发就发，而且不会建立可靠传输，也就是说传输过程中有可能会导致部分数据丢失，但是它比TCP传输更加简单高效，适合视频直播之类的。</li></ul><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fq_70%2Cc_zoom%2Cw_640%2Fimages%2F20200212%2F0f3d7f77442643c099dddbb159a183f6.jpeg&amp;refer=http%3A%2F%2F5b0988e595225.cdn.sohucs.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1637824557&amp;t=b5d5cb0c013ae945e838e88a345edb9c" alt="img"></p><hr><h2 id="了解Socket技术"><a href="#了解Socket技术" class="headerlink" title="了解Socket技术"></a>了解Socket技术</h2><p>通过Socket技术（它是计算机之间进行<strong>通信</strong>的<strong>一种约定</strong>或一种方式），我们就可以实现两台计算机之间的通信，Socket也被翻译为<code>套接字</code>，是操作系统底层提供的一项通信技术，它支持TCP和UDP。而Java就对socket底层支持进行了一套完整的封装，我们可以通过Java来实现Socket通信。</p><p>要实现Socket通信，我们必须创建一个数据发送者和一个数据接收者，也就是客户端和服务端，我们需要提前启动服务端，来等待客户端的连接，而客户端只需要随时启动去连接服务端即可！</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//服务端</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span>(ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>)){    <span class="hljs-comment">//将服务端创建在端口8080上</span><br>        System.out.println(<span class="hljs-string">"正在等待客户端连接..."</span>);<br>        Socket socket = server.accept();  <span class="hljs-comment">//当没有客户端连接时，线程会阻塞，直到有客户端连接为止</span><br>        System.out.println(<span class="hljs-string">"客户端已连接，IP地址为："</span>+socket.getInetAddress().getHostAddress());<br>    }<span class="hljs-keyword">catch</span> (IOException e){<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//客户端</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span> (Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">8080</span>)){<br>        System.out.println(<span class="hljs-string">"已连接到服务端！"</span>);<br>    }<span class="hljs-keyword">catch</span> (IOException e){<br>        System.out.println(<span class="hljs-string">"服务端连接失败！"</span>);<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>实际上它就是一个TCP连接的建立过程：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.reader8.cn%2Fuploadfile%2Fjiaocheng%2F201401101%2F3039%2F2014013015391315977.jpg&amp;refer=http%3A%2F%2Fwww.reader8.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1637838562&amp;t=a22f860adb01fda478ecb76f34c34252" alt="img"></p><p>一旦TCP连接建立，服务端和客户端之间就可以相互发送数据，直到客户端主动关闭连接。当然，服务端不仅仅只可以让一个客户端进行连接，我们可以尝试让服务端一直运行来不断接受客户端的连接：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span>(ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>)){    <span class="hljs-comment">//将服务端创建在端口8080上</span><br>        System.out.println(<span class="hljs-string">"正在等待客户端连接..."</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>){   <span class="hljs-comment">//无限循环等待客户端连接</span><br>            Socket socket = server.accept();<br>            System.out.println(<span class="hljs-string">"客户端已连接，IP地址为："</span>+socket.getInetAddress().getHostAddress());<br>        }<br>    }<span class="hljs-keyword">catch</span> (IOException e){<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>现在我们就可以多次去连接此服务端了。</p><h2 id="使用Socket进行数据传输"><a href="#使用Socket进行数据传输" class="headerlink" title="使用Socket进行数据传输"></a>使用Socket进行数据传输</h2><p>通过Socket对象，我们就可以获取到对应的I/O流进行网络数据传输：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        <span class="hljs-keyword">try</span> (Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">8080</span>);<br>             Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in)){<br>            System.out.println(<span class="hljs-string">"已连接到服务端！"</span>);<br>            OutputStream stream = socket.getOutputStream();<br>            OutputStreamWriter writer = <span class="hljs-keyword">new</span> OutputStreamWriter(stream);  <span class="hljs-comment">//通过转换流来帮助我们快速写入内容</span><br>            System.out.println(<span class="hljs-string">"请输入要发送给服务端的内容："</span>);<br>            String text = scanner.nextLine();<br>            writer.write(text+<span class="hljs-string">'\n'</span>);   <span class="hljs-comment">//因为对方是readLine()这里加个换行符</span><br>            writer.flush();<br>            System.out.println(<span class="hljs-string">"数据已发送："</span>+text);<br>        }<span class="hljs-keyword">catch</span> (IOException e){<br>            System.out.println(<span class="hljs-string">"服务端连接失败！"</span>);<br>            e.printStackTrace();<br>        }<span class="hljs-keyword">finally</span> {<br>            System.out.println(<span class="hljs-string">"客户端断开连接！"</span>);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span>(ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>)){    <span class="hljs-comment">//将服务端创建在端口8080上</span><br>        System.out.println(<span class="hljs-string">"正在等待客户端连接..."</span>);<br>        Socket socket = server.accept();<br>        System.out.println(<span class="hljs-string">"客户端已连接，IP地址为："</span>+socket.getInetAddress().getHostAddress());<br>        BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket.getInputStream()));  <span class="hljs-comment">//通过</span><br>        System.out.print(<span class="hljs-string">"接收到客户端数据："</span>);<br>        System.out.println(reader.readLine());<br>      socket.close();   <span class="hljs-comment">//和服务端TCP连接完成之后，记得关闭socket</span><br>    }<span class="hljs-keyword">catch</span> (IOException e){<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>同理，既然服务端可以读取客户端的内容，客户端也可以在发送后等待服务端给予响应：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span> (Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">8080</span>);<br>         Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in)){<br>        System.out.println(<span class="hljs-string">"已连接到服务端！"</span>);<br>        OutputStream stream = socket.getOutputStream();<br>        OutputStreamWriter writer = <span class="hljs-keyword">new</span> OutputStreamWriter(stream);  <span class="hljs-comment">//通过转换流来帮助我们快速写入内容</span><br>        System.out.println(<span class="hljs-string">"请输入要发送给服务端的内容："</span>);<br>        String text = scanner.nextLine();<br>        writer.write(text+<span class="hljs-string">'\n'</span>);   <span class="hljs-comment">//因为对方是readLine()这里加个换行符</span><br>        writer.flush();<br>        System.out.println(<span class="hljs-string">"数据已发送："</span>+text);<br>        BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket.getInputStream()));<br>        System.out.println(<span class="hljs-string">"收到服务器返回："</span>+reader.readLine());<br>    }<span class="hljs-keyword">catch</span> (IOException e){<br>        System.out.println(<span class="hljs-string">"服务端连接失败！"</span>);<br>        e.printStackTrace();<br>    }<span class="hljs-keyword">finally</span> {<br>        System.out.println(<span class="hljs-string">"客户端断开连接！"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span>(ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>)){    <span class="hljs-comment">//将服务端创建在端口8080上</span><br>        System.out.println(<span class="hljs-string">"正在等待客户端连接..."</span>);<br>        Socket socket = server.accept();<br>        System.out.println(<span class="hljs-string">"客户端已连接，IP地址为："</span>+socket.getInetAddress().getHostAddress());<br>        BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket.getInputStream()));  <span class="hljs-comment">//通过</span><br>        System.out.print(<span class="hljs-string">"接收到客户端数据："</span>);<br>        System.out.println(reader.readLine());<br>        OutputStreamWriter writer = <span class="hljs-keyword">new</span> OutputStreamWriter(socket.getOutputStream());<br>        writer.write(<span class="hljs-string">"已收到！"</span>);<br>        writer.flush();<br>    }<span class="hljs-keyword">catch</span> (IOException e){<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以手动关闭单向的流：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">socket.shutdownOutput();  <span class="hljs-comment">//关闭输出方向的流</span><br>socket.shutdownInput();  <span class="hljs-comment">//关闭输入方向的流</span><br></code></pre></td></tr></tbody></table></figure><p>如果我们不希望服务端等待太长的时间，我们可以通过调用<code>setSoTimeout()</code>方法来设定IO超时时间：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">socket.setSoTimeout(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></tbody></table></figure><p>当超过设定时间都依然没有收到客户端或是服务端的数据时，会抛出异常：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">java.net.SocketTimeoutException: Read timed out<br>at java.net.SocketInputStream.socketRead0(Native Method)<br>at java.net.SocketInputStream.socketRead(SocketInputStream.java:<span class="hljs-number">116</span>)<br>at java.net.SocketInputStream.read(SocketInputStream.java:<span class="hljs-number">171</span>)<br>at java.net.SocketInputStream.read(SocketInputStream.java:<span class="hljs-number">141</span>)<br>at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:<span class="hljs-number">284</span>)<br>at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:<span class="hljs-number">326</span>)<br>at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:<span class="hljs-number">178</span>)<br>at java.io.InputStreamReader.read(InputStreamReader.java:<span class="hljs-number">184</span>)<br>at java.io.BufferedReader.fill(BufferedReader.java:<span class="hljs-number">161</span>)<br>at java.io.BufferedReader.readLine(BufferedReader.java:<span class="hljs-number">324</span>)<br>at java.io.BufferedReader.readLine(BufferedReader.java:<span class="hljs-number">389</span>)<br>at com.test.Main.main(Main.java:<span class="hljs-number">41</span>)<br></code></pre></td></tr></tbody></table></figure><p>我们之前使用的都是通过构造方法直接连接服务端，那么是否可以等到我们想要的时候再去连接呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (Socket socket = <span class="hljs-keyword">new</span> Socket(); <span class="hljs-comment">//调用无参构造不会自动连接</span><br>     Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in)){ <br>    socket.connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">8080</span>), <span class="hljs-number">1000</span>);  <span class="hljs-comment">//手动调用connect方法进行连接</span><br></code></pre></td></tr></tbody></table></figure><p>如果连接的双方发生意外而通知不到对方，导致一方还持有连接，这样就会占用资源，因此我们可以使用<code>setKeepAlive()</code>方法来防止此类情况发生：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">socket.setKeepAlive(<span class="hljs-keyword">true</span>);<br></code></pre></td></tr></tbody></table></figure><p>当客户端连接后，如果设置了keeplive为 true，当对方没有发送任何数据过来，超过一个时间(看系统内核参数配置)，那么我们这边会发送一个ack探测包发到对方，探测双方的TCP/IP连接是否有效。</p><p>TCP在传输过程中，实际上会有一个缓冲区用于数据的发送和接收：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic1.zhimg.com%2Fv2-72f5d4bebca1242a163cbd1ebff3cdbc_b.jpg&amp;refer=http%3A%2F%2Fpic1.zhimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1637902504&amp;t=2b8dead347f9d2a5bd72e703fc11b987" alt="img"></p><p>此缓冲区大小为：8192，我们可以手动调整其大小来优化传输效率：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">socket.setReceiveBufferSize(<span class="hljs-number">25565</span>);   <span class="hljs-comment">//TCP接收缓冲区</span><br>socket.setSendBufferSize(<span class="hljs-number">25565</span>);    <span class="hljs-comment">//TCP发送缓冲区</span><br></code></pre></td></tr></tbody></table></figure><h2 id="使用Socket传输文件"><a href="#使用Socket传输文件" class="headerlink" title="使用Socket传输文件"></a>使用Socket传输文件</h2><p>既然Socket为我们提供了IO流便于数据传输，那么我们就可以轻松地实现文件传输了。</p><h2 id="使用浏览器访问Socket服务器"><a href="#使用浏览器访问Socket服务器" class="headerlink" title="使用浏览器访问Socket服务器"></a>使用浏览器访问Socket服务器</h2><p>在了解了如何使用Socket传输文件后，我们来看看，浏览器是如何向服务器发起请求的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        <span class="hljs-keyword">try</span>(ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>)){    <span class="hljs-comment">//将服务端创建在端口8080上</span><br>            System.out.println(<span class="hljs-string">"正在等待客户端连接..."</span>);<br>            Socket socket = server.accept();<br>            System.out.println(<span class="hljs-string">"客户端已连接，IP地址为："</span>+socket.getInetAddress().getHostAddress());<br>            InputStream in = socket.getInputStream();  <span class="hljs-comment">//通过</span><br>            System.out.println(<span class="hljs-string">"接收到客户端数据："</span>);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>){<br>                <span class="hljs-keyword">int</span> i = in.read();<br>                <span class="hljs-keyword">if</span>(i == -<span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>                System.out.print((<span class="hljs-keyword">char</span>) i);<br>            }<br>        }<span class="hljs-keyword">catch</span> (Exception e){<br>            e.printStackTrace();<br>        }<br>    }<br></code></pre></td></tr></tbody></table></figure><p>我们现在打开浏览器，输入<a href="http://localhost:8080或是http://127.0.0.1:8080/，来连接我们本地开放的服务器。">http://localhost:8080或是http://127.0.0.1:8080/，来连接我们本地开放的服务器。</a></p><p>我们发现浏览器是无法打开这个链接的，但是我们服务端却收到了不少的信息：</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">GET</span> <span class="hljs-string">/ HTTP/1.1</span><br><span class="hljs-attr">Host</span>: <span class="hljs-string">127.0.0.1:8080</span><br><span class="hljs-attr">Connection</span>: <span class="hljs-string">keep-alive</span><br><span class="hljs-meta">Cache-Control</span>: <span class="hljs-string">max-age=0</span><br><span class="hljs-meta">sec-ch-ua</span>: <span class="hljs-string">"Chromium";v="94", "Google Chrome";v="94", ";Not A Brand";v="99"</span><br><span class="hljs-meta">sec-ch-ua-mobile</span>: <span class="hljs-string">?0</span><br><span class="hljs-meta">sec-ch-ua-platform</span>: <span class="hljs-string">"macOS"</span><br><span class="hljs-meta">Upgrade-Insecure-Requests</span>: <span class="hljs-string">1</span><br><span class="hljs-meta">User-Agent</span>: <span class="hljs-string">Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36</span><br><span class="hljs-attr">Accept</span>: <span class="hljs-string">text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="hljs-meta">Sec-Fetch-Site</span>: <span class="hljs-string">none</span><br><span class="hljs-meta">Sec-Fetch-Mode</span>: <span class="hljs-string">navigate</span><br><span class="hljs-meta">Sec-Fetch-User</span>: <span class="hljs-string">?1</span><br><span class="hljs-meta">Sec-Fetch-Dest</span>: <span class="hljs-string">document</span><br><span class="hljs-meta">Accept-Encoding</span>: <span class="hljs-string">gzip, deflate, br</span><br><span class="hljs-meta">Accept-Language</span>: <span class="hljs-string">zh-CN,zh;q=0.9,und;q=0.8,en;q=0.7</span><br></code></pre></td></tr></tbody></table></figure><p>实际上这些内容都是Http协议规定的请求头内容。HTTP是一种应用层协议，全称为超文本传输协议，它本质也是基于TCP协议进行数据传输，因此我们的服务端能够读取HTTP请求。但是Http协议并不会保持长连接，在得到我们响应的数据后会立即关闭TCP连接。</p><p>既然使用的是Http连接，如果我们的服务器要支持响应HTTP请求，那么就需要按照HTTP协议的规则，返回一个规范的响应文本，首先是响应头，它至少要包含一个响应码：</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-string">200 Accpeted</span><br></code></pre></td></tr></tbody></table></figure><p>然后就是响应内容（注意一定要换行再写），我们尝试来编写一下支持HTTP协议的响应内容：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span>(ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>)){    <span class="hljs-comment">//将服务端创建在端口8080上</span><br>        System.out.println(<span class="hljs-string">"正在等待客户端连接..."</span>);<br>        Socket socket = server.accept();<br>        System.out.println(<span class="hljs-string">"客户端已连接，IP地址为："</span>+socket.getInetAddress().getHostAddress());<br>        BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket.getInputStream()));  <span class="hljs-comment">//通过</span><br>        System.out.println(<span class="hljs-string">"接收到客户端数据："</span>);<br>        <span class="hljs-keyword">while</span> (reader.ready()) System.out.println(reader.readLine());   <span class="hljs-comment">//ready是判断当前流中是否还有可读内容</span><br>        OutputStreamWriter writer = <span class="hljs-keyword">new</span> OutputStreamWriter(socket.getOutputStream());<br>        writer.write(<span class="hljs-string">"HTTP/1.1 200 Accepted\r\n"</span>);   <span class="hljs-comment">//200是响应码，Http协议规定200为接受请求，400为错误的请求，404为找不到此资源（不止这些，还有很多）</span><br>        writer.write(<span class="hljs-string">"\r\n"</span>);   <span class="hljs-comment">//在请求头写完之后还要进行一次换行，然后写入我们的响应实体（会在浏览器上展示的内容）</span><br>        writer.write(<span class="hljs-string">"lbwnb!"</span>);<br>        writer.flush();<br>    }<span class="hljs-keyword">catch</span> (Exception e){<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以打开浏览器的开发者模式（这里推荐使用Chrome/Edge浏览器，按下F12即可打开），我们来观察一下浏览器的实际请求过程。</p>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;Java网络编程&quot;&gt;&lt;a href=&quot;#Java网络编程&quot; class=&quot;headerlink&quot; title=&quot;Java网络编程&quot;&gt;&lt;/a&gt;Java网络编程&lt;/h1&gt;&lt;p&gt;在JavaSE阶段，我们学习了I/O流，既然I/O流如此强大，那么能否跨越不同的主机进行I/O操作呢？这就要提到Java的网络编程了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;本章会涉及到&lt;code&gt;计算机网络&lt;/code&gt;相关内容（只会讲解大致内容，不会完整的讲解计算机网络知识）&lt;/p&gt;
&lt;h2 id=&quot;计算机网络基础&quot;&gt;&lt;a href=&quot;#计算机网络基础&quot; class=&quot;headerlink&quot; title=&quot;计算机网络基础&quot;&gt;&lt;/a&gt;计算机网络基础&lt;/h2&gt;&lt;p&gt;利用通信线路和通信设备，将地理位置不同的、功能独立的多台计算机互连起来，以功能完善的网络软件来实现资源共享和信息传递，就构成了计算机网络系统。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pics2.baidu.com/feed/503d269759ee3d6d1356774cd59afe244e4ade3c.jpeg?token=f256bfddbd14418f8f3d3d4964ed4cf5&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;比如我们家里的路由器，通过将我们的设备（手机、平板、电脑、电视剧）连接到路由器，来实现对互联网的访问。实际上，我们的路由器连接在互联网上，而我们的设备又连接了路由器，这样我们的设备就可以通过路由器访问到互联网了。通过网络，我们可以直接访问互联网上的另一台主机，比如我们要把QQ的消息发送给我们的朋友，或是通过远程桌面管理来操作另一台电脑，也可以是连接本地网络上的打印机。&lt;/p&gt;
&lt;p&gt;既然我们可以通过网络访问其他计算机，那么如何区别不同的计算机呢？通过IP地址，我们就可以区分不同的计算机了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.it610.com%2Fimage%2Finfo5%2Facf4321f34144b69811bdde9bec045c8.jpg&amp;amp;refer=http%3A%2F%2Fimg.it610.com&amp;amp;app=2002&amp;amp;size=f9999,10000&amp;amp;q=a80&amp;amp;n=0&amp;amp;g=0n&amp;amp;fmt=jpeg?sec=1637820816&amp;amp;t=955be58edb486e7a69cdea2381714252&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://xiaofanshutu.github.io/posts/0.html"/>
    <id>https://xiaofanshutu.github.io/posts/0.html</id>
    <published>2025-08-31T15:29:05.025Z</published>
    <updated>2025-08-31T15:31:22.575Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JavaWeb后端"><a href="#JavaWeb后端" class="headerlink" title="JavaWeb后端"></a>JavaWeb后端</h1><p>经过前面的学习，现在终于可以正式进入到后端的学习当中，不过，我们还是需要再系统地讲解一下HTTP通信基础知识，它是我们学习JavaWeb的基础知识，我们之前已经学习过TCP通信，而HTTP实际上是基于TCP协议之上的应用层协议，因此理解它并不难理解。</p><p>打好基础是关键！为什么要去花费时间来讲解计算机网络基础，我们学习一门技术，如果仅仅是知道如何使用却不知道其原理，那么就成了彻头彻尾的“码农”，只知道搬运代码实现功能，却不知道这行代码的执行流程，在遇到一些问题的时候就不知道如何解决，无论是知识层面还是应用层面都得不到提升。</p><p>无论怎么样，我们都要明确，我们学习JavaWeb的最终目的是为了搭建一个网站，并且让用户能访问我们的网站并在我们的网站上做一些事情。</p><h2 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h2><p>在计算机网络（谢希仁 第七版 第264页）中，是这样描述万维网的：</p><blockquote><p> 万维网（World Wide Web）并非是某种特殊的计算机网络，万维网是一个大规模的联机式信息储藏所，英文简称<code>Web</code>，万维网用**<u>链接</u>**的方法，能够非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需求获取丰富的信息。</p></blockquote><p>这句话说的非常官方，但是也蕴藏着许多的信息，首先它指明，我们的互联网上存在许许多多的服务器，而我们通过访问这些服务器就能快速获取服务器为我们提供的信息（比如打开百度就能展示搜索、打开小破站能刷视频、打开微博能查看实时热点）而这些服务器就是由不同的公司在运营。</p><p>其次，我们通过浏览器，只需要输入对应的网址或是点击页面中的一个链接，就能够快速地跳转到另一个页面，从而按我们的意愿来访问服务器。</p><p>而书中是这样描述万维网的工作方式：</p><blockquote><p>万维网以客户服务器的方式工作，浏览器就是安装在用户主机上的万维网客户程序，万维网文档所驻留的主机则运行服务器程序，因此这台主机也称为万维网服务器。<strong>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档</strong>，在一个客户程序主窗口上显示出的万维网文档称为页面。</p></blockquote><p>上面提到的客户程序其实就是我们电脑上安装的浏览器，而服务端就是我们即将要去学习的Web服务器，也就是说，我们要明白如何搭建一个Web服务器并向用户发送我们提供的Web页面，在浏览器中显示的，一般就是HTML文档被解析后的样子。</p><p>那么，我们的服务器可能不止一个页面，可能会有很多个页面，那么客户端如何知道该去访问哪个服务器的哪个页面呢？这个时候就需要用到<code>URL</code>统一资源定位符。互联网上所有的资源，都有一个唯一确定的URL，比如<code>http://www.baidu.com</code></p><p>URL的格式为：</p><blockquote><p>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</p><p>协议是指采用什么协议来访问服务器，不同的协议决定了服务器返回信息的格式，我们一般使用HTTP协议。</p><p>主机可以是一个域名，也可以是一个IP地址（实际上域名最后会被解析为IP地址进行访问）</p><p>端口是当前服务器上Web应用程序开启的端口，我们前面学习TCP通信的时候已经介绍过了，HTTP协议默认使用80端口，因此有时候可以省略。</p><p>路径就是我们希望去访问此服务器上的某个文件，不同的路径代表访问不同的资源。</p></blockquote><p>我们接着来了解一下什么是HTTP协议：</p><blockquote><p>HTTP是面向事务的应用层协议，它是万维网上能够可靠交换文件的重要基础。HTTP不仅传送完成超文本跳转所需的必须信息，而且也传送任何可从互联网上得到的信息，如文本、超文本、声音和图像。</p></blockquote><p>实际上我们之前访问百度、访问自己的网站，所有的传输都是以HTTP作为协议进行的。</p><p>我们来看看HTTP的传输原理：</p><blockquote><p>HTTP使用了面向连接的TCP作为运输层协议，保证了数据的可靠传输。HTTP不必考虑数据在传输过程中被丢弃后又怎样被重传。但是HTTP协议本身是无连接的。也就是说，HTTP虽然使用了TCP连接，但是通信的双方在交换HTTP报文之前不需要先建立HTTP连接。1997年以前使用的是HTTP/1.0协议，之后就是HTTP/1.1协议了。</p></blockquote><p>那么既然HTTP是基于TCP进行通信的，我们首先来回顾一下TCP的通信原理：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fstatic.oschina.net%2Fuploads%2Fspace%2F2016%2F0407%2F144257_WTql_2537915.jpg&amp;refer=http%3A%2F%2Fstatic.oschina.net&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1640244422&amp;t=e2c991d149b7ae79d3baa7868633f4d6" alt="点击查看源网页"></p><p>TCP协议实际上是经历了三次握手再进行通信，也就是说保证整个通信是稳定的，才可以进行数据交换，并且在连接已经建立的过程中，双方随时可以互相发送数据，直到有一方主动关闭连接，这时在进行四次挥手，完成整个TCP通信。</p><p>而HTTP和TCP并不是一个层次的通信协议，TCP是传输层协议，而HTTP是应用层协议，因此，实际上HTTP的内容会作为TCP协议的报文被封装，并继续向下一层进行传递，而传输到客户端时，会依次进行解包，还原为最开始的HTTP数据。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.edatop.com%2Ftech%2Fimages%2Fefans%2Fmcu%2Fmcu-257524hyx0ez3djs.png&amp;refer=http%3A%2F%2Fwww.edatop.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1640244335&amp;t=b0e3e66fdac9f66ab64262a725e041f8" alt="点击查看源网页"></p><p>HTTP使用TCP协议是为了使得数据传输更加可靠，既然它是依靠TCP协议进行数据传输，那么为什么说它本身是无连接的呢？我们来看一下HTTP的传输过程：</p><blockquote><p>用户在点击鼠标链接某个万维网文档时，HTTP协议首先要和服务器建立TCP连接。这需要使用三报文握手。当建立TCP连接的三报文握手的前两部分完成后（即经过了一个RTT时间后），万维网客户就把HTTP请求报文作为建立TCP连接的三报文握手中的第三个报文的数据，发送给万维网服务器。服务器收到HTTP请求报文后，就把所请求的文档作为响应报文返回给客户。</p></blockquote><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.pianshen.com%2Fimages%2F323%2F7b19a0d1acac11f91ba549001758a393.png&amp;refer=http%3A%2F%2Fwww.pianshen.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1640245028&amp;t=bb9d88a42c52313924edc8a7d937cbf8" alt="点击查看源网页"></p><p>因此，我们的浏览器请求一个页面，需要两倍的往返时间。</p><p>最后，我们再来了解一下HTTP的报文结构：</p><p><img src="https://img2.baidu.com/it/u=1539060868,3030092954&amp;fm=26&amp;fmt=auto" alt="img"></p><p>由客户端向服务端发送是报文称为请求报文，而服务端返回给客户端的称为响应报文，实际上，整个报文全部是以文本形式发送的，通过使用空格和换行来完成分段。</p><p>现在，我们已经了解了HTTP协议的全部基础知识，那么什么是Web服务器呢，实际上，它就是一个软件，但是它已经封装了所有的HTTP协议层面的操作，我们无需关心如何使用HTTP协议通信，而是直接基于服务器软件进行开发，我们只需要关心我们的页面数据如何展示、前后端如何交互即可。</p><h2 id="认识Tomcat服务器"><a href="#认识Tomcat服务器" class="headerlink" title="认识Tomcat服务器"></a>认识Tomcat服务器</h2><p><a href="http://tomcat.apache.org/"><img src="https://tomcat.apache.org/res/images/tomcat.png" alt="Tomcat Home"></a></p><p>Tomcat（汤姆猫）就是一个典型的Web应用服务器软件，通过运行Tomcat服务器，我们就可以快速部署我们的Web项目，并交由Tomcat进行管理，我们只需要直接通过浏览器访问我们的项目即可。</p><p>那么首先，我们需要进行一个简单的环境搭建，我们需要在Tomcat官网下载最新的Tomcat服务端程序：<a href="https://tomcat.apache.org/download-10.cgi%EF%BC%88%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6%E5%8F%AF%E8%83%BD%E6%9C%89%E7%82%B9%E6%85%A2%EF%BC%89">https://tomcat.apache.org/download-10.cgi（下载速度可能有点慢）</a></p><ul><li>下载：64-bit Windows zip</li></ul><p>下载完成后，解压，并放入桌面，接下来需要配置一下环境变量，打开<code>高级系统设置</code>，打开<code>环境变量</code>，添加一个新的系统变量，变量名称为<code>JRE_HOME</code>，填写JDK的安装目录+/jre，比如Zulujdk默认就是：C:\Program Files\Zulu\zulu-8\jre</p><p>设置完成后，我们进入tomcat文件夹bin目录下，并在当前位置打开CMD窗口，将startup.sh拖入窗口按回车运行，如果环境变量配置有误，会提示，若没问题，服务器则正常启动。</p><p>如果出现乱码，说明编码格式配置有问题，我们修改一下服务器的配置文件，打开<code>conf</code>文件夹，找到<code>logging.properties</code>文件，这就是日志的配置文件（我们在前面已经给大家讲解过了）将ConsoleHandler的默认编码格式修改为GBK编码格式：</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">java.util.logging.ConsoleHandler.encoding</span> = <span class="hljs-string">GBK</span><br></code></pre></td></tr></tbody></table></figure><p>现在重新启动服务器，就可以正常显示中文了。</p><p>服务器启动成功之后，不要关闭，我们打开浏览器，在浏览器中访问：<a href="http://localhost:8080/%EF%BC%8CTomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%BB%98%E8%AE%A4%E6%98%AF%E4%BD%BF%E7%94%A88080%E7%AB%AF%E5%8F%A3%EF%BC%88%E5%8F%AF%E4%BB%A5%E5%9C%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E4%BF%AE%E6%94%B9%EF%BC%89%EF%BC%8C%E8%AE%BF%E9%97%AE%E6%88%90%E5%8A%9F%E8%AF%B4%E6%98%8E%E6%88%91%E4%BB%AC%E7%9A%84Tomcat%E7%8E%AF%E5%A2%83%E5%B7%B2%E7%BB%8F%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F%E4%BA%86%E3%80%82">http://localhost:8080/，Tomcat服务器默认是使用8080端口（可以在配置文件中修改），访问成功说明我们的Tomcat环境已经部署成功了。</a></p><p>整个Tomcat目录下，我们已经认识了bin目录（所有可执行文件，包括启动和关闭服务器的脚本）以及conf目录（服务器配置文件目录），那么我们接着来看其他的文件夹：</p><ul><li>lib目录：Tomcat服务端运行的一些依赖，不用关心。</li><li>logs目录：所有的日志信息都在这里。</li><li>temp目录：存放运行时产生的一些临时文件，不用关心。</li><li>work目录：工作目录，Tomcat会将jsp文件转换为java文件（我们后面会讲到，这里暂时不提及）</li><li>webapp目录：所有的Web项目都在这里，每个文件夹都是一个Web应用程序：</li></ul><p>我们发现，官方已经给我们预设了一些项目了，访问后默认使用的项目为ROOT项目，也就是我们默认打开的网站。</p><p>我们也可以访问example项目，只需要在后面填写路径即可：<a href="http://localhost:8080/examples/%EF%BC%8C%E6%88%96%E6%98%AFdocs%E9%A1%B9%E7%9B%AE%EF%BC%88%E8%BF%99%E4%B8%AA%E6%98%AFTomcat%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%87%E6%A1%A3%EF%BC%89http://localhost:8080/docs/">http://localhost:8080/examples/，或是docs项目（这个是Tomcat的一些文档）http://localhost:8080/docs/</a></p><p>Tomcat还自带管理页面，我们打开：<a href="http://localhost:8080/manager%EF%BC%8C%E6%8F%90%E7%A4%BA%E9%9C%80%E8%A6%81%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%EF%BC%8C%E7%94%B1%E4%BA%8E%E4%B8%8D%E7%9F%A5%E9%81%93%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%88%91%E4%BB%AC%E5%85%88%E7%82%B9%E5%87%BB%E5%8F%96%E6%B6%88%EF%BC%8C%E9%A1%B5%E9%9D%A2%E4%B8%AD%E5%87%BA%E7%8E%B0%E5%A6%82%E4%B8%8B%E5%86%85%E5%AE%B9%EF%BC%9A">http://localhost:8080/manager，提示需要用户名和密码，由于不知道是什么，我们先点击取消，页面中出现如下内容：</a></p><blockquote><p>You are not authorized to view this page. If you have not changed any configuration files, please examine the file <code>conf/tomcat-users.xml</code> in your installation. That file must contain the credentials to let you use this webapp.</p><p>For example, to add the <code>manager-gui</code> role to a user named <code>tomcat</code> with a password of <code>s3cret</code>, add the following to the config file listed above.</p><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;role <span class="hljs-attribute">rolename</span>=<span class="hljs-string">"manager-gui"</span>/&gt;<br>&lt;user <span class="hljs-attribute">username</span>=<span class="hljs-string">"tomcat"</span> <span class="hljs-attribute">password</span>=<span class="hljs-string">"s3cret"</span> <span class="hljs-attribute">roles</span>=<span class="hljs-string">"manager-gui"</span>/&gt;<br></code></pre></td></tr></tbody></table></figure><p>Note that for Tomcat 7 onwards, the roles required to use the manager application were changed from the single <code>manager</code> role to the following four roles. You will need to assign the role(s) required for the functionality you wish to access.</p><ul><li><code>manager-gui</code> - allows access to the HTML GUI and the status pages</li><li><code>manager-script</code> - allows access to the text interface and the status pages</li><li><code>manager-jmx</code> - allows access to the JMX proxy and the status pages</li><li><code>manager-status</code> - allows access to the status pages only</li></ul><p>The HTML interface is protected against CSRF but the text and JMX interfaces are not. To maintain the CSRF protection:</p><ul><li>Users with the <code>manager-gui</code> role should not be granted either the <code>manager-script</code> or <code>manager-jmx</code> roles.</li><li>If the text or jmx interfaces are accessed through a browser (e.g. for testing since these interfaces are intended for tools not humans) then the browser must be closed afterwards to terminate the session.</li></ul><p>For more information - please see the <a href="http://localhost:8080/docs/manager-howto.html">Manager App How-To</a>.</p></blockquote><p>现在我们按照上面的提示，去配置文件中进行修改：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">role</span> <span class="hljs-attr">rolename</span>=<span class="hljs-string">"manager-gui"</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">username</span>=<span class="hljs-string">"admin"</span> <span class="hljs-attr">password</span>=<span class="hljs-string">"admin"</span> <span class="hljs-attr">roles</span>=<span class="hljs-string">"manager-gui"</span>/&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>现在再次打开管理页面，已经可以成功使用此用户进行登陆了。登录后，展示给我们的是一个图形化界面，我们可以快速预览当前服务器的一些信息，包括已经在运行的Web应用程序，甚至还可以查看当前的Web应用程序有没有出现内存泄露。</p><p>同样的，还有一个虚拟主机管理页面，用于一台主机搭建多个Web站点，一般情况下使用不到，这里就不做演示了。</p><p>我们可以将我们自己的项目也放到webapp文件夹中，这样就可以直接访问到了，我们在webapp目录下新建test文件夹，将我们之前编写的前端代码全部放入其中（包括html文件、js、css、icon等），重启服务器。</p><p>我们可以直接通过 <a href="http://localhost:8080/test/">http://localhost:8080/test/</a> 来进行访问。</p><hr><h2 id="使用Maven创建Web项目"><a href="#使用Maven创建Web项目" class="headerlink" title="使用Maven创建Web项目"></a>使用Maven创建Web项目</h2><p>虽然我们已经可以在Tomcat上部署我们的前端页面了，但是依然只是一个静态页面（每次访问都是同样的样子），那么如何向服务器请求一个动态的页面呢（比如显示我们访问当前页面的时间）这时就需要我们编写一个Web应用程序来实现了，我们需要在用户向服务器发起页面请求时，进行一些处理，再将结果发送给用户的浏览器。</p><p><strong>注意：</strong>这里需要使用终极版IDEA，如果你的还是社区版，就很难受了。</p><p>我们打开IDEA，新建一个项目，选择Java Enterprise（社区版没有此选项！）项目名称随便，项目模板选择Web应用程序，然后我们需要配置Web应用程序服务器，将我们的Tomcat服务器集成到IDEA中。配置很简单，首先点击新建，然后设置Tomcat主目录即可，配置完成后，点击下一步即可，依赖项使用默认即可，然后点击完成，之后IDEA会自动帮助我们创建Maven项目。</p><p>创建完成后，直接点击右上角即可运行此项目了，但是我们发现，有一个Servlet页面不生效。</p><p>需要注意的是，Tomcat10以上的版本比较新，Servlet API包名发生了一些变化，因此我们需要修改一下依赖：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jakarta.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jakarta.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>注意包名全部从javax改为jakarta，我们需要手动修改一下。</p><p>感兴趣的可以了解一下为什么名称被修改了：</p><blockquote><p>Eclipse基金会在2019年对 Java EE 标准的每个规范进行了重命名，阐明了每个规范在Jakarta EE平台未来的角色。</p><p>新的名称Jakarta EE是Java EE的第二次重命名。2006年5月，“J2EE”一词被弃用，并选择了Java EE这个名称。在YouTube还只是一家独立的公司的时候，数字2就就从名字中消失了，而且当时冥王星仍然被认为是一颗行星。同样，作为Java SE 5（2004）的一部分，数字2也从J2SE中删除了，那时谷歌还没有上市。</p><p><strong>因为不能再使用javax名称空间，Jakarta EE提供了非常明显的分界线。</strong></p><ul><li>Jakarta 9（2019及以后）使用jakarta命名空间。</li><li>Java EE 5（2005）到Java EE 8（2017）使用javax命名空间。</li><li>Java EE 4使用javax命名空间。</li></ul></blockquote><p>我们可以将项目直接打包为war包（默认），打包好之后，放入webapp文件夹，就可以直接运行我们通过Java编写的Web应用程序了，访问路径为文件的名称。</p><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>前面我们已经完成了基本的环境搭建，那么现在我们就可以开始来了解我们的第一个重要类——Servlet。</p><p>它是Java EE的一个标准，大部分的Web服务器都支持此标准，包括Tomcat，就像之前的JDBC一样，由官方定义了一系列接口，而具体实现由我们来编写，最后交给Web服务器（如Tomcat）来运行我们编写的Servlet。</p><p>那么，它能做什么呢？我们可以通过实现Servlet来进行动态网页响应，使用Servlet，不再是直接由Tomcat服务器发送我们编写好的静态网页内容（HTML文件），而是由我们通过Java代码进行动态拼接的结果，它能够很好地实现动态网页的返回。</p><p>当然，Servlet并不是专用于HTTP协议通信，也可以用于其他的通信，但是一般都是用于HTTP。</p><h3 id="创建Servlet"><a href="#创建Servlet" class="headerlink" title="创建Servlet"></a>创建Servlet</h3><p>那么如何创建一个Servlet呢，非常简单，我们只需要实现<code>Servlet</code>类即可，并添加注解<code>@WebServlet</code>来进行注册。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet("/test")</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestServlet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>{<br>...实现接口方法<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们现在就可以去访问一下我们的页面：<a href="http://localhost:8080/test/test">http://localhost:8080/test/test</a></p><p>我们发现，直接访问此页面是没有任何内容的，这是因为我们还没有为该请求方法编写实现，这里先不做讲解，后面我们会对浏览器的请求处理做详细的介绍。</p><p>除了直接编写一个类，我们也可以在<code>web.xml</code>中进行注册，现将类上<code>@WebServlet</code>的注解去掉：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.example.webtest.TestServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/test<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>这样的方式也能注册Servlet，但是显然直接使用注解更加方便，因此之后我们一律使用注解进行开发。只有比较新的版本才支持此注解，老的版本是不支持的哦。</p><p>实际上，Tomcat服务器会为我们提供一些默认的Servlet，也就是说在服务器启动后，即使我们什么都不编写，Tomcat也自带了几个默认的Servlet，他们编写在conf目录下的web.xml中：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- The mapping for the default servlet --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- The mappings for the JSP servlet --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>jsp<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.jspx<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br></code></pre></td></tr></tbody></table></figure><p>我们发现，默认的Servlet实际上可以帮助我们去访问一些静态资源，这也是为什么我们启动Tomcat服务器之后，能够直接访问webapp目录下的静态页面。</p><p>我们可以将之前编写的页面放入到webapp目录下，来测试一下是否能直接访问。</p><h3 id="探究Servlet的生命周期"><a href="#探究Servlet的生命周期" class="headerlink" title="探究Servlet的生命周期"></a>探究Servlet的生命周期</h3><p>我们已经了解了如何注册一个Servlet，那么我们接着来看看，一个Servlet是如何运行的。</p><p>首先我们需要了解，Servlet中的方法各自是在什么时候被调用的，我们先编写一个打印语句来看看：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestServlet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TestServlet</span><span class="hljs-params">()</span></span>{<br>        System.out.println(<span class="hljs-string">"我是构造方法！"</span>);<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ServletConfig servletConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>{<br>        System.out.println(<span class="hljs-string">"我是init"</span>);<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletConfig <span class="hljs-title">getServletConfig</span><span class="hljs-params">()</span> </span>{<br>        System.out.println(<span class="hljs-string">"我是getServletConfig"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>{<br>        System.out.println(<span class="hljs-string">"我是service"</span>);<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getServletInfo</span><span class="hljs-params">()</span> </span>{<br>        System.out.println(<span class="hljs-string">"我是getServletInfo"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>{<br>        System.out.println(<span class="hljs-string">"我是destroy"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们首先启动一次服务器，然后访问我们定义的页面，然后再关闭服务器，得到如下的顺序：</p><blockquote><p>我是构造方法！<br>我是init<br>我是service<br>我是service（出现两次是因为浏览器请求了2次，是因为有一次是请求favicon.ico，浏览器通病）</p><p>我是destroy</p></blockquote><p>我们可以多次尝试去访问此页面，但是init和构造方法只会执行一次，而每次访问都会执行的是<code>service</code>方法，因此，一个Servlet的生命周期为：</p><ul><li>首先执行构造方法完成 Servlet 初始化</li><li>Servlet 初始化后调用 <strong>init ()</strong> 方法。</li><li>Servlet 调用 <strong>service()</strong> 方法来处理客户端的请求。</li><li>Servlet 销毁前调用 <strong>destroy()</strong> 方法。</li><li>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。</li></ul><p>现在我们发现，实际上在Web应用程序运行时，每当浏览器向服务器发起一个请求时，都会创建一个线程执行一次<code>service</code>方法，来让我们处理用户的请求，并将结果响应给用户。</p><p>我们发现<code>service</code>方法中，还有两个参数，<code>ServletRequest</code>和<code>ServletResponse</code>，实际上，用户发起的HTTP请求，就被Tomcat服务器封装为了一个<code>ServletRequest</code>对象，我们得到是其实是Tomcat服务器帮助我们创建的一个实现类，HTTP请求报文中的所有内容，都可以从<code>ServletRequest</code>对象中获取，同理，<code>ServletResponse</code>就是我们需要返回给浏览器的HTTP响应报文实体类封装。</p><p>那么我们来看看<code>ServletRequest</code>中有哪些内容，我们可以获取请求的一些信息：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>{<br>    <span class="hljs-comment">//首先将其转换为HttpServletRequest（继承自ServletRequest，一般是此接口实现）</span><br>        HttpServletRequest request = (HttpServletRequest) servletRequest;<br>        <br>        System.out.println(request.getProtocol());  <span class="hljs-comment">//获取协议版本</span><br>        System.out.println(request.getRemoteAddr());  <span class="hljs-comment">//获取访问者的IP地址</span><br>    System.out.println(request.getMethod());   <span class="hljs-comment">//获取请求方法</span><br>        <span class="hljs-comment">//获取头部信息</span><br>        Enumeration&lt;String&gt; enumeration = request.getHeaderNames();<br>        <span class="hljs-keyword">while</span> (enumeration.hasMoreElements()){<br>            String name = enumeration.nextElement();<br>            System.out.println(name + <span class="hljs-string">": "</span> + request.getHeader(name));<br>        }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现，整个HTTP请求报文中的所有内容，都可以通过<code>HttpServletRequest</code>对象来获取，当然，它的作用肯定不仅仅是获取头部信息，我们还可以使用它来完成更多操作，后面会一一讲解。</p><p>那么我们再来看看<code>ServletResponse</code>，这个是服务端的响应内容，我们可以在这里填写我们想要发送给浏览器显示的内容：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//转换为HttpServletResponse（同上）</span><br>HttpServletResponse response = (HttpServletResponse) servletResponse;<br><span class="hljs-comment">//设定内容类型以及编码格式（普通HTML文本使用text/html，之后会讲解文件传输）</span><br>response.setHeader(<span class="hljs-string">"Content-type"</span>, <span class="hljs-string">"text/html;charset=UTF-8"</span>);<br><span class="hljs-comment">//获取Writer直接写入内容</span><br>response.getWriter().write(<span class="hljs-string">"我是响应内容！"</span>);<br><span class="hljs-comment">//所有内容写入完成之后，再发送给浏览器</span><br></code></pre></td></tr></tbody></table></figure><p>现在我们在浏览器中打开此页面，就能够收到服务器发来的响应内容了。其中，响应头部分，是由Tomcat帮助我们生成的一个默认响应头。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.qingruanit.net%2FcatchImages%2F20170218%2F1487385940733020268.png&amp;refer=http%3A%2F%2Fwww.qingruanit.net&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1640328590&amp;t=27d773847d13c6ac21c270379dc25717" alt="点击查看源网页"></p><p>因此，实际上整个流程就已经很清晰明了了。</p><h3 id="解读和使用HttpServlet"><a href="#解读和使用HttpServlet" class="headerlink" title="解读和使用HttpServlet"></a>解读和使用HttpServlet</h3><p>前面我们已经学习了如何创建、注册和使用Servlet，那么我们继续来深入学习Servlet接口的一些实现类。</p><p>首先<code>Servlet</code>有一个直接实现抽象类<code>GenericServlet</code>，那么我们来看看此类做了什么事情。</p><p>我们发现，这个类完善了配置文件读取和Servlet信息相关的的操作，但是依然没有去实现service方法，因此此类仅仅是用于完善一个Servlet的基本操作，那么我们接着来看<code>HttpServlet</code>，它是遵循HTTP协议的一种Servlet，继承自<code>GenericServlet</code>，它根据HTTP协议的规则，完善了service方法。</p><p>在阅读了HttpServlet源码之后，我们发现，其实我们只需要继承HttpServlet来编写我们的Servlet就可以了，并且它已经帮助我们提前实现了一些操作，这样就会给我们省去很多的时间。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Log</span><br><span class="hljs-meta">@WebServlet("/test")</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>{<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>{<br>        resp.setContentType(<span class="hljs-string">"text/html;charset=UTF-8"</span>);<br>        resp.getWriter().write(<span class="hljs-string">"&lt;h1&gt;恭喜你解锁了全新玩法&lt;/h1&gt;"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>现在，我们只需要重写对应的请求方式，就可以快速完成Servlet的编写。</p><h3 id="WebServlet注解详解"><a href="#WebServlet注解详解" class="headerlink" title="@WebServlet注解详解"></a>@WebServlet注解详解</h3><p>我们接着来看WebServlet注解，我们前面已经得知，可以直接使用此注解来快速注册一个Servlet，那么我们来想细看看此注解还有什么其他的玩法。</p><p>首先name属性就是Servlet名称，而urlPatterns和value实际上是同样功能，就是代表当前Servlet的访问路径，它不仅仅可以是一个固定值，还可以进行通配符匹配：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet("/test/*")</span><br></code></pre></td></tr></tbody></table></figure><p>上面的路径表示，所有匹配<code>/test/随便什么</code>的路径名称，都可以访问此Servlet，我们可以在浏览器中尝试一下。</p><p>也可以进行某个扩展名称的匹配：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet("*.js")</span><br></code></pre></td></tr></tbody></table></figure><p>这样的话，获取任何以js结尾的文件，都会由我们自己定义的Servlet处理。</p><p>那么如果我们的路径为<code>/</code>呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet("/")</span><br></code></pre></td></tr></tbody></table></figure><p>此路径和Tomcat默认为我们提供的Servlet冲突，会直接替换掉默认的，而使用我们的，此路径的意思为，如果没有找到匹配当前访问路径的Servlet，那么久会使用此Servlet进行处理。</p><p>我们还可以为一个Servlet配置多个访问路径：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet({"/test1", "/test2"})</span><br></code></pre></td></tr></tbody></table></figure><p>我们接着来看loadOnStartup属性，此属性决定了是否在Tomcat启动时就加载此Servlet，默认情况下，Servlet只有在被访问时才会加载，它的默认值为-1，表示不在启动时加载，我们可以将其修改为大于等于0的数，来开启启动时加载。并且数字的大小决定了此Servlet的启动优先级。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Log</span><br><span class="hljs-meta">@WebServlet(value = "/test", loadOnStartup = 1)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>{<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>{<br>        <span class="hljs-keyword">super</span>.init();<br>        log.info(<span class="hljs-string">"我被初始化了！"</span>);<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>{<br>        resp.setContentType(<span class="hljs-string">"text/html;charset=UTF-8"</span>);<br>        resp.getWriter().write(<span class="hljs-string">"&lt;h1&gt;恭喜你解锁了全新玩法&lt;/h1&gt;"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>其他内容都是Servlet的一些基本配置，这里就不详细讲解了。</p><h3 id="使用POST请求完成登陆"><a href="#使用POST请求完成登陆" class="headerlink" title="使用POST请求完成登陆"></a>使用POST请求完成登陆</h3><p>我们前面已经了解了如何使用Servlet来处理HTTP请求，那么现在，我们就结合前端，来实现一下登陆操作。</p><p>我们需要修改一下我们的Servlet，现在我们要让其能够接收一个POST请求：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Log</span><br><span class="hljs-meta">@WebServlet("/login")</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>{<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>{<br>        req.getParameterMap().forEach((k, v) -&gt; {<br>            System.out.println(k + <span class="hljs-string">": "</span> + Arrays.toString(v));<br>        });<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><code>ParameterMap</code>存储了我们发送的POST请求所携带的表单数据，我们可以直接将其遍历查看，浏览器发送了什么数据。</p><p>现在我们再来修改一下前端：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>登录到系统<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"login"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"用户名"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"密码"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>通过修改form标签的属性，现在我们点击登录按钮，会自动向后台发送一个POST请求，请求地址为当前地址+/login（注意不同路径的写法），也就是我们上面编写的Servlet路径。</p><p>运行服务器，测试后发现，在点击按钮后，确实向服务器发起了一个POST请求，并且携带了表单中文本框的数据。</p><p>现在，我们根据已有的基础，将其与数据库打通，我们进行一个真正的用户登录操作，首先修改一下Servlet的逻辑：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>{<br>    <span class="hljs-comment">//首先设置一下响应类型</span><br>    resp.setContentType(<span class="hljs-string">"text/html;charset=UTF-8"</span>);<br>    <span class="hljs-comment">//获取POST请求携带的表单数据</span><br>    Map&lt;String, String[]&gt; map = req.getParameterMap();<br>    <span class="hljs-comment">//判断表单是否完整</span><br>    <span class="hljs-keyword">if</span>(map.containsKey(<span class="hljs-string">"username"</span>) &amp;&amp; map.containsKey(<span class="hljs-string">"password"</span>)) {<br>        String username = req.getParameter(<span class="hljs-string">"username"</span>);<br>        String password = req.getParameter(<span class="hljs-string">"password"</span>);<br><br>        <span class="hljs-comment">//权限校验（待完善）</span><br>    }<span class="hljs-keyword">else</span> {<br>        resp.getWriter().write(<span class="hljs-string">"错误，您的表单数据不完整！"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>接下来我们再去编写Mybatis的依赖和配置文件，创建一个表，用于存放我们用户的账号和密码。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">"development"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"development"</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"JDBC"</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"POOLED"</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${驱动类（含包名）}"</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${数据库连接URL}"</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${用户名}"</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${密码}"</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>配置完成后，在我们的Servlet的init方法中编写Mybatis初始化代码，因为它只需要初始化一次。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">SqlSessionFactory factory;<br><span class="hljs-meta">@SneakyThrows</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>{<br>    factory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(Resources.getResourceAsReader(<span class="hljs-string">"mybatis-config.xml"</span>));<br>}<br></code></pre></td></tr></tbody></table></figure><p>现在我们创建一个实体类以及Mapper来进行用户信息查询：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{<br>    String username;<br>    String password;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>{<br><br>    <span class="hljs-meta">@Select("select * from users where username = #{username} and password = #{password}")</span><br>    <span class="hljs-function">User <span class="hljs-title">getUser</span><span class="hljs-params">(<span class="hljs-meta">@Param("username")</span> String username, <span class="hljs-meta">@Param("password")</span> String password)</span></span>;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.example.dao.UserMapper"</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>好了，现在完事具备，只欠东风了，我们来完善一下登陆验证逻辑：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//登陆校验（待完善）</span><br><span class="hljs-keyword">try</span> (SqlSession sqlSession = factory.openSession(<span class="hljs-keyword">true</span>)){<br>    UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br>    User user = mapper.getUser(username, password);<br>    <span class="hljs-comment">//判断用户是否登陆成功，若查询到信息则表示存在此用户</span><br>    <span class="hljs-keyword">if</span>(user != <span class="hljs-keyword">null</span>){<br>        resp.getWriter().write(<span class="hljs-string">"登陆成功！"</span>);<br>    }<span class="hljs-keyword">else</span> {<br>        resp.getWriter().write(<span class="hljs-string">"登陆失败，请验证您的用户名或密码！"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>现在再去浏览器上进行测试吧！</p><p>注册界面其实是同理的，这里就不多做讲解了。</p><h3 id="上传和下载文件"><a href="#上传和下载文件" class="headerlink" title="上传和下载文件"></a>上传和下载文件</h3><p>首先我们来看看比较简单的下载文件，首先将我们的icon.png放入到resource文件夹中，接着我们编写一个Servlet用于处理文件下载：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet("/file")</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>{<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>{<br>      resp.setContentType(<span class="hljs-string">"image/png"</span>);  <br>      OutputStream outputStream = resp.getOutputStream();<br>      InputStream inputStream = Resources.getResourceAsStream(<span class="hljs-string">"icon.png"</span>);<br><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>为了更加快速地编写IO代码，我们可以引入一个工具库：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>使用此类库可以快速完成IO操作：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">resp.setContentType(<span class="hljs-string">"image/png"</span>);<br>OutputStream outputStream = resp.getOutputStream();<br>InputStream inputStream = Resources.getResourceAsStream(<span class="hljs-string">"icon.png"</span>);<br><span class="hljs-comment">//直接使用copy方法完成转换</span><br>IOUtils.copy(inputStream, outputStream);<br></code></pre></td></tr></tbody></table></figure><p>现在我们在前端页面添加一个链接，用于下载此文件：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"file"</span> <span class="hljs-attr">download</span>=<span class="hljs-string">"icon.png"</span>&gt;</span>点我下载高清资源<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>下载文件搞定，那么如何上传一个文件呢？</p><p>首先我们编写前端部分：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"file"</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">"multipart/form-data"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"file"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"test-file"</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>上传文件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>注意必须添加<code>enctype="multipart/form-data"</code>，来表示此表单用于文件传输。</p><p>现在我们来修改一下Servlet代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MultipartConfig</span><br><span class="hljs-meta">@WebServlet("/file")</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>{<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>{<br>        <span class="hljs-keyword">try</span>(FileOutputStream stream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"/Users/nagocoler/Documents/IdeaProjects/WebTest/test.png"</span>)){<br>            Part part = req.getPart(<span class="hljs-string">"test-file"</span>);<br>            IOUtils.copy(part.getInputStream(), stream);<br>            resp.setContentType(<span class="hljs-string">"text/html;charset=UTF-8"</span>);<br>            resp.getWriter().write(<span class="hljs-string">"文件上传成功！"</span>);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>注意，必须添加<code>@MultipartConfig</code>注解来表示此Servlet用于处理文件上传请求。</p><p>现在我们再运行服务器，并将我们刚才下载的文件又上传给服务端。</p><h3 id="使用XHR请求数据"><a href="#使用XHR请求数据" class="headerlink" title="使用XHR请求数据"></a>使用XHR请求数据</h3><p>现在我们希望，网页中的部分内容，可以动态显示，比如网页上有一个时间，旁边有一个按钮，点击按钮就可以刷新当前时间。</p><p>这个时候就需要我们在网页展示时向后端发起请求了，并根据后端响应的结果，动态地更新页面中的内容，要实现此功能，就需要用到JavaScript来帮助我们，首先在js中编写我们的XHR请求，并在请求中完成动态更新：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateTime</span>(<span class="hljs-params"></span>) </span>{<br>    <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>    xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<br>        <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span> &amp;&amp; xhr.status === <span class="hljs-number">200</span>) {<br>            <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"time"</span>).innerText = xhr.responseText<br>        }<br>    };<br>    xhr.open(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'time'</span>, <span class="hljs-literal">true</span>);<br>    xhr.send();<br>}<br></code></pre></td></tr></tbody></table></figure><p>接着修改一下前端页面，添加一个时间显示区域：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"time"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"updateTime()"</span>&gt;</span>更新数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>    updateTime()<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>最后创建一个Servlet用于处理时间更新请求：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet("/time")</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimeServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>{<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>{<br>        SimpleDateFormat dateFormat = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy年MM月dd日 HH:mm:ss"</span>);<br>        String date = dateFormat.format(<span class="hljs-keyword">new</span> Date());<br>        resp.setContentType(<span class="hljs-string">"text/html;charset=UTF-8"</span>);<br>        resp.getWriter().write(date);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>现在点击按钮就可以更新了。</p><p>GET请求也能传递参数，这里做一下演示。</p><h3 id="重定向与请求转发"><a href="#重定向与请求转发" class="headerlink" title="重定向与请求转发"></a>重定向与请求转发</h3><p>当我们希望用户登录完成之后，直接跳转到网站的首页，那么这个时候，我们就可以使用重定向来完成。当浏览器收到一个重定向的响应时，会按照重定向响应给出的地址，再次向此地址发出请求。</p><p>实现重定向很简单，只需要调用一个方法即可，我们修改一下登陆成功后执行的代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">resp.sendRedirect(<span class="hljs-string">"time"</span>);<br></code></pre></td></tr></tbody></table></figure><p>调用后，响应的状态码会被设置为302，并且响应头中添加了一个Location属性，此属性表示，需要重定向到哪一个网址。</p><p>现在，如果我们成功登陆，那么服务器会发送给我们一个重定向响应，这时，我们的浏览器会去重新请求另一个网址。这样，我们在登陆成功之后，就可以直接帮助用户跳转到用户首页了。</p><p>那么我们接着来看请求转发，请求转发其实是一种服务器内部的跳转机制，我们知道，重定向会使得浏览器去重新请求一个页面，而请求转发则是服务器内部进行跳转，它的目的是，直接将本次请求转发给其他Servlet进行处理，并由其他Servlet来返回结果，因此它是在进行内部的转发。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">req.getRequestDispatcher(<span class="hljs-string">"/time"</span>).forward(req, resp);<br></code></pre></td></tr></tbody></table></figure><p>现在，在登陆成功的时候，我们将请求转发给处理时间的Servlet，注意这里的路径规则和之前的不同，我们需要填写Servlet上指明的路径，并且请求转发只能转发到此应用程序内部的Servlet，不能转发给其他站点或是其他Web应用程序。</p><p>现在再次进行登陆操作，我们发现，返回结果为一个405页面，证明了，我们的请求现在是被另一个Servlet进行处理，并且请求的信息全部被转交给另一个Servlet，由于此Servlet不支持POST请求，因此返回405状态码。</p><p>那么也就是说，该请求包括请求参数也一起被传递了，那么我们可以尝试获取以下POST请求的参数。</p><p>现在我们给此Servlet添加POST请求处理，直接转交给Get请求处理：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>{<br>    <span class="hljs-keyword">this</span>.doGet(req, resp);<br>}<br></code></pre></td></tr></tbody></table></figure><p>再次访问，成功得到结果，但是我们发现，浏览器只发起了一次请求，并没有再次请求新的URL，也就是说，这一次请求直接返回了请求转发后的处理结果。</p><p>那么，请求转发有什么好处呢？它可以携带数据！</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">req.setAttribute(<span class="hljs-string">"test"</span>, <span class="hljs-string">"我是请求转发前的数据"</span>);<br>req.getRequestDispatcher(<span class="hljs-string">"/time"</span>).forward(req, resp);<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(req.getAttribute(<span class="hljs-string">"test"</span>));<br></code></pre></td></tr></tbody></table></figure><p>通过<code>setAttribute</code>方法来给当前请求添加一个附加数据，在请求转发后，我们可以直接获取到该数据。</p><p>重定向属于2次请求，因此无法使用这种方式来传递数据，那么，如何在重定向之间传递数据呢？我们可以使用即将要介绍的ServletContext对象。</p><p>最后总结，两者的区别为：</p><ul><li>请求转发是一次请求，重定向是两次请求</li><li>请求转发地址栏不会发生改变， 重定向地址栏会发生改变</li><li>请求转发可以共享请求参数 ，重定向之后，就获取不了共享参数了</li><li>请求转发只能转发给内部的Servlet</li></ul><h3 id="了解ServletContext对象"><a href="#了解ServletContext对象" class="headerlink" title="了解ServletContext对象"></a>了解ServletContext对象</h3><p>ServletContext全局唯一，它是属于整个Web应用程序的，我们可以通过<code>getServletContext()</code>来获取到此对象。</p><p>此对象也能设置附加值：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ServletContext context = getServletContext();<br>context.setAttribute(<span class="hljs-string">"test"</span>, <span class="hljs-string">"我是重定向之前的数据"</span>);<br>resp.sendRedirect(<span class="hljs-string">"time"</span>);<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(getServletContext().getAttribute(<span class="hljs-string">"test"</span>));<br></code></pre></td></tr></tbody></table></figure><p>因为无论在哪里，无论什么时间，获取到的ServletContext始终是同一个对象，因此我们可以随时随地获取我们添加的属性。</p><p>它不仅仅可以用来进行数据传递，还可以做一些其他的事情，比如请求转发：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">context.getRequestDispatcher(<span class="hljs-string">"/time"</span>).forward(req, resp);<br></code></pre></td></tr></tbody></table></figure><p>它还可以获取根目录下的资源文件（注意是webapp根目录下的，不是resource中的资源）</p><h3 id="初始化参数"><a href="#初始化参数" class="headerlink" title="初始化参数"></a>初始化参数</h3><p>初始化参数类似于初始化配置需要的一些值，比如我们的数据库连接相关信息，就可以通过初始化参数来给予Servlet，或是一些其他的配置项，也可以使用初始化参数来实现。</p><p>我们可以给一个Servlet添加一些初始化参数：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(value = "/login", initParams = {</span><br><span class="hljs-meta">        @WebInitParam(name = "test", value = "我是一个默认的初始化参数")</span><br><span class="hljs-meta">})</span><br></code></pre></td></tr></tbody></table></figure><p>它也是以键值对形式保存的，我们可以直接通过Servlet的<code>getInitParameter</code>方法获取：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(getInitParameter(<span class="hljs-string">"test"</span>));<br></code></pre></td></tr></tbody></table></figure><p>但是，这里的初始化参数仅仅是针对于此Servlet，我们也可以定义全局初始化参数，只需要在web.xml编写即可：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>lbwnb<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>我是全局初始化参数<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>我们需要使用ServletContext来读取全局初始化参数：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ServletContext context = getServletContext();<br>System.out.println(context.getInitParameter(<span class="hljs-string">"lbwnb"</span>));<br></code></pre></td></tr></tbody></table></figure><p>有关ServletContext其他的内容，我们需要完成后面内容的学习，才能理解。</p><hr><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>什么是Cookie？不是曲奇，它可以在浏览器中保存一些信息，并且在下次请求时，请求头中会携带这些信息。</p><p>我们可以编写一个测试用例来看看：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">"test"</span>, <span class="hljs-string">"yyds"</span>);<br>resp.addCookie(cookie);<br>resp.sendRedirect(<span class="hljs-string">"time"</span>);<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Cookie cookie : req.getCookies()) {<br>    System.out.println(cookie.getName() + <span class="hljs-string">": "</span> + cookie.getValue());<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以观察一下，在<code>HttpServletResponse</code>中添加Cookie之后，浏览器的响应头中会包含一个<code>Set-Cookie</code>属性，同时，在重定向之后，我们的请求头中，会携带此Cookie作为一个属性，同时，我们可以直接通过<code>HttpServletRequest</code>来快速获取有哪些Cookie信息。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.uml.org.cn%2Fxjs%2Fimages%2F2019032226.jpg&amp;refer=http%3A%2F%2Fwww.uml.org.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1640427806&amp;t=a452f8b27a0769ca82d2269664e71a5e" alt="点击查看源网页"></p><p>还有这么神奇的事情吗？那么我们来看看，一个Cookie包含哪些信息：</p><ul><li>name   -   Cookie的名称，Cookie一旦创建，名称便不可更改</li><li>value  -   Cookie的值，如果值为Unicode字符，需要为字符编码。如果为二进制数据，则需要使用BASE64编码</li><li>maxAge  -  Cookie失效的时间，单位秒。如果为正数，则该Cookie在maxAge秒后失效。如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。如果为0，表示删除该Cookie。默认为-1。</li><li>secure  -  该Cookie是否仅被使用安全协议传输。安全协议。安全协议有HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false。</li><li>path  -  Cookie的使用路径。如果设置为“/sessionWeb/”，则只有contextPath为“/sessionWeb”的程序可以访问该Cookie。如果设置为“/”，则本域名下contextPath都可以访问该Cookie。注意最后一个字符必须为“/”。</li><li>domain  -  可以访问该Cookie的域名。如果设置为“.google.com”，则所有以“google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”。</li><li>comment  -  该Cookie的用处说明，浏览器显示Cookie信息的时候显示该说明。</li><li>version  -  Cookie使用的版本号。0表示遵循Netscape的Cookie规范，1表示遵循W3C的RFC 2109规范</li></ul><p>我们发现，最关键的其实是<code>name</code>、<code>value</code>、<code>maxAge</code>、<code>domain</code>属性。</p><p>那么我们来尝试修改一下maxAge来看看失效时间：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">cookie.setMaxAge(<span class="hljs-number">20</span>);<br></code></pre></td></tr></tbody></table></figure><p>设定为20秒，我们可以直接看到，响应头为我们设定了20秒的过期时间。20秒内访问都会携带此Cookie，而超过20秒，Cookie消失。</p><p>既然了解了Cookie的作用，我们就可以通过使用Cookie来实现记住我功能，我们可以将用户名和密码全部保存在Cookie中，如果访问我们的首页时携带了这些Cookie，那么我们就可以直接为用户进行登陆，如果登陆成功则直接跳转到首页，如果登陆失败，则清理浏览器中的Cookie。</p><p>那么首先，我们先在前端页面的表单中添加一个勾选框：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"记住我"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"remember-me"</span>&gt;</span><br>        记住我<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>接着，我们在登陆成功时进行判断，如果用户勾选了记住我，那么就讲Cookie存储到本地：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(map.containsKey(<span class="hljs-string">"remember-me"</span>)){   <span class="hljs-comment">//若勾选了勾选框，那么会此表单信息</span><br>    Cookie cookie_username = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">"username"</span>, username);<br>    cookie_username.setMaxAge(<span class="hljs-number">30</span>);<br>    Cookie cookie_password = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">"password"</span>, password);<br>    cookie_password.setMaxAge(<span class="hljs-number">30</span>);<br>    resp.addCookie(cookie_username);<br>    resp.addCookie(cookie_password);<br>}<br></code></pre></td></tr></tbody></table></figure><p>然后，我们修改一下默认的请求地址，现在一律通过<code>http://localhost:8080/yyds/login</code>进行登陆，那么我们需要添加GET请求的相关处理：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>{<br>    Cookie[] cookies = req.getCookies();<br>    <span class="hljs-keyword">if</span>(cookies != <span class="hljs-keyword">null</span>){<br>        String username = <span class="hljs-keyword">null</span>;<br>        String password = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">for</span> (Cookie cookie : cookies) {<br>            <span class="hljs-keyword">if</span>(cookie.getName().equals(<span class="hljs-string">"username"</span>)) username = cookie.getValue();<br>            <span class="hljs-keyword">if</span>(cookie.getName().equals(<span class="hljs-string">"password"</span>)) password = cookie.getValue();<br>        }<br>        <span class="hljs-keyword">if</span>(username != <span class="hljs-keyword">null</span> &amp;&amp; password != <span class="hljs-keyword">null</span>){<br>            <span class="hljs-comment">//登陆校验</span><br>            <span class="hljs-keyword">try</span> (SqlSession sqlSession = factory.openSession(<span class="hljs-keyword">true</span>)){<br>                UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br>                User user = mapper.getUser(username, password);<br>                <span class="hljs-keyword">if</span>(user != <span class="hljs-keyword">null</span>){<br>                    resp.sendRedirect(<span class="hljs-string">"time"</span>);<br>                    <span class="hljs-keyword">return</span>;   <span class="hljs-comment">//直接返回</span><br>                }<br>            }<br>        }<br>    }<br>    req.getRequestDispatcher(<span class="hljs-string">"/"</span>).forward(req, resp);   <span class="hljs-comment">//正常情况还是转发给默认的Servlet帮我们返回静态页面</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>现在，30秒内都不需要登陆，访问登陆页面后，会直接跳转到time页面。</p><p>现在已经离我们理想的页面越来越接近了，但是仍然有一个问题，就是我们的首页，无论是否登陆，所有人都可以访问，那么，如何才可以实现只有登陆之后才能访问呢？这就需要用到Session了。</p><hr><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>由于HTTP是无连接的，那么如何能够辨别当前的请求是来自哪个用户发起的呢？Session就是用来处理这种问题的，每个用户的会话都会有一个自己的Session对象，来自同一个浏览器的所有请求，就属于同一个会话。</p><p>但是HTTP协议是无连接的呀，那Session是如何做到辨别是否来自同一个浏览器呢？Session实际上是基于Cookie实现的，前面我们了解了Cookie，我们知道，服务端可以将Cookie保存到浏览器，当浏览器下次访问时，就会附带这些Cookie信息。</p><p>Session也利用了这一点，它会给浏览器设定一个叫做<code>JSESSIONID</code>的Cookie，值是一个随机的排列组合，而此Cookie就对应了你属于哪一个对话，只要我们的浏览器携带此Cookie访问服务器，服务器就会通过Cookie的值进行辨别，得到对应的Session对象，因此，这样就可以追踪到底是哪一个浏览器在访问服务器。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.xaecong.com%2Fuploadfile%2F2018-5%2F20180511113613649.gif&amp;refer=http%3A%2F%2Fwww.xaecong.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1640433362&amp;t=bbfd240d9a7ec60468840f01b097d2a2" alt="点击查看源网页"></p><p>那么现在，我们在用户登录成功之后，将用户对象添加到Session中，只要是此用户发起的请求，我们都可以从<code>HttpSession</code>中读取到存储在会话中的数据：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">HttpSession session = req.getSession();<br>session.setAttribute(<span class="hljs-string">"user"</span>, user);<br></code></pre></td></tr></tbody></table></figure><p>同时，如果用户没有登录就去访问首页，那么我们将发送一个重定向请求，告诉用户，需要先进行登录才可以访问：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">HttpSession session = req.getSession();<br>User user = (User) session.getAttribute(<span class="hljs-string">"user"</span>);<br><span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span>) {<br>    resp.sendRedirect(<span class="hljs-string">"login"</span>);<br>    <span class="hljs-keyword">return</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>在访问的过程中，注意观察Cookie变化。</p><p>Session并不是永远都存在的，它有着自己的过期时间，默认时间为30分钟，若超过此时间，Session将丢失，我们可以在配置文件中修改过期时间：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>我们也可以在代码中使用<code>invalidate</code>方法来使Session立即失效：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">session.invalidate();<br></code></pre></td></tr></tbody></table></figure><p>现在，通过Session，我们就可以更好地控制用户对于资源的访问，只有完成登陆的用户才有资格访问首页。</p><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>有了Session之后，我们就可以很好地控制用户的登陆验证了，只有授权的用户，才可以访问一些页面，但是我们需要一个一个去进行配置，还是太过复杂，能否一次性地过滤掉没有登录验证的用户呢？</p><p>过滤器相当于在所有访问前加了一堵墙，来自浏览器的所有访问请求都会首先经过过滤器，只有过滤器允许通过的请求，才可以顺利地到达对应的Servlet，而过滤器不允许的通过的请求，我们可以自由地进行控制是否进行重定向或是请求转发。并且过滤器可以添加很多个，就相当于添加了很多堵墙，我们的请求只有穿过层层阻碍，才能与Servlet相拥，像极了爱情。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimages.cnitblog.com%2Fblog%2F150046%2F201501%2F072114593437292.png&amp;refer=http%3A%2F%2Fimages.cnitblog.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1640479081&amp;t=a1259950e28398b095ea7ce30c022904" alt="点击查看源网页"></p><p>添加一个过滤器非常简单，只需要实现Filter接口，并添加<code>@WebFilter</code>注解即可：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebFilter("/*")</span>   <span class="hljs-comment">//路径的匹配规则和Servlet一致，这里表示匹配所有请求</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>{<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>{<br>        <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>这样我们就成功地添加了一个过滤器，那么添加一句打印语句看看，是否所有的请求都会经过此过滤器：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">HttpServletRequest request = (HttpServletRequest) servletRequest;<br>System.out.println(request.getRequestURL());<br></code></pre></td></tr></tbody></table></figure><p>我们发现，现在我们发起的所有请求，一律需要经过此过滤器，并且所有的请求都没有任何的响应内容。</p><p>那么如何让请求可以顺利地到达对应的Servlet，也就是说怎么让这个请求顺利通过呢？我们只需要在最后添加一句：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">filterChain.doFilter(servletRequest, servletResponse);<br></code></pre></td></tr></tbody></table></figure><p>那么这行代码是什么意思呢？</p><p>由于我们整个应用程序可能存在多个过滤器，那么这行代码的意思实际上是将此请求继续传递给下一个过滤器，当没有下一个过滤器时，才会到达对应的Servlet进行处理，我们可以再来创建一个过滤器看看效果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebFilter("/*")</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFilter2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>{<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>{<br>        System.out.println(<span class="hljs-string">"我是2号过滤器"</span>);<br>        filterChain.doFilter(servletRequest, servletResponse);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>由于过滤器的过滤顺序是按照类名的自然排序进行的，因此我们将第一个过滤器命名进行调整。</p><p>我们发现，在经过第一个过滤器之后，会继续前往第二个过滤器，只有两个过滤器全部经过之后，才会到达我们的Servlet中。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimages.cnitblog.com%2Fblog%2F34303%2F201212%2F30153033-d9e09a9c8dfe403fb9f6303052ba4b6c.png&amp;refer=http%3A%2F%2Fimages.cnitblog.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1640479150&amp;t=d14eb2b4c2a3d6e987fc9cf6680a326f" alt="点击查看源网页"></p><p>实际上，当<code>doFilter</code>方法调用时，就会一直向下直到Servlet，在Servlet处理完成之后，又依次返回到最前面的Filter，类似于递归的结构，我们添加几个输出语句来判断一下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>{<br>    System.out.println(<span class="hljs-string">"我是2号过滤器"</span>);<br>    filterChain.doFilter(servletRequest, servletResponse);<br>    System.out.println(<span class="hljs-string">"我是2号过滤器，处理后"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>{<br>    System.out.println(<span class="hljs-string">"我是1号过滤器"</span>);<br>    filterChain.doFilter(servletRequest, servletResponse);<br>    System.out.println(<span class="hljs-string">"我是1号过滤器，处理后"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>最后验证我们的结论。</p><p>同Servlet一样，Filter也有对应的HttpFilter专用类，它针对HTTP请求进行了专门处理，因此我们可以直接使用HttpFilter来编写：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericFilter</span> </span>{<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">7478463438252262094L</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpFilter</span><span class="hljs-params">()</span> </span>{<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>{<br>        <span class="hljs-keyword">if</span> (req <span class="hljs-keyword">instanceof</span> HttpServletRequest &amp;&amp; res <span class="hljs-keyword">instanceof</span> HttpServletResponse) {<br>            <span class="hljs-keyword">this</span>.doFilter((HttpServletRequest)req, (HttpServletResponse)res, chain);<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ServletException(<span class="hljs-string">"non-HTTP request or response"</span>);<br>        }<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse res, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>{<br>        chain.doFilter(req, res);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>那么现在，我们就可以给我们的应用程序添加一个过滤器，用户在未登录情况下，只允许静态资源和登陆页面请求通过，登陆之后畅行无阻：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebFilter("/*")</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpFilter</span> </span>{<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse res, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>{<br>        String url = req.getRequestURL().toString();<br>        <span class="hljs-comment">//判断是否为静态资源</span><br>        <span class="hljs-keyword">if</span>(!url.endsWith(<span class="hljs-string">".js"</span>) &amp;&amp; !url.endsWith(<span class="hljs-string">".css"</span>) &amp;&amp; !url.endsWith(<span class="hljs-string">".png"</span>)){<br>            HttpSession session = req.getSession();<br>            User user = (User) session.getAttribute(<span class="hljs-string">"user"</span>);<br>            <span class="hljs-comment">//判断是否未登陆</span><br>            <span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span> &amp;&amp; !url.endsWith(<span class="hljs-string">"login"</span>)){<br>                res.sendRedirect(<span class="hljs-string">"login"</span>);<br>                <span class="hljs-keyword">return</span>;<br>            }<br>        }<br>        <span class="hljs-comment">//交给过滤链处理</span><br>        chain.doFilter(req, res);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>现在，我们的页面已经基本完善为我们想要的样子了。</p><p>当然，可能跟着教程编写的项目比较乱，大家可以自己花费一点时间来重新编写一个Web应用程序，加深对之前讲解知识的理解。我们也会在之后安排一个编程实战进行深化练习。</p><hr><h2 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h2><p>监听器并不是我们学习的重点内容，那么什么是监听器呢？</p><p>如果我们希望，在应用程序加载的时候，或是Session创建的时候，亦或是在Request对象创建的时候进行一些操作，那么这个时候，我们就可以使用监听器来实现。</p><p><img src="https://img-blog.csdn.net/20180825212011379?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MjA0MTc5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>默认为我们提供了很多类型的监听器，我们这里就演示一下监听Session的创建即可：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebListener</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpSessionListener</span> </span>{<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionCreated</span><span class="hljs-params">(HttpSessionEvent se)</span> </span>{<br>        System.out.println(<span class="hljs-string">"有一个Session被创建了"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>有关监听器相关内容，了解即可。</p><hr><h2 id="了解JSP页面与加载规则"><a href="#了解JSP页面与加载规则" class="headerlink" title="了解JSP页面与加载规则"></a>了解JSP页面与加载规则</h2><p>前面我们已经完成了整个Web应用程序生命周期中所有内容的学习，我们已经完全了解，如何编写一个Web应用程序，并放在Tomcat上部署运行，以及如何控制浏览器发来的请求，通过Session+Filter实现用户登陆验证，通过Cookie实现自动登陆等操作。到目前为止，我们已经具备编写一个完整Web网站的能力。</p><p>在之前的教程中，我们的前端静态页面并没有与后端相结合，我们前端页面所需的数据全部需要单独向后端发起请求获取，并动态进行内容填充，这是一种典型的前后端分离写法，前端只负责要数据和显示数据，后端只负责处理数据和提供数据，这也是现在更流行的一种写法，让前端开发者和后端开发者各尽其责，更加专一，这才是我们所希望的开发模式。</p><p>JSP并不是我们需要重点学习的内容，因为它已经过时了，使用JSP会导致前后端严重耦合，因此这里只做了解即可。</p><p>JSP其实就是一种模板引擎，那么何谓模板引擎呢？顾名思义，它就是一个模板，而模板需要我们填入数据，才可以变成一个页面，也就是说，我们可以直接在前端页面中直接填写数据，填写后生成一个最终的HTML页面返回给前端。</p><p>首先我们来创建一个新的项目，项目创建成功后，删除Java目录下的内容，只留下默认创建的jsp文件，我们发现，在webapp目录中，存在一个<code>index.jsp</code>文件，现在我们直接运行项目，会直接访问这个JSP页面。</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">"text/html; charset=UTF-8"</span> pageEncoding=<span class="hljs-string">"UTF-8"</span> %&gt;<br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;JSP - Hello World&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;&lt;%= <span class="hljs-string">"Hello World!"</span> %&gt;<br>&lt;/h1&gt;<br>&lt;br/&gt;<br>&lt;a href="hello-servlet"&gt;Hello Servlet&lt;/a&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></tbody></table></figure><p>但是我们并没有编写对应的Servlet来解析啊，那么为什么这个JSP页面会被加载呢？</p><p>实际上，我们一开始提到的两个Tomcat默认的Servlet中，一个是用于请求静态资源，还有一个就是用于处理jsp的：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- The mappings for the JSP servlet --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>jsp<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.jspx<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>那么，JSP和普通HTML页面有什么区别呢，我们发现它的语法和普通HTML页面几乎一致，我们可以直接在JSP中编写Java代码，并在页面加载的时候执行，我们随便找个地方插入：</p><figure class="highlight jsp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%<br>    System.out.println(<span class="hljs-string">"JSP页面被加载"</span>);<br>%&gt;<br></code></pre></td></tr></tbody></table></figure><p>我们发现，请求一次页面，页面就会加载一次，并执行我们填写的Java代码。也就是说，我们可以直接在此页面中执行Java代码来填充我们的数据，这样我们的页面就变成了一个动态页面，使用<code>&lt;%=  %&gt;</code>来填写一个值：</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;h1&gt;&lt;%= new Date() %&gt;&lt;/h1&gt;<br></code></pre></td></tr></tbody></table></figure><p>现在访问我们的网站，每次都会创建一个新的Date对象，因此每次访问获取的时间都不一样，我们的网站已经算是一个动态的网站的了。</p><p>虽然这样在一定程度上上为我们提供了便利，但是这样的写法相当于整个页面既要编写前端代码，也要编写后端代码，随着项目的扩大，整个页面会显得难以阅读，并且现在都是前后端开发人员职责非常明确的，如果要编写JSP页面，那就必须要招一个既会前端也会后端的程序员，这样显然会导致不必要的开销。</p><p>那么我们来研究一下，为什么JSP页面能够在加载的时候执行Java代码呢？</p><p>首先我们将此项目打包，并在Tomcat服务端中运行，生成了一个文件夹并且可以正常访问。</p><p>我们现在看到<code>work</code>目录，我们发现这个里面多了一个<code>index_jsp.java</code>和<code>index_jsp.class</code>，那么这些东西是干嘛的呢，我们来反编译一下就啥都知道了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">index_jsp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">org</span>.<span class="hljs-title">apache</span>.<span class="hljs-title">jasper</span>.<span class="hljs-title">runtime</span>.<span class="hljs-title">HttpJspBase</span>  //继承自<span class="hljs-title">HttpServlet</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">org</span>.<span class="hljs-title">apache</span>.<span class="hljs-title">jasper</span>.<span class="hljs-title">runtime</span>.<span class="hljs-title">JspSourceDependent</span>,</span><br><span class="hljs-class">                 <span class="hljs-title">org</span>.<span class="hljs-title">apache</span>.<span class="hljs-title">jasper</span>.<span class="hljs-title">runtime</span>.<span class="hljs-title">JspSourceImports</span> </span>{<br><br> ...<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">_jspService</span><span class="hljs-params">(<span class="hljs-keyword">final</span> jakarta.servlet.http.HttpServletRequest request, <span class="hljs-keyword">final</span> jakarta.servlet.http.HttpServletResponse response)</span></span><br><span class="hljs-function">      <span class="hljs-keyword">throws</span> java.io.IOException, jakarta.servlet.ServletException </span>{<br><br>    <span class="hljs-keyword">if</span> (!jakarta.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) {<br>      <span class="hljs-keyword">final</span> java.lang.String _jspx_method = request.getMethod();<br>      <span class="hljs-keyword">if</span> (<span class="hljs-string">"OPTIONS"</span>.equals(_jspx_method)) {<br>        response.setHeader(<span class="hljs-string">"Allow"</span>,<span class="hljs-string">"GET, HEAD, POST, OPTIONS"</span>);<br>        <span class="hljs-keyword">return</span>;<br>      }<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-string">"GET"</span>.equals(_jspx_method) &amp;&amp; !<span class="hljs-string">"POST"</span>.equals(_jspx_method) &amp;&amp; !<span class="hljs-string">"HEAD"</span>.equals(_jspx_method)) {<br>        response.setHeader(<span class="hljs-string">"Allow"</span>,<span class="hljs-string">"GET, HEAD, POST, OPTIONS"</span>);<br>        response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, <span class="hljs-string">"JSP 只允许 GET、POST 或 HEAD。Jasper 还允许 OPTIONS"</span>);<br>        <span class="hljs-keyword">return</span>;<br>      }<br>    }<br><br>    <span class="hljs-keyword">final</span> jakarta.servlet.jsp.PageContext pageContext;<br>    jakarta.servlet.http.HttpSession session = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">final</span> jakarta.servlet.ServletContext application;<br>    <span class="hljs-keyword">final</span> jakarta.servlet.ServletConfig config;<br>    jakarta.servlet.jsp.JspWriter out = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">final</span> java.lang.Object page = <span class="hljs-keyword">this</span>;<br>    jakarta.servlet.jsp.JspWriter _jspx_out = <span class="hljs-keyword">null</span>;<br>    jakarta.servlet.jsp.PageContext _jspx_page_context = <span class="hljs-keyword">null</span>;<br><br><br>    <span class="hljs-keyword">try</span> {<br>      response.setContentType(<span class="hljs-string">"text/html; charset=UTF-8"</span>);<br>      pageContext = _jspxFactory.getPageContext(<span class="hljs-keyword">this</span>, request, response,<br>             <span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>, <span class="hljs-number">8192</span>, <span class="hljs-keyword">true</span>);<br>      _jspx_page_context = pageContext;<br>      application = pageContext.getServletContext();<br>      config = pageContext.getServletConfig();<br>      session = pageContext.getSession();<br>      out = pageContext.getOut();<br>      _jspx_out = out;<br><br>      out.write(<span class="hljs-string">"\n"</span>);<br>      out.write(<span class="hljs-string">"\n"</span>);<br>      out.write(<span class="hljs-string">"&lt;!DOCTYPE html&gt;\n"</span>);<br>      out.write(<span class="hljs-string">"&lt;html&gt;\n"</span>);<br>      out.write(<span class="hljs-string">"&lt;head&gt;\n"</span>);<br>      out.write(<span class="hljs-string">"    &lt;title&gt;JSP - Hello World&lt;/title&gt;\n"</span>);<br>      out.write(<span class="hljs-string">"&lt;/head&gt;\n"</span>);<br>      out.write(<span class="hljs-string">"&lt;body&gt;\n"</span>);<br>      out.write(<span class="hljs-string">"&lt;h1&gt;"</span>);<br>      out.print( <span class="hljs-keyword">new</span> Date() );<br>      out.write(<span class="hljs-string">"&lt;/h1&gt;\n"</span>);<br><br>    System.out.println(<span class="hljs-string">"JSP页面被加载"</span>);<br><br>      out.write(<span class="hljs-string">"\n"</span>);<br>      out.write(<span class="hljs-string">"&lt;br/&gt;\n"</span>);<br>      out.write(<span class="hljs-string">"&lt;a href=\"hello-servlet\"&gt;Hello Servlet&lt;/a&gt;\n"</span>);<br>      out.write(<span class="hljs-string">"&lt;/body&gt;\n"</span>);<br>      out.write(<span class="hljs-string">"&lt;/html&gt;"</span>);<br>    } <span class="hljs-keyword">catch</span> (java.lang.Throwable t) {<br>      <span class="hljs-keyword">if</span> (!(t <span class="hljs-keyword">instanceof</span> jakarta.servlet.jsp.SkipPageException)){<br>        out = _jspx_out;<br>        <span class="hljs-keyword">if</span> (out != <span class="hljs-keyword">null</span> &amp;&amp; out.getBufferSize() != <span class="hljs-number">0</span>)<br>          <span class="hljs-keyword">try</span> {<br>            <span class="hljs-keyword">if</span> (response.isCommitted()) {<br>              out.flush();<br>            } <span class="hljs-keyword">else</span> {<br>              out.clearBuffer();<br>            }<br>          } <span class="hljs-keyword">catch</span> (java.io.IOException e) {}<br>        <span class="hljs-keyword">if</span> (_jspx_page_context != <span class="hljs-keyword">null</span>) _jspx_page_context.handlePageException(t);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ServletException(t);<br>      }<br>    } <span class="hljs-keyword">finally</span> {<br>      _jspxFactory.releasePageContext(_jspx_page_context);<br>    }<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现，它是继承自<code>HttpJspBase</code>类，我们可以反编译一下jasper.jar（它在tomcat的lib目录中）来看看:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.apache.jasper.runtime;<br><br><span class="hljs-keyword">import</span> jakarta.servlet.ServletConfig;<br><span class="hljs-keyword">import</span> jakarta.servlet.ServletException;<br><span class="hljs-keyword">import</span> jakarta.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> jakarta.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> jakarta.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> jakarta.servlet.jsp.HttpJspPage;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> org.apache.jasper.compiler.Localizer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpJspBase</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpJspPage</span> </span>{<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">HttpJspBase</span><span class="hljs-params">()</span> </span>{<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ServletConfig config)</span> <span class="hljs-keyword">throws</span> ServletException </span>{<br>        <span class="hljs-keyword">super</span>.init(config);<br>        <span class="hljs-keyword">this</span>.jspInit();<br>        <span class="hljs-keyword">this</span>._jspInit();<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getServletInfo</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> Localizer.getMessage(<span class="hljs-string">"jsp.engine.info"</span>, <span class="hljs-keyword">new</span> Object[]{<span class="hljs-string">"3.0"</span>});<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">this</span>.jspDestroy();<br>        <span class="hljs-keyword">this</span>._jspDestroy();<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>{<br>        <span class="hljs-keyword">this</span>._jspService(request, response);<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jspInit</span><span class="hljs-params">()</span> </span>{<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">_jspInit</span><span class="hljs-params">()</span> </span>{<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jspDestroy</span><span class="hljs-params">()</span> </span>{<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">_jspDestroy</span><span class="hljs-params">()</span> </span>{<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">_jspService</span><span class="hljs-params">(HttpServletRequest var1, HttpServletResponse var2)</span> <span class="hljs-keyword">throws</span> ServletException, IOException</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>实际上，Tomcat在加载JSP页面时，会将其动态转换为一个java类并编译为class进行加载，而生成的Java类，正是一个Servlet的子类，而页面的内容全部被编译为输出字符串，这便是JSP的加载原理，因此，JSP本质上依然是一个Servlet！</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.debugrun.com%2Fpic%2F2017%2F10%2F8%2F017e6d66d6d9589dfc7377a052ca8047.png&amp;refer=http%3A%2F%2Fimg.debugrun.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1640487718&amp;t=2656b55a2eb461b4a90afb1076aeb355" alt="点击查看源网页"></p><p>如果同学们感兴趣的话，可以查阅一下其他相关的教程，本教程不再讲解此技术。</p><hr><h2 id="使用Thymeleaf模板引擎"><a href="#使用Thymeleaf模板引擎" class="headerlink" title="使用Thymeleaf模板引擎"></a>使用Thymeleaf模板引擎</h2><p>虽然JSP为我们带来了便捷，但是其缺点也是显而易见的，那么有没有一种既能实现模板，又能兼顾前后端分离的模板引擎呢？</p><p><strong>Thymeleaf</strong>（百里香叶）是一个适用于Web和独立环境的现代化服务器端Java模板引擎，官方文档：<a href="https://www.thymeleaf.org/documentation.html%E3%80%82">https://www.thymeleaf.org/documentation.html。</a></p><p>那么它和JSP相比，好在哪里呢，我们来看官网给出的例子：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"#{msgs.headers.name}"</span>&gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"#{msgs.headers.price}"</span>&gt;</span>Price<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">"prod: ${allProducts}"</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${prod.name}"</span>&gt;</span>Oranges<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${#numbers.formatDecimal(prod.price, 1, 2)}"</span>&gt;</span>0.99<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>我们可以在前端页面中填写占位符，而这些占位符的实际值则由后端进行提供，这样，我们就不用再像JSP那样前后端都写在一起了。</p><p>那么我们来创建一个例子感受一下，首先还是新建一个项目，注意，在创建时，勾选Thymeleaf依赖。</p><p>首先编写一个前端页面，名称为<code>test.html</code>，注意，是放在resource目录下，在html标签内部添加<code>xmlns:th="http://www.thymeleaf.org"</code>引入Thymeleaf定义的标签属性：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${title}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>接着我们编写一个Servlet作为默认页面：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet("/index")</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>{<br><br>    TemplateEngine engine;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>{<br>        engine = <span class="hljs-keyword">new</span> TemplateEngine();<br>        ClassLoaderTemplateResolver r = <span class="hljs-keyword">new</span> ClassLoaderTemplateResolver();<br>        engine.setTemplateResolver(r);<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>{<br>        Context context = <span class="hljs-keyword">new</span> Context();<br>        context.setVariable(<span class="hljs-string">"title"</span>, <span class="hljs-string">"我是标题"</span>);<br>        engine.process(<span class="hljs-string">"test.html"</span>, context, resp.getWriter());<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现，浏览器得到的页面，就是已经经过模板引擎解析好的页面，而我们的代码依然是后端处理数据，前端展示数据，因此使用Thymeleaf就能够使得当前Web应用程序的前后端划分更加清晰。</p><p>虽然Thymeleaf在一定程度上分离了前后端，但是其依然是在后台渲染HTML页面并发送给前端，并不是真正意义上的前后端分离。</p><h3 id="Thymeleaf语法基础"><a href="#Thymeleaf语法基础" class="headerlink" title="Thymeleaf语法基础"></a>Thymeleaf语法基础</h3><p>那么，如何使用Thymeleaf呢？</p><p>首先我们看看后端部分，我们需要通过<code>TemplateEngine</code>对象来将模板文件渲染为最终的HTML页面：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">TemplateEngine engine;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>{<br>    engine = <span class="hljs-keyword">new</span> TemplateEngine();<br>  <span class="hljs-comment">//设定模板解析器决定了从哪里获取模板文件，这里直接使用ClassLoaderTemplateResolver表示加载内部资源文件</span><br>    ClassLoaderTemplateResolver r = <span class="hljs-keyword">new</span> ClassLoaderTemplateResolver();<br>    engine.setTemplateResolver(r);<br>}<br></code></pre></td></tr></tbody></table></figure><p>由于此对象只需要创建一次，之后就可以一直使用了。接着我们来看如何使用模板引擎进行解析：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>{<br>    <span class="hljs-comment">//创建上下文，上下文中包含了所有需要替换到模板中的内容</span><br>    Context context = <span class="hljs-keyword">new</span> Context();<br>    context.setVariable(<span class="hljs-string">"title"</span>, <span class="hljs-string">"&lt;h1&gt;我是标题&lt;/h1&gt;"</span>);<br>    <span class="hljs-comment">//通过此方法就可以直接解析模板并返回响应</span><br>    engine.process(<span class="hljs-string">"test.html"</span>, context, resp.getWriter());<br>}<br></code></pre></td></tr></tbody></table></figure><p>操作非常简单，只需要简单几步配置就可以实现模板的解析。接下来我们就可以在前端页面中通过上下文提供的内容，来将Java代码中的数据解析到前端页面。</p><p>接着我们来了解Thymeleaf如何为普通的标签添加内容，比如我们示例中编写的：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${title}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>我们使用了<code>th:text</code>来为当前标签指定内部文本，注意任何内容都会变成普通文本，即使传入了一个HTML代码，如果我希望向内部添加一个HTML文本呢？我们可以使用<code>th:utext</code>属性：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:utext</span>=<span class="hljs-string">"${title}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>并且，传入的title属性，不仅仅只是一个字符串的值，而是一个字符串的引用，我们可以直接通过此引用调用相关的方法：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${title.toLowerCase()}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>这样看来，Thymeleaf既能保持JSP为我们带来的便捷，也能兼顾前后端代码的界限划分。</p><p>除了替换文本，它还支持替换一个元素的任意属性，我们发现，<code>th:</code>能够拼接几乎所有的属性，一旦使用<code>th:属性名称</code>，那么属性的值就可以通过后端提供了，比如我们现在想替换一个图片的链接：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>{<br>    Context context = <span class="hljs-keyword">new</span> Context();<br>    context.setVariable(<span class="hljs-string">"url"</span>, <span class="hljs-string">"http://n.sinaimg.cn/sinakd20121/600/w1920h1080/20210727/a700-adf8480ff24057e04527bdfea789e788.jpg"</span>);<br>  context.setVariable(<span class="hljs-string">"alt"</span>, <span class="hljs-string">"图片就是加载不出来啊"</span>);<br>    engine.process(<span class="hljs-string">"test.html"</span>, context, resp.getWriter());<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"700"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"${url}"</span> <span class="hljs-attr">th:alt</span>=<span class="hljs-string">"${alt}"</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>现在访问我们的页面，就可以看到替换后的结果了。</p><p>Thymeleaf还可以进行一些算术运算，几乎Java中的运算它都可以支持：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${value % 2}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>同样的，它还支持三元运算：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${value % 2 == 0 ? 'yyds' : 'lbwnb'}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>多个属性也可以通过<code>+</code>进行拼接，就像Java中的字符串拼接一样，这里要注意一下，字符串不能直接写，要添加单引号：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${name}+' 我是文本 '+${value}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><h3 id="Thymeleaf流程控制语法"><a href="#Thymeleaf流程控制语法" class="headerlink" title="Thymeleaf流程控制语法"></a>Thymeleaf流程控制语法</h3><p>除了一些基本的操作，我们还可以使用Thymeleaf来处理流程控制语句，当然，不是直接编写Java代码的形式，而是添加一个属性即可。</p><p>首先我们来看if判断语句，如果if条件满足，则此标签留下，若if条件不满足，则此标签自动被移除：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>{<br>    Context context = <span class="hljs-keyword">new</span> Context();<br>    context.setVariable(<span class="hljs-string">"eval"</span>, <span class="hljs-keyword">true</span>);<br>    engine.process(<span class="hljs-string">"test.html"</span>, context, resp.getWriter());<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">"${eval}"</span>&gt;</span>我是判断条件标签<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p><code>th:if</code>会根据其中传入的值或是条件表达式的结果进行判断，只有满足的情况下，才会显示此标签，具体的判断规则如下：</p><ul><li>如果值不是空的：<ul><li>如果值是布尔值并且为<code>true</code>。</li><li>如果值是一个数字，并且是非零</li><li>如果值是一个字符，并且是非零</li><li>如果值是一个字符串，而不是“错误”、“关闭”或“否”</li><li>如果值不是布尔值、数字、字符或字符串。</li></ul></li><li>如果值为空，th:if将计算为false</li></ul><p><code>th:if</code>还有一个相反的属性<code>th:unless</code>，效果完全相反，这里就不演示了。</p><p>我们接着来看多分支条件判断，我们可以使用<code>th:switch</code>属性来实现：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:switch</span>=<span class="hljs-string">"${eval}"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:case</span>=<span class="hljs-string">"1"</span>&gt;</span>我是1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:case</span>=<span class="hljs-string">"2"</span>&gt;</span>我是2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:case</span>=<span class="hljs-string">"3"</span>&gt;</span>我是3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>只不过没有default属性，但是我们可以使用<code>th:case="*"</code>来代替：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:case</span>=<span class="hljs-string">"*"</span>&gt;</span>我是Default<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>最后我们再来看看，它如何实现遍历，假如我们有一个存放书籍信息的List需要显示，那么如何快速生成一个列表呢？我们可以使用<code>th:each</code>来进行遍历操作：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>{<br>    Context context = <span class="hljs-keyword">new</span> Context();<br>    context.setVariable(<span class="hljs-string">"list"</span>, Arrays.asList(<span class="hljs-string">"伞兵一号的故事"</span>, <span class="hljs-string">"倒一杯卡布奇诺"</span>, <span class="hljs-string">"玩游戏要啸着玩"</span>, <span class="hljs-string">"十七张牌前的电脑屏幕"</span>));<br>    engine.process(<span class="hljs-string">"test.html"</span>, context, resp.getWriter());<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">"title : ${list}"</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"'《'+${title}+'》'"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p><code>th:each</code>中需要填写 “单个元素名称 : ${列表}”，这样，所有的列表项都可以使用遍历的单个元素，只要使用了<code>th:each</code>，都会被循环添加。因此最后生成的结果为：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>《伞兵一号的故事》<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>《倒一杯卡布奇诺》<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>《玩游戏要啸着玩》<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>《十七张牌前的电脑屏幕》<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>我们还可以获取当前循环的迭代状态，只需要在最后添加<code>iterStat</code>即可，从中可以获取很多信息，比如当前的顺序：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">"title, iterStat : ${list}"</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${iterStat.index}+'.《'+${title}+'》'"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>状态变量在<code>th:each</code>属性中定义，并包含以下数据：</p><ul><li>当前<em>迭代索引</em>，以0开头。这是<code>index</code>属性。</li><li>当前<em>迭代索引</em>，以1开头。这是<code>count</code>属性。</li><li>迭代变量中的元素总量。这是<code>size</code>属性。</li><li>每个迭代的<em>迭代变量</em>。这是<code>current</code>属性。</li><li>当前迭代是偶数还是奇数。这些是<code>even/odd</code>布尔属性。</li><li>当前迭代是否是第一个迭代。这是<code>first</code>布尔属性。</li><li>当前迭代是否是最后一个迭代。这是<code>last</code>布尔属性。</li></ul><p>通过了解了流程控制语法，现在我们就可以很轻松地使用Thymeleaf来快速替换页面中的内容了。</p><h3 id="Thymeleaf模板布局"><a href="#Thymeleaf模板布局" class="headerlink" title="Thymeleaf模板布局"></a>Thymeleaf模板布局</h3><p>在某些网页中，我们会发现，整个网站的页面，除了中间部分的内容会随着我们的页面跳转而变化外，有些部分是一直保持一个状态的，比如打开小破站，我们翻动评论或是切换视频分P的时候，变化的仅仅是对应区域的内容，实际上，其他地方的内容会无论内部页面如何跳转，都不会改变。</p><p>Thymeleaf就可以轻松实现这样的操作，我们只需要将不会改变的地方设定为模板布局，并在不同的页面中插入这些模板布局，就无需每个页面都去编写同样的内容了。现在我们来创建两个页面：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"head"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是标题内容，每个页面都有<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"body"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">"title, iterStat : ${list}"</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${iterStat.index}+'.《'+${title}+'》'"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"head"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是标题内容，每个页面都有<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"body"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>这个页面的样子是这样的<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>接着将模板引擎写成工具类的形式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThymeleafUtil</span> </span>{<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> TemplateEngine engine;<br>    <span class="hljs-keyword">static</span>  {<br>        engine = <span class="hljs-keyword">new</span> TemplateEngine();<br>        ClassLoaderTemplateResolver r = <span class="hljs-keyword">new</span> ClassLoaderTemplateResolver();<br>        engine.setTemplateResolver(r);<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TemplateEngine <span class="hljs-title">getEngine</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> engine;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet("/index2")</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServlet2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>{<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>{<br>        Context context = <span class="hljs-keyword">new</span> Context();<br>        ThymeleafUtil.getEngine().process(<span class="hljs-string">"test2.html"</span>, context, resp.getWriter());<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>现在就有两个Servlet分别对应两个页面了，但是这两个页面实际上是存在重复内容的，我们要做的就是将这些重复内容提取出来。</p><p>我们单独编写一个<code>head.html</code>来存放重复部分：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"head"</span> <span class="hljs-attr">th:fragment</span>=<span class="hljs-string">"head-title"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是标题内容，每个页面都有<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>现在，我们就可以直接将页面中的内容快速替换：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:include</span>=<span class="hljs-string">"head.html::head-title"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"body"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">"title, iterStat : ${list}"</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${iterStat.index}+'.《'+${title}+'》'"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>我们可以使用<code>th:insert</code>和<code>th:replace</code>和<code>th:include</code>这三种方法来进行页面内容替换，那么<code>th:insert</code>和<code>th:replace</code>（和<code>th:include</code>，自3.0年以来不推荐）有什么区别？</p><ul><li><code>th:insert</code>最简单：它只会插入指定的片段作为标签的主体。</li><li><code>th:replace</code>实际上将标签直接<em>替换</em>为指定的片段。</li><li><code>th:include</code>和<code>th:insert</code>相似，但它没有插入片段，而是只插入此片段<em>的内容</em>。</li></ul><p>你以为这样就完了吗？它还支持参数传递，比如我们现在希望插入二级标题，并且由我们的子页面决定：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"head"</span> <span class="hljs-attr">th:fragment</span>=<span class="hljs-string">"head-title"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是标题内容，每个页面都有<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是二级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>稍加修改，就像JS那样添加一个参数名称：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"head"</span> <span class="hljs-attr">th:fragment</span>=<span class="hljs-string">"head-title(sub)"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是标题内容，每个页面都有<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${sub}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>现在直接在替换位置添加一个参数即可：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:include</span>=<span class="hljs-string">"head.html::head-title('这个是第1个页面的二级标题')"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"body"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">"title, iterStat : ${list}"</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${iterStat.index}+'.《'+${title}+'》'"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>这样，不同的页面还有着各自的二级标题。</p><hr><h2 id="探讨Tomcat类加载机制"><a href="#探讨Tomcat类加载机制" class="headerlink" title="探讨Tomcat类加载机制"></a>探讨Tomcat类加载机制</h2><p>有关JavaWeb的内容，我们就聊到这里，在最后，我们还是来看一下Tomcat到底是如何加载和运行我们的Web应用程序的。</p><p>Tomcat服务器既然要同时运行多个Web应用程序，那么就必须要实现不同应用程序之间的隔离，也就是说，Tomcat需要分别去加载不同应用程序的类以及依赖，还必须保证应用程序之间的类无法相互访问，而传统的类加载机制无法做到这一点，同时每个应用程序都有自己的依赖，如果两个应用程序使用了同一个版本的同一个依赖，那么还有必要去重新加载吗，带着诸多问题，Tomcat服务器编写了一套自己的类加载机制。</p><p><img src="https://images2018.cnblogs.com/blog/137084/201805/137084-20180526104342525-959933190.png" alt="img"></p><p>首先我们要知道，Tomcat本身也是一个Java程序，它要做的是去动态加载我们编写的Web应用程序中的类，而要解决以上提到的一些问题，就出现了几个新的类加载器，我们来看看各个加载器的不同之处：</p><ul><li>Common ClassLoader：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Web应用程序访问。</li><li>Catalina ClassLoader：Tomcat容器私有的类加载器，加载路径中的class对于Web应用程序不可见。</li><li>Shared ClassLoader：各个Web应用程序共享的类加载器，加载路径中的class对于所有Web应用程序可见，但是对于Tomcat容器不可见。</li><li>Webapp ClassLoader：各个Web应用程序私有的类加载器，加载路径中的class只对当前Web应用程序可见，每个Web应用程序都有一个自己的类加载器，此加载器可能存在多个实例。</li><li>JasperLoader：JSP类加载器，每个JSP文件都有一个自己的类加载器，也就是说，此加载器可能会存在多个实例。</li></ul><p>通过这样进行划分，就很好地解决了我们上面所提到的问题，但是我们发现，这样的类加载机制，破坏了JDK的<code>双亲委派机制</code>（在JavaSE阶段讲解过），比如Webapp ClassLoader，它只加载自己的class文件，它没有将类交给父类加载器进行加载，也就是说，我们可以随意创建和JDK同包同名的类，岂不是就出问题了？</p><p>难道Tomcat的开发团队没有考虑到这个问题吗？</p><p><img src="https://images0.cnblogs.com/blog2015/449064/201506/141304597074685.jpg" alt="img"></p><p>实际上，WebAppClassLoader的加载机制是这样的：WebAppClassLoader 加载类的时候，绕开了 AppClassLoader，直接先使用 ExtClassLoader 来加载类。这样的话，如果定义了同包同名的类，就不会被加载，而如果是自己定义 的类，由于该类并不是JDK内部或是扩展类，所有不会被加载，而是再次回到WebAppClassLoader进行加载，如果还失败，再使用AppClassloader进行加载。</p><hr><h2 id="实战：编写图书管理系统"><a href="#实战：编写图书管理系统" class="headerlink" title="实战：编写图书管理系统"></a>实战：编写图书管理系统</h2><p>图书管理系统需要再次迎来升级，现在，我们可以直接访问网站来操作图书，这里我们给大家提供一个前端模板直接编写，省去编写前端的时间。</p><p>本次实战使用到的框架：Servlet+Mybatis+Thymeleaf</p><p>注意在编写的时候，为了使得整体的代码简洁高效，我们严格遵守三层架构模式：</p><p><img src="https://www.runoob.com/wp-content/uploads/2018/08/1535337833-4838-1359192395-1143.png" alt="img"></p><p>就是说，表示层只做UI，包括接受请求和相应，给模板添加上下文，以及进行页面的解析，最后响应给浏览器；业务逻辑层才是用于进行数据处理的地方，表示层需要向逻辑层索要数据，才能将数据添加到模板的上下文中；数据访问层一般就是连接数据库，包括增删改查等基本的数据库操作，业务逻辑层如果需要从数据库取数据，就需要向数据访问层请求数据。</p><p>当然，贯穿三大层次的当属实体类了，我们还需要创建对应的实体类进行数据的封装，以便于在三层架构中进行数据传递。</p><p>接下来，明确我们要实现的功能，也就是项目需求：</p><ul><li>图书管理员的登陆和退出（只有登陆之后才能进入管理页面）</li><li>图书的列表浏览（包括书籍是否被借出的状态也要进行显示）以及图书的添加和删除</li><li>学生的列表浏览</li><li>查看所有的借阅列表，添加借阅信息</li></ul><hr><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>首先祝贺各位顺利完成了JavaWeb相关知识的学习。</p><p>本教程创作的动力离不开各位观众姥爷们的支持，我们也会在后面为大家录制更多的Java技术栈教程，如果您喜欢本系列视频的话，直接用三连狠狠的砸向UP主吧！</p><p>虽然我们现在已经学会了如何去编写一个网站，但是实际上，这样的开发模式已经过时（不过拿去当毕设当期末设计直接无敌好吧），我们还需要继续深入了解更加现代化的开发模式，这样我们才有机会参与到企业的项目开发当中。</p><p>希望在后续的视频中，还能看到各位的身影，完结撒花！</p>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;JavaWeb后端&quot;&gt;&lt;a href=&quot;#JavaWeb后端&quot; class=&quot;headerlink&quot; title=&quot;JavaWeb后端&quot;&gt;&lt;/a&gt;JavaWeb后端&lt;/h1&gt;&lt;p&gt;经过前面的学习，现在终于可以正式进入到后端的学习当中，不过，我们还是需要再系统地讲解一下HTTP通信基础知识，它是我们学习JavaWeb的基础知识，我们之前已经学习过TCP通信，而HTTP实际上是基于TCP协议之上的应用层协议，因此理解它并不难理解。&lt;/p&gt;
&lt;p&gt;打好基础是关键！为什么要去花费时间来讲解计算机网络基础，我们学习一门技术，如果仅仅是知道如何使用却不知道其原理，那么就成了彻头彻尾的“码农”，只知道搬运代码实现功能，却不知道这行代码的执行流程，在遇到一些问题的时候就不知道如何解决，无论是知识层面还是应用层面都得不到提升。&lt;/p&gt;
&lt;p&gt;无论怎么样，我们都要明确，我们学习JavaWeb的最终目的是为了搭建一个网站，并且让用户能访问我们的网站并在我们的网站上做一些事情。&lt;/p&gt;
&lt;h2 id=&quot;计算机网络基础&quot;&gt;&lt;a href=&quot;#计算机网络基础&quot; class=&quot;headerlink&quot; title=&quot;计算机网络基础&quot;&gt;&lt;/a&gt;计算机网络基础&lt;/h2&gt;&lt;p&gt;在计算机网络（谢希仁 第七版 第264页）中，是这样描述万维网的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 万维网（World Wide Web）并非是某种特殊的计算机网络，万维网是一个大规模的联机式信息储藏所，英文简称&lt;code&gt;Web&lt;/code&gt;，万维网用**&lt;u&gt;链接&lt;/u&gt;**的方法，能够非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需求获取丰富的信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这句话说的非常官方，但是也蕴藏着许多的信息，首先它指明，我们的互联网上存在许许多多的服务器，而我们通过访问这些服务器就能快速获取服务器为我们提供的信息（比如打开百度就能展示搜索、打开小破站能刷视频、打开微博能查看实时热点）而这些服务器就是由不同的公司在运营。&lt;/p&gt;
&lt;p&gt;其次，我们通过浏览器，只需要输入对应的网址或是点击页面中的一个链接，就能够快速地跳转到另一个页面，从而按我们的意愿来访问服务器。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://xiaofanshutu.github.io/posts/0.html"/>
    <id>https://xiaofanshutu.github.io/posts/0.html</id>
    <published>2025-08-31T15:29:05.024Z</published>
    <updated>2025-08-31T15:31:22.573Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h1><p><strong>提醒：</strong>还没有申请到IDEA专业版本授权的同学要抓紧了，很快就需要用到。</p><p>经过前面基础内容的学习，现在我们就可以正式地进入Web开发的学习当中啦~</p><p>本章节会讲解前端基础内容（如果已经学习过，可以直接跳到下一个大章节了）那么什么是前端，什么又是后端呢？</p><ul><li>前端：我们网站的页面，包括网站的样式、图片、视频等一切用户可见的内容都是前端的内容。</li><li>后端：处理网站的所有数据来源，比如我们之前从数据库中查询数据，而我们查询的数据经过处理最终会被展示到前端，而用于处理前端数据的工作就是由后端来完成的。</li></ul><p>相当于，前端仅仅是一层皮，它直接决定了整个网站的美观程度，我们可以自由地编排页面的布局，甚至可以编写好看的特效；而灵魂则是后端，如何处理用户的交互、如何处理数据查询是后端的职责所在，我们前面学习的都是后端内容，而Java也是一门专注于后端开发的语言。</p><p>对于前端开发我们需要学习一些新的内容，只有了解了它们，我们才能编写出美观的页面。</p><p>本教程并不会过多地去讲解前端知识，我们只会提及一些必要的内容，我们主要学习的是JavaWeb，更倾向于后端开发，学习前端的目的只是为了让同学们了解前后端的交互方式，在进行后端开发时思路能够更加清晰，有关前端的完整内容学习，可以浏览其他前端知识教程。</p><p>我们在最开始讲解网络编程时，提到了浏览器访问服务器，实际上浏览器访问服务器就是一种B/S结构，而我们使用Java代码编写的客户端连接服务器就是一种C/S结构。</p><p>Web开发还要从HTML开始讲起，这个语言非常简单，很好学习，看完视频如果你觉得前端简单自己更喜欢一些，建议马上转前端吧，还来得及，工资还比后端高，不像后端那么枯燥乏味。</p><h2 id="HTML页面"><a href="#HTML页面" class="headerlink" title="HTML页面"></a>HTML页面</h2><p>我们前面学习了XML语言，它是一种标记语言，我们需要以成对标签的格式进行填写，但是它是专用于保存数据，而不是展示数据，而HTML恰恰相反，它专用于展示数据，由于我们前面已经学习过XML语言了，HTML语言和XML很相似，所以我们学习起来会很快。</p><h3 id="第一个HTML页面"><a href="#第一个HTML页面" class="headerlink" title="第一个HTML页面"></a>第一个HTML页面</h3><p>我们前面知道，通过浏览器可以直接浏览XML文件，而浏览器一般是用于浏览HTML文件的，以HTML语言编写的内容，会被浏览器识别为一个页面，并根据我们编写的内容，将对应的组件添加到浏览器窗口中。</p><p>我们一般使用Chrome、Safari、Microsoft Edge等浏览器进行测试，IE浏览器已经彻底淘汰了！</p><p>比如我们可以创建一个Html文件来看看浏览器会如何识别，使用IDEA也能编写HTML页面，我们在IDEA中新建一个<code>Web模块</code>，进入之后我们发现，项目中没有任何内容，我们右键新建一个HTML文件，选择HTML5文件，并命名为index，创建后出现：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>我们发现，它和XML基本长得一样，并且还自带了一些标签，那么现在我们通过浏览器来浏览这个HTML文件（这里推荐使用内置预览，不然还得来回切换窗口）</p><p>我们发现现在什么东西都没有，但是在浏览器的标签位置显示了网页的名称为<code>Title</code>，并且显示了一个IDEA的图标作为网页图标。</p><p>现在我们稍微进行一些修改：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>lbw的直播间<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    现在全体起立<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>再次打开浏览器，我们发现页面中出现了我们输入的文本内容，并且标题也改为了我们自定义的标题。</p><p>我们可以在设置-&gt;工具-&gt;Web浏览器和预览中将重新加载页面规则改为<code>变更时</code>，这样我们使用内置浏览器或是外部浏览器，可以自动更新我们编写的内容。</p><p>我们还可以在页面中添加一个图片，随便将一张图片放到html文件的同级目录下，命名为<code>image.xxx</code>，其中xxx是后缀名称，不要修改，我们在body节点中添加以下内容：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"300"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"image.xxx"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"剑光如我，斩尽牛杂"</span>&gt;</span><br><span class="hljs-comment">&lt;!--  注意xxx替换成对应的后缀名称  --&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>我们发现，我们的页面中居然能够显示我们添加的图片内容。因此，我们只需要编写对应的标签，浏览器就能够自动识别为对应的组件，并将其展示到我们的浏览器窗口中。</p><p>我们再来看看插入一个B站的视频，很简单，只需要到对应的视频下方，找到分享，我们看到有一个嵌入代码：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"//player.bilibili.com/player.html?aid=333231998&amp;bvid=BV1rA411g7q8&amp;cid=346917516&amp;page=1"</span> <span class="hljs-attr">scrolling</span>=<span class="hljs-string">"no"</span> <span class="hljs-attr">border</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">"no"</span> <span class="hljs-attr">framespacing</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">allowfullscreen</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"800"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"500"</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>每一个页面都是通过这些标签来编写的，几乎所有的网站都是使用HTML编写页面。</p><h3 id="HTML语法规范"><a href="#HTML语法规范" class="headerlink" title="HTML语法规范"></a>HTML语法规范</h3><p>一个HTML文件中一般分为两个部分：</p><ul><li>头部：一般包含页面的标题、页面的图标、还有页面的一些设置，也可以在这里导入css、js等内容。</li><li>主体：整个页面所有需要显示的内容全部在主体编写。</li></ul><p>我们首先来看头部，我们之前使用的HTML文件中头部包含了这些内容：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>lbw的直播间<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>首先<code>meta</code>标签用于定义页面的一些元信息，这里使用它来定义了一个字符集（编码格式），一般是UTF-8，下面的<code>title</code>标签就是页面的标题，会显示在浏览器的上方。我们现在来给页面设置一个图标，图标一般可以在字节跳动的IconPark网站找到：<a href="https://iconpark.oceanengine.com/home%EF%BC%8C%E9%80%89%E6%8B%A9%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E5%96%9C%E6%AC%A2%E7%9A%84%E5%9B%BE%E6%A0%87%E4%B8%8B%E8%BD%BD%E5%8D%B3%E5%8F%AF%E3%80%82">https://iconpark.oceanengine.com/home，选择一个自己喜欢的图标下载即可。</a></p><p>将图标放入到项目目录中，并命名为icon.png，在HTML头部添加以下内容：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"icon"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"icon.png"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"image/x-icon"</span> /&gt;</span><br></code></pre></td></tr></tbody></table></figure><p><code>link</code>标签用于关联当前HTML页面与其他资源的关系，关系通过<code>rel</code>属性指定，这里使用的是icon表示这个文件是当前页面图标。</p><p>现在访问此页面，我们发现页面的图标已经变成我们指定的图标样式了。</p><p>现在我们再来看主体，我们可以在主体内部编写该页面要展示的所有内容，比如我们之前就用到了img标签来展示一个图片，其中每一个标签都称为一个元素：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"300"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"image.xxx"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"当图片加载失败时，显示的文本"</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>我们发现，这个标签只存在一个，并没有成对出现，HTML中有些标签是单标签，也就是说只有这一个，还有一些标签是双标签，必须成对出现，HTML中，也不允许交叉嵌套，但是出现交叉嵌套时，浏览器并不会提示错误，而是仍旧尝试去解析这些内容，甚至会帮助我们进行一定程度的修复，比如：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"//player.bilibili.com/player.html?aid=333231998&amp;bvid=BV1rA411g7q8&amp;cid=346917516&amp;page=1"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"800"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"500"</span></span><br><span class="hljs-tag">            <span class="hljs-attr">scrolling</span>=<span class="hljs-string">"no"</span> <span class="hljs-attr">border</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">"no"</span> <span class="hljs-attr">framespacing</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">allowfullscreen</span>=<span class="hljs-string">"true"</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>很明显上面的代码已经出现交叉嵌套的情况了，但是依然能够在浏览器中正确地显示。</p><p>在主体中，我们一般使用div标签来分割页面：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>我是第一块<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>我是第二块<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>通过使用<code>div</code>标签，我们将整个页面按行划分，而高度就是内部元素的高度，那么如果只希望按元素划分，也就是说元素占多大就划分多大的空间，那么我们就可以使用<code>span</code>标签来划分：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我是第一块第一个部分<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我是第一块第二个部分<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>我是第二块<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>我们也可以使用<code>p</code>段落标签，它一般用于文章分段：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>        你看这个彬彬啊，才喝几罐就醉了，真的太逊了。 这个彬彬就是逊呀！<br>        听你这么说，你很勇哦？ 开玩笑，我超勇的，超会喝的啦。<br>        超会喝，很勇嘛。身材不错哦，蛮结实的嘛。<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>        哎，杰哥，你干嘛啊。都几岁了，还那么害羞！我看你，完全是不懂哦！<br>        懂，懂什么啊？ 你想懂？我房里有一些好康的。<br>        好康，是新游戏哦！ 什么新游戏，比游戏还刺激！<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>        杰哥，这是什么啊？ 哎呦，你脸红啦！来，让我看看。<br>        不要啦！！ 让我看看嘛。 不要啦，杰哥，你干嘛啊！<br>        让我看看你法语正不正常啊！<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>那么如果遇到特殊字符该怎么办呢？和XML一样，我们可以使用转义字符：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.51wendang.com%2Fpic%2F208288d7561926f359c6be84%2F1-352-jpg_6_0_______-356-0-0-356.jpg&amp;refer=http%3A%2F%2Fwww.51wendang.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1639877607&amp;t=bcc1fcfe8bae53e90c365a4fd8c00a1c" alt="点击查看源网页"></p><p><strong>注意：</strong>多个连续的空格字符只能被识别为一个，如果需要连续多个必须使用转义字符，同时也不会识别换行，换行只会变成一个空格，需要换行必须使用<code>br</code>标签。</p><p>通过了解了HTML的一些基础语法，我们现在就知道一个页面大致是如何编写了。</p><h3 id="HTML常用标签"><a href="#HTML常用标签" class="headerlink" title="HTML常用标签"></a>HTML常用标签</h3><p>前面我们已经了解了HTML的基本语法规范，那么现在我们就来看看，有哪些常用的标签吧，首先是换行和分割线：</p><ul><li>br 换行</li><li>hr 分割线</li></ul><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        我是一段文字<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>我是第二段文字<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>我是底部文字<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>标题一般用h1到h6表示，我们来看看效果：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>一级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>二级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>三级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>四级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>五级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>六级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是正文内容，真不错。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>现在我们来看看超链接，我们可以添加一个链接用于指向其他网站：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://www.bilibili.com"</span>&gt;</span>点击访问小破站<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>我们也可以指定页面上的一个锚点进行滚动：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#test"</span>&gt;</span>跳转锚点<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"image.jpeg"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"500"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"image.jpeg"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"500"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"image.jpeg"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"500"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"image.jpeg"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"500"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"test"</span>&gt;</span>我是锚点<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"image.jpeg"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"500"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"image.jpeg"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"500"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"image.jpeg"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"500"</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>每个元素都可以有一个id属性，我们只需要给元素添加一个id属性，就使用a标签可以跳转到一个指定锚点。</p><p>我们接着来看看列表元素，这是一个无需列表，其中每一个<code>li</code>表示一个列表项：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>一号选项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>二号选项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>三号选项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>四号选项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>五号选项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>我们也可以使用<code>ol</code>来显示一个有序列表：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>一号选项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>二号选项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>三号选项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>四号选项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>五号选项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>表格也是很重要的一种元素，但是它编写起来相对有一点麻烦：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>学号<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>性别<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>年级<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>0001<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>小明<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2019<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>0002<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>小红<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2020<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>虽然这样生成了一个表格，但是这个表格并没有分割线，并且格式也不符合我们想要的样式，那么如何才能修改这些基础属性的样式呢，我们就需要聊聊CSS了。</p><h3 id="HTML表单"><a href="#HTML表单" class="headerlink" title="HTML表单"></a>HTML表单</h3><p>表单就像其名字一样，用户在页面中填写了对应的内容，点击按钮就可以提交到后台，比如登陆界面，就可以使用表单来实现：</p><p>一个网页中最重要的当属输入框和按钮了，那么我们来看看如何创建一个输入框和按钮：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>    我是输入框<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>对于一个输入框，我们一般会将其包括在一个<code>lable</code>标签中，它和span效果一样，但是我们点击前面文字也能快速获取输入框焦点。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>登陆我们的网站<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>        账号：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>        密码：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>输入框可以有很多类型，我们来试试看password，现在输入内容就不会直接展示原文了。</p><p>创建一个按钮有以下几种方式，在学习JavaWeb时，我们更推荐第二种方式，我们后面进行登陆操作需要配合表单使用：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>登陆<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"登陆"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"登陆"</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>现在我们就可以写一个大致的登陆页面了：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>登陆我们的网站<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>                账号：<br>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Username..."</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>                密码：<br>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Password..."</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://www.baidu.com"</span>&gt;</span>忘记密码<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"登陆"</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>表单一般使用<code>form</code>标签将其囊括，但是现在我们还用不到表单提交，因此之后我们再来讲解表单的提交。</p><p><code>input</code>只能实现单行文本，那么如何实现多行文本呢？</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>    这是我们的文本框<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"文本内容..."</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">"10"</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">"10"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>我们还可以指定默认的行数和列数，拖动左下角可以自定义文本框的大小。</p><p>我们还可以在页面中添加勾选框：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span>&gt;</span><br>    我同意本网站的隐私政策<br><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>上面演示的是一个多选框，那么我们来看看单选框：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"role"</span>&gt;</span><br>    学生<br><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"role"</span>&gt;</span><br>    教师<br><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>这里需要使用name属性进行分组，同一个组内的选项只能选择一个。</p><p>我们也可以添加列表让用户进行选择，创建一个下拉列表：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>    登陆身份：<br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>学生<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>教师<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>默认选取的是第一个选项，我们可以通过<code>selected</code>属性来决定默认使用的是哪个选项。</p><p>当然，HTML的元素远不止我们所提到的这些，有关更多HTML元素的内容，可以自行了解。</p><hr><h2 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h2><p>之前我们编写的页面非常基础，我们只能通过一些很基本的属性来排列我们的页面元素，那么如何实现更高度的自定义呢，我们就需要用到CSS来自定义样式，首先我们创建一个名为<code>style.css</code>的文件。</p><p>首先在我们HTML文件的头部添加：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"style.css"</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>我们在CSS文件中添加以下内容：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> {<br>    <span class="hljs-attribute">text-align</span>: center;<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现，网页的内容全部变为居中显示了，这正是css在生效，相当于我们现在给页面添加了自定义的样式规则。</p><p>当然，我们也可以选择不使用CSS，而是直接对某个元素添加样式：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"text-align: center;"</span>&gt;</span><br>  ...<br></code></pre></td></tr></tbody></table></figure><p>这样的效果其实是等同于上面的css文件的，相当于我们直接把样式定义在指定元素上。</p><p>也可以在头部直接定义样式，而不是使用外部文件：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>    body {<br>        text-align: center;<br>    }<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>使用以上三种方式都可以自定义页面的样式，我们推荐使用还是第一种，不然我们的代码会很繁杂。</p><p>样式的属性是非常多的，我们不可能一个一个全部讲完，视频中用到什么再来讲解什么，如果同学们感兴趣，可以自行下去了解。</p><h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><p>我们首先来了解一下选择器，那么什么是选择器呢？我们想要自定义一个元素的样式，那么我们肯定要去选择某个元素，只有先找到要自定义的元素，我们才能开始编写样式。</p><p>我们上面的例子中使用的就是标签名选择器，它可以快速选择页面中所有指定的的标签，比如我们之前使用的就是<code>body</code>标签，那么就相当于页面中所有的body元素全都使用此样式，那么我们现在来试试看选择页面中所有的<code>input</code>标签：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span> {<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现，页面中所有的<code>input</code>元素宽度全部被设定为了200个像素（<code>px</code>是单位大小，代表像素，除了<code>px</code>还有<code>em</code>和<code>rem</code>，他们是根据当前元素字体大小决定的相对大小，一般用于适配各种大小的浏览器窗口，这里暂时不用）</p><p>样式编写完成后，如果只有一个属性，可以不带<code>;</code>若多个属性则每个属性后面都需要添加一个<code>;</code></p><p>因此，一个标签选择器的格式为：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">标签名称 {<br>  属性名称: 属性值<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们还可以设定输入框的字体大小、行高等：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span> {<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">40px</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们现在可以通过选择器快速地去设置某个元素样式了，那么如何实现只设置某个元素的样式呢，现在我们来看看，id选择器，我们之前已经讲解过了，每个元素都可以有一个id属性，我们可以将其当做一个跳转的锚点使用，而现在，我们可以使用css来进行定位：</p><p>我们先为元素添加id属性：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"title"</span>&gt;</span>登陆我们的网站<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>现在使用CSS选择我们的元素，并设定一个属性，选择某个id需要在前面加上一个<code>#</code>：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#title</span> {<br>    <span class="hljs-attribute">color</span>: red;<br>}<br></code></pre></td></tr></tbody></table></figure><p>虽然id选择器已经可以很方便的指定某个元素，但是如果我们希望n个但不是元素都被选择，id选择器就无法实现了，因为每个元素的id是唯一的，不允许出现重复id的元素，因此接着我们来讲解一下类选择器。</p><p>每个元素都可以有一个<code>class</code>属性，表示当前元素属于某个类（注意这里的类和我们Java中的类概念完全不同）一个元素可以属于很多个类，一个类也可以被很多个元素使用：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> &gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"test"</span>&gt;</span><br>            账号：<br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Username..."</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"test"</span>&gt;</span><br>            密码：<br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Password..."</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>上面的例子中，两个<code>label</code>元素都使用了<code>test</code>类（类名称是我们自定义的），现在我们在css文件中编写以下内容来以类进行选择：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.test</span>{<br>    <span class="hljs-attribute">color</span>: blue;<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现，两个标签的文本内容都变为了蓝色，因此使用类选择器，能够对所有为此类的元素添加样式。注意在进行类选择时，我们需要在类名前面加上<code>.</code>来表示。</p><h3 id="组合选择器和优先级问题"><a href="#组合选择器和优先级问题" class="headerlink" title="组合选择器和优先级问题"></a>组合选择器和优先级问题</h3><p>我们也可以让多个选择器，共用一个css样式：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.test</span>, <span class="hljs-selector-id">#title</span> {<br>    <span class="hljs-attribute">color</span>: red;<br>}<br></code></pre></td></tr></tbody></table></figure><p>只需要并排写即可，注意中间需要添加一个英文的逗号用于分割，我们也可以使用<code>*</code>来一次性选择所有的元素：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">* {<br>    <span class="hljs-attribute">color</span>: red;<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们还可以选择位于某个元素内的某个元素：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">label</span> {<br>    <span class="hljs-attribute">color</span>: red;<br>}<br></code></pre></td></tr></tbody></table></figure><p>这样的话，就会选择所有位于div元素中的label元素。</p><p>当然，我们这里只介绍了一些常用的选择器，有关详细的CSS选择器可以查阅：<a href="https://www.runoob.com/cssref/css-selectors.html">https://www.runoob.com/cssref/css-selectors.html</a></p><p>我们接着来看一下选择器的优先级：</p><p><img src="https://img2020.cnblogs.com/blog/1864877/202004/1864877-20200408234042787-674324294.png" alt="img"></p><p>我们根据上面的信息，来测试一下，首先编写一下HTML文件：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"test"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"simple"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: blue"</span>&gt;</span>我是测试文本内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>现在我们来编写一下css文件：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.test</span> {<br>    <span class="hljs-attribute">color</span>: yellow;<br>}<br><br><span class="hljs-selector-id">#simple</span> {<br>    <span class="hljs-attribute">color</span>: red;<br>}<br><br>* {<br>    <span class="hljs-attribute">color</span>: palegreen;<br>}<br></code></pre></td></tr></tbody></table></figure><p>那么现在我们可以看到，实际上生效的是我们直接编写在标签内部的内联属性，那么现在我们依次进行移除，来看看它们的优先级。</p><p>那么如果我们希望某个属性无视任何的优先级，我们可以在属性后面添加<code>!important</code>标记，表示此属性是一个重要属性，它的优先级会被置为最高。</p><p><strong>思考：</strong>那要是我每个选择器的这个属性后面都加一个<code>!important</code>会怎么样？</p><h3 id="自定义边距"><a href="#自定义边距" class="headerlink" title="自定义边距"></a>自定义边距</h3><p>我们来看看，如何使用css控制一个div板块的样式，首先编写以下代码，相当于一个div嵌套了一个div元素：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"outer"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"inner"</span>&gt;</span><br>        <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>现在编写一下自定义的css样式，我们将div设定为固定大小，并且背景颜色添加为绿色：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#outer</span> {<br>    <span class="hljs-attribute">background</span>: palegreen;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现左侧快速预览页面存在空隙，这是因为浏览器给我们添加了一个边距属性，我们只需要覆盖此属性并将其设定为0即可：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> {<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>现在我们给内部嵌套的div也设定一个大小，并将颜色设定为橙色：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#inner</span> {<br>    <span class="hljs-attribute">background</span>: darkorange;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>现在我们发现内部的div元素位于右上角，我们还可以以百分比的形式来指定大小：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#inner</span> {<br>    <span class="hljs-attribute">background</span>: darkorange;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>百分比会依照当前可用大小来进行分配，比如当前位于一个div内部，并且外部div元素是固定大小300px，因此100%就相当于使用了外部的全部大小，也是300px，现在内部元素完全将外部元素覆盖了，整个元素现在呈现为橙色。</p><p>我们可以为一个元素设定边距，边距分为外边距和内边距，外部元素内边距决定了内部元素与外部元素之间的间隔，我们来修改一下css样式：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#outer</span> {<br>    <span class="hljs-attribute">background</span>: palegreen;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现，内部的div元素小了一圈，这是因为外部div元素设定了内边距，上下左右都被设定为10px大小。</p><p>而我们发现，实际上我们在一开始也是将body的外边距设定为了0，整个页面跟浏览器窗口直接间隔0px的宽度。</p><h3 id="编写一个漂亮的登陆界面"><a href="#编写一个漂亮的登陆界面" class="headerlink" title="编写一个漂亮的登陆界面"></a>编写一个漂亮的登陆界面</h3><p>现在我们就来尝试编写一个漂亮的登陆界面吧！</p><hr><h2 id="JavaScript语言"><a href="#JavaScript语言" class="headerlink" title="JavaScript语言"></a>JavaScript语言</h2><p>也称为js，是我们整个前端基础的重点内容，只有了解了JavaScript语言，我们才能了解前端如何与后端交互。</p><p>JavaScript与Java没有毛关系，仅仅只是名字中包含了Java而已，跟Java比起来，它更像Python，它是一门解释型语言，不需要进行编译，它甚至可以直接在浏览器的命令窗口中运行。</p><p>它相当于是前端静态页面的一个补充，它可以让一个普通的页面在后台执行一些程序，比如我们点击一个按钮，我们可能希望执行某些操作，比如下载文件、页面跳转、页面弹窗、进行登陆等，都可以使用JavaScript来帮助我们实现。</p><p>我们来看看一个简单的JavaScript程序：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span>; j++) {<br>        <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j+<span class="hljs-number">1</span>]){<br>            <span class="hljs-keyword">const</span> tmp = arr[j]<br>            arr[j] = arr[j+<span class="hljs-number">1</span>]<br>            arr[j+<span class="hljs-number">1</span>] = tmp<br>        }<br>    }<br>}<br><br><span class="hljs-built_in">window</span>.alert(arr)<br></code></pre></td></tr></tbody></table></figure><p>这段代码实际上就是实现了一个冒泡排序算法，我们可以直接在页面的头部中引用此js文件，浏览器会在加载时自动执行js文件中编写的内容：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"test.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>我们发现JS的语法和Java非常相似，但是它还是和Java存在一些不同之处，而且存在很多阴间语法，那么我们来看看JS的语法。</p><h3 id="JavaScript基本语法"><a href="#JavaScript基本语法" class="headerlink" title="JavaScript基本语法"></a>JavaScript基本语法</h3><p>在js中，定义变量和Java中有一些不同，定义一个变量可以使用<code>let</code>关键字或是<code>var</code>关键字，IDEA推荐我们使用<code>let</code>关键字，因为<code>var</code>存在一定的设计缺陷（这里就不做讲解了，之后一律使用let关键字进行变量声明）：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br>a++;<br><span class="hljs-built_in">window</span>.alert(a)<br></code></pre></td></tr></tbody></table></figure><p>上面的结果中，我们得到了a的结果是11，也就是说自增和自减运算在JS中也是支持的，并且JS每一句结尾可以不用加分号。</p><p>js并不是Java那样的强类型语言（任意变量的类型一定是明确的），它是一门弱类型语言，变量的类型并不会在一开始确定，因此我们在定义变量时无需指定变量的确切类型，而是在运行时动态解析类型：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br>a = <span class="hljs-string">"HelloWorld！"</span><br><span class="hljs-built_in">console</span>.info(a)<br></code></pre></td></tr></tbody></table></figure><p>我们发现，变量a已经被赋值为数字类型，但是我们依然在后续能将其赋值一个字符串，它的类型是随时可变的。</p><p>很多人说，这种变态的类型机制是JS的一大缺陷。</p><p>世界上只有两种语言：一种是很多人骂的，一种是没人用的。</p><p>我们接着来看看，JS中存在的基本数据类型：</p><ul><li>Number：数字类型（包括小数和整数）</li><li>String：字符串类型（可以使用单引号或是双引号）</li><li>Boolean：布尔类型（与Java一致）</li></ul><p>还包括一些特殊值：</p><ul><li><p>undefined：未定义 - 变量声明但不赋值默认为undefined</p></li><li><p>null：空值 - 等同于Java中的null</p></li><li><p>NaN：非数字 - 值不是合法数字，比如：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.alert(<span class="hljs-number">100</span>/<span class="hljs-string">'xx'</span>)<br></code></pre></td></tr></tbody></table></figure></li></ul><p>我们可以使用<code>typeof</code>关键字来查看当前变量值的类型：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">console</span>.info(<span class="hljs-keyword">typeof</span> a)<br>a = <span class="hljs-string">'Hello World'</span><br><span class="hljs-built_in">console</span>.info(<span class="hljs-keyword">typeof</span> a)<br></code></pre></td></tr></tbody></table></figure><h3 id="JavaScript逻辑运算和流程控制"><a href="#JavaScript逻辑运算和流程控制" class="headerlink" title="JavaScript逻辑运算和流程控制"></a>JavaScript逻辑运算和流程控制</h3><p>我们接着来看看js中的关系运算符，包括如下8个关系运算符：大于（&gt;）,小于（&lt;）,小于等于（&lt;=）,大于等于（&gt;=）,相等（==），不等（!=），全等（===），不全等（!==）</p><p>其实关系运算符大致和Java中的使用方法一致，不过它还可以进行字符串比较，有点像C++的语法：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.info(<span class="hljs-number">666</span> &gt; <span class="hljs-number">777</span>)<br><span class="hljs-built_in">console</span>.info(<span class="hljs-string">'aa'</span> &gt; <span class="hljs-string">'ab'</span>)<br></code></pre></td></tr></tbody></table></figure><p>那么，相等和全等有什么区别呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">console.info(<span class="hljs-string">'10'</span> == <span class="hljs-number">10</span>)<br>console.info(<span class="hljs-string">'10'</span> === <span class="hljs-number">10</span>)<br></code></pre></td></tr></tbody></table></figure><p>我们发现，在Java中，若运算符两边是不同的基本数据类型，会直接得到false，而JS中却不像这样，我们发现字符串的10居然等于数字10，而使用全等判断才是我们希望的结果。</p><p><code>==</code>的比较规则是：当操作数类型一样时，比较的规则和恒等运算符一样，都相等才相等，如果两个操作数是字符串，则进行字符串的比较，如果里面有一个操作数不是字符串，那两个操作数通过Number()方法进行转换，转成数字进行比较。</p><p>因此，我们上面进行的判断实际上是运算符两边都进行了数字转换的结果进行比较，自然也就得到了true，而全等判断才是我们在Java中认识的相等判断。</p><p>我们接着来看逻辑运算，JS中包括&amp;&amp;、||、&amp;、|、?:等，我们先来看看位运算符：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.info(<span class="hljs-number">4</span> &amp; <span class="hljs-number">7</span>)<br><span class="hljs-built_in">console</span>.info(<span class="hljs-number">4</span> | <span class="hljs-number">7</span>)<br></code></pre></td></tr></tbody></table></figure><p>实际上和Java中是一样的，那么我再来看看逻辑运算：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.info(<span class="hljs-literal">true</span> || <span class="hljs-literal">false</span>)<br></code></pre></td></tr></tbody></table></figure><p>对于boolean变量的判断，是与Java一致的，但是JS也可以使用非Boolen类型变量进行判断：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.info(!<span class="hljs-number">0</span>)<br><span class="hljs-built_in">console</span>.info(!<span class="hljs-number">1</span>)<br></code></pre></td></tr></tbody></table></figure><p>和C/C++语言一样，0代表false，非0代表true，那么字符串呢？</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.info(!<span class="hljs-string">"a"</span>)<br><span class="hljs-built_in">console</span>.info(!<span class="hljs-string">""</span>)<br></code></pre></td></tr></tbody></table></figure><p>我们发现，空串为false，非空串为true，我们再来看看：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.info(<span class="hljs-literal">true</span> || <span class="hljs-number">7</span>)<br><span class="hljs-built_in">console</span>.info(<span class="hljs-number">7</span> || <span class="hljs-literal">true</span>)<br></code></pre></td></tr></tbody></table></figure><p>我们发现，前者得到的结果为true，而后者得到的结果却是是7，真是滑天下之大稽，什么鬼玩意，实际上是因为，默认非0都是true，而后者又是先判断的7，因此会直接得到7而不是被转换为true</p><p>那么我们再来看看几个特殊值默认代表什么：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.info(!<span class="hljs-literal">undefined</span>)<br><span class="hljs-built_in">console</span>.info(!<span class="hljs-literal">null</span>)<br><span class="hljs-built_in">console</span>.info(!<span class="hljs-literal">NaN</span>)<br></code></pre></td></tr></tbody></table></figure><p>最后来使用一下三元运算符，实际上和Java中是一样的：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-literal">true</span> ? <span class="hljs-string">"xx"</span> : <span class="hljs-number">20</span><br><span class="hljs-built_in">console</span>.info(a)<br></code></pre></td></tr></tbody></table></figure><p>得益于JS的动态类型，emmm，三元运算符不一定需要固定的返回值类型。</p><p>JS的分支结构，实际上和Java是一样的，也是使用if-else语句来进行：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(<span class="hljs-string">"lbwnb"</span>){   <span class="hljs-comment">//非空串为true</span><br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"!!!"</span>)<br>} <span class="hljs-keyword">else</span> {<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"???"</span>)<br>}<br></code></pre></td></tr></tbody></table></figure><p>同理，多分支语句也能实现：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(<span class="hljs-string">""</span>){<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"!!!"</span>)<br>} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(-<span class="hljs-number">666</span>){<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"???"</span>)<br>} <span class="hljs-keyword">else</span> {<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"O.O"</span>)<br>}<br></code></pre></td></tr></tbody></table></figure><p>当然，多分支语句也可以使用switch来完成：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-string">"a"</span><br><span class="hljs-keyword">switch</span> (a){<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">"a"</span>:<br>        <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"1"</span>)<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">"b"</span>:<br>        <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"2"</span>)<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">"c"</span>:<br>        <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"3"</span>)<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"4"</span>)<br>}<br></code></pre></td></tr></tbody></table></figure><p>接着我们来看看循环结构，其实循环结构也和Java相差不大：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">10</span><br><span class="hljs-keyword">while</span>(i--){<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"100"</span>)<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"??"</span>)<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="JavaScript函数定义"><a href="#JavaScript函数定义" class="headerlink" title="JavaScript函数定义"></a>JavaScript函数定义</h3><p>JS中的方法和Java中的方法定义不太一样，JS中一般称其为函数，我们来看看定义一个函数的格式是什么：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"有一个人前来买瓜"</span>)<br>}<br></code></pre></td></tr></tbody></table></figure><p>定义一个函数，需要在前面加上<code>function</code>关键字表示这是一个函数，后面跟上函数名称和<code>()</code>，其中可以包含参数，在<code>{}</code>中编写函数代码。我们只需要直接使用函数名+<code>()</code>就能调用函数：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">f();<br></code></pre></td></tr></tbody></table></figure><p>我们接着来看一下，如何给函数添加形式参数以及返回值：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a</span>) </span>{<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"得到的实参为："</span>+a)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">666</span><br>}<br><br>f(<span class="hljs-string">"aa"</span>);<br></code></pre></td></tr></tbody></table></figure><p>由于JS是动态类型，因此我们不必指明参数a的类型，同时也不必指明返回值的类型，一个函数可能返回不同类型的结果，因此直接编写return语句即可。同理，我们可以在调用函数时，不传参，那么默认会使用undefined：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a</span>) </span>{<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"得到的实参为："</span>+a)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">666</span><br>}<br><br>f();<br></code></pre></td></tr></tbody></table></figure><p>那么如果我们希望不传参的时候使用我们自定义的默认值呢？</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a = <span class="hljs-string">"6666"</span></span>) </span>{<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"得到的实参为："</span>+a)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">666</span><br>}<br><br>f();<br></code></pre></td></tr></tbody></table></figure><p>我们可以直接在形参后面指定默认值。</p><p>函数本身也是一种类型，他可以被变量接收，所有函数类型的变量，也可以直接被调用：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a = <span class="hljs-string">"6666"</span></span>) </span>{<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"得到的实参为："</span>+a)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">666</span><br>}<br><br><span class="hljs-keyword">let</span> k = f;<br>k();<br></code></pre></td></tr></tbody></table></figure><p>我们也可以直接将匿名函数赋值给变量：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>{<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"实参为："</span>+str)<br>}<br></code></pre></td></tr></tbody></table></figure><p>既然函数是一种类型，那么函数也能作为一个参数进行传递：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">test</span>) </span>{<br>    test();<br>}<br><br>f(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"这是一个匿名函数"</span>)<br>})<br></code></pre></td></tr></tbody></table></figure><p>对于所有的匿名函数，可以像Java的匿名接口实现一样编写lambda表达式：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">test</span>) </span>{<br>    test();<br>}<br><br>f(<span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"可以，不跟你多bb"</span>)<br>})<br></code></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">test</span>) </span>{<br>    test(<span class="hljs-string">"这个是回调参数"</span>);<br>}<br><br>f(<span class="hljs-function"><span class="hljs-params">param</span> =&gt;</span> {<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"接受到回调参数："</span>+param)<br>})<br></code></pre></td></tr></tbody></table></figure><h3 id="JavaScript数组和对象"><a href="#JavaScript数组和对象" class="headerlink" title="JavaScript数组和对象"></a>JavaScript数组和对象</h3><p>JS中的数组定义与Java不同，它更像是Python中的列表，数组中的每个元素并不需要时同样的类型：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-string">"lbwnb"</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">NaN</span>]<br></code></pre></td></tr></tbody></table></figure><p>我们可以直接使用下标来访问：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-string">"lbwnb"</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">NaN</span>]<br><span class="hljs-built_in">console</span>.info(arr[<span class="hljs-number">1</span>])<br></code></pre></td></tr></tbody></table></figure><p>我们一开始编写的排序算法，也是使用了数组。</p><p>数组还可以动态扩容，如果我们尝试访问超出数组长度的元素，并不会出现错误，而是得到undefined，同样的，我们也可以直接往超出数组长度的地方设置元素：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-string">"lbwnb"</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">NaN</span>]<br>arr[<span class="hljs-number">5</span>] = <span class="hljs-string">"???"</span><br><span class="hljs-built_in">console</span>.info(arr)<br></code></pre></td></tr></tbody></table></figure><p>也可以使用<code>push</code>和<code>pop</code>来实现栈操作：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-string">"lbwnb"</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">NaN</span>]<br>arr.push(<span class="hljs-string">"bbb"</span>)<br><span class="hljs-built_in">console</span>.info(arr.pop())<br><span class="hljs-built_in">console</span>.info(arr)<br></code></pre></td></tr></tbody></table></figure><p>数组还包括一些其他的方法，这里就不一一列出了：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-string">"lbwnb"</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">NaN</span>]<br>arr.fill(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">console</span>.info(arr.map(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> {<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">'xxx'</span>+o<br>}))<br></code></pre></td></tr></tbody></table></figure><p>我们接着来看对象，JS中也能定义对象，但是这里的对象有点颠覆我们的认知：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>()<br><span class="hljs-keyword">let</span> obj = {}<br></code></pre></td></tr></tbody></table></figure><p>以上两种写法都能够创建一个对象，但是更推荐使用下面的一种。</p><p>JS中的对象也是非常随意的，我们可以动态为其添加属性：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = {}<br>obj.name = <span class="hljs-string">"伞兵一号"</span><br><span class="hljs-built_in">console</span>.info(obj)<br></code></pre></td></tr></tbody></table></figure><p>同理，我们也可以给对象动态添加一个函数：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = {}<br>obj.f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"我是对象内部的函数"</span>)<br>}<br><br>obj.f()<br></code></pre></td></tr></tbody></table></figure><p>我们可以在函数内使用this关键字来指定对象内的属性：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> name = <span class="hljs-string">"我是外部变量"</span><br><span class="hljs-keyword">let</span> obj = {}<br>obj.name = <span class="hljs-string">"我是内部变量"</span><br>obj.f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"name属性为："</span>+<span class="hljs-built_in">this</span>.name)<br>}<br><br>obj.f()<br></code></pre></td></tr></tbody></table></figure><p><strong>注意：</strong>如果使用lambda表达式，那么this并不会指向对象。</p><p>除了动态添加属性，我们也可以在一开始的时候指定对象内部的成员：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = {<br>    name: <span class="hljs-string">"我是内部的变量"</span>,<br>  f: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{<br>        <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"name属性为："</span>+<span class="hljs-built_in">this</span>.name)<br>    }<br>}<br><br>obj.f()<br></code></pre></td></tr></tbody></table></figure><p>注意如果有多行属性，需要在属性定义后添加一个<code>,</code>进行分割！</p><h3 id="JavaScript事件"><a href="#JavaScript事件" class="headerlink" title="JavaScript事件"></a>JavaScript事件</h3><p>当我们点击一个页面中的按钮之后，我们希望之后能够进行登陆操作，或是执行一些JS代码来实现某些功能，那么这个时候，就需要用到事件。</p><p>事件相当于一个通知，我们可以提前设定好事件发生时需要执行的内容，当事件发生时，就会执行我们预先设定好的JS代码。</p><p>事件有很多种类型，其中常用的有：</p><ul><li>onclick：点击事件</li><li>oninput：内容输入事件</li><li>onsubmit：内容提交事件</li></ul><p>那么如何为事件添加一个动作呢？</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">oninput</span>=<span class="hljs-string">"console.info('正在输入文本')"</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>我们可以直接为一个元素添加对应事件的属性，比如<code>oninput</code>事件，我们可以直接在事件的值中编写js代码，但是注意，只能使用单引号，因为双引号用于囊括整个值。</p><p>我们也可以单独编写一个函数，当事件发生时直接调用我们的函数：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{<br>    <span class="hljs-built_in">window</span>.alert(<span class="hljs-string">"你输入了一个字符"</span>)<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">oninput</span>=<span class="hljs-string">"oninput()"</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>仅仅了解了事件，还不足以实现高度自定义，我们接着来看DOM。</p><h3 id="Document对象"><a href="#Document对象" class="headerlink" title="Document对象"></a>Document对象</h3><p>当网页被加载时，浏览器会创建页面的文档对象模型（<em>D</em>ocument <em>O</em>bject <em>M</em>odel），它将整个页面的所有元素全部映射为JS对象，这样我们就可以在JS中操纵页面中的元素。</p><p><img src="https://www.w3school.com.cn/i/ct_htmltree.gif" alt="DOM HTML 树"></p><p>比如我现在想要读取页面中某个输入框中的内容，那么我们就需要从DOM中获取此输入框元素的对象：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"pwd"</span>).value<br></code></pre></td></tr></tbody></table></figure><p>通过document对象就能够快速获取当前页面中对应的元素，并且我们也可以快速获取元素中的一些属性。</p><p>比如现在我们可以结合事件，来进行密码长度的校验，密码长度小于6则不合法，不合法的密码，会让密码框边框变红，那么首先我们先来编写一个css样式：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.illegal-pwd</span>{<br>    <span class="hljs-attribute">border</span>: red <span class="hljs-number">1px</span> solid <span class="hljs-meta">!important</span>;<br>    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">5px</span> red;<br>}<br></code></pre></td></tr></tbody></table></figure><p>接着我们来编写一下js代码，定义一个函数，此函数接受一个参数（元素本身的对象）检测输入的长度是否大于6，否则就将当前元素的class属性设定为css指定的class：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkIllegal</span>(<span class="hljs-params">e</span>) </span>{<br>    <span class="hljs-keyword">if</span>(e.value.length &lt; <span class="hljs-number">6</span>) {<br>        e.setAttribute(<span class="hljs-string">"class"</span>, <span class="hljs-string">"illegal-pwd"</span>)   <br>    }<span class="hljs-keyword">else</span> {<br>        e.removeAttribute(<span class="hljs-string">"class"</span>)<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>最后我们将此函数绑定到<code>oninput</code>事件即可，注意传入了一个this，这里的this代表的是输入框元素本身：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"pwd"</span> <span class="hljs-attr">oninput</span>=<span class="hljs-string">"checkIllegal(this)"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>现在我们在输入的时候，会自动检查密码是否合法。</p><p>既然oninput本身也是一个属性，那么实际上我们可以动态进行修改：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"pwd"</span>).oninput = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"???"</span>)<br></code></pre></td></tr></tbody></table></figure><p>那么，我们前面提及的window对象又是什么东西呢？</p><p>实际上Window对象范围更加广阔，它甚至直接代表了整个窗口，当然也包含我们的Document对象，我们一般通过Window对象来弹出提示框之类的东西。</p><h3 id="发送XHR请求"><a href="#发送XHR请求" class="headerlink" title="发送XHR请求"></a>发送XHR请求</h3><p>JS的大致内容我们已经全部学习完成了，那么如何使用JS与后端进行交互呢？</p><p>我们知道，如果我们需要提交表单，那么我们就需要将表单的信息全部发送给我们的服务器，那么，如何发送给服务器呢？</p><p>通过使用XMLHttpRequest对象，来向服务器发送一个HTTP请求，下面是一个最简单的请求格式：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>xhr.open(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'https://www.baidu.com'</span>);<br>xhr.send();<br></code></pre></td></tr></tbody></table></figure><p>上面的例子中，我们向服务器发起了一次网络请求，但是我们请求的是百度的服务器，并且此请求的方法为GET请求。</p><p>我们现在将其绑定到一个按钮上作为事件触发：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">http</span>(<span class="hljs-params"></span>) </span>{<br>    <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>    xhr.open(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'https://www.baidu.com'</span>);<br>    xhr.send();    <br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"http()"</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>我们可以在网络中查看我们发起的HTTP请求并且查看请求的响应结果，比如上面的请求，会返回百度这个页面的全部HTML代码。</p><p>实际上，我们的浏览器在我们输入网址后，也会向对应网站的服务器发起一次HTTP的GET请求。</p><p>在浏览器得到页面响应后，会加载当前页面，如果当前页面还引用了其他资源文件，那么会继续向服务器发起请求，直到页面中所有的资源文件全部加载完成后，才会停止。</p>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;前端基础&quot;&gt;&lt;a href=&quot;#前端基础&quot; class=&quot;headerlink&quot; title=&quot;前端基础&quot;&gt;&lt;/a&gt;前端基础&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;提醒：&lt;/strong&gt;还没有申请到IDEA专业版本授权的同学要抓紧了，很快就需要用到。&lt;/p&gt;
&lt;p&gt;经过前面基础内容的学习，现在我们就可以正式地进入Web开发的学习当中啦~&lt;/p&gt;
&lt;p&gt;本章节会讲解前端基础内容（如果已经学习过，可以直接跳到下一个大章节了）那么什么是前端，什么又是后端呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前端：我们网站的页面，包括网站的样式、图片、视频等一切用户可见的内容都是前端的内容。&lt;/li&gt;
&lt;li&gt;后端：处理网站的所有数据来源，比如我们之前从数据库中查询数据，而我们查询的数据经过处理最终会被展示到前端，而用于处理前端数据的工作就是由后端来完成的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相当于，前端仅仅是一层皮，它直接决定了整个网站的美观程度，我们可以自由地编排页面的布局，甚至可以编写好看的特效；而灵魂则是后端，如何处理用户的交互、如何处理数据查询是后端的职责所在，我们前面学习的都是后端内容，而Java也是一门专注于后端开发的语言。&lt;/p&gt;
&lt;p&gt;对于前端开发我们需要学习一些新的内容，只有了解了它们，我们才能编写出美观的页面。&lt;/p&gt;
&lt;p&gt;本教程并不会过多地去讲解前端知识，我们只会提及一些必要的内容，我们主要学习的是JavaWeb，更倾向于后端开发，学习前端的目的只是为了让同学们了解前后端的交互方式，在进行后端开发时思路能够更加清晰，有关前端的完整内容学习，可以浏览其他前端知识教程。&lt;/p&gt;
&lt;p&gt;我们在最开始讲解网络编程时，提到了浏览器访问服务器，实际上浏览器访问服务器就是一种B/S结构，而我们使用Java代码编写的客户端连接服务器就是一种C/S结构。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://xiaofanshutu.github.io/posts/0.html"/>
    <id>https://xiaofanshutu.github.io/posts/0.html</id>
    <published>2025-08-31T15:29:05.022Z</published>
    <updated>2025-08-31T15:31:22.574Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java与数据库"><a href="#Java与数据库" class="headerlink" title="Java与数据库"></a>Java与数据库</h1><p>通过Java如何去使用数据库来帮助我们存储数据呢，这将是本章节讨论的重点。</p><h2 id="初识JDBC"><a href="#初识JDBC" class="headerlink" title="初识JDBC"></a>初识JDBC</h2><p>JDBC是什么？JDBC英文名为：Java Data Base Connectivity(Java数据库连接)，官方解释它是Java编程语言和广泛的数据库之间独立于数据库的连接标准的Java API，根本上说JDBC是一种规范，它提供的接口，一套完整的，允许便捷式访问底层数据库。可以用JAVA来写不同类型的可执行文件：JAVA应用程序、JAVA Applets、Java Servlet、JSP等，不同的可执行文件都能通过JDBC访问数据库，又兼备存储的优势。简单说它就是Java与数据库的连接的桥梁或者插件，用Java代码就能操作数据库的增删改查、存储过程、事务等。</p><p>我们可以发现，JDK自带了一个<code>java.sql</code>包，而这里面就定义了大量的接口，不同类型的数据库，都可以通过实现此接口，编写适用于自己数据库的实现类。而不同的数据库厂商实现的这套标准，我们称为<code>数据库驱动</code>。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>那么我们首先来进行一些准备工作，以便开始JDBC的学习：</p><ul><li>将idea连接到我们的数据库，以便以后调试。</li><li>将mysql驱动jar依赖导入到项目中（推荐6.0版本以上，这里用到是8.0）</li><li>向Jetbrians申请一个学生/教师授权，用于激活idea终极版（进行JavaWeb开发需要用到，一般申请需要3-7天时间审核）不是大学生的话…emmm…懂的都懂。</li><li>教育授权申请地址：<a href="https://www.jetbrains.com/shop/eform/students">https://www.jetbrains.com/shop/eform/students</a></li></ul><p>一个Java程序并不是一个人的战斗，我们可以在别人开发的基础上继续向上开发，其他的开发者可以将自己编写的Java代码打包为<code>jar</code>，我们只需要导入这个<code>jar</code>作为依赖，即可直接使用别人的代码，就像我们直接去使用JDK提供的类一样。</p><h3 id="使用JDBC连接数据库"><a href="#使用JDBC连接数据库" class="headerlink" title="使用JDBC连接数据库"></a>使用JDBC连接数据库</h3><p><strong>注意：</strong>6.0版本以上，不用手动加载驱动，我们直接使用即可！</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 通过DriverManager来获得数据库连接</span><br><span class="hljs-keyword">try</span> (Connection connection = DriverManager.getConnection(<span class="hljs-string">"连接URL"</span>,<span class="hljs-string">"用户名"</span>,<span class="hljs-string">"密码"</span>);<br>     <span class="hljs-comment">//2. 创建一个用于执行SQL的Statement对象</span><br>     Statement statement = connection.createStatement()){   <span class="hljs-comment">//注意前两步都放在try()中，因为在最后需要释放资源！</span><br>    <span class="hljs-comment">//3. 执行SQL语句，并得到结果集</span><br>    ResultSet set = statement.executeQuery(<span class="hljs-string">"select * from 表名"</span>);<br>    <span class="hljs-comment">//4. 查看结果</span><br>    <span class="hljs-keyword">while</span> (set.next()){<br>        ...<br>    }<br>}<span class="hljs-keyword">catch</span> (SQLException e){<br>    e.printStackTrace();<br>}<br><span class="hljs-comment">//5. 释放资源，try-with-resource语法会自动帮助我们close</span><br></code></pre></td></tr></tbody></table></figure><p>其中，连接的URL如果记不住格式，我们可以打开idea的数据库连接配置，复制一份即可。（其实idea本质也是使用的JDBC，整个idea程序都是由Java编写的，实际上idea就是一个Java程序）</p><h3 id="了解DriverManager"><a href="#了解DriverManager" class="headerlink" title="了解DriverManager"></a>了解DriverManager</h3><p>我们首先来了解一下DriverManager是什么东西，它其实就是管理我们的数据库驱动的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerDriver</span><span class="hljs-params">(java.sql.Driver driver,</span></span><br><span class="hljs-function"><span class="hljs-params">        DriverAction da)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> SQLException </span>{<br><br>    <span class="hljs-comment">/* Register the driver if it has not already been added to our list */</span><br>    <span class="hljs-keyword">if</span>(driver != <span class="hljs-keyword">null</span>) {<br>        registeredDrivers.addIfAbsent(<span class="hljs-keyword">new</span> DriverInfo(driver, da));    <span class="hljs-comment">//在刚启动时，mysql实现的驱动会被加载，我们可以断点调试一下。</span><br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-comment">// This is for compatibility with the original DriverManager</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    }<br><br>    println(<span class="hljs-string">"registerDriver: "</span> + driver);<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以通过调用getConnection()来进行数据库的链接：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CallerSensitive</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">(String url,</span></span><br><span class="hljs-function"><span class="hljs-params">    String user, String password)</span> <span class="hljs-keyword">throws</span> SQLException </span>{<br>    java.util.Properties info = <span class="hljs-keyword">new</span> java.util.Properties();<br><br>    <span class="hljs-keyword">if</span> (user != <span class="hljs-keyword">null</span>) {<br>        info.put(<span class="hljs-string">"user"</span>, user);<br>    }<br>    <span class="hljs-keyword">if</span> (password != <span class="hljs-keyword">null</span>) {<br>        info.put(<span class="hljs-string">"password"</span>, password);<br>    }<br><br>    <span class="hljs-keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));   <span class="hljs-comment">//内部有实现</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以手动为驱动管理器添加一个日志打印：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> {<br>    DriverManager.setLogWriter(<span class="hljs-keyword">new</span> PrintWriter(System.out));   <span class="hljs-comment">//这里直接设定为控制台输出</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>现在我们执行的数据库操作日志会在控制台实时打印。</p><h3 id="了解Connection"><a href="#了解Connection" class="headerlink" title="了解Connection"></a>了解Connection</h3><p>Connection是数据库的连接对象，可以通过连接对象来创建一个Statement用于执行SQL语句：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Statement <span class="hljs-title">createStatement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException</span>;<br></code></pre></td></tr></tbody></table></figure><p>我们发现除了普通的Statement，还存在PreparedStatement：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">PreparedStatement <span class="hljs-title">prepareStatement</span><span class="hljs-params">(String sql)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> SQLException</span>;<br></code></pre></td></tr></tbody></table></figure><p>在后面我们会详细介绍PreparedStatement的使用，它能够有效地预防SQL注入式攻击。</p><p>它还支持事务的处理，也放到后面来详细进行讲解。</p><h3 id="了解Statement"><a href="#了解Statement" class="headerlink" title="了解Statement"></a>了解Statement</h3><p>我们发现，我们之前使用了<code>executeQuery()</code>方法来执行<code>select</code>语句，此方法返回给我们一个ResultSet对象，查询得到的数据，就存放在ResultSet中！</p><p>Statement除了执行这样的DQL语句外，我们还可以使用<code>executeUpdate()</code>方法来执行一个DML或是DDL语句，它会返回一个int类型，表示执行后受影响的行数，可以通过它来判断DML语句是否执行成功。</p><p>也可以通过<code>excute()</code>来执行任意的SQL语句，它会返回一个<code>boolean</code>来表示执行结果是一个ResultSet还是一个int，我们可以通过使用<code>getResultSet()</code>或是<code>getUpdateCount()</code>来获取。</p><h3 id="执行DML操作"><a href="#执行DML操作" class="headerlink" title="执行DML操作"></a>执行DML操作</h3><p>我们通过几个例子来向数据库中插入数据。</p><h3 id="执行DQL操作"><a href="#执行DQL操作" class="headerlink" title="执行DQL操作"></a>执行DQL操作</h3><p>执行DQL操作会返回一个ResultSet对象，我们来看看如何从ResultSet中去获取数据：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//首先要明确，select返回的数据类似于一个excel表格</span><br><span class="hljs-keyword">while</span> (set.next()){<br>    <span class="hljs-comment">//每调用一次next()就会向下移动一行，首次调用会移动到第一行</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>我们在移动行数后，就可以通过set中提供的方法，来获取每一列的数据。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F202005062358238.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlZ2lubw%3D%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70&amp;refer=http%3A%2F%2Fimg-blog.csdnimg.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1638091193&amp;t=bf37a5cb988d0a641d00c7e325d06ce7" alt="img"></p><h3 id="执行批处理操作"><a href="#执行批处理操作" class="headerlink" title="执行批处理操作"></a>执行批处理操作</h3><p>当我们要执行很多条语句时，可以不用一次一次地提交，而是一口气全部交给数据库处理，这样会节省很多的时间。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>{<br>    <span class="hljs-keyword">try</span> (Connection connection = DriverManager.getConnection();<br>         Statement statement = connection.createStatement()){<br><br>        statement.addBatch(<span class="hljs-string">"insert into user values ('f', 1234)"</span>);<br>        statement.addBatch(<span class="hljs-string">"insert into user values ('e', 1234)"</span>);   <span class="hljs-comment">//添加每一条批处理语句</span><br>        statement.executeBatch();   <span class="hljs-comment">//一起执行</span><br><br>    }<span class="hljs-keyword">catch</span> (SQLException e){<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="将查询结果映射为对象"><a href="#将查询结果映射为对象" class="headerlink" title="将查询结果映射为对象"></a>将查询结果映射为对象</h3><p>既然我们现在可以从数据库中获取数据了，那么现在就可以将这些数据转换为一个类来进行操作，首先定义我们的实体类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>{<br>    Integer sid;<br>    String name;<br>    String sex;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(Integer sid, String name, String sex)</span> </span>{<br>        <span class="hljs-keyword">this</span>.sid = sid;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.sex = sex;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span>{<br>        System.out.println(<span class="hljs-string">"我叫："</span>+name+<span class="hljs-string">"，学号为："</span>+sid+<span class="hljs-string">"，我的性别是："</span>+sex);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>现在我们来进行一个转换：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (set.next()){<br>    Student student = <span class="hljs-keyword">new</span> Student(set.getInt(<span class="hljs-number">1</span>), set.getString(<span class="hljs-number">2</span>), set.getString(<span class="hljs-number">3</span>));<br>    student.say();<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>注意：</strong>列的下标是从1开始的。</p><p>我们也可以利用反射机制来将查询结果映射为对象，使用反射的好处是，无论什么类型都可以通过我们的方法来进行实体类型映射：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">convert</span><span class="hljs-params">(ResultSet set, Class&lt;T&gt; clazz)</span></span>{<br>    <span class="hljs-keyword">try</span> {<br>        Constructor&lt;T&gt; constructor = clazz.getConstructor(clazz.getConstructors()[<span class="hljs-number">0</span>].getParameterTypes());   <span class="hljs-comment">//默认获取第一个构造方法</span><br>        Class&lt;?&gt;[] param = constructor.getParameterTypes();  <span class="hljs-comment">//获取参数列表</span><br>        Object[] object = <span class="hljs-keyword">new</span> Object[param.length];  <span class="hljs-comment">//存放参数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; param.length; i++) {   <span class="hljs-comment">//是从1开始的</span><br>            object[i] = set.getObject(i+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(object[i].getClass() != param[i])<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SQLException(<span class="hljs-string">"错误的类型转换："</span>+object[i].getClass()+<span class="hljs-string">" -&gt; "</span>+param[i]);<br>        }<br>        <span class="hljs-keyword">return</span> constructor.newInstance(object);<br>    } <span class="hljs-keyword">catch</span> (ReflectiveOperationException | SQLException e) {<br>        e.printStackTrace();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>现在我们就可以通过我们的方法来将查询结果转换为一个对象了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (set.next()){<br>    Student student = convert(set, Student.class);<br>    <span class="hljs-keyword">if</span>(student != <span class="hljs-keyword">null</span>) student.say();<br>}<br></code></pre></td></tr></tbody></table></figure><p>实际上，在后面我们会学习Mybatis框架，它对JDBC进行了深层次的封装，而它就进行类似上面反射的操作来便于我们对数据库数据与实体类的转换。</p><h3 id="实现登陆与SQL注入攻击"><a href="#实现登陆与SQL注入攻击" class="headerlink" title="实现登陆与SQL注入攻击"></a>实现登陆与SQL注入攻击</h3><p>在使用之前，我们先来看看如果我们想模拟登陆一个用户，我们该怎么去写：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (Connection connection = DriverManager.getConnection(<span class="hljs-string">"URL"</span>,<span class="hljs-string">"用户名"</span>,<span class="hljs-string">"密码"</span>);<br>     Statement statement = connection.createStatement();<br>     Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in)){<br>    ResultSet res = statement.executeQuery(<span class="hljs-string">"select * from user where username='"</span>+scanner.nextLine()+<span class="hljs-string">"'and pwd='"</span>+scanner.nextLine()+<span class="hljs-string">"';"</span>);<br>    <span class="hljs-keyword">while</span> (res.next()){<br>        String username = res.getString(<span class="hljs-number">1</span>);<br>        System.out.println(username+<span class="hljs-string">" 登陆成功！"</span>);<br>    }<br>}<span class="hljs-keyword">catch</span> (SQLException e){<br>    e.printStackTrace();<br>}<br></code></pre></td></tr></tbody></table></figure><p>用户可以通过自己输入用户名和密码来登陆，乍一看好像没啥问题，那如果我输入的是以下内容呢：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">Test<br>1111' or 1=1; <span class="hljs-comment">-- </span><br><span class="hljs-comment"># Test 登陆成功！</span><br></code></pre></td></tr></tbody></table></figure><p>1=1一定是true，那么我们原本的SQL语句会变为：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> username=<span class="hljs-string">'Test'</span> <span class="hljs-keyword">and</span> pwd=<span class="hljs-string">'1111'</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>=<span class="hljs-number">1</span>; <span class="hljs-comment">-- '</span><br></code></pre></td></tr></tbody></table></figure><p>我们发现，如果允许这样的数据插入，那么我们原有的SQL语句结构就遭到了破坏，使得用户能够随意登陆别人的账号。因此我们可能需要限制用户的输入来防止用户输入一些SQL语句关键字，但是关键字非常多，这并不是解决问题的最好办法。</p><h3 id="使用PreparedStatement"><a href="#使用PreparedStatement" class="headerlink" title="使用PreparedStatement"></a>使用PreparedStatement</h3><p>我们发现，如果单纯地使用Statement来执行SQL命令，会存在严重的SQL注入攻击漏洞！而这种问题，我们可以使用PreparedStatement来解决：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>{<br>    <span class="hljs-keyword">try</span> (Connection connection = DriverManager.getConnection(<span class="hljs-string">"URL"</span>,<span class="hljs-string">"用户名"</span>,<span class="hljs-string">"密码"</span>);<br>         PreparedStatement statement = connection.prepareStatement(<span class="hljs-string">"select * from user where username= ? and pwd=?;"</span>);<br>         Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in)){<br><br>        statement.setString(<span class="hljs-number">1</span>, scanner.nextLine());<br>        statement.setString(<span class="hljs-number">2</span>, scanner.nextLine());<br>        System.out.println(statement);    <span class="hljs-comment">//打印查看一下最终执行的</span><br>        ResultSet res = statement.executeQuery();<br>        <span class="hljs-keyword">while</span> (res.next()){<br>            String username = res.getString(<span class="hljs-number">1</span>);<br>            System.out.println(username+<span class="hljs-string">" 登陆成功！"</span>);<br>        }<br>    }<span class="hljs-keyword">catch</span> (SQLException e){<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现，我们需要提前给到PreparedStatement一个SQL语句，并且使用<code>?</code>作为占位符，它会预编译一个SQL语句，通过直接将我们的内容进行替换的方式来填写数据。使用这种方式，我们之前的例子就失效了！我们来看看实际执行的SQL语句是什么：</p><figure class="highlight n1ql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">com.mysql.cj.jdbc.ClientPreparedStatement: <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> username= <span class="hljs-string">'Test'</span> <span class="hljs-keyword">and</span> pwd=<span class="hljs-string">'123456'</span><span class="hljs-string">' or 1=1; -- '</span>;<br></code></pre></td></tr></tbody></table></figure><p>我们发现，我们输入的参数一旦出现<code>'</code>时，会被变为转义形式<code>\'</code>，而最外层有一个真正的<code>'</code>来将我们输入的内容进行包裹，因此它能够有效地防止SQL注入攻击！</p><h3 id="管理事务"><a href="#管理事务" class="headerlink" title="管理事务"></a>管理事务</h3><p>JDBC默认的事务处理行为是自动提交，所以前面我们执行一个SQL语句就会被直接提交（相当于没有启动事务），所以JDBC需要进行事务管理时，首先要通过Connection对象调用setAutoCommit(false) 方法, 将SQL语句的提交（commit）由驱动程序转交给应用程序负责。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">con.setAutoCommit();   <span class="hljs-comment">//关闭自动提交后相当于开启事务。</span><br><span class="hljs-comment">// SQL语句</span><br><span class="hljs-comment">// SQL语句</span><br><span class="hljs-comment">// SQL语句</span><br>con.commit();或 con.rollback();<br></code></pre></td></tr></tbody></table></figure><p>一旦关闭自动提交，那么现在执行所有的操作如果在最后不进行<code>commit()</code>来提交事务的话，那么所有的操作都会丢失，只有提交之后，所有的操作才会被保存！也可以使用<code>rollback()</code>来手动回滚之前的全部操作！</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>{<br>    <span class="hljs-keyword">try</span> (Connection connection = DriverManager.getConnection(<span class="hljs-string">"URL"</span>,<span class="hljs-string">"用户名"</span>,<span class="hljs-string">"密码"</span>);<br>         Statement statement = connection.createStatement()){<br><br>        connection.setAutoCommit(<span class="hljs-keyword">false</span>);  <span class="hljs-comment">//关闭自动提交，现在将变为我们手动提交</span><br>        statement.executeUpdate(<span class="hljs-string">"insert into user values ('a', 1234)"</span>);<br>        statement.executeUpdate(<span class="hljs-string">"insert into user values ('b', 1234)"</span>);<br>        statement.executeUpdate(<span class="hljs-string">"insert into user values ('c', 1234)"</span>);<br><br>        connection.commit();   <span class="hljs-comment">//如果前面任何操作出现异常，将不会执行commit()，之前的操作也就不会生效</span><br>    }<span class="hljs-keyword">catch</span> (SQLException e){<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们来接着尝试一下使用回滚操作：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>{<br>    <span class="hljs-keyword">try</span> (Connection connection = DriverManager.getConnection(<span class="hljs-string">"URL"</span>,<span class="hljs-string">"用户名"</span>,<span class="hljs-string">"密码"</span>);<br>         Statement statement = connection.createStatement()){<br><br>        connection.setAutoCommit(<span class="hljs-keyword">false</span>);  <span class="hljs-comment">//关闭自动提交，现在将变为我们手动提交</span><br>        statement.executeUpdate(<span class="hljs-string">"insert into user values ('a', 1234)"</span>);<br>        statement.executeUpdate(<span class="hljs-string">"insert into user values ('b', 1234)"</span>);<br><br>        connection.rollback();   <span class="hljs-comment">//回滚，撤销前面全部操作</span><br><br>        statement.executeUpdate(<span class="hljs-string">"insert into user values ('c', 1234)"</span>);<br><br>        connection.commit();   <span class="hljs-comment">//提交事务（注意，回滚之前的内容都没了）</span><br><br>    }<span class="hljs-keyword">catch</span> (SQLException e){<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>同样的，我们也可以去创建一个回滚点来实现定点回滚：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>{<br>    <span class="hljs-keyword">try</span> (Connection connection = DriverManager.getConnection(<span class="hljs-string">"URL"</span>,<span class="hljs-string">"用户名"</span>,<span class="hljs-string">"密码"</span>);<br>         Statement statement = connection.createStatement()){<br><br>        connection.setAutoCommit(<span class="hljs-keyword">false</span>);  <span class="hljs-comment">//关闭自动提交，现在将变为我们手动提交</span><br>        statement.executeUpdate(<span class="hljs-string">"insert into user values ('a', 1234)"</span>);<br>        <br>        Savepoint savepoint = connection.setSavepoint();   <span class="hljs-comment">//创建回滚点</span><br>        statement.executeUpdate(<span class="hljs-string">"insert into user values ('b', 1234)"</span>);<br><br>        connection.rollback(savepoint);   <span class="hljs-comment">//回滚到回滚点，撤销前面全部操作</span><br><br>        statement.executeUpdate(<span class="hljs-string">"insert into user values ('c', 1234)"</span>);<br><br>        connection.commit();   <span class="hljs-comment">//提交事务（注意，回滚之前的内容都没了）</span><br><br>    }<span class="hljs-keyword">catch</span> (SQLException e){<br>        e.printStackTrace();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>通过开启事务，我们就可以更加谨慎地进行一些操作了，如果我们想从事务模式切换为原有的自动提交模式，我们可以直接将其设置回去：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>{<br>    <span class="hljs-keyword">try</span> (Connection connection = DriverManager.getConnection(<span class="hljs-string">"URL"</span>,<span class="hljs-string">"用户名"</span>,<span class="hljs-string">"密码"</span>);<br>         Statement statement = connection.createStatement()){<br><br>        connection.setAutoCommit(<span class="hljs-keyword">false</span>);  <span class="hljs-comment">//关闭自动提交，现在将变为我们手动提交</span><br>        statement.executeUpdate(<span class="hljs-string">"insert into user values ('a', 1234)"</span>);<br>        connection.setAutoCommit(<span class="hljs-keyword">true</span>);   <span class="hljs-comment">//重新开启自动提交，开启时把之前的事务模式下的内容给提交了</span><br>        statement.executeUpdate(<span class="hljs-string">"insert into user values ('d', 1234)"</span>);<br>        <span class="hljs-comment">//没有commit也成功了！</span><br>    }<span class="hljs-keyword">catch</span> (SQLException e){<br>        e.printStackTrace();<br>    }<br><br></code></pre></td></tr></tbody></table></figure><p>通过学习JDBC，我们现在就可以通过Java来访问和操作我们的数据库了！为了更好地衔接，我们还会接着讲解主流持久层框架——Mybatis，加深JDBC的记忆。</p><hr><h2 id="使用Lombok"><a href="#使用Lombok" class="headerlink" title="使用Lombok"></a>使用Lombok</h2><p>我们发现，在以往编写项目时，尤其是在类进行类内部成员字段封装时，需要编写大量的get/set方法，这不仅使得我们类定义中充满了get和set方法，同时如果字段名称发生改变，又要挨个进行修改，甚至当字段变得很多时，构造方法的编写会非常麻烦！</p><p>通过使用Lombok（小辣椒）就可以解决这样的问题！</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Finews.gtimg.com%2Fnewsapp_bt%2F0%2F14004711543%2F1000&amp;refer=http%3A%2F%2Finews.gtimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1638080575&amp;t=91a3937a42d14fe8129b3761bbdef82c" alt="img"></p><p>我们来看看，使用原生方式和小辣椒方式编写类的区别，首先是传统方式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>{<br>    <span class="hljs-keyword">private</span> Integer sid;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String sex;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(Integer sid, String name, String sex)</span> </span>{<br>        <span class="hljs-keyword">this</span>.sid = sid;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.sex = sex;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getSid</span><span class="hljs-params">()</span> </span>{             <span class="hljs-comment">//长！</span><br>        <span class="hljs-keyword">return</span> sid;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSid</span><span class="hljs-params">(Integer sid)</span> </span>{     <span class="hljs-comment">//到！</span><br>        <span class="hljs-keyword">this</span>.sid = sid;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{             <span class="hljs-comment">//爆！</span><br>        <span class="hljs-keyword">return</span> name;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>{    <span class="hljs-comment">//炸！</span><br>        <span class="hljs-keyword">this</span>.name = name;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSex</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> sex;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSex</span><span class="hljs-params">(String sex)</span> </span>{<br>        <span class="hljs-keyword">this</span>.sex = sex;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>而使用Lombok之后：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>{<br>    <span class="hljs-keyword">private</span> Integer sid;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String sex;<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现，使用Lombok之后，只需要添加几个注解，就能够解决掉我们之前长长的一串代码！</p><h3 id="配置Lombok"><a href="#配置Lombok" class="headerlink" title="配置Lombok"></a>配置Lombok</h3><ul><li>首先我们需要导入Lombok的jar依赖，和jdbc依赖是一样的，放在项目目录下直接导入就行了。可以在这里进行下载：<a href="https://projectlombok.org/download">https://projectlombok.org/download</a></li><li>然后我们要安装一下Lombok插件，由于IDEA默认都安装了Lombok的插件，因此直接导入依赖后就可以使用了。</li><li>重启IDEA</li></ul><p>Lombok是一种插件化注解API，是通过添加注解来实现的，然后在javac进行编译的时候，进行处理。</p><p>Java的编译过程可以分成三个阶段：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL29wZW5qZGsuamF2YS5uZXQvZ3JvdXBzL2NvbXBpbGVyL2RvYy9jb21waWxhdGlvbi1vdmVydmlldy9qYXZhYy1mbG93LnBuZw?x-oss-process=image/format,png" alt="img"></p><ol><li>所有源文件会被解析成语法树。</li><li>调用注解处理器。如果注解处理器产生了新的源文件，新文件也要进行编译。</li><li>最后，语法树会被分析并转化成类文件。</li></ol><p>实际上在上述的第二阶段，会执行*<a href="https://github.com/rzwitserloot/lombok/blob/master/src/core/lombok/core/AnnotationProcessor.java">lombok.core.AnnotationProcessor</a>*，它所做的工作就是我们上面所说的，修改语法树。</p><h3 id="使用Lombok-1"><a href="#使用Lombok-1" class="headerlink" title="使用Lombok"></a>使用Lombok</h3><p>我们通过实战来演示一下Lombok的实用注解：</p><ul><li>我们通过添加<code>@Getter</code>和<code>@Setter</code>来为当前类的所有字段生成get/set方法，他们可以添加到类或是字段上，注意静态字段不会生成，final字段无法生成set方法。<ul><li>我们还可以使用@Accessors来控制生成Getter和Setter的样式。 </li></ul></li><li>我们通过添加<code>@ToString</code>来为当前类生成预设的toString方法。</li><li>我们可以通过添加<code>@EqualsAndHashCode</code>来快速生成比较和哈希值方法。</li><li>我们可以通过添加<code>@AllArgsConstructor</code>和<code>@NoArgsConstructor</code>来快速生成全参构造和无参构造。</li><li>我们可以添加<code>@RequiredArgsConstructor</code>来快速生成参数只包含<code>final</code>或被标记为<code>@NonNull</code>的成员字段。</li><li>使用<code>@Data</code>能代表<code>@Setter</code>、<code>@Getter</code>、<code>@RequiredArgsConstructor</code>、<code>@ToString</code>、<code>@EqualsAndHashCode</code>全部注解。<ul><li>一旦使用<code>@Data</code>就不建议此类有继承关系，因为<code>equal</code>方法可能不符合预期结果（尤其是仅比较子类属性）。</li></ul></li><li>使用<code>@Value</code>与<code>@Data</code>类似，但是并不会生成setter并且成员属性都是final的。</li><li>使用<code>@SneakyThrows</code>来自动生成try-catch代码块。</li><li>使用<code>@Cleanup</code>作用与局部变量，在最后自动调用其<code>close()</code>方法（可以自由更换）</li><li>使用<code>@Builder</code>来快速生成建造者模式。<ul><li>通过使用<code>@Builder.Default</code>来指定默认值。</li><li>通过使用<code>@Builder.ObtainVia</code>来指定默认值的获取方式。</li></ul></li></ul><hr><h2 id="认识Mybatis"><a href="#认识Mybatis" class="headerlink" title="认识Mybatis"></a>认识Mybatis</h2><p>在前面JDBC的学习中，虽然我们能够通过JDBC来连接和操作数据库，但是哪怕只是完成一个SQL语句的执行，都需要编写大量的代码，更不用说如果我还需要进行实体类映射，将数据转换为我们可以直接操作的实体类型，JDBC很方便，但是还不够方便，我们需要一种更加简洁高效的方式来和数据库进行交互。</p><p><strong>再次强调：</strong>学习厉害的框架或是厉害的技术，并不是为了一定要去使用它，而是它们能够使得我们在不同的开发场景下，合理地使用这些技术，以灵活地应对需要解决的问题。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F26720164-60462fc7927f8784.jpg&amp;refer=http%3A%2F%2Fupload-images.jianshu.io&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1638550660&amp;t=a0923b35afbaed1a168b74eb45ad2b4f" alt="img"></p><p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。</p><p>我们依然使用传统的jar依赖方式，从最原始开始讲起，不使用Maven，有关Maven内容我们会在后面统一讲解！全程围绕官方文档讲解！</p><p>这一块内容很多很杂，再次强调要多实践！</p><h3 id="XML语言概述"><a href="#XML语言概述" class="headerlink" title="XML语言概述"></a>XML语言概述</h3><p>在开始介绍Mybatis之前，XML语言发明最初是用于数据的存储和传输，它可以长这样：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">outer</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>阿伟<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">desc</span>&gt;</span>怎么又在玩电动啊<span class="hljs-tag">&lt;/<span class="hljs-name">desc</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">inner</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"1"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">age</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">age</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sex</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">sex</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">inner</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">outer</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>如果你学习过前端知识，你会发现它和HTML几乎长得一模一样！但是请注意，虽然它们长得差不多，但是他们的意义却不同，HTML主要用于通过编排来展示数据，而XML主要是存放数据，它更像是一个配置文件！当然，浏览器也是可以直接打开XML文件的。</p><p>一个XML文件存在以下的格式规范：</p><ul><li>必须存在一个根节点，将所有的子标签全部包含。</li><li>可以但不必须包含一个头部声明（主要是可以设定编码格式）</li><li>所有的标签必须成对出现，可以嵌套但不能交叉嵌套</li><li>区分大小写。</li><li>标签中可以存在属性，比如上面的<code>type="1"</code>就是<code>inner</code>标签的一个属性，属性的值由单引号或双引号包括。</li></ul><p>XML文件也可以使用注释：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="hljs-comment">&lt;!-- 注释内容 --&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>通过IDEA我们可以使用<code>Ctrl</code>+<code>/</code>来快速添加注释文本（不仅仅适用于XML，还支持很多种类型的文件）</p><p>那如果我们的内容中出现了<code>&lt;</code>或是<code>&gt;</code>字符，那该怎么办呢？我们就可以使用XML的转义字符来代替：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.jxdoc.com%2Fpic%2F28d1ff67caaedd3383c4d358%2F1-332-jpg_6_0_______-505-0-0-505.jpg&amp;refer=http%3A%2F%2Fimg.jxdoc.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1639322216&amp;t=88d1ea1adb9cbf1611eaf4c9fa16b8b0" alt="img"></p><p>如果嫌一个一个改太麻烦，也可以使用CD来快速创建不解析区域：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">test</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>&lt;![CDATA[我看你&lt;&gt;&lt;&gt;&lt;&gt;是一点都不懂哦&gt;&gt;&gt;]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>那么，我们现在了解了XML文件的定义，现在该如何去解析一个XML文件呢？比如我们希望将定义好的XML文件读取到Java程序中，这时该怎么做呢？</p><p>JDK为我们内置了一个叫做<code>org.w3c</code>的XML解析库，我们来看看如何使用它来进行XML文件内容解析：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建DocumentBuilderFactory对象</span><br>DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();<br><span class="hljs-comment">// 创建DocumentBuilder对象</span><br><span class="hljs-keyword">try</span> {<br>    DocumentBuilder builder = factory.newDocumentBuilder();<br>    Document d = builder.parse(<span class="hljs-string">"file:mappers/test.xml"</span>);<br>    <span class="hljs-comment">// 每一个标签都作为一个节点</span><br>    NodeList nodeList = d.getElementsByTagName(<span class="hljs-string">"test"</span>);  <span class="hljs-comment">// 可能有很多个名字为test的标签</span><br>    Node rootNode = nodeList.item(<span class="hljs-number">0</span>); <span class="hljs-comment">// 获取首个</span><br><br>    NodeList childNodes = rootNode.getChildNodes(); <span class="hljs-comment">// 一个节点下可能会有很多个节点，比如根节点下就囊括了所有的节点</span><br>    <span class="hljs-comment">//节点可以是一个带有内容的标签（它内部就还有子节点），也可以是一段文本内容</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; childNodes.getLength(); i++) {<br>        Node child = childNodes.item(i);<br>        <span class="hljs-keyword">if</span>(child.getNodeType() == Node.ELEMENT_NODE)  <span class="hljs-comment">//过滤换行符之类的内容，因为它们都被认为是一个文本节点</span><br>        System.out.println(child.getNodeName() + <span class="hljs-string">"："</span> +child.getFirstChild().getNodeValue());<br>        <span class="hljs-comment">// 输出节点名称，也就是标签名称，以及标签内部的文本（内部的内容都是子节点，所以要获取内部的节点）</span><br>    }<br>} <span class="hljs-keyword">catch</span> (Exception e) {<br>    e.printStackTrace();<br>}<br></code></pre></td></tr></tbody></table></figure><p>当然，学习和使用XML只是为了更好地去认识Mybatis的工作原理，以及如何使用XML来作为Mybatis的配置文件，这是在开始之前必须要掌握的内容（使用Java读取XML内容不要求掌握，但是需要知道Mybatis就是通过这种方式来读取配置文件的）</p><p>不仅仅是Mybatis，包括后面的Spring等众多框架都会用到XML来作为框架的配置文件！</p><h3 id="初次使用Mybatis"><a href="#初次使用Mybatis" class="headerlink" title="初次使用Mybatis"></a>初次使用Mybatis</h3><p>那么我们首先来感受一下Mybatis给我们带来的便捷，就从搭建环境开始，中文文档网站：<a href="https://mybatis.org/mybatis-3/zh/configuration.html">https://mybatis.org/mybatis-3/zh/configuration.html</a></p><p>我们需要导入Mybatis的依赖，Jar包需要在github上下载，如果卡得一匹，连不上可以在视频简介处从分享的文件中获取。同样地放入到项目的根目录下，右键作为依赖即可！（依赖变多之后，我们可以将其放到一个单独的文件夹，不然会很繁杂）</p><p>依赖导入完成后，我们就可以编写Mybatis的配置文件了（现在不是在Java代码中配置了，而是通过一个XML文件去配置，这样就使得硬编码的部分大大减少，项目后期打包成Jar运行不方便修复，但是通过配置文件，我们随时都可以去修改，就变得很方便了，同时代码量也大幅度减少，配置文件填写完成后，我们只需要关心项目的业务逻辑而不是如何去读取配置文件）我们按照官方文档给定的提示，在项目根目录下新建名为<code>mybatis-config.xml</code>的文件，并填写以下内容：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">  <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="hljs-meta">  <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">"development"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"development"</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"JDBC"</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"POOLED"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${驱动类（含包名）}"</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${数据库连接URL}"</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${用户名}"</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${密码}"</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>我们发现，在最上方还引入了一个叫做DTD（文档类型定义）的东西，它提前帮助我们规定了一些标签，我们就需要使用Mybatis提前帮助我们规定好的标签来进行配置（因为只有这样Mybatis才能正确识别我们配置的内容）</p><p>通过进行配置，我们就告诉了Mybatis我们链接数据库的一些信息，包括URL、用户名、密码等，这样Mybatis就知道该链接哪个数据库、使用哪个账号进行登陆了（也可以不使用配置文件，这里不做讲解，还请各位小伙伴自行阅读官方文档）</p><p>配置文件完成后，我们需要在Java程序启动时，让Mybatis对配置文件进行读取并得到一个<code>SqlSessionFactory</code>对象：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>{<br>    SqlSessionFactory sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"mybatis-config.xml"</span>));<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = sqlSessionFactory.openSession(<span class="hljs-keyword">true</span>)){<br><span class="hljs-comment">//暂时还没有业务</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>直接运行即可，虽然没有干什么事情，但是不会出现错误，如果之前的配置文件编写错误，直接运行会产生报错！那么现在我们来看看，<code>SqlSessionFactory</code>对象是什么东西：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.h5w3.com%2Fwp-content%2Fuploads%2F2021%2F01%2F1460000039107464.png&amp;refer=http%3A%2F%2Fwww.h5w3.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1639372889&amp;t=f37deb63f29f0dc2f8b6a3517a68b86c" alt="img"></p><p>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的，我们可以通过<code>SqlSessionFactory</code>来创建多个新的会话，<code>SqlSession</code>对象，每个会话就相当于我不同的地方登陆一个账号去访问数据库，你也可以认为这就是之前JDBC中的<code>Statement</code>对象，会话之间相互隔离，没有任何关联。</p><p>而通过<code>SqlSession</code>就可以完成几乎所有的数据库操作，我们发现这个接口中定义了大量数据库操作的方法，因此，现在我们只需要通过一个对象就能完成数据库交互了，极大简化了之前的流程。</p><p>我们来尝试一下直接读取实体类，读取实体类肯定需要一个映射规则，比如类中的哪个字段对应数据库中的哪个字段，在查询语句返回结果后，Mybatis就会自动将对应的结果填入到对象的对应字段上。首先编写实体类，，直接使用Lombok是不是就很方便了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>{<br>    <span class="hljs-keyword">int</span> sid;   <span class="hljs-comment">//名称最好和数据库字段名称保持一致，不然可能会映射失败导致查询结果丢失</span><br>    String name;<br>    String sex;<br>}<br></code></pre></td></tr></tbody></table></figure><p>在根目录下重新创建一个mapper文件夹，新建名为<code>TestMapper.xml</code>的文件作为我们的映射器，并填写以下内容：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"TestMapper"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectStudent"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"com.test.entity.Student"</span>&gt;</span><br>        select * from student<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>其中namespace就是命名空间，每个Mapper都是唯一的，因此需要用一个命名空间来区分，它还可以用来绑定一个接口。我们在里面写入了一个select标签，表示添加一个select操作，同时id作为操作的名称，resultType指定为我们刚刚定义的实体类，表示将数据库结果映射为<code>Student</code>类，然后就在标签中写入我们的查询语句即可。</p><p>编写好后，我们在配置文件中添加这个Mapper映射器：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">url</span>=<span class="hljs-string">"file:mappers/TestMapper.xml"</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--    这里用的是url，也可以使用其他类型，我们会在后面讲解    --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>最后在程序中使用我们定义好的Mapper即可：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>{<br>    SqlSessionFactory sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"mybatis-config.xml"</span>));<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = sqlSessionFactory.openSession(<span class="hljs-keyword">true</span>)){<br>        List&lt;Student&gt; student = sqlSession.selectList(<span class="hljs-string">"selectStudent"</span>);<br>        student.forEach(System.out::println);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们会发现，Mybatis非常智能，我们只需要告诉一个映射关系，就能够直接将查询结果转化为一个实体类！</p><h3 id="配置Mybatis"><a href="#配置Mybatis" class="headerlink" title="配置Mybatis"></a>配置Mybatis</h3><p>在了解了Mybatis为我们带来的便捷之后，现在我们就可以正式地去学习使用Mybatis了！</p><p>由于<code>SqlSessionFactory</code>一般只需要创建一次，因此我们可以创建一个工具类来集中创建<code>SqlSession</code>，这样会更加方便一些：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisUtil</span> </span>{<br><br>    <span class="hljs-comment">//在类加载时就进行创建</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory sqlSessionFactory;<br>    <span class="hljs-keyword">static</span> {<br>        <span class="hljs-keyword">try</span> {<br>            sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"mybatis-config.xml"</span>));<br>        } <span class="hljs-keyword">catch</span> (FileNotFoundException e) {<br>            e.printStackTrace();<br>        }<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取一个新的会话</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> autoCommit 是否开启自动提交（跟JDBC是一样的，如果不自动提交，则会变成事务操作）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> SqlSession对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title">getSession</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> autoCommit)</span></span>{<br>        <span class="hljs-keyword">return</span> sqlSessionFactory.openSession(autoCommit);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>现在我们只需要在main方法中这样写即可查询结果了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">true</span>)){<br>        List&lt;Student&gt; student = sqlSession.selectList(<span class="hljs-string">"selectStudent"</span>);<br>        student.forEach(System.out::println);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>之前我们演示了，如何创建一个映射器来将结果快速转换为实体类，但是这样可能还是不够方便，我们每次都需要去找映射器对应操作的名称，而且还要知道对应的返回类型，再通过<code>SqlSession</code>来执行对应的方法，能不能再方便一点呢？</p><p>现在，我们可以通过<code>namespace</code>来绑定到一个接口上，利用接口的特性，我们可以直接指明方法的行为，而实际实现则是由Mybatis来完成。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestMapper</span> </span>{<br>    <span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">selectStudent</span><span class="hljs-params">()</span></span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>将Mapper文件的命名空间修改为我们的接口，建议同时将其放到同名包中，作为内部资源：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"com.test.mapper.TestMapper"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectStudent"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"com.test.entity.Student"</span>&gt;</span><br>        select * from student<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>作为内部资源后，我们需要修改一下配置文件中的mapper定义，不使用url而是resource表示是Jar内部的文件：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"com/test/mapper/TestMapper.xml"</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>现在我们就可以直接通过<code>SqlSession</code>获取对应的实现类，通过接口中定义的行为来直接获取结果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">true</span>)){<br>        TestMapper testMapper = sqlSession.getMapper(TestMapper.class);<br>        List&lt;Student&gt; student = testMapper.selectStudent();<br>        student.forEach(System.out::println);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>那么肯定有人好奇，TestMapper明明是一个我们自己定义接口啊，Mybatis也不可能提前帮我们写了实现类啊，那这接口怎么就出现了一个实现类呢？我们可以通过调用<code>getClass()</code>方法来看看实现类是个什么：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">TestMapper testMapper = sqlSession.getMapper(TestMapper.class);<br>System.out.println(testMapper.getClass());<br></code></pre></td></tr></tbody></table></figure><p>我们发现，实现类名称很奇怪，名称为<code>com.sun.proxy.$Proxy4</code>，它是通过动态代理生成的，相当于动态生成了一个实现类，而不是预先定义好的，有关Mybatis这一部分的原理，我们放在最后一节进行讲解。</p><p>接下来，我们再来看配置文件，之前我们并没有对配置文件进行一个详细的介绍：</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;configuration&gt;<br>    &lt;environments <span class="hljs-keyword">default</span>=<span class="hljs-string">"development"</span>&gt;<br>        &lt;environment id=<span class="hljs-string">"development"</span>&gt;<br>            &lt;transactionManager type=<span class="hljs-string">"JDBC"</span>/&gt;<br>            &lt;dataSource type=<span class="hljs-string">"POOLED"</span>&gt;<br>                &lt;property name=<span class="hljs-string">"driver"</span> value=<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>/&gt;<br>                &lt;property name=<span class="hljs-string">"url"</span> value=<span class="hljs-string">"jdbc:mysql://localhost:3306/study"</span>/&gt;<br>                &lt;property name=<span class="hljs-string">"username"</span> value=<span class="hljs-string">"test"</span>/&gt;<br>                &lt;property name=<span class="hljs-string">"password"</span> value=<span class="hljs-string">"123456"</span>/&gt;<br>            &lt;/dataSource&gt;<br>        &lt;/environment&gt;<br>    &lt;/environments&gt;<br>    &lt;mappers&gt;<br>        &lt;mapper resource=<span class="hljs-string">"com/test/mapper/TestMapper.xml"</span>/&gt;<br>    &lt;/mappers&gt;<br>&lt;/configuration&gt;<br></code></pre></td></tr></tbody></table></figure><p>首先就从<code>environments</code>标签说起，一般情况下，我们在开发中，都需要指定一个数据库的配置信息，包含连接URL、用户、密码等信息，而<code>environment</code>就是用于进行这些配置的！实际情况下可能会不止有一个数据库连接信息，比如开发过程中我们一般会使用本地的数据库，而如果需要将项目上传到服务器或是防止其他人的电脑上运行时，我们可能就需要配置另一个数据库的信息，因此，我们可以提前定义好所有的数据库信息，该什么时候用什么即可！</p><p>在<code>environments</code>标签上有一个default属性，来指定默认的环境，当然如果我们希望使用其他环境，可以修改这个默认环境，也可以在创建工厂时选择环境：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder()<br>        .build(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"mybatis-config.xml"</span>), <span class="hljs-string">"环境ID"</span>);<br></code></pre></td></tr></tbody></table></figure><p>我们还可以给类型起一个别名，以简化Mapper的编写：</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!-- 需要在environments的上方 --&gt;<br>&lt;typeAliases&gt;<br>    &lt;typeAlias type=<span class="hljs-string">"com.test.entity.Student"</span> alias=<span class="hljs-string">"Student"</span>/&gt;<br>&lt;/typeAliases&gt;<br></code></pre></td></tr></tbody></table></figure><p>现在Mapper就可以直接使用别名了：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"com.test.mapper.TestMapper"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectStudent"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"Student"</span>&gt;</span><br>        select * from student<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>如果这样还是很麻烦，我们也可以直接让Mybatis去扫描一个包，并将包下的所有类自动起别名（别名为首字母小写的类名）</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;typeAliases&gt;<br>    &lt;<span class="hljs-keyword">package</span> name=<span class="hljs-string">"com.test.entity"</span>/&gt;<br>&lt;/typeAliases&gt;<br></code></pre></td></tr></tbody></table></figure><p>也可以为指定实体类添加一个注解，来指定别名：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Alias("lbwnb")</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>{<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sid;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String sex;<br>}<br></code></pre></td></tr></tbody></table></figure><p>当然，Mybatis也包含许多的基础配置，通过使用：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">""</span> <span class="hljs-attr">value</span>=<span class="hljs-string">""</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>所有的配置项可以在中文文档处查询，本文不会进行详细介绍，在后面我们会提出一些比较重要的配置项。</p><p>有关配置文件的介绍就暂时到这里为止，我们讨论的重心应该是Mybatis的应用，而不是配置文件，所以省略了一部分内容的讲解。</p><h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><p>在了解了Mybatis的一些基本配置之后，我们就可以正式来使用Mybatis来进行数据库操作了！</p><p>在前面我们演示了如何快速进行查询，我们只需要编写一个对应的映射器既可以了：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"com.test.mapper.TestMapper"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"studentList"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"Student"</span>&gt;</span><br>        select * from student<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>当然，如果你不喜欢使用实体类，那么这些属性还可以被映射到一个Map上：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectStudent"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"Map"</span>&gt;</span><br>    select * from student<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestMapper</span> </span>{<br>    <span class="hljs-function">List&lt;Map&gt; <span class="hljs-title">selectStudent</span><span class="hljs-params">()</span></span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>Map中就会以键值对的形式来存放这些结果了。</p><p>通过设定一个<code>resultType</code>属性，让Mybatis知道查询结果需要映射为哪个实体类，要求字段名称保持一致。那么如果我们不希望按照这样的规则来映射呢？我们可以自定义<code>resultMap</code>来设定映射规则：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"Test"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"Student"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"sid"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"sid"</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"name"</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"sex"</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>通过指定映射规则，我们现在名称和性别一栏就发生了交换，因为我们将其映射字段进行了交换。</p><p>如果一个类中存在多个构造方法，那么很有可能会出现这样的错误：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">### Exception in thread "main" org.apache.ibatis.exceptions.PersistenceException: <br>### Error querying database.  Cause: org.apache.ibatis.executor.ExecutorException: No constructor found in com.test.entity.Student matching [java.lang.Integer, java.lang.String, java.lang.String]<br>### The error may exist in com/test/mapper/TestMapper.xml<br>### The error may involve com.test.mapper.TestMapper.getStudentBySid<br>### The error occurred while handling results<br>### SQL: select * from student where sid = ?<br>### Cause: org.apache.ibatis.executor.ExecutorException: No constructor found in com.test.entity.Student matching [java.lang.Integer, java.lang.String, java.lang.String]<br>at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:<span class="hljs-number">30</span>)<br>...<br></code></pre></td></tr></tbody></table></figure><p>这时就需要使用<code>constructor</code>标签来指定构造方法：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"test"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"Student"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">arg</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"sid"</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">"Integer"</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">arg</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">"String"</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">constructor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>值得注意的是，指定构造方法后，若此字段被填入了构造方法作为参数，将不会通过反射给字段单独赋值，而构造方法中没有传入的字段，依然会被反射赋值，有关<code>resultMap</code>的内容，后面还会继续讲解。</p><p>如果数据库中存在一个带下划线的字段，我们可以通过设置让其映射为以驼峰命名的字段，比如<code>my_test</code>映射为<code>myTest</code></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"mapUnderscoreToCamelCase"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>如果不设置，默认为不开启，也就是默认需要名称保持一致。</p><p>我们接着来看看条件查询，既然是条件查询，那么肯定需要我们传入查询条件，比如现在我们想通过sid字段来通过学号查找信息：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Student <span class="hljs-title">getStudentBySid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sid)</span></span>;<br></code></pre></td></tr></tbody></table></figure><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getStudentBySid"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"int"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"Student"</span>&gt;</span><br>    select * from student where sid = #{sid}<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>我们通过使用<code>#{xxx}</code>或是<code>${xxx}</code>来填入我们给定的属性，实际上Mybatis本质也是通过<code>PreparedStatement</code>首先进行一次预编译，有效地防止SQL注入问题，但是如果使用<code>${xxx}</code>就不再是通过预编译，而是直接传值，因此我们一般都使用<code>#{xxx}</code>来进行操作。</p><p>使用<code>parameterType</code>属性来指定参数类型（非必须，可以不用，推荐不用）</p><p>接着我们来看插入、更新和删除操作，其实与查询操作差不多，不过需要使用对应的标签，比如插入操作：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"addStudent"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"Student"</span>&gt;</span><br>    insert into student(name, sex) values(#{name}, #{sex})<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addStudent</span><span class="hljs-params">(Student student)</span></span>;<br></code></pre></td></tr></tbody></table></figure><p>我们这里使用的是一个实体类，我们可以直接使用实体类里面对应属性替换到SQL语句中，只需要填写属性名称即可，和条件查询是一样的。</p><h3 id="复杂查询"><a href="#复杂查询" class="headerlink" title="复杂查询"></a>复杂查询</h3><p>一个老师可以教授多个学生，那么能否一次性将老师的学生全部映射给此老师的对象呢，比如：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> </span>{<br>    <span class="hljs-keyword">int</span> tid;<br>    String name;<br>    List&lt;Student&gt; studentList;<br>}<br></code></pre></td></tr></tbody></table></figure><p>映射为Teacher对象时，同时将其教授的所有学生一并映射为List列表，显然这是一种一对多的查询，那么这时就需要进行复杂查询了。而我们之前编写的都非常简单，直接就能完成映射，因此我们现在需要使用<code>resultMap</code>来自定义映射规则：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getTeacherByTid"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"asTeacher"</span>&gt;</span><br>        select *, teacher.name as tname from student inner join teach on student.sid = teach.sid<br>                              inner join teacher on teach.tid = teacher.tid where teach.tid = #{tid}<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"asTeacher"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"Teacher"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"tid"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"tid"</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"tname"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"name"</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"studentList"</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">"Student"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"sid"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"sid"</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"name"</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"sex"</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>可以看到，我们的查询结果是一个多表联查的结果，而联查的数据就是我们需要映射的数据（比如这里是一个老师有N个学生，联查的结果也是这一个老师对应N个学生的N条记录），其中<code>id</code>标签用于在多条记录中辨别是否为同一个对象的数据，比如上面的查询语句得到的结果中，<code>tid</code>这一行始终为<code>1</code>，因此所有的记录都应该是<code>tid=1</code>的教师的数据，而不应该变为多个教师的数据，如果不加id进行约束，那么会被识别成多个教师的数据！</p><p>通过使用collection来表示将得到的所有结果合并为一个集合，比如上面的数据中每个学生都有单独的一条记录，因此tid相同的全部学生的记录就可以最后合并为一个List，得到最终的映射结果，当然，为了区分，最好也设置一个id，只不过这个例子中可以当做普通的<code>result</code>使用。</p><p>了解了一对多，那么多对一又该如何查询呢，比如每个学生都有一个对应的老师，现在Student新增了一个Teacher对象，那么现在又该如何去处理呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Accessors(chain = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>{<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sid;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String sex;<br>    <span class="hljs-keyword">private</span> Teacher teacher;<br>}<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> </span>{<br>    <span class="hljs-keyword">int</span> tid;<br>    String name;<br>}<br></code></pre></td></tr></tbody></table></figure><p>现在我们希望的是，每次查询到一个Student对象时都带上它的老师，同样的，我们也可以使用<code>resultMap</code>来实现（先修改一下老师的类定义，不然会很麻烦）：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"test2"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"Student"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"sid"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"sid"</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"name"</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"sex"</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"teacher"</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">"Teacher"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"tid"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"tid"</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"tname"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"name"</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectStudent"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"test2"</span>&gt;</span><br>    select *, teacher.name as tname from student left join teach on student.sid = teach.sid<br>                                                 left join teacher on teach.tid = teacher.tid<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>通过使用<code>association</code>进行关联，形成多对一的关系，实际上和一对多是同理的，都是对查询结果的一种处理方式罢了。</p><h3 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h3><p>我们可以在获取<code>SqlSession</code>关闭自动提交来开启事务模式，和JDBC其实都差不多：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">false</span>)){<br>        TestMapper testMapper = sqlSession.getMapper(TestMapper.class);<br><br>        testMapper.addStudent(<span class="hljs-keyword">new</span> Student().setSex(<span class="hljs-string">"男"</span>).setName(<span class="hljs-string">"小王"</span>));<br><br>        testMapper.selectStudent().forEach(System.out::println);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现，在关闭自动提交后，我们的内容是没有进入到数据库的，现在我们来试一下在最后提交事务：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sqlSession.commit();<br></code></pre></td></tr></tbody></table></figure><p>在事务提交后，我们的内容才会被写入到数据库中。现在我们来试试看回滚操作：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">false</span>)){<br>    TestMapper testMapper = sqlSession.getMapper(TestMapper.class);<br><br>    testMapper.addStudent(<span class="hljs-keyword">new</span> Student().setSex(<span class="hljs-string">"男"</span>).setName(<span class="hljs-string">"小王"</span>));<br><br>    testMapper.selectStudent().forEach(System.out::println);<br>    sqlSession.rollback();<br>    sqlSession.commit();<br>}<br></code></pre></td></tr></tbody></table></figure><p>回滚操作也印证成功。</p><h3 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h3><p>动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。</p><p>我们直接使用官网的例子进行讲解。</p><h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><p>MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。 </p><p>其实缓存机制我们在之前学习IO流的时候已经提及过了，我们可以提前将一部分内容放入缓存，下次需要获取数据时，我们就可以直接从缓存中读取，这样的话相当于直接从内存中获取而不是再去向数据库索要数据，效率会更高。</p><p>因此Mybatis内置了一个缓存机制，我们查询时，如果缓存中存在数据，那么我们就可以直接从缓存中获取，而不是再去向数据库进行请求。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fresource.shangmayuan.com%2Fdroxy-blog%2F2021%2F03%2F02%2F071d25e4f9d841e0ac9df54038d98fd0-2.png&amp;refer=http%3A%2F%2Fresource.shangmayuan.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1639463836&amp;t=38cf5a85386f76cfd22ca3c6dcc5b6bb" alt="img"></p><p>Mybatis存在一级缓存和二级缓存，我们首先来看一下一级缓存，默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存（一级缓存无法关闭，只能调整），我们来看看下面这段代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">true</span>)){<br>        TestMapper testMapper = sqlSession.getMapper(TestMapper.class);<br>        Student student1 = testMapper.getStudentBySid(<span class="hljs-number">1</span>);<br>        Student student2 = testMapper.getStudentBySid(<span class="hljs-number">1</span>);<br>        System.out.println(student1 == student2);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现，两次得到的是同一个Student对象，也就是说我们第二次查询并没有重新去构造对象，而是直接得到之前创建好的对象。如果还不是很明显，我们可以修改一下实体类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Accessors(chain = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>{<br>        System.out.println(<span class="hljs-string">"我被构造了"</span>);<br>    }<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sid;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String sex;<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们通过前面的学习得知Mybatis在映射为对象时，在只有一个构造方法的情况下，无论你构造方法写成什么样子，都会去调用一次构造方法，如果存在多个构造方法，那么就会去找匹配的构造方法。我们可以通过查看构造方法来验证对象被创建了几次。</p><p>结果显而易见，只创建了一次，也就是说当第二次进行同样的查询时，会直接使用第一次的结果，因为第一次的结果已经被缓存了。</p><p>那么如果我修改了数据库中的内容，缓存还会生效吗：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">true</span>)){<br>        TestMapper testMapper = sqlSession.getMapper(TestMapper.class);<br>        Student student1 = testMapper.getStudentBySid(<span class="hljs-number">1</span>);<br>        testMapper.addStudent(<span class="hljs-keyword">new</span> Student().setName(<span class="hljs-string">"小李"</span>).setSex(<span class="hljs-string">"男"</span>));<br>        Student student2 = testMapper.getStudentBySid(<span class="hljs-number">1</span>);<br>        System.out.println(student1 == student2);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现，当我们进行了插入操作后，缓存就没有生效了，我们再次进行查询得到的是一个新创建的对象。</p><p>也就是说，一级缓存，在进行DML操作后，会使得缓存失效，也就是说Mybatis知道我们对数据库里面的数据进行了修改，所以之前缓存的内容可能就不是当前数据库里面最新的内容了。还有一种情况就是，当前会话结束后，也会清理全部的缓存，因为已经不会再用到了。但是一定注意，一级缓存只针对于单个会话，多个会话之间不相通。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">true</span>)){<br>        TestMapper testMapper = sqlSession.getMapper(TestMapper.class);<br><br>        Student student2;<br>        <span class="hljs-keyword">try</span>(SqlSession sqlSession2 = MybatisUtil.getSession(<span class="hljs-keyword">true</span>)){<br>            TestMapper testMapper2 = sqlSession2.getMapper(TestMapper.class);<br>            student2 = testMapper2.getStudentBySid(<span class="hljs-number">1</span>);<br>        }<br><br>        Student student1 = testMapper.getStudentBySid(<span class="hljs-number">1</span>);<br>        System.out.println(student1 == student2);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>注意：</strong>一个会话DML操作只会重置当前会话的缓存，不会重置其他会话的缓存，也就是说，其他会话缓存是不会更新的！</p><p>一级缓存给我们提供了很高速的访问效率，但是它的作用范围实在是有限，如果一个会话结束，那么之前的缓存就全部失效了，但是我们希望缓存能够扩展到所有会话都能使用，因此我们可以通过二级缓存来实现，二级缓存默认是关闭状态，要开启二级缓存，我们需要在映射器XML文件中添加：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span>/&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>可见二级缓存是Mapper级别的，也就是说，当一个会话失效时，它的缓存依然会存在于二级缓存中，因此如果我们再次创建一个新的会话会直接使用之前的缓存，我们首先根据官方文档进行一些配置：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">&lt;cache<br>  eviction="FIFO"<br>  flushInterval="60000"<br>  size="512"<br>  readOnly="true"/&gt;<br></code></pre></td></tr></tbody></table></figure><p>我们来编写一个代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Student student;<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">true</span>)){<br>        TestMapper testMapper = sqlSession.getMapper(TestMapper.class);<br>        student = testMapper.getStudentBySid(<span class="hljs-number">1</span>);<br>    }<br><br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession2 = MybatisUtil.getSession(<span class="hljs-keyword">true</span>)){<br>        TestMapper testMapper2 = sqlSession2.getMapper(TestMapper.class);<br>        Student student2 = testMapper2.getStudentBySid(<span class="hljs-number">1</span>);<br>        System.out.println(student2 == student);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以看到，上面的代码中首先是第一个会话在进行读操作，完成后会结束会话，而第二个操作重新创建了一个新的会话，再次执行了同样的查询，我们发现得到的依然是缓存的结果。</p><p>那么如果我不希望某个方法开启缓存呢？我们可以添加useCache属性来关闭缓存：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getStudentBySid"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"Student"</span> <span class="hljs-attr">useCache</span>=<span class="hljs-string">"false"</span>&gt;</span><br>    select * from student where sid = #{sid}<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>我们也可以使用flushCache=”false”在每次执行后都清空缓存，通过这这个我们还可以控制DML操作完成之后不清空缓存。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getStudentBySid"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"Student"</span> <span class="hljs-attr">flushCache</span>=<span class="hljs-string">"true"</span>&gt;</span><br>    select * from student where sid = #{sid}<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>添加了二级缓存之后，会先从二级缓存中查找数据，当二级缓存中没有时，才会从一级缓存中获取，当一级缓存中都还没有数据时，才会请求数据库，因此我们再来执行上面的代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">true</span>)){<br>        TestMapper testMapper = sqlSession.getMapper(TestMapper.class);<br><br>        Student student2;<br>        <span class="hljs-keyword">try</span>(SqlSession sqlSession2 = MybatisUtil.getSession(<span class="hljs-keyword">true</span>)){<br>            TestMapper testMapper2 = sqlSession2.getMapper(TestMapper.class);<br>            student2 = testMapper2.getStudentBySid(<span class="hljs-number">1</span>);<br>        }<br><br>        Student student1 = testMapper.getStudentBySid(<span class="hljs-number">1</span>);<br>        System.out.println(student1 == student2);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>得到的结果就会是同一个对象了，因为现在是优先从二级缓存中获取。</p><p>读取顺序：二级缓存 =&gt; 一级缓存 =&gt; 数据库</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F2176079-2e6599c454e7af19.png&amp;refer=http%3A%2F%2Fupload-images.jianshu.io&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1639471352&amp;t=c7c1d6b11de1ad9af91e092590c58d83" alt="img"></p><p>虽然缓存机制给我们提供了很大的性能提升，但是缓存存在一个问题，我们之前在<code>计算机组成原理</code>中可能学习过缓存一致性问题，也就是说当多个CPU在操作自己的缓存时，可能会出现各自的缓存内容不同步的问题，而Mybatis也会这样，我们来看看这个例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">true</span>)){<br>        TestMapper testMapper = sqlSession.getMapper(TestMapper.class);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>){<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>            System.out.println(testMapper.getStudentBySid(<span class="hljs-number">1</span>));<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们现在循环地每三秒读取一次，而在这个过程中，我们使用IDEA手动修改数据库中的数据，将1号同学的学号改成100，那么理想情况下，下一次读取将无法获取到小明，因为小明的学号已经发生变化了。</p><p>但是结果却是依然能够读取，并且sid并没有发生改变，这也证明了Mybatis的缓存在生效，因为我们是从外部进行修改，Mybatis不知道我们修改了数据，所以依然在使用缓存中的数据，但是这样很明显是不正确的，因此，如果存在多台服务器或者是多个程序都在使用Mybatis操作同一个数据库，并且都开启了缓存，需要解决这个问题，要么就得关闭Mybatis的缓存来保证一致性：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cacheEnabled"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"false"</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getStudentBySid"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"Student"</span> <span class="hljs-attr">useCache</span>=<span class="hljs-string">"false"</span> <span class="hljs-attr">flushCache</span>=<span class="hljs-string">"true"</span>&gt;</span><br>    select * from student where sid = #{sid}<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>要么就需要实现缓存共用，也就是让所有的Mybatis都使用同一个缓存进行数据存取，在后面，我们会继续学习Redis、Ehcache、Memcache等缓存框架，通过使用这些工具，就能够很好地解决缓存一致性问题。</p><h3 id="使用注解开发"><a href="#使用注解开发" class="headerlink" title="使用注解开发"></a>使用注解开发</h3><p>在之前的开发中，我们已经体验到Mybatis为我们带来的便捷了，我们只需要编写对应的映射器，并将其绑定到一个接口上，即可直接通过该接口执行我们的SQL语句，极大的简化了我们之前JDBC那样的代码编写模式。那么，能否实现无需xml映射器配置，而是直接使用注解在接口上进行配置呢？答案是可以的，也是现在推荐的一种方式（也不是说XML就不要去用了，由于Java 注解的表达能力和灵活性十分有限，可能相对于XML配置某些功能实现起来会不太好办，但是在大部分场景下，直接使用注解开发已经绰绰有余了）</p><p>首先我们来看一下，使用XML进行映射器编写时，我们需要现在XML中定义映射规则和SQL语句，然后再将其绑定到一个接口的方法定义上，然后再使用接口来执行：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"addStudent"</span>&gt;</span><br>    insert into student(name, sex) values(#{name}, #{sex})<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addStudent</span><span class="hljs-params">(Student student)</span></span>;<br></code></pre></td></tr></tbody></table></figure><p>而现在，我们可以直接使用注解来实现，每个操作都有一个对应的注解：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Insert("insert into student(name, sex) values(#{name}, #{sex})")</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addStudent</span><span class="hljs-params">(Student student)</span></span>;<br></code></pre></td></tr></tbody></table></figure><p>当然，我们还需要修改一下配置文件中的映射器注册：</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;mappers&gt;<br>    &lt;mapper <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"com.test.mapper.MyMapper"</span>/&gt;<br>    &lt;!--  也可以直接注册整个包下的 &lt;<span class="hljs-keyword">package</span> name=<span class="hljs-string">"com.test.mapper"</span>/&gt;  --&gt;<br>&lt;/mappers&gt;<br></code></pre></td></tr></tbody></table></figure><p>通过直接指定Class，来让Mybatis知道我们这里有一个通过注解实现的映射器。</p><p>我们接着来看一下，如何使用注解进行自定义映射规则：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Results({</span><br><span class="hljs-meta">        @Result(id = true, column = "sid", property = "sid"),</span><br><span class="hljs-meta">        @Result(column = "sex", property = "name"),</span><br><span class="hljs-meta">        @Result(column = "name", property = "sex")</span><br><span class="hljs-meta">})</span><br><span class="hljs-meta">@Select("select * from student")</span><br><span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">getAllStudent</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></tbody></table></figure><p>直接通过<code>@Results</code>注解，就可以直接进行配置了，此注解的value是一个<code>@Result</code>注解数组，每个<code>@Result</code>注解都都一个单独的字段配置，其实就是我们之前在XML映射器中写的：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"test"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"Student"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"sid"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"sid"</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"sex"</span>/&gt;</span>    <br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"name"</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>现在我们就可以通过注解来自定义映射规则了。那么如何使用注解来完成复杂查询呢？我们还是使用一个老师多个学生的例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Results({</span><br><span class="hljs-meta">        @Result(id = true, column = "tid", property = "tid"),</span><br><span class="hljs-meta">        @Result(column = "name", property = "name"),</span><br><span class="hljs-meta">        @Result(column = "tid", property = "studentList", many =</span><br><span class="hljs-meta">            @Many(select = "getStudentByTid")</span><br><span class="hljs-meta">        )</span><br><span class="hljs-meta">})</span><br><span class="hljs-meta">@Select("select * from teacher where tid = #{tid}")</span><br><span class="hljs-function">Teacher <span class="hljs-title">getTeacherBySid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tid)</span></span>;<br><br><span class="hljs-meta">@Select("select * from student inner join teach on student.sid = teach.sid where tid = #{tid}")</span><br><span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">getStudentByTid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tid)</span></span>;<br></code></pre></td></tr></tbody></table></figure><p>我们发现，多出了一个子查询，而这个子查询是单独查询该老师所属学生的信息，而子查询结果作为<code>@Result</code>注解的一个many结果，代表子查询的所有结果都归入此集合中（也就是之前的collection标签）</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"asTeacher"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"Teacher"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"tid"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"tid"</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"tname"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"name"</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"studentList"</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">"Student"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"sid"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"sid"</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"name"</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"sex"</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>同理，<code>@Result</code>也提供了<code>@One</code>子注解来实现一对一的关系表示，类似于之前的<code>assocation</code>标签：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Results({</span><br><span class="hljs-meta">        @Result(id = true, column = "sid", property = "sid"),</span><br><span class="hljs-meta">        @Result(column = "sex", property = "name"),</span><br><span class="hljs-meta">        @Result(column = "name", property = "sex"),</span><br><span class="hljs-meta">        @Result(column = "sid", property = "teacher", one =</span><br><span class="hljs-meta">            @One(select = "getTeacherBySid")</span><br><span class="hljs-meta">        )</span><br><span class="hljs-meta">})</span><br><span class="hljs-meta">@Select("select * from student")</span><br><span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">getAllStudent</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></tbody></table></figure><p>如果现在我希望直接使用注解编写SQL语句但是我希望映射规则依然使用XML来实现，这时该怎么办呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ResultMap("test")</span><br><span class="hljs-meta">@Select("select * from student")</span><br><span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">getAllStudent</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></tbody></table></figure><p>提供了<code>@ResultMap</code>注解，直接指定ID即可，这样我们就可以使用XML中编写的映射规则了，这里就不再演示了。</p><p>那么如果出现之前的两个构造方法的情况，且没有任何一个构造方法匹配的话，该怎么处理呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Accessors(chain = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sid)</span></span>{<br>        System.out.println(<span class="hljs-string">"我是一号构造方法"</span>+sid);<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sid, String name)</span></span>{<br>        System.out.println(<span class="hljs-string">"我是二号构造方法"</span>+sid+name);<br>    }<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sid;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String sex;<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以通过<code>@ConstructorArgs</code>注解来指定构造方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConstructorArgs({</span><br><span class="hljs-meta">        @Arg(column = "sid", javaType = int.class),</span><br><span class="hljs-meta">        @Arg(column = "name", javaType = String.class)</span><br><span class="hljs-meta">})</span><br><span class="hljs-meta">@Select("select * from student where sid = #{sid} and sex = #{sex}")</span><br><span class="hljs-function">Student <span class="hljs-title">getStudentBySidAndSex</span><span class="hljs-params">(<span class="hljs-meta">@Param("sid")</span> <span class="hljs-keyword">int</span> sid, <span class="hljs-meta">@Param("sex")</span> String sex)</span></span>;<br></code></pre></td></tr></tbody></table></figure><p>得到的结果和使用<code>constructor</code>标签效果一致，这里就不多做讲解了。</p><p>我们发现，当参数列表中出现两个以上的参数时，会出现错误：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select("select * from student where sid = #{sid} and sex = #{sex}")</span><br><span class="hljs-function">Student <span class="hljs-title">getStudentBySidAndSex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sid, String sex)</span></span>;<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Exception in thread <span class="hljs-string">"main"</span> org.apache.ibatis.exceptions.PersistenceException: <br>### Error querying database.  Cause: org.apache.ibatis.binding.BindingException: Parameter 'sid' not found. Available parameters are [arg1, arg0, param1, param2]<br>### Cause: org.apache.ibatis.binding.BindingException: Parameter 'sid' not found. Available parameters are [arg1, arg0, param1, param2]<br>at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:<span class="hljs-number">30</span>)<br>at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:<span class="hljs-number">153</span>)<br>at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:<span class="hljs-number">145</span>)<br>at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:<span class="hljs-number">140</span>)<br>at org.apache.ibatis.session.defaults.DefaultSqlSession.selectOne(DefaultSqlSession.java:<span class="hljs-number">76</span>)<br>at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:<span class="hljs-number">87</span>)<br>at org.apache.ibatis.binding.MapperProxy$PlainMethodInvoker.invoke(MapperProxy.java:<span class="hljs-number">145</span>)<br>at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:<span class="hljs-number">86</span>)<br>at com.sun.proxy.$Proxy6.getStudentBySidAndSex(Unknown Source)<br>at com.test.Main.main(Main.java:<span class="hljs-number">16</span>)<br></code></pre></td></tr></tbody></table></figure><p>原因是Mybatis不明确到底哪个参数是什么，因此我们可以添加<code>@Param</code>来指定参数名称：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select("select * from student where sid = #{sid} and sex = #{sex}")</span><br><span class="hljs-function">Student <span class="hljs-title">getStudentBySidAndSex</span><span class="hljs-params">(<span class="hljs-meta">@Param("sid")</span> <span class="hljs-keyword">int</span> sid, <span class="hljs-meta">@Param("sex")</span> String sex)</span></span>;<br></code></pre></td></tr></tbody></table></figure><p><strong>探究：</strong>要是我两个参数一个是基本类型一个是对象类型呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(testMapper.addStudent(<span class="hljs-number">100</span>, <span class="hljs-keyword">new</span> Student().setName(<span class="hljs-string">"小陆"</span>).setSex(<span class="hljs-string">"男"</span>)));<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Insert("insert into student(sid, name, sex) values(#{sid}, #{name}, #{sex})")</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addStudent</span><span class="hljs-params">(<span class="hljs-meta">@Param("sid")</span> <span class="hljs-keyword">int</span> sid, <span class="hljs-meta">@Param("student")</span>  Student student)</span></span>;<br></code></pre></td></tr></tbody></table></figure><p>那么这个时候，就出现问题了，Mybatis就不能明确这些属性是从哪里来的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">### SQL: insert into student(sid, name, sex) values(?, ?, ?)<br>### Cause: org.apache.ibatis.binding.BindingException: Parameter 'name' not found. Available parameters are [student, param1, sid, param2]<br>at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:<span class="hljs-number">30</span>)<br>at org.apache.ibatis.session.defaults.DefaultSqlSession.update(DefaultSqlSession.java:<span class="hljs-number">196</span>)<br>at org.apache.ibatis.session.defaults.DefaultSqlSession.insert(DefaultSqlSession.java:<span class="hljs-number">181</span>)<br>at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:<span class="hljs-number">62</span>)<br>at org.apache.ibatis.binding.MapperProxy$PlainMethodInvoker.invoke(MapperProxy.java:<span class="hljs-number">145</span>)<br>at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:<span class="hljs-number">86</span>)<br>at com.sun.proxy.$Proxy6.addStudent(Unknown Source)<br>at com.test.Main.main(Main.java:<span class="hljs-number">16</span>)<br></code></pre></td></tr></tbody></table></figure><p>那么我们就通过参数名称.属性的方式去让Mybatis知道我们要用的是哪个属性：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Insert("insert into student(sid, name, sex) values(#{sid}, #{student.name}, #{student.sex})")</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addStudent</span><span class="hljs-params">(<span class="hljs-meta">@Param("sid")</span> <span class="hljs-keyword">int</span> sid, <span class="hljs-meta">@Param("student")</span>  Student student)</span></span>;<br></code></pre></td></tr></tbody></table></figure><p>那么如何通过注解控制缓存机制呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CacheNamespace(readWrite = false)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyMapper</span> </span>{<br><br>    <span class="hljs-meta">@Select("select * from student")</span><br>    <span class="hljs-meta">@Options(useCache = false)</span><br>    <span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">getAllStudent</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></tbody></table></figure><p>使用<code>@CacheNamespace</code>注解直接定义在接口上即可，然后我们可以通过使用<code>@Options</code>来控制单个操作的缓存启用。</p><h3 id="探究Mybatis的动态代理机制"><a href="#探究Mybatis的动态代理机制" class="headerlink" title="探究Mybatis的动态代理机制"></a>探究Mybatis的动态代理机制</h3><p>在探究动态代理机制之前，我们要先聊聊什么是代理：其实顾名思义，就好比我开了个大棚，里面栽种的西瓜，那么西瓜成熟了是不是得去卖掉赚钱，而我们的西瓜非常多，一个人肯定卖不过来，肯定就要去多找几个开水果摊的帮我们卖，这就是一种代理。实际上是由水果摊老板在帮我们卖瓜，我们只告诉老板卖多少钱，而至于怎么卖的是由水果摊老板决定的。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F2020112311143434.png%3Fx-oss-process%26%2361%3Bimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhdHR5MTkyMA%26%2361%3B%26%2361%3B%2Csize_16%2Ccolor_FFFFFF%2Ct_7&amp;refer=http%3A%2F%2Fimg-blog.csdnimg.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1639472394&amp;t=b5590551c75049e91fc497b9920bdb83" alt="img"></p><p>那么现在我们来尝试实现一下这样的类结构，首先定义一个接口用于规范行为：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Shopper</span> </span>{<br><br>    <span class="hljs-comment">//卖瓜行为</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saleWatermelon</span><span class="hljs-params">(String customer)</span></span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>然后需要实现一下卖瓜行为，也就是我们要告诉老板卖多少钱，这里就直接写成成功出售：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShopperImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shopper</span></span>{<br><br>    <span class="hljs-comment">//卖瓜行为的实现</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saleWatermelon</span><span class="hljs-params">(String customer)</span> </span>{<br>        System.out.println(<span class="hljs-string">"成功出售西瓜给 ===&gt; "</span>+customer);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>最后老板代理后肯定要用自己的方式去出售这些西瓜，成交之后再按照我们告诉老板的价格进行出售：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShopperProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shopper</span></span>{<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Shopper impl;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ShopperProxy</span><span class="hljs-params">(Shopper impl)</span></span>{<br>        <span class="hljs-keyword">this</span>.impl = impl;<br>    }<br><br>    <span class="hljs-comment">//代理卖瓜行为</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saleWatermelon</span><span class="hljs-params">(String customer)</span> </span>{<br>        <span class="hljs-comment">//首先进行 代理商讨价还价行为</span><br>        System.out.println(customer + <span class="hljs-string">"：哥们，这瓜多少钱一斤啊？"</span>);<br>        System.out.println(<span class="hljs-string">"老板：两块钱一斤。"</span>);<br>        System.out.println(customer + <span class="hljs-string">"：你这瓜皮子是金子做的，还是瓜粒子是金子做的？"</span>);<br>        System.out.println(<span class="hljs-string">"老板：你瞅瞅现在哪有瓜啊，这都是大棚的瓜，你嫌贵我还嫌贵呢。"</span>);<br>        System.out.println(customer + <span class="hljs-string">"：给我挑一个。"</span>);<br><br>        impl.saleWatermelon(customer);   <span class="hljs-comment">//讨价还价成功，进行我们告诉代理商的卖瓜行为</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>现在我们来试试看：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        Shopper shopper = <span class="hljs-keyword">new</span> ShopperProxy(<span class="hljs-keyword">new</span> ShopperImpl());<br>        shopper.saleWatermelon(<span class="hljs-string">"小强"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>这样的操作称为静态代理，也就是说我们需要提前知道接口的定义并进行实现才可以完成代理，而Mybatis这样的是无法预知代理接口的，我们就需要用到动态代理。</p><p>JDK提供的反射框架就为我们很好地解决了动态代理的问题，在这里相当于对JavaSE阶段反射的内容进行一个补充。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShopperProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>{<br><br>    Object target;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ShopperProxy</span><span class="hljs-params">(Object target)</span></span>{<br>        <span class="hljs-keyword">this</span>.target = target;<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>{<br>        String customer = (String) args[<span class="hljs-number">0</span>];<br>        System.out.println(customer + <span class="hljs-string">"：哥们，这瓜多少钱一斤啊？"</span>);<br>        System.out.println(<span class="hljs-string">"老板：两块钱一斤。"</span>);<br>        System.out.println(customer + <span class="hljs-string">"：你这瓜皮子是金子做的，还是瓜粒子是金子做的？"</span>);<br>        System.out.println(<span class="hljs-string">"老板：你瞅瞅现在哪有瓜啊，这都是大棚的瓜，你嫌贵我还嫌贵呢。"</span>);<br>        System.out.println(customer + <span class="hljs-string">"：行，给我挑一个。"</span>);<br>        <span class="hljs-keyword">return</span> method.invoke(target, args);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>通过实现InvocationHandler来成为一个动态代理，我们发现它提供了一个invoke方法，用于调用被代理对象的方法并完成我们的代理工作。现在就可以通过<code> Proxy.newProxyInstance</code>来生成一个动态代理类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Shopper impl = <span class="hljs-keyword">new</span> ShopperImpl();<br>    Shopper shopper = (Shopper) Proxy.newProxyInstance(impl.getClass().getClassLoader(),<br>            impl.getClass().getInterfaces(), <span class="hljs-keyword">new</span> ShopperProxy(impl));<br>    shopper.saleWatermelon(<span class="hljs-string">"小强"</span>);<br>  System.out.println(shopper.getClass());<br>}<br></code></pre></td></tr></tbody></table></figure><p>通过打印类型我们发现，就是我们之前看到的那种奇怪的类：<code>class com.sun.proxy.$Proxy0</code>，因此Mybatis其实也是这样的来实现的（肯定有人问了：Mybatis是直接代理接口啊，你这个不还是要把接口实现了吗？）那我们来改改，现在我们不代理任何类了，直接做接口实现：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShopperProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>{<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>{<br>        String customer = (String) args[<span class="hljs-number">0</span>];<br>        System.out.println(customer + <span class="hljs-string">"：哥们，这瓜多少钱一斤啊？"</span>);<br>        System.out.println(<span class="hljs-string">"老板：两块钱一斤。"</span>);<br>        System.out.println(customer + <span class="hljs-string">"：你这瓜皮子是金子做的，还是瓜粒子是金子做的？"</span>);<br>        System.out.println(<span class="hljs-string">"老板：你瞅瞅现在哪有瓜啊，这都是大棚的瓜，你嫌贵我还嫌贵呢。"</span>);<br>        System.out.println(customer + <span class="hljs-string">"：行，给我挑一个。"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Shopper shopper = (Shopper) Proxy.newProxyInstance(Shopper.class.getClassLoader(),<br>            <span class="hljs-keyword">new</span> Class[]{ Shopper.class },   <span class="hljs-comment">//因为本身就是接口，所以直接用就行</span><br>            <span class="hljs-keyword">new</span> ShopperProxy());<br>    shopper.saleWatermelon(<span class="hljs-string">"小强"</span>);<br>    System.out.println(shopper.getClass());<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以去看看Mybatis的源码。</p><p>Mybatis的学习差不多就到这里为止了，不过，同样类型的框架还有很多，Mybatis属于半自动框架，SQL语句依然需要我们自己编写，虽然存在一定的麻烦，但是会更加灵活，而后面我们还会学习JPA，它是全自动的框架，你几乎见不到SQL的影子！</p><hr><h2 id="使用JUnit进行单元测试"><a href="#使用JUnit进行单元测试" class="headerlink" title="使用JUnit进行单元测试"></a>使用JUnit进行单元测试</h2><p>首先一问：我们为什么需要单元测试？</p><p>随着我们的项目逐渐变大，比如我们之前编写的图书管理系统，我们都是边在写边在测试，而我们当时使用的测试方法，就是直接在主方法中运行测试，但是，在很多情况下，我们的项目可能会很庞大，不可能每次都去完整地启动一个项目来测试某一个功能，这样显然会降低我们的开发效率，因此，我们需要使用单元测试来帮助我们针对于某个功能或是某个模块单独运行代码进行测试，而不是启动整个项目。</p><p>同时，在我们项目的维护过程中，难免会涉及到一些原有代码的修改，很有可能出现改了代码导致之前的功能出现问题（牵一发而动全身），而我们又不一定能立即察觉到，因此，我们可以提前保存一些测试用例，每次完成代码后都可以跑一遍测试用例，来确保之前的功能没有因为后续的修改而出现问题。</p><p>我们还可以利用单元测试来评估某个模块或是功能的耗时和性能，快速排查导致程序运行缓慢的问题，这些都可以通过单元测试来完成，可见单元测试对于开发的重要性。</p><h3 id="尝试JUnit"><a href="#尝试JUnit" class="headerlink" title="尝试JUnit"></a>尝试JUnit</h3><p>首先需要导入JUnit依赖，我们在这里使用Junit4进行介绍，最新的Junit5放到Maven板块一起讲解，Jar包已经放在视频下方简介中，直接去下载即可。同时IDEA需要安装JUnit插件（默认是已经捆绑安装的，因此无需多余配置）</p><p>现在我们创建一个新的类，来编写我们的单元测试用例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMain</span> </span>{<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>{<br>        System.out.println(<span class="hljs-string">"我是测试用例1"</span>);<br>    }<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span></span>{<br>        System.out.println(<span class="hljs-string">"我是测试用例2"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以点击类前面的测试按钮，或是单个方法前的测试按钮，如果点击类前面的测试按钮，会执行所有的测试用例。</p><p>运行测试后，我们发现控制台得到了一个测试结果，显示为绿色表示测试通过。</p><p>只需要通过打上<code>@Test</code>注解，即可将一个方法标记为测试案例，我们可以直接运行此测试案例，但是我们编写的测试方法有以下要求：</p><ul><li>方法必须是public的</li><li>不能是静态方法</li><li>返回值必须是void</li><li>必须是没有任何参数的方法</li></ul><p>对于一个测试案例来说，我们肯定希望测试的结果是我们所期望的一个值，因此，如果测试的结果并不是我们所期望的结果，那么这个测试就应该没有成功通过！</p><p>我们可以通过断言工具类来进行判定：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMain</span> </span>{<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>{<br>        System.out.println(<span class="hljs-string">"我是测试案例！"</span>);<br>        Assert.assertEquals(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);    <span class="hljs-comment">//参数1是期盼值，参数2是实际测试结果值</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>通过运行代码后，我们发现测试过程中抛出了一个错误，并且IDEA给我们显示了期盼结果和测试结果，那么现在我们来测试一个案例，比如我们想查看冒泡排序的编写是否正确：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-keyword">int</span>[] arr = {<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>};<br><br>    <span class="hljs-comment">//错误的冒泡排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span> - i; j++) {<br>            <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j + <span class="hljs-number">1</span>]){<br>                <span class="hljs-keyword">int</span> tmp = arr[j];<br>                arr[j] = arr[j+<span class="hljs-number">1</span>];<br>                <span class="hljs-comment">// arr[j+1] = tmp;</span><br>            }<br>        }<br>    }<br><br>    Assert.assertArrayEquals(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>}, arr);<br>}<br></code></pre></td></tr></tbody></table></figure><p>通过测试，我们发现得到的结果并不是我们想要的结果，因此现在我们需要去修改为正确的冒泡排序，修改后，测试就能正确通过了。我们还可以再通过一个案例来更加深入地了解测试，现在我们想测试从数据库中取数据是否为我们预期的数据：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">true</span>)){<br>        TestMapper mapper = sqlSession.getMapper(TestMapper.class);<br>        Student student = mapper.getStudentBySidAndSex(<span class="hljs-number">1</span>, <span class="hljs-string">"男"</span>);<br><br>        Assert.assertEquals(<span class="hljs-keyword">new</span> Student().setName(<span class="hljs-string">"小明"</span>).setSex(<span class="hljs-string">"男"</span>).setSid(<span class="hljs-number">1</span>), student);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>那么如果我们在进行所有的测试之前需要做一些前置操作该怎么办呢，一种办法是在所有的测试用例前面都加上前置操作，但是这样显然是很冗余的，因为一旦发生修改就需要挨个进行修改，因此我们需要更加智能的方法，我们可以通过<code>@Before</code>注解来添加测试用例开始之前的前置操作：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMain</span> </span>{<br><br>    <span class="hljs-keyword">private</span> SqlSessionFactory sqlSessionFactory;<br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>{<br>        System.out.println(<span class="hljs-string">"测试前置正在初始化..."</span>);<br>        <span class="hljs-keyword">try</span> {<br>            sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder()<br>                    .build(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"mybatis-config.xml"</span>));<br>        } <span class="hljs-keyword">catch</span> (FileNotFoundException e) {<br>            e.printStackTrace();<br>        }<br>        System.out.println(<span class="hljs-string">"测试初始化完成，正在开始测试案例..."</span>);<br>    }<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>{<br>        <span class="hljs-keyword">try</span> (SqlSession sqlSession = sqlSessionFactory.openSession(<span class="hljs-keyword">true</span>)){<br>            TestMapper mapper = sqlSession.getMapper(TestMapper.class);<br>            Student student = mapper.getStudentBySidAndSex(<span class="hljs-number">1</span>, <span class="hljs-string">"男"</span>);<br><br>            Assert.assertEquals(<span class="hljs-keyword">new</span> Student().setName(<span class="hljs-string">"小明"</span>).setSex(<span class="hljs-string">"男"</span>).setSid(<span class="hljs-number">1</span>), student);<br>            System.out.println(<span class="hljs-string">"测试用例1通过！"</span>);<br>        }<br>    }<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span></span>{<br>        <span class="hljs-keyword">try</span> (SqlSession sqlSession = sqlSessionFactory.openSession(<span class="hljs-keyword">true</span>)){<br>            TestMapper mapper = sqlSession.getMapper(TestMapper.class);<br>            Student student = mapper.getStudentBySidAndSex(<span class="hljs-number">2</span>, <span class="hljs-string">"女"</span>);<br><br>            Assert.assertEquals(<span class="hljs-keyword">new</span> Student().setName(<span class="hljs-string">"小红"</span>).setSex(<span class="hljs-string">"女"</span>).setSid(<span class="hljs-number">2</span>), student);<br>            System.out.println(<span class="hljs-string">"测试用例2通过！"</span>);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>同理，在所有的测试完成之后，我们还想添加一个收尾的动作，那么只需要使用<code>@After</code>注解即可添加结束动作：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@After</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span></span>{<br>    System.out.println(<span class="hljs-string">"测试结束，收尾工作正在进行..."</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>有关JUnit的使用我们就暂时只介绍这么多。</p><hr><h2 id="JUL日志系统"><a href="#JUL日志系统" class="headerlink" title="JUL日志系统"></a>JUL日志系统</h2><p>首先一问：我们为什么需要日志系统？</p><p>我们之前一直都在使用<code>System.out.println</code>来打印信息，但是，如果项目中存在大量的控制台输出语句，会显得很凌乱，而且日志的粒度是不够细的，假如我们现在希望，项目只在debug的情况下打印某些日志，而在实际运行时不打印日志，采用直接输出的方式就很难实现了，因此我们需要使用日志框架来规范化日志输出。</p><p>而JDK为我们提供了一个自带的日志框架，位于<code>java.util.logging</code>包下，我们可以使用此框架来实现日志的规范化打印，使用起来非常简单：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>      <span class="hljs-comment">// 首先获取日志打印器</span><br>        Logger logger = Logger.getLogger(Main.class.getName());<br>      <span class="hljs-comment">// 调用info来输出一个普通的信息，直接填写字符串即可</span><br>        logger.info(<span class="hljs-string">"我是普通的日志"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以在主类中使用日志打印，得到日志的打印结果：</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">十一月 15, 2021 12:55:37 下午 com.test.Main main<br>信息: 我是普通的日志<br></code></pre></td></tr></tbody></table></figure><p>我们发现，通过日志输出的结果会更加规范。</p><h3 id="JUL日志讲解"><a href="#JUL日志讲解" class="headerlink" title="JUL日志讲解"></a>JUL日志讲解</h3><p>日志分为7个级别，详细信息我们可以在Level类中查看：</p><ul><li> SEVERE（最高值）- 一般用于代表严重错误</li><li>WARNING  - 一般用于表示某些警告，但是不足以判断为错误</li><li> INFO （默认级别）  -  常规消息</li><li> CONFIG</li><li> FINE</li><li> FINER</li><li> FINEST（最低值）</li></ul><p>我们之前通过<code>info</code>方法直接输出的结果就是使用的默认级别的日志，我们可以通过<code>log</code>方法来设定该条日志的输出级别：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Logger logger = Logger.getLogger(Main.class.getName());<br>    logger.log(Level.SEVERE, <span class="hljs-string">"严重的错误"</span>, <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"我就是错误"</span>));<br>    logger.log(Level.WARNING, <span class="hljs-string">"警告的内容"</span>);<br>    logger.log(Level.INFO, <span class="hljs-string">"普通的信息"</span>);<br>    logger.log(Level.CONFIG, <span class="hljs-string">"级别低于普通信息"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现，级别低于默认级别的日志信息，无法输出到控制台，我们可以通过设置来修改日志的打印级别：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Logger logger = Logger.getLogger(Main.class.getName());<br><br>    <span class="hljs-comment">//修改日志级别</span><br>    logger.setLevel(Level.CONFIG);<br>    <span class="hljs-comment">//不使用父日志处理器</span><br>    logger.setUseParentHandlers(<span class="hljs-keyword">false</span>);<br>    <span class="hljs-comment">//使用自定义日志处理器</span><br>    ConsoleHandler handler = <span class="hljs-keyword">new</span> ConsoleHandler();<br>    handler.setLevel(Level.CONFIG);<br>    logger.addHandler(handler);<br><br>    logger.log(Level.SEVERE, <span class="hljs-string">"严重的错误"</span>, <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"我就是错误"</span>));<br>    logger.log(Level.WARNING, <span class="hljs-string">"警告的内容"</span>);<br>    logger.log(Level.INFO, <span class="hljs-string">"普通的信息"</span>);<br>    logger.log(Level.CONFIG, <span class="hljs-string">"级别低于普通信息"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>每个<code>Logger</code>都有一个父日志打印器，我们可以通过<code>getParent()</code>来获取：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>{<br>    Logger logger = Logger.getLogger(Main.class.getName());<br>    System.out.println(logger.getParent().getClass());<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现，得到的是<code>java.util.logging.LogManager$RootLogger</code>这个类，它默认使用的是ConsoleHandler，且日志级别为INFO，由于每一个日志打印器都会直接使用父类的处理器，因此我们之前需要关闭父类然后使用我们自己的处理器。</p><p>我们通过使用自己日志处理器来自定义级别的信息打印到控制台，当然，日志处理器不仅仅只有控制台打印，我们也可以使用文件处理器来处理日志信息，我们继续添加一个处理器：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//添加输出到本地文件</span><br>FileHandler fileHandler = <span class="hljs-keyword">new</span> FileHandler(<span class="hljs-string">"test.log"</span>);<br>fileHandler.setLevel(Level.WARNING);<br>logger.addHandler(fileHandler);<br></code></pre></td></tr></tbody></table></figure><p>注意，这个时候就有两个日志处理器了，因此控制台和文件的都会生效。如果日志的打印格式我们不喜欢，我们还可以自定义打印格式，比如我们控制台处理器就默认使用的是<code>SimpleFormatter</code>，而文件处理器则是使用的<code>XMLFormatter</code>，我们可以自定义：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用自定义日志处理器(控制台)</span><br>ConsoleHandler handler = <span class="hljs-keyword">new</span> ConsoleHandler();<br>handler.setLevel(Level.CONFIG);<br>handler.setFormatter(<span class="hljs-keyword">new</span> XMLFormatter());<br>logger.addHandler(handler);<br></code></pre></td></tr></tbody></table></figure><p>我们可以直接配置为想要的打印格式，如果这些格式还不能满足你，那么我们也可以自行实现：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>{<br>    Logger logger = Logger.getLogger(Main.class.getName());<br>    logger.setUseParentHandlers(<span class="hljs-keyword">false</span>);<br><br>    <span class="hljs-comment">//为了让颜色变回普通的颜色，通过代码块在初始化时将输出流设定为System.out</span><br>    ConsoleHandler handler = <span class="hljs-keyword">new</span> ConsoleHandler(){{<br>        setOutputStream(System.out);<br>    }};<br>    <span class="hljs-comment">//创建匿名内部类实现自定义的格式</span><br>    handler.setFormatter(<span class="hljs-keyword">new</span> Formatter() {<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">format</span><span class="hljs-params">(LogRecord record)</span> </span>{<br>            SimpleDateFormat format = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss.SSS"</span>);<br>            String time = format.format(<span class="hljs-keyword">new</span> Date(record.getMillis()));  <span class="hljs-comment">//格式化日志时间</span><br>            String level = record.getLevel().getName();  <span class="hljs-comment">// 获取日志级别名称</span><br>            <span class="hljs-comment">// String level = record.getLevel().getLocalizedName();   // 获取本地化名称（语言跟随系统）</span><br>            String thread = String.format(<span class="hljs-string">"%10s"</span>, Thread.currentThread().getName());  <span class="hljs-comment">//线程名称（做了格式化处理，留出10格空间）</span><br>            <span class="hljs-keyword">long</span> threadID = record.getThreadID();   <span class="hljs-comment">//线程ID</span><br>            String className = String.format(<span class="hljs-string">"%-20s"</span>, record.getSourceClassName());  <span class="hljs-comment">//发送日志的类名</span><br>            String msg = record.getMessage();   <span class="hljs-comment">//日志消息</span><br><br>          <span class="hljs-comment">//\033[33m作为颜色代码，30~37都有对应的颜色，38是没有颜色，IDEA能显示，但是某些地方可能不支持</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">"\033[38m"</span> + time + <span class="hljs-string">"  \033[33m"</span> + level + <span class="hljs-string">" \033[35m"</span> + threadID<br>                    + <span class="hljs-string">"\033[38m --- ["</span> + thread + <span class="hljs-string">"] \033[36m"</span> + className + <span class="hljs-string">"\033[38m : "</span> + msg + <span class="hljs-string">"\n"</span>;<br>        }<br>    });<br>    logger.addHandler(handler);<br><br>    logger.info(<span class="hljs-string">"我是测试消息1..."</span>);<br>    logger.log(Level.INFO, <span class="hljs-string">"我是测试消息2..."</span>);<br>    logger.log(Level.WARNING, <span class="hljs-string">"我是测试消息3..."</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>日志可以设置过滤器，如果我们不希望某些日志信息被输出，我们可以配置过滤规则：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>{<br>    Logger logger = Logger.getLogger(Main.class.getName());<br><br>    <span class="hljs-comment">//自定义过滤规则</span><br>    logger.setFilter(record -&gt; !record.getMessage().contains(<span class="hljs-string">"普通"</span>));<br><br>    logger.log(Level.SEVERE, <span class="hljs-string">"严重的错误"</span>, <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"我就是错误"</span>));<br>    logger.log(Level.WARNING, <span class="hljs-string">"警告的内容"</span>);<br>    logger.log(Level.INFO, <span class="hljs-string">"普通的信息"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>实际上，整个日志的输出流程如下：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F20210310214730384.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4NjIzMzc1%2Csize_16%2Ccolor_FFFFFF%2Ct_70&amp;refer=http%3A%2F%2Fimg-blog.csdnimg.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1639566412&amp;t=aec06446b8338134a3dbddfaba9bde69" alt="img"></p><h3 id="Properties配置文件"><a href="#Properties配置文件" class="headerlink" title="Properties配置文件"></a>Properties配置文件</h3><p>Properties文件是Java的一种配置文件，我们之前学习了XML，但是我们发现XML配置文件读取实在是太麻烦，那么能否有一种简单一点的配置文件呢？我们可以使用Properties文件：</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">name</span>=<span class="hljs-string">Test</span><br><span class="hljs-attr">desc</span>=<span class="hljs-string">Description</span><br></code></pre></td></tr></tbody></table></figure><p>该文件配置很简单，格式为<code>配置项=配置值</code>，我们可以直接通过<code>Properties</code>类来将其读取为一个类似于Map一样的对象：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>{<br>    Properties properties = <span class="hljs-keyword">new</span> Properties();<br>    properties.load(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"test.properties"</span>));<br>    System.out.println(properties);<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现，<code>Properties</code>类是继承自<code>Hashtable</code>，而<code>Hashtable</code>是实现的Map接口，也就是说，<code>Properties</code>本质上就是一个Map一样的结构，它会把所有的配置项映射为一个Map，这样我们就可以快速地读取对应配置的值了。</p><p>我们也可以将已经存在的Properties对象放入输出流进行保存，我们这里就不保存文件了，而是直接打印到控制台，我们只需要提供输出流即可：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>{<br>    Properties properties = <span class="hljs-keyword">new</span> Properties();<br>  <span class="hljs-comment">// properties.setProperty("test", "lbwnb");  //和put效果一样</span><br>    properties.put(<span class="hljs-string">"test"</span>, <span class="hljs-string">"lbwnb"</span>);<br>    properties.store(System.out, <span class="hljs-string">"????"</span>);<br>  <span class="hljs-comment">//properties.storeToXML(System.out, "????");  保存为XML格式</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>我们可以通过<code>System.getProperties()</code>获取系统的参数，我们来看看：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>{<br>    System.getProperties().store(System.out, <span class="hljs-string">"系统信息："</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="编写日志配置文件"><a href="#编写日志配置文件" class="headerlink" title="编写日志配置文件"></a>编写日志配置文件</h3><p>我们可以通过进行配置文件来规定日志打印器的一些默认值：</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># RootLogger 的默认处理器为</span><br><span class="hljs-attr">handlers</span>= <span class="hljs-string">java.util.logging.ConsoleHandler</span><br><span class="hljs-comment"># RootLogger 的默认的日志级别</span><br><span class="hljs-meta">.level</span>= <span class="hljs-string">CONFIG</span><br></code></pre></td></tr></tbody></table></figure><p>我们来尝试使用配置文件来进行配置：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>{<br>    <span class="hljs-comment">//获取日志管理器</span><br>    LogManager manager = LogManager.getLogManager();<br>    <span class="hljs-comment">//读取我们自己的配置文件</span><br>    manager.readConfiguration(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"logging.properties"</span>));<br>    <span class="hljs-comment">//再获取日志打印器</span><br>    Logger logger = Logger.getLogger(Main.class.getName());<br>    logger.log(Level.CONFIG, <span class="hljs-string">"我是一条日志信息"</span>);   <span class="hljs-comment">//通过自定义配置文件，我们发现默认级别不再是INFO了</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>我们也可以去修改<code>ConsoleHandler</code>的默认配置：</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 指定默认日志级别</span><br><span class="hljs-meta">java.util.logging.ConsoleHandler.level</span> = <span class="hljs-string">ALL</span><br><span class="hljs-comment"># 指定默认日志消息格式</span><br><span class="hljs-meta">java.util.logging.ConsoleHandler.formatter</span> = <span class="hljs-string">java.util.logging.SimpleFormatter</span><br><span class="hljs-comment"># 指定默认的字符集</span><br><span class="hljs-meta">java.util.logging.ConsoleHandler.encoding</span> = <span class="hljs-string">UTF-8</span><br></code></pre></td></tr></tbody></table></figure><p>其实，我们阅读<code>ConsoleHandler</code>的源码就会发现，它就是通过读取配置文件来进行某些参数设置：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Private method to configure a ConsoleHandler from LogManager</span><br><span class="hljs-comment">// properties and/or default values as specified in the class</span><br><span class="hljs-comment">// javadoc.</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">()</span> </span>{<br>    LogManager manager = LogManager.getLogManager();<br>    String cname = getClass().getName();<br><br>    setLevel(manager.getLevelProperty(cname +<span class="hljs-string">".level"</span>, Level.INFO));<br>    setFilter(manager.getFilterProperty(cname +<span class="hljs-string">".filter"</span>, <span class="hljs-keyword">null</span>));<br>    setFormatter(manager.getFormatterProperty(cname +<span class="hljs-string">".formatter"</span>, <span class="hljs-keyword">new</span> SimpleFormatter()));<br>    <span class="hljs-keyword">try</span> {<br>        setEncoding(manager.getStringProperty(cname +<span class="hljs-string">".encoding"</span>, <span class="hljs-keyword">null</span>));<br>    } <span class="hljs-keyword">catch</span> (Exception ex) {<br>        <span class="hljs-keyword">try</span> {<br>            setEncoding(<span class="hljs-keyword">null</span>);<br>        } <span class="hljs-keyword">catch</span> (Exception ex2) {<br>            <span class="hljs-comment">// doing a setEncoding with null should always work.</span><br>            <span class="hljs-comment">// assert false;</span><br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="使用Lombok快速开启日志"><a href="#使用Lombok快速开启日志" class="headerlink" title="使用Lombok快速开启日志"></a>使用Lombok快速开启日志</h3><p>我们发现，如果我们现在需要全面使用日志系统，而不是传统的直接打印，那么就需要在每个类都去编写获取Logger的代码，这样显然是很冗余的，能否简化一下这个流程呢？</p><p>前面我们学习了Lombok，我们也体会到Lombok给我们带来的便捷，我们可以通过一个注解快速生成构造方法、Getter和Setter，同样的，Logger也是可以使用Lombok快速生成的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Log</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        System.out.println(<span class="hljs-string">"自动生成的Logger名称："</span>+log.getName());<br>        log.info(<span class="hljs-string">"我是日志信息"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>只需要添加一个<code>@Log</code>注解即可，添加后，我们可以直接使用一个静态变量log，而它就是自动生成的Logger。我们也可以手动指定名称：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Log(topic = "打工是不可能打工的")</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        System.out.println(<span class="hljs-string">"自动生成的Logger名称："</span>+log.getName());<br>        log.info(<span class="hljs-string">"我是日志信息"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="Mybatis日志系统"><a href="#Mybatis日志系统" class="headerlink" title="Mybatis日志系统"></a>Mybatis日志系统</h3><p>Mybatis也有日志系统，它详细记录了所有的数据库操作等，但是我们在前面的学习中没有开启它，现在我们学习了日志之后，我们就可以尝试开启Mybatis的日志系统，来监控所有的数据库操作，要开启日志系统，我们需要进行配置：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"logImpl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"STDOUT_LOGGING"</span> /&gt;</span><br></code></pre></td></tr></tbody></table></figure><p><code>logImpl</code>包括很多种配置项，包括 SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING，而默认情况下是未配置，也就是说不打印。我们这里将其设定为STDOUT_LOGGING表示直接使用标准输出将日志信息打印到控制台，我们编写一个测试案例来看看效果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMain</span> </span>{<br><br>    <span class="hljs-keyword">private</span> SqlSessionFactory sqlSessionFactory;<br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>{<br>        <span class="hljs-keyword">try</span> {<br>            sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder()<br>                    .build(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"mybatis-config.xml"</span>));<br>        } <span class="hljs-keyword">catch</span> (FileNotFoundException e) {<br>            e.printStackTrace();<br>        }<br>    }<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>{<br>        <span class="hljs-keyword">try</span>(SqlSession sqlSession = sqlSessionFactory.openSession(<span class="hljs-keyword">true</span>)){<br>            TestMapper mapper = sqlSession.getMapper(TestMapper.class);<br>            System.out.println(mapper.getStudentBySidAndSex(<span class="hljs-number">1</span>, <span class="hljs-string">"男"</span>));<br>            System.out.println(mapper.getStudentBySidAndSex(<span class="hljs-number">1</span>, <span class="hljs-string">"男"</span>));<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们发现，两次获取学生信息，只有第一次打开了数据库连接，而第二次并没有。</p><p>现在我们学习了日志系统，那么我们来尝试使用日志系统输出Mybatis的日志信息：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"logImpl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"JDK_LOGGING"</span> /&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>将其配置为JDK_LOGGING表示使用JUL进行日志打印，因为Mybatis的日志级别都比较低，因此我们需要设置一下<code>logging.properties</code>默认的日志级别：</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">handlers</span>= <span class="hljs-string">java.util.logging.ConsoleHandler</span><br><span class="hljs-meta">.level</span>= <span class="hljs-string">ALL</span><br><span class="hljs-meta">java.util.logging.ConsoleHandler.level</span> = <span class="hljs-string">ALL</span><br></code></pre></td></tr></tbody></table></figure><p>代码编写如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Log</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMain</span> </span>{<br><br>    <span class="hljs-keyword">private</span> SqlSessionFactory sqlSessionFactory;<br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>{<br>        <span class="hljs-keyword">try</span> {<br>            sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder()<br>                    .build(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"mybatis-config.xml"</span>));<br>            LogManager manager = LogManager.getLogManager();<br>            manager.readConfiguration(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"logging.properties"</span>));<br>        } <span class="hljs-keyword">catch</span> (IOException e) {<br>            e.printStackTrace();<br>        }<br>    }<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>{<br>        <span class="hljs-keyword">try</span>(SqlSession sqlSession = sqlSessionFactory.openSession(<span class="hljs-keyword">true</span>)){<br>            TestMapper mapper = sqlSession.getMapper(TestMapper.class);<br>            log.info(mapper.getStudentBySidAndSex(<span class="hljs-number">1</span>, <span class="hljs-string">"男"</span>).toString());<br>            log.info(mapper.getStudentBySidAndSex(<span class="hljs-number">1</span>, <span class="hljs-string">"男"</span>).toString());<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>但是我们发现，这样的日志信息根本没法看，因此我们需要修改一下日志的打印格式，我们自己创建一个格式化类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFormatter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Formatter</span> </span>{<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">format</span><span class="hljs-params">(LogRecord record)</span> </span>{<br>        SimpleDateFormat format = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss.SSS"</span>);<br>        String time = format.format(<span class="hljs-keyword">new</span> Date(record.getMillis()));  <span class="hljs-comment">//格式化日志时间</span><br>        <span class="hljs-keyword">return</span> time + <span class="hljs-string">" : "</span> + record.getMessage() + <span class="hljs-string">"\n"</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>现在再来修改一下默认的格式化实现：</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">handlers</span>= <span class="hljs-string">java.util.logging.ConsoleHandler</span><br><span class="hljs-meta">.level</span>= <span class="hljs-string">ALL</span><br><span class="hljs-meta">java.util.logging.ConsoleHandler.level</span> = <span class="hljs-string">ALL</span><br><span class="hljs-meta">java.util.logging.ConsoleHandler.formatter</span> = <span class="hljs-string">com.test.TestFormatter</span><br></code></pre></td></tr></tbody></table></figure><p>现在就好看多了，当然，我们还可以继续为Mybatis添加文件日志，这里就不做演示了。</p><hr><h2 id="使用Maven管理项目"><a href="#使用Maven管理项目" class="headerlink" title="使用Maven管理项目"></a>使用Maven管理项目</h2><p><strong>注意：</strong>开始之前，看看你C盘空间够不够，最好预留2GB空间以上！</p><p><strong>吐槽：</strong>很多电脑预装系统C盘都给得巨少，就算不装软件，一些软件的缓存文件也能给你塞满，建议有时间重装一下系统重新分配一下磁盘空间。</p><p>Maven 翻译为”专家”、”内行”，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。Maven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。</p><p>通过Maven，可以帮助我们做：</p><ul><li>项目的自动构建，包括代码的编译、测试、打包、安装、部署等操作。</li><li>依赖管理，项目使用到哪些依赖，可以快速完成导入。</li></ul><p>我们之前并没有讲解如何将我们的项目打包为Jar文件运行，同时，我们导入依赖的时候，每次都要去下载对应的Jar包，这样其实是很麻烦的，并且还有可能一个Jar包依赖于另一个Jar包，就像之前使用JUnit一样，因此我们需要一个更加方便的包管理机制。</p><p>Maven也需要安装环境，但是IDEA已经自带了Maven环境，因此我们不需要再去进行额外的环境安装（无IDEA也能使用Maven，但是配置过程很麻烦，并且我们现在使用的都是IDEA的集成开发环境，所以这里就不讲解Maven命令行操作了）我们直接创建一个新的Maven项目即可。</p><h3 id="Maven项目结构"><a href="#Maven项目结构" class="headerlink" title="Maven项目结构"></a>Maven项目结构</h3><p>我们可以来看一下，一个Maven项目和我们普通的项目有什么区别：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2Fimg_convert%2F910235ebc812ba94abb0f762e3914f67.png&amp;refer=http%3A%2F%2Fimg-blog.csdnimg.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1639621411&amp;t=2a62e7ef9b056d8cbe772e34fea0cc6f" alt="img"></p><p>那么首先，我们需要了解一下POM文件，它相当于是我们整个Maven项目的配置文件，它也是使用XML编写的：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>MavenTest<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>我们可以看到，Maven的配置文件是以<code>project</code>为根节点，而<code>modelVersion</code>定义了当前模型的版本，一般是4.0.0，我们不用去修改。</p><p><code>groupId</code>、<code>artifactId</code>、<code>version</code>这三个元素合在一起，用于唯一区别每个项目，别人如果需要将我们编写的代码作为依赖，那么就必须通过这三个元素来定位我们的项目，我们称为一个项目的基本坐标，所有的项目一般都有自己的Maven坐标，因此我们通过Maven导入其他的依赖只需要填写这三个基本元素就可以了，无需再下载Jar文件，而是Maven自动帮助我们下载依赖并导入。</p><ul><li><code>groupId</code> 一般用于指定组名称，命名规则一般和包名一致，比如我们这里使用的是<code>org.example</code>，一个组下面可以有很多个项目。</li><li><code>artifactId</code> 一般用于指定项目在当前组中的唯一名称，也就是说在组中用于区分于其他项目的标记。</li><li><code>version</code> 代表项目版本，随着我们项目的开发和改进，版本号也会不断更新，就像LOL一样，每次赛季更新都会有一个大版本更新，我们的Maven项目也是这样，我们可以手动指定当前项目的版本号，其他人使用我们的项目作为依赖时，也可以根本版本号进行选择（这里的SNAPSHOT代表快照，一般表示这是一个处于开发中的项目，正式发布项目一般只带版本号）</li></ul><p><code>properties</code>中一般都是一些变量和选项的配置，我们这里指定了JDK的源代码和编译版本为1.8，无需进行修改。</p><h3 id="Maven依赖导入"><a href="#Maven依赖导入" class="headerlink" title="Maven依赖导入"></a>Maven依赖导入</h3><p>现在我们尝试使用Maven来帮助我们快速导入依赖，我们需要导入之前的JDBC驱动依赖、JUnit依赖、Mybatis依赖、Lombok依赖，那么如何使用Maven来管理依赖呢？</p><p>我们可以创建一个<code>dependencies</code>节点：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    //里面填写的就是所有的依赖<br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>那么现在就可以向节点中填写依赖了，那么我们如何知道每个依赖的坐标呢？我们可以在：<a href="https://mvnrepository.com/">https://mvnrepository.com/</a> 进行查询（可能打不开，建议用流量，或是直接百度某个项目的Maven依赖），我们直接搜索lombok即可，打开后可以看到已经给我们写出了依赖的坐标：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.22<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>我们直接将其添加到<code>dependencies</code>节点中即可，现在我们来编写一个测试用例看看依赖导入成功了没有：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        Student student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"小明"</span>, <span class="hljs-number">18</span>);<br>        System.out.println(student);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>{<br>    String name;<br>    <span class="hljs-keyword">int</span> age;<br>}<br></code></pre></td></tr></tbody></table></figure><p>项目运行成功，表示成功导入了依赖。那么，Maven是如何进行依赖管理呢，以致于如此便捷的导入依赖，我们来看看Maven项目的依赖管理流程：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimage.bubuko.com%2Finfo%2F201901%2F20190106202802893827.png&amp;refer=http%3A%2F%2Fimage.bubuko.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1639624645&amp;t=75fdf146baa915fbba88918895f92b81" alt="img"></p><p>通过流程图我们得知，一个项目依赖一般是存储在中央仓库中，也有可能存储在一些其他的远程仓库（私服），几乎所有的依赖都被放到了中央仓库中，因此，Maven可以直接从中央仓库中下载大部分的依赖（Maven第一次导入依赖是需要联网的），远程仓库中下载之后 ，会暂时存储在本地仓库，我们会发现我们本地存在一个<code>.m2</code>文件夹，这就是Maven本地仓库文件夹，默认建立在C盘，如果你C盘空间不足，会出现问题！</p><p>在下次导入依赖时，如果Maven发现本地仓库中就已经存在某个依赖，那么就不会再去远程仓库下载了。</p><p>可能在导入依赖时，小小伙伴们会出现卡顿的问题，我们建议配置一下IDEA自带的Maven插件远程仓库地址，我们打开IDEA的安装目录，找到<code>安装根目录/plugins/maven/lib/maven3/conf</code>文件夹，找到<code>settings.xml</code>文件，打开编辑：</p><p>找到mirros标签，添加以下内容：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span> <br></code></pre></td></tr></tbody></table></figure><p>这样，我们就将默认的远程仓库地址（国外），配置为国内的阿里云仓库地址了（依赖的下载速度就会快起来了）</p><h3 id="Maven依赖作用域"><a href="#Maven依赖作用域" class="headerlink" title="Maven依赖作用域"></a>Maven依赖作用域</h3><p>除了三个基本的属性用于定位坐标外，依赖还可以添加以下属性：</p><ul><li><strong>type</strong>：依赖的类型，对于项目坐标定义的packaging。大部分情况下，该元素不必声明，其默认值为jar</li><li><strong>scope</strong>：依赖的范围（作用域，着重讲解）</li><li><strong>optional</strong>：标记依赖是否可选</li><li><strong>exclusions</strong>：用来排除传递性依赖（一个项目有可能依赖于其他项目，就像我们的项目，如果别人要用我们的项目作为依赖，那么就需要一起下载我们项目的依赖，如Lombok）</li></ul><p>我们着重来讲解一下<code>scope</code>属性，它决定了依赖的作用域范围：</p><ul><li><strong>compile</strong> ：为默认的依赖有效范围。如果在定义依赖关系的时候，没有明确指定依赖有效范围的话，则默认采用该依赖有效范围。此种依赖，在编译、运行、测试时均有效。</li><li><strong>provided</strong> ：在编译、测试时有效，但是在运行时无效，也就是说，项目在运行时，不需要此依赖，比如我们上面的Lombok，我们只需要在编译阶段使用它，编译完成后，实际上已经转换为对应的代码了，因此Lombok不需要在项目运行时也存在。</li><li><strong>runtime</strong> ：在运行、测试时有效，但是在编译代码时无效。比如我们如果需要自己写一个JDBC实现，那么肯定要用到JDK为我们指定的接口，但是实际上在运行时是不用自带JDK的依赖，因此只保留我们自己写的内容即可。</li><li><strong>test</strong> ：只在测试时有效，例如：JUnit，我们一般只会在测试阶段使用JUnit，而实际项目运行时，我们就用不到测试了，那么我们来看看，导入JUnit的依赖：</li></ul><p>同样的，我们可以在网站上搜索Junit的依赖，我们这里导入最新的JUnit5作为依赖：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>我们所有的测试用例全部编写到Maven项目给我们划分的test目录下，位于此目录下的内容不会在最后被打包到项目中，只用作开发阶段测试使用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainTest</span> </span>{<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>{<br>        System.out.println(<span class="hljs-string">"测试"</span>);<br>      <span class="hljs-comment">//Assert在JUnit5时名称发生了变化Assertions</span><br>        Assertions.assertArrayEquals(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}, <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>});<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>因此，一般仅用作测试的依赖如JUnit只保留在测试中即可，那么现在我们再来添加JDBC和Mybatis的依赖：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>我们发现，Maven还给我们提供了一个<code>resource</code>文件夹，我们可以将一些静态资源，比如配置文件，放入到这个文件夹中，项目在打包时会将资源文件夹中文件一起打包的Jar中，比如我们在这里编写一个Mybatis的配置文件：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"mapUnderscoreToCamelCase"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cacheEnabled"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"logImpl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"JDK_LOGGING"</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 需要在environments的上方 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"com.test.entity"</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">"development"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"development"</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"JDBC"</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"POOLED"</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"jdbc:mysql://localhost:3306/study"</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"test"</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"123456"</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.test.mapper.TestMapper"</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>现在我们创建一下测试用例，顺便带大家了解一下Junit5的一些比较方便的地方：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainTest</span> </span>{<br><br>    <span class="hljs-comment">//因为配置文件位于内部，我们需要使用Resources类的getResourceAsStream来获取内部的资源文件</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory factory;<br><br>    <span class="hljs-comment">//在JUnit5中@Before被废弃，它被细分了：</span><br>    <span class="hljs-meta">@BeforeAll</span> <span class="hljs-comment">// 一次性开启所有测试案例只会执行一次 (方法必须是static)</span><br>    <span class="hljs-comment">// @BeforeEach 一次性开启所有测试案例每个案例开始之前都会执行一次</span><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>{<br>        factory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder()<br>                .build(Resources.getResourceAsStream(<span class="hljs-string">"mybatis.xml"</span>));<br>    }<br><br><br>    <span class="hljs-meta">@DisplayName("Mybatis数据库测试")</span>  <span class="hljs-comment">//自定义测试名称</span><br>    <span class="hljs-meta">@RepeatedTest(3)</span>  <span class="hljs-comment">//自动执行多次测试</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>{<br>        <span class="hljs-keyword">try</span> (SqlSession sqlSession = factory.openSession(<span class="hljs-keyword">true</span>)){<br>            TestMapper testMapper = sqlSession.getMapper(TestMapper.class);<br>            System.out.println(testMapper.getStudentBySid(<span class="hljs-number">1</span>));<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>那么就有人提问了，如果我需要的依赖没有上传的远程仓库，而是只有一个Jar怎么办呢？我们可以使用第四种作用域：</p><ul><li><strong>system</strong>：作用域和provided是一样的，但是它不是从远程仓库获取，而是直接导入本地Jar包：</li></ul><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.jntm<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lbwnb<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>system<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">systemPath</span>&gt;</span>C://学习资料/4K高清无码/test.jar<span class="hljs-tag">&lt;/<span class="hljs-name">systemPath</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>比如上面的例子，如果scope为system，那么我们需要添加一个systemPath来指定jar文件的位置，这里就不再演示了。</p><h3 id="Maven可选依赖"><a href="#Maven可选依赖" class="headerlink" title="Maven可选依赖"></a>Maven可选依赖</h3><p>当项目中的某些依赖不希望被使用此项目作为依赖的项目使用时，我们可以给依赖添加<code>optional</code>标签表示此依赖是可选的，默认在导入依赖时，不会导入可选的依赖：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>比如Mybatis的POM文件中，就存在大量的可选依赖：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.30<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.30<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br> ...<br></code></pre></td></tr></tbody></table></figure><p>由于Mybatis要支持多种类型的日志，需要用到很多种不同的日志框架，因此需要导入这些依赖来做兼容，但是我们项目中并不一定会使用这些日志框架作为Mybatis的日志打印器，因此这些日志框架仅Mybatis内部做兼容需要导入使用，而我们可以选择不使用这些框架或是选择其中一个即可，也就是说我们导入Mybatis之后想用什么日志框架再自己加就可以了。</p><h3 id="Maven排除依赖"><a href="#Maven排除依赖" class="headerlink" title="Maven排除依赖"></a>Maven排除依赖</h3><p>我们了解了可选依赖，现在我们可以让使用此项目作为依赖的项目默认不使用可选依赖，但是如果存在那种不是可选依赖，但是我们导入此项目有不希望使用此依赖该怎么办呢，这个时候我们就可以通过排除依赖来防止添加不必要的依赖：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>我们这里演示了排除JUnit的一些依赖，我们可以在外部库中观察排除依赖之后和之前的效果。</p><h3 id="Maven继承关系"><a href="#Maven继承关系" class="headerlink" title="Maven继承关系"></a>Maven继承关系</h3><p>一个Maven项目可以继承自另一个Maven项目，比如多个子项目都需要父项目的依赖，我们就可以使用继承关系来快速配置。</p><p>我们右键左侧栏，新建一个模块，来创建一个子项目：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>MavenTest<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ChildModel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>我们可以看到，IDEA默认给我们添加了一个parent节点，表示此Maven项目是父Maven项目的子项目，子项目直接继承父项目的<code>groupId</code>，子项目会直接继承父项目的所有依赖，除非依赖添加了optional标签，我们来编写一个测试用例尝试一下:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.java.Log;<br><br><span class="hljs-meta">@Log</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        log.info(<span class="hljs-string">"我是日志信息"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以看到，子项目也成功继承了Lombok依赖。</p><p>我们还可以让父Maven项目统一管理所有的依赖，包括版本号等，子项目可以选取需要的作为依赖，而版本全由父项目管理，我们可以将<code>dependencies</code>全部放入<code>dependencyManagement</code>节点，这样父项目就完全作为依赖统一管理。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.22<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>我们发现，子项目的依赖失效了，因为现在父项目没有依赖，而是将所有的依赖进行集中管理，子项目需要什么再拿什么即可，同时子项目无需指定版本，所有的版本全部由父项目决定，子项目只需要使用即可：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>当然，父项目如果还存在dependencies节点的话，里面的内依赖依然是直接继承：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>      ...<br></code></pre></td></tr></tbody></table></figure><h3 id="Maven常用命令"><a href="#Maven常用命令" class="headerlink" title="Maven常用命令"></a>Maven常用命令</h3><p>我们可以看到在IDEA右上角Maven板块中，每个Maven项目都有一个生命周期，实际上这些是Maven的一些插件，每个插件都有各自的功能，比如：</p><ul><li><code>clean</code>命令，执行后会清理整个<code>target</code>文件夹，在之后编写Springboot项目时可以解决一些缓存没更新的问题。</li><li><code>validate</code>命令可以验证项目的可用性。</li><li><code>compile</code>命令可以将项目编译为.class文件。</li><li><code>install</code>命令可以将当前项目安装到本地仓库，以供其他项目导入作为依赖使用</li><li><code>verify</code>命令可以按顺序执行每个默认生命周期阶段（<code>validate</code>，<code>compile</code>，<code>package</code>等）</li></ul><h3 id="Maven测试项目"><a href="#Maven测试项目" class="headerlink" title="Maven测试项目"></a>Maven测试项目</h3><p>通过使用<code>test</code>命令，可以一键测试所有位于test目录下的测试案例，请注意有以下要求：</p><ul><li>测试类的名称必须是以<code>Test</code>结尾，比如<code>MainTest</code></li><li>测试方法上必须标注<code>@Test</code>注解，实测<code>@RepeatedTest</code>无效</li></ul><p>这是由于JUnit5比较新，我们需要重新配置插件升级到高版本，才能完美的兼容Junit5：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- JUnit 5 requires Surefire version 2.22.0 or higher --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.22.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>现在<code>@RepeatedTest</code>、<code>@BeforeAll</code>也能使用了。</p><h3 id="Maven打包项目"><a href="#Maven打包项目" class="headerlink" title="Maven打包项目"></a>Maven打包项目</h3><p>我们的项目在编写完成之后，要么作为Jar依赖，供其他模型使用，要么就作为一个可以执行的程序，在控制台运行，我们只需要直接执行<code>package</code>命令就可以直接对项目的代码进行打包，生成jar文件。</p><p>当然，以上方式仅适用于作为Jar依赖的情况，如果我们需要打包一个可执行文件，那么我不仅需要将自己编写的类打包到Jar中，同时还需要将依赖也一并打包到Jar中，因为我们使用了别人为我们通过的框架，自然也需要运行别人的代码，我们需要使用另一个插件来实现一起打包：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">descriptorRefs</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">descriptorRef</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">descriptorRefs</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">archive</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">manifest</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">addClasspath</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">addClasspath</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>com.test.Main<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">archive</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>make-assembly<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>single<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>在打包之前也会执行一次test命令，来保证项目能够正常运行，当测试出现问题时，打包将无法完成，我们也可以手动跳过，选择<code>执行Maven目标</code>来手动执行Maven命令，输入<code>mvn package -Dmaven.test.skip=true </code>来以跳过测试的方式进行打包。</p><p>最后得到我们的Jar文件，在同级目录下输入<code>java -jar xxxx.jar</code>来运行我们打包好的Jar可执行程序（xxx代表文件名称）</p><ul><li><code>deploy</code>命令用于发布项目到本地仓库和远程仓库，一般情况下用不到，这里就不做讲解了。</li><li><code>site</code>命令用于生成当前项目的发布站点，暂时不需要了解。</li></ul><p>我们之前还讲解了多模块项目，那么多模块下父项目存在一个<code>packing</code>打包类型标签，所有的父级项目的packing都为pom，packing默认是jar类型，如果不作配置，maven会将该项目打成jar包。作为父级项目，还有一个重要的属性，那就是modules，通过modules标签将项目的所有子项目引用进来，在build父级项目时，会根据子模块的相互依赖关系整理一个build顺序，然后依次build。</p><hr><h2 id="实战：基于Mybatis-JUL-Lombok-Maven的图书管理系统（带单元测试）"><a href="#实战：基于Mybatis-JUL-Lombok-Maven的图书管理系统（带单元测试）" class="headerlink" title="实战：基于Mybatis+JUL+Lombok+Maven的图书管理系统（带单元测试）"></a>实战：基于Mybatis+JUL+Lombok+Maven的图书管理系统（带单元测试）</h2><p>项目需求：</p><ul><li>在线录入学生信息和书籍信息</li><li>查询书籍信息列表</li><li>查询学生信息列表</li><li>查询借阅信息列表</li><li>完整的日志系统</li></ul>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;Java与数据库&quot;&gt;&lt;a href=&quot;#Java与数据库&quot; class=&quot;headerlink&quot; title=&quot;Java与数据库&quot;&gt;&lt;/a&gt;Java与数据库&lt;/h1&gt;&lt;p&gt;通过Java如何去使用数据库来帮助我们存储数据呢，这将是本章节讨论的重点。&lt;/p&gt;
&lt;h2 id=&quot;初识JDBC&quot;&gt;&lt;a href=&quot;#初识JDBC&quot; class=&quot;headerlink&quot; title=&quot;初识JDBC&quot;&gt;&lt;/a&gt;初识JDBC&lt;/h2&gt;&lt;p&gt;JDBC是什么？JDBC英文名为：Java Data Base Connectivity(Java数据库连接)，官方解释它是Java编程语言和广泛的数据库之间独立于数据库的连接标准的Java API，根本上说JDBC是一种规范，它提供的接口，一套完整的，允许便捷式访问底层数据库。可以用JAVA来写不同类型的可执行文件：JAVA应用程序、JAVA Applets、Java Servlet、JSP等，不同的可执行文件都能通过JDBC访问数据库，又兼备存储的优势。简单说它就是Java与数据库的连接的桥梁或者插件，用Java代码就能操作数据库的增删改查、存储过程、事务等。&lt;/p&gt;
&lt;p&gt;我们可以发现，JDK自带了一个&lt;code&gt;java.sql&lt;/code&gt;包，而这里面就定义了大量的接口，不同类型的数据库，都可以通过实现此接口，编写适用于自己数据库的实现类。而不同的数据库厂商实现的这套标准，我们称为&lt;code&gt;数据库驱动&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h3&gt;&lt;p&gt;那么我们首先来进行一些准备工作，以便开始JDBC的学习：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将idea连接到我们的数据库，以便以后调试。&lt;/li&gt;
&lt;li&gt;将mysql驱动jar依赖导入到项目中（推荐6.0版本以上，这里用到是8.0）&lt;/li&gt;
&lt;li&gt;向Jetbrians申请一个学生/教师授权，用于激活idea终极版（进行JavaWeb开发需要用到，一般申请需要3-7天时间审核）不是大学生的话…emmm…懂的都懂。&lt;/li&gt;
&lt;li&gt;教育授权申请地址：&lt;a href=&quot;https://www.jetbrains.com/shop/eform/students&quot;&gt;https://www.jetbrains.com/shop/eform/students&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个Java程序并不是一个人的战斗，我们可以在别人开发的基础上继续向上开发，其他的开发者可以将自己编写的Java代码打包为&lt;code&gt;jar&lt;/code&gt;，我们只需要导入这个&lt;code&gt;jar&lt;/code&gt;作为依赖，即可直接使用别人的代码，就像我们直接去使用JDK提供的类一样。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://xiaofanshutu.github.io/posts/0.html"/>
    <id>https://xiaofanshutu.github.io/posts/0.html</id>
    <published>2025-08-31T15:29:05.020Z</published>
    <updated>2025-08-31T15:31:22.573Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h1><p>数据库是学习JavaWeb的一个前置，只有了解了数据库的操作和使用，我们才能更好地组织和管理网站应用产生的数据。</p><p><img src="https://img2.baidu.com/it/u=873816781,3605513900&amp;fm=26&amp;fmt=auto" alt="img"></p><h2 id="什么是数据库"><a href="#什么是数据库" class="headerlink" title="什么是数据库"></a>什么是数据库</h2><p>数据库是数据管理的有效技术，是由一批数据构成的有序集合，这些数据被存放在结构化的数据表里。数据表之间相互关联，反映客观事物间的本质联系。数据库能有效地帮助一个组织或企业科学地管理各类信息资源。简而言之，我们的数据可以交给数据库来帮助我们进行管理，同时数据库能够为我们提供高效的访问性能。</p><p>在JavaSE学习阶段中，我们学习了如何使用文件I/O来将数据保存到本地，这样就可以将一个数据持久地存储在本地，即使程序重新打开，我们也能加载回上一次的数据，但是当我们的数据变得非常多的时候，这样的方式就显得不太方便了。同时我们如果需要查找众多数据的中的某一个，就只能加载到内存再进行查找，这样显然是很难受的！</p><p>而数据库就是专门做这事的，我们可以快速查找想要的数据，便捷地插入、修改和删除数据，并且数据库不仅能做这些事，还能提供更多便于管理数据和操作数据的功能！</p><h3 id="常见的数据库"><a href="#常见的数据库" class="headerlink" title="常见的数据库"></a>常见的数据库</h3><p>常见的数据库有很多种，包括但不限于：</p><ul><li>MySQL - 免费，用的最多的，开源数据库，适用于中小型</li><li>Microsoft SQL Server - 收钱的，但是提供技术支持，适用于Windows Server</li><li>Oracle - 收钱的，大型数据库系统</li></ul><p>而我们要学习的是MySQL数据，其实无论学习哪种数据库，SQL语句大部分都是通用的，只有少许语法是不通用的，因此我们只需要学习一种数据库其他的也就差不多都会了。</p><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>数据模型与现实世界中的模型一样，是对现实世界数据特征的一种抽象。实际上，我们之前学习的类就是对现实世界数据的一种抽象，比如一个学生的特征包括姓名，年龄，年级，学号，专业等，这些特征也称为实体的一种属性，属性具有以下特点：</p><ul><li>属性不可再分</li><li>一个实体的属性可以有很多个</li><li>用于唯一区分不同实体的的属性，称为Key，比如每个同学的学号都是不一样的</li><li>属性取值可以有一定的约束，比如性别只能是男或是女</li></ul><p>实体或是属性之间可以具有一定的联系，比如一个老师可以教很多个学生，而学生相对于老师就是被教授的关系；又比如每个同学都有一个学号与其唯一对应，因此学号和学生之间也有一种联系。而像一个老师教多个学生的联系就是一种一对多的联系（1:n），而学号唯一对应，就是一种一对一的联系（1:1）；每一个老师不仅可以教多个学生，每一个学生也可以有多个教师，这就是一种多对多的联系（n:m）</p><p>MySQL就是一种关系型数据库，通过使用关系型数据库，我们就可以很好地存储这样带有一定联系的数据。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Ffile1.renrendoc.com%2Ffileroot_temp2%2F2020-10%2F17%2F763fb9f3-871d-4f1c-abe7-0a5025cf52a5%2F763fb9f3-871d-4f1c-abe7-0a5025cf52a52.gif&amp;refer=http%3A%2F%2Ffile1.renrendoc.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1637926750&amp;t=31a308e5d8efd32bae55a40c963f459d" alt="img"></p><p>通过构建一个ER图，我们就能很好地理清不同数据模型之间的关系和特点。</p><h2 id="数据库的创建"><a href="#数据库的创建" class="headerlink" title="数据库的创建"></a>数据库的创建</h2><p>既然了解了属性和联系，那么我们就来尝试创建一个数据库，并在数据库中添加用于存放数据的表，每一张表都代表一种实体的数据。首先我们要明确，我们需要创建什么样子的表：</p><ul><li>学生表：用于存放所有学生的数据，学生（<u>学号</u>，姓名，性别）</li><li>教师表：用于存放所有教师的数据，教师（<u>教师号</u>，姓名）</li><li>授课表：用于存放教师与学生的授课信息，授课（学号，教师号）</li></ul><p>其中，标注下划线的属性，作为Key，用于区别于其他实体数据的唯一标记。</p><p>为了理解起来更加轻松，我们从图形界面操作再讲到SQL语句，请不要着急。我们现在通过Navicat或idea自带的数据库客户端来创建一个数据库和上述三个表。</p><h2 id="数据库的规范化"><a href="#数据库的规范化" class="headerlink" title="数据库的规范化"></a>数据库的规范化</h2><p>要去设计存放一个实体的表，我们就需要了解数据库的关系规范化，尽可能减少“不好”的关系存在，如何设计一个优良的关系模型是最关键的内容！简而言之，我们要学习一下每一个表该如何去设计。</p><h3 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h3><p>第一范式是指数据库的每一列都是不可分割的基本数据项，而下面这样的就存在可分割的情况：</p><ul><li>学生（姓名，电话号码）</li></ul><p>电话号码实际上包括了<code>家用座机电话</code>和<code>移动电话</code>，因此它可以被拆分为：</p><ul><li>学生（姓名，座机号码，手机号码）</li></ul><p>满足第一范式是关系型数据库最基本的要求！</p><h3 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h3><p>第二范式要求表中必须存在主键，且其他的属性必须完全依赖于主键，比如：</p><ul><li>学生（<u>学号</u>，姓名，性别）</li></ul><p>学号是每个学生的唯一标识，每个学生都有着不同的学号，因此此表中存在一个主键，并且每个学生的所有属性都依赖于学号，学号发生改变就代表学生发生改变，姓名和性别都会因此发生改变，所有此表满足第二范式。</p><h3 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h3><p>在满足第二范式的情况下，所有的属性都不传递依赖于主键，满足第三范式。</p><ul><li>学生借书情况（<u>借阅编号</u>，学生学号，书籍编号，书籍名称，书籍作者）</li></ul><p>实际上书籍编号依赖于借阅编号，而书籍名称和书籍作者依赖于书籍编号，因此存在传递依赖的情况，我们可以将书籍信息进行单独拆分为另一张表：</p><ul><li>学生借书情况（<u>借阅编号</u>，学生学号，书籍编号）</li><li>书籍（<u>书籍编号</u>，书籍名称，书籍作者）</li></ul><p>这样就消除了传递依赖，从而满足第三范式。</p><h3 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h3><p>BCNF作为第三范式的补充，假设仓库管理关系表为StorehouseManage(仓库ID, 存储物品ID, 管理员ID, 数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。这个数据库表中存在如下决定关系：</p><p>(仓库ID, 存储物品ID) →(管理员ID, 数量)</p><p>(管理员ID, 存储物品ID) → (仓库ID, 数量)</p><p>所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系：</p><p>(仓库ID) → (管理员ID)</p><p>(管理员ID) → (仓库ID)</p><p>即存在关键字段决定关键字段的情况，如果修改管理员ID，那么就必须逐一进行修改，所以其不符合BCNF范式。</p><hr><h2 id="认识SQL语句"><a href="#认识SQL语句" class="headerlink" title="认识SQL语句"></a>认识SQL语句</h2><p>结构化查询语言（Structured Query Language）简称SQL，这是一种特殊的语言，它专门用于数据库的操作。每一种数据库都支持SQL，但是他们之间会存在一些细微的差异，因此不同的数据库都存在自己的“方言”。</p><p>SQL语句不区分大小写（关键字推荐使用大写），它支持多行，并且需要使用<code>;</code>进行结尾！</p><p>SQL也支持注释，通过使用<code>--</code>或是<code>#</code>来编写注释内容，也可以使用<code>/*</code>来进行多行注释。</p><p>我们要学习的就是以下四种类型的SQL语言：</p><ul><li>数据查询语言（Data Query Language, DQL）基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块。</li><li>数据操纵语言（Data Manipulation Language, DML）是SQL语言中，负责对数据库对象运行数据访问工作的指令集，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入、更新与删除，是开发以数据为中心的应用程序必定会使用到的指令。</li><li>数据库定义语言DDL(Data Definition Language)，是用于描述数据库中要存储的现实世界实体的语言。</li><li>DCL（Data Control Language）是数据库控制语言。是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL。</li></ul><p>我们平时所说的CRUD其实就是增删改查（Create/Retrieve/Update/Delete）</p><hr><h2 id="数据库定义语言（DDL）"><a href="#数据库定义语言（DDL）" class="headerlink" title="数据库定义语言（DDL）"></a>数据库定义语言（DDL）</h2><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><p>我们可以通过<code>create database</code>来创建一个数据库：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> 数据库名<br></code></pre></td></tr></tbody></table></figure><p>为了能够支持中文，我们在创建时可以设定编码格式：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> 数据库名 <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci;<br></code></pre></td></tr></tbody></table></figure><p>如果我们创建错误了，我们可以将此数据库删除，通过使用<code>drop database</code>来删除一个数据库：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">database</span> 数据库名<br></code></pre></td></tr></tbody></table></figure><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p>数据库创建完成后，我们一般通过<code>create table</code>语句来创建一张表：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名(列名 数据类型[列级约束条件],<br>             列名 数据类型[列级约束条件],<br>             ...<br>             [,表级约束条件])<br></code></pre></td></tr></tbody></table></figure><h3 id="SQL数据类型"><a href="#SQL数据类型" class="headerlink" title="SQL数据类型"></a>SQL数据类型</h3><p>以下的数据类型用于字符串存储：</p><ul><li>char(n)可以存储任意字符串，但是是固定长度为n，如果插入的长度小于定义长度时，则用空格填充。</li><li>varchar(n)也可以存储任意数量字符串，长度不固定，但不能超过n，不会用空格填充。</li></ul><p>以下数据类型用于存储数字：</p><ul><li>smallint用于存储小的整数，范围在 (-32768，32767)</li><li>int用于存储一般的整数，范围在 (-2147483648，2147483647)</li><li>bigint用于存储大型整数，范围在 (-9,223,372,036,854,775,808，9,223,372,036,854,775,807)</li><li>float用于存储单精度小数</li><li>double用于存储双精度的小数</li></ul><p>以下数据类型用于存储时间：</p><ul><li>date存储日期</li><li>time存储时间</li><li>year存储年份</li><li>datetime用于混合存储日期+时间</li></ul><h3 id="列级约束条件"><a href="#列级约束条件" class="headerlink" title="列级约束条件"></a>列级约束条件</h3><p>列级约束有六种：主键Primary key、外键foreign key 、唯一 unique、检查 check （MySQL不支持）、默认default 、非空/空值 not null/ null</p><h3 id="表级约束条件"><a href="#表级约束条件" class="headerlink" title="表级约束条件"></a>表级约束条件</h3><p>表级约束有四种：主键、外键、唯一、检查</p><p>现在我们通过SQL语句来创建我们之前提到的三张表。</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">[CONSTRAINT &lt;外键名&gt;] FOREIGN KEY 字段名 [，字段名2，…] REFERENCES &lt;主表名&gt; 主键列1 [，主键列2，…]<br></code></pre></td></tr></tbody></table></figure><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><p>如果我们想修改表结构，我们可以通过<code>alter table</code>来进行修改：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名[<span class="hljs-keyword">ADD</span> 新列名 数据类型[列级约束条件]]<br> [<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> 列名[restrict|<span class="hljs-keyword">cascade</span>]]<br> [<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> 列名 新数据类型]<br></code></pre></td></tr></tbody></table></figure><p>我们可以通过ADD来添加一个新的列，通过DROP来删除一个列，不过我们可以添加restrict或cascade，默认是restrict，表示如果此列作为其他表的约束或视图引用到此列时，将无法删除，而cascade会强制连带引用此列的约束、视图一起删除。还可以通过ALTER来修改此列的属性。</p><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p>我们可以通过<code>drop table</code>来删除一个表：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> 表名[restrict|<span class="hljs-keyword">cascade</span>]<br></code></pre></td></tr></tbody></table></figure><p>其中restrict和cascade上面的效果一致。</p><hr><h2 id="数据库操纵语言（DML）"><a href="#数据库操纵语言（DML）" class="headerlink" title="数据库操纵语言（DML）"></a>数据库操纵语言（DML）</h2><p>前面我们已经学习了如何使用SQL语句来创建、修改、删除数据库以及表，而如何向数据库中插入、删除、更新数据，将是本版块讨论的重点。</p><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>通过使用<code>insert into</code>语句来向数据库中插入一条数据（一条记录）：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 <span class="hljs-keyword">VALUES</span>(值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, 值<span class="hljs-number">3</span>)<br></code></pre></td></tr></tbody></table></figure><p>如果插入的数据与列一一对应，那么可以省略列名，但是如果希望向指定列上插入数据，就需要给出列名：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名(列名<span class="hljs-number">1</span>, 列名<span class="hljs-number">2</span>) <span class="hljs-keyword">VALUES</span>(值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>)<br></code></pre></td></tr></tbody></table></figure><p>我们也可以一次性向数据库中插入多条数据：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名(列名<span class="hljs-number">1</span>, 列名<span class="hljs-number">2</span>) <span class="hljs-keyword">VALUES</span>(值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>), (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>), (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>)<br></code></pre></td></tr></tbody></table></figure><p>我们来试试看向我们刚刚创建的表中添加三条数据。</p><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>我们可以通过<code>update</code>语句来更新表中的数据：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> 表名 <span class="hljs-keyword">SET</span> 列名=值,... <span class="hljs-keyword">WHERE</span> 条件<br></code></pre></td></tr></tbody></table></figure><p>注意，SQL语句中的等于判断是<code>=</code></p><p><strong>警告：</strong>如果忘记添加<code>WHERE</code>字句来限定条件，将使得整个表中此列的所有数据都被修改！</p><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>我们可以通过使用<code>delete</code>来删除表中的数据：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表名<br></code></pre></td></tr></tbody></table></figure><p>通过这种方式，将删除表中全部数据，我们也可以使用<code>where</code>来添加条件，只删除指定的数据：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="数据库查询语言（DQL）"><a href="#数据库查询语言（DQL）" class="headerlink" title="数据库查询语言（DQL）"></a>数据库查询语言（DQL）</h2><p>数据库的查询是我们整个数据库学习中的重点内容，面对数据库中庞大的数据，该如何去寻找我们想要的数据，就是我们主要讨论的问题。</p><h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><p>单表查询是最简单的一种查询，我们只需要在一张表中去查找数据即可，通过使用<code>select</code>语句来进行单表查询：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 指定查询某一列数据</span><br><span class="hljs-keyword">SELECT</span> 列名[,列名] <span class="hljs-keyword">FROM</span> 表名<br><span class="hljs-comment">-- 会以别名显示此列</span><br><span class="hljs-keyword">SELECT</span> 列名 别名 <span class="hljs-keyword">FROM</span> 表名<br><span class="hljs-comment">-- 查询所有的列数据</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> 表名<br><span class="hljs-comment">-- 只查询不重复的值</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> 列名 <span class="hljs-keyword">FROM</span> 表名<br></code></pre></td></tr></tbody></table></figure><p>我们也可以添加<code>where</code>字句来限定查询目标：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件<br></code></pre></td></tr></tbody></table></figure><h3 id="常用查询条件"><a href="#常用查询条件" class="headerlink" title="常用查询条件"></a>常用查询条件</h3><ul><li>一般的比较运算符，包括=、&gt;、&lt;、&gt;=、&lt;=、!=等。</li><li>是否在集合中：in、not in</li><li>字符模糊匹配：like，not like</li><li>多重条件连接查询：and、or、not</li></ul><p>我们来尝试使用一下上面这几种条件。</p><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><p>我们可以通过<code>order by</code>来将查询结果进行排序：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 列名 <span class="hljs-keyword">ASC</span>|<span class="hljs-keyword">DESC</span><br></code></pre></td></tr></tbody></table></figure><p>使用ASC表示升序排序，使用DESC表示降序排序，默认为升序。</p><p>我们也可以可以同时添加多个排序：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 列名<span class="hljs-number">1</span> <span class="hljs-keyword">ASC</span>|<span class="hljs-keyword">DESC</span>, 列名<span class="hljs-number">2</span> <span class="hljs-keyword">ASC</span>|<span class="hljs-keyword">DESC</span><br></code></pre></td></tr></tbody></table></figure><p>这样会先按照列名1进行排序，每组列名1相同的数据再按照列名2排序。</p><h3 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h3><p>聚集函数一般用作统计，包括：</p><ul><li><code>count([distinct]*)</code>统计所有的行数（distinct表示去重再统计，下同）</li><li><code>count([distinct]列名)</code>统计某列的值总和</li><li><code>sum([distinct]列名)</code>求一列的和（注意必须是数字类型的）</li><li><code>avg([distinct]列名)</code>求一列的平均值（注意必须是数字类型）</li><li><code>max([distinct]列名)</code>求一列的最大值</li><li><code>min([distinct]列名)</code>求一列的最小值</li></ul><p>一般聚集函数是这样使用的：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">count</span>(<span class="hljs-keyword">distinct</span> 列名) <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <br></code></pre></td></tr></tbody></table></figure><h3 id="分组和分页查询"><a href="#分组和分页查询" class="headerlink" title="分组和分页查询"></a>分组和分页查询</h3><p>通过使用<code>group by</code>来对查询结果进行分组，它需要结合聚合函数一起使用：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">sum</span>(*) <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 列名<br></code></pre></td></tr></tbody></table></figure><p>我们还可以添加<code>having</code>来限制分组条件：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">sum</span>(*) <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 列名 <span class="hljs-keyword">HAVING</span> 约束条件<br></code></pre></td></tr></tbody></table></figure><p>我们可以通过<code>limit</code>来限制查询的数量，只取前n个结果：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">LIMIT</span> 数量<br></code></pre></td></tr></tbody></table></figure><p>我们也可以进行分页：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">LIMIT</span> 起始位置,数量<br></code></pre></td></tr></tbody></table></figure><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p>多表查询是同时查询的两个或两个以上的表，多表查询会提通过连接转换为单表查询。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span>, 表<span class="hljs-number">2</span><br></code></pre></td></tr></tbody></table></figure><p>直接这样查询会得到两张表的笛卡尔积，也就是每一项数据和另一张表的每一项数据都结合一次，会产生庞大的数据。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span>, 表<span class="hljs-number">2</span> <span class="hljs-keyword">WHERE</span> 条件<br></code></pre></td></tr></tbody></table></figure><p>这样，只会从笛卡尔积的结果中得到满足条件的数据。</p><p><strong>注意：</strong>如果两个表中都带有此属性吗，需要添加表名前缀来指明是哪一个表的数据。</p><h3 id="自身连接查询"><a href="#自身连接查询" class="headerlink" title="自身连接查询"></a>自身连接查询</h3><p>自身连接，就是将表本身和表进行笛卡尔积计算，得到结果，但是由于表名相同，因此要先起一个别名：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> 表名 别名<span class="hljs-number">1</span>, 表名 别名<span class="hljs-number">2</span><br></code></pre></td></tr></tbody></table></figure><p>其实自身连接查询和前面的是一样的，只是连接对象变成自己和自己了。</p><h3 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h3><p>外连接就是专门用于联合查询情景的，比如现在有一个存储所有用户的表，还有一张用户详细信息的表，我希望将这两张表结合到一起来查看完整的数据，我们就可以通过使用外连接来进行查询，外连接有三种方式：</p><ul><li>通过使用<code>inner join</code>进行内连接，只会返回两个表满足条件的交集部分：</li></ul><p><img src="https://img-blog.csdnimg.cn/2019053022120536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg1ODIwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>通过使用<code>left join</code>进行左连接，不仅会返回两个表满足条件的交集部分，也会返回左边表中的全部数据，而在右表中缺失的数据会使用<code>null</code>来代替（右连接<code>right join</code>同理，只是反过来而已，这里就不再介绍了）：</li></ul><p><img src="https://img-blog.csdnimg.cn/20190530221543230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg1ODIwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><p>我们可以将查询的结果作为另一个查询的条件，比如：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 列名 = (<span class="hljs-keyword">SELECT</span> 列名 <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件)<br></code></pre></td></tr></tbody></table></figure><p>我们来再次尝试编写一下在最开始我们查找某教师所有学生的SQL语句。</p><hr><h2 id="数据库控制语言（DCL）"><a href="#数据库控制语言（DCL）" class="headerlink" title="数据库控制语言（DCL）"></a>数据库控制语言（DCL）</h2><p>庞大的数据库不可能由一个人来管理，我们需要更多的用户来一起管理整个数据库。</p><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>我们可以通过<code>create user</code>来创建用户：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> 用户名 <span class="hljs-keyword">identified</span> <span class="hljs-keyword">by</span> 密码;<br></code></pre></td></tr></tbody></table></figure><p>也可以不带密码：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> 用户名;<br></code></pre></td></tr></tbody></table></figure><p>我们可以通过@来限制用户登录的登录IP地址，<code>%</code>表示匹配所有的IP地址，默认使用的就是任意IP地址。</p><h3 id="登陆用户"><a href="#登陆用户" class="headerlink" title="登陆用户"></a>登陆用户</h3><p>首先需要添加一个环境变量，然后我们通过cmd去登陆mysql：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">login -u 用户名 -p<br></code></pre></td></tr></tbody></table></figure><p>输入密码后即可登陆此用户，我们输入以下命令来看看能否访问所有数据库：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">databases</span>;<br></code></pre></td></tr></tbody></table></figure><p>我们发现，虽然此用户能够成功登录，但是并不能查看完整的数据库列表，这是因为此用户还没有权限！</p><h3 id="用户授权"><a href="#用户授权" class="headerlink" title="用户授权"></a>用户授权</h3><p>我们可以通过使用<code>grant</code>来为一个数据库用户进行授权：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span>|权限<span class="hljs-number">1</span>,权限<span class="hljs-number">2.</span>..(列<span class="hljs-number">1</span>,...) <span class="hljs-keyword">on</span> 数据库.表 <span class="hljs-keyword">to</span> 用户 [<span class="hljs-keyword">with</span> <span class="hljs-keyword">grant</span> <span class="hljs-keyword">option</span>]<br></code></pre></td></tr></tbody></table></figure><p>其中all代表授予所有权限，当数据库和表为<code>*</code>，代表为所有的数据库和表都授权。如果在最后添加了<code>with grant option</code>，那么被授权的用户还能将已获得的授权继续授权给其他用户。</p><p>我们可以使用<code>revoke</code>来收回一个权限：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">revoke</span> <span class="hljs-keyword">all</span>|权限<span class="hljs-number">1</span>,权限<span class="hljs-number">2.</span>..(列<span class="hljs-number">1</span>,...) <span class="hljs-keyword">on</span> 数据库.表 <span class="hljs-keyword">from</span> 用户<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图本质就是一个查询的结果，不过我们每次都可以通过打开视图来按照我们想要的样子查看数据。既然视图本质就是一个查询的结果，那么它本身就是一个虚表，并不是真实存在的，数据实际上还是存放在原来的表中。</p><p>我们可以通过<code>create view</code>来创建视图;</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> 视图名称(列名) <span class="hljs-keyword">as</span> 子查询语句 [<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">CHECK</span> <span class="hljs-keyword">OPTION</span>];<br></code></pre></td></tr></tbody></table></figure><p>WITH CHECK OPTION是指当创建后，如果更新视图中的数据，是否要满足子查询中的条件表达式，不满足将无法插入，创建后，我们就可以使用<code>select</code>语句来直接查询视图上的数据了，因此，还能在视图的基础上，导出其他的视图。</p><ol><li>若视图是由两个以上基本表导出的，则此视图不允许更新。</li><li>若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT和UPDATE操作，但允许执行DELETE操作。</li><li>若视图的字段来自集函数，则此视图不允许更新。</li><li>若视图定义中含有GROUP BY子句，则此视图不允许更新。</li><li>若视图定义中含有DISTINCT短语，则此视图不允许更新。</li><li>若视图定义中有嵌套查询，并且内层查询的FROM子句中涉及的表也是导出该视图的基本表，则此视图不允许更新。例如将成绩在平均成绩之上的元组定义成一个视图GOOD_SC： CREATE VIEW GOOD_SC AS SELECT Sno, Cno, Grade FROM SC WHERE Grade &gt; (SELECT AVG(Grade) FROM SC); 　　导出视图GOOD_SC的基本表是SC，内层查询中涉及的表也是SC，所以视图GOOD_SC是不允许更新的。</li><li>一个不允许更新的视图上定义的视图也不允许更新</li></ol><p>通过<code>drop</code>来删除一个视图：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">view</span> apptest<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>在数据量变得非常庞大时，通过创建索引，能够大大提高我们的查询效率，就像Hash表一样，它能够快速地定位元素存放的位置，我们可以通过下面的命令创建索引：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建索引</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> 索引名称 <span class="hljs-keyword">ON</span> 表名 (列名)<br><span class="hljs-comment">-- 查看表中的索引</span><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">FROM</span> student<br></code></pre></td></tr></tbody></table></figure><p>我们也可以通过下面的命令删除一个索引：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> 索引名称 <span class="hljs-keyword">on</span> 表名<br></code></pre></td></tr></tbody></table></figure><p>虽然添加索引后会使得查询效率更高，但是我们不能过度使用索引，索引为我们带来高速查询效率的同时，也会在数据更新时产生额外建立索引的开销，同时也会占用磁盘资源。</p><hr><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器就像其名字一样，在某种条件下会自动触发，在<code>select</code>/<code>update</code>/<code>delete</code>时，会自动执行我们预先设定的内容，触发器通常用于检查内容的安全性，相比直接添加约束，触发器显得更加灵活。</p><p>触发器所依附的表称为基本表，当触发器表上发生<code>select</code>/<code>update</code>/<code>delete</code>等操作时，会自动生成两个临时的表（new表和old表，只能由触发器使用）</p><p>比如在<code>insert</code>操作时，新的内容会被插入到new表中；在<code>delete</code>操作时，旧的内容会被移到old表中，我们仍可在old表中拿到被删除的数据；在<code>update</code>操作时，旧的内容会被移到old表中，新的内容会出现在new表中。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> 触发器名称 [<span class="hljs-keyword">BEFORE</span>|<span class="hljs-keyword">AFTER</span>] [<span class="hljs-keyword">INSERT</span>|<span class="hljs-keyword">UPDATE</span>|<span class="hljs-keyword">DELETE</span>] <span class="hljs-keyword">ON</span> 表名/视图名 <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-keyword">ROW</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> student.sno = new.sno<br></code></pre></td></tr></tbody></table></figure><p> FOR EACH ROW表示针对每一行都会生效，无论哪行进行指定操作都会执行触发器！</p><p>通过下面的命令来查看触发器：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">TRIGGERS</span><br></code></pre></td></tr></tbody></table></figure><p>如果不需要，我们就可以删除此触发器：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TRIGGER</span> 触发器名称<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>当我们要进行的操作非常多时，比如要依次删除很多个表的数据，我们就需要执行大量的SQL语句来完成，这些数据库操作语句就可以构成一个事务！只有Innodb引擎支持事务，我们可以这样来查看支持的引擎：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">ENGINES</span>;<br></code></pre></td></tr></tbody></table></figure><p>MySQL默认采用的是Innodb引擎，我们也可以去修改为其他的引擎。</p><p>事务具有以下特性：</p><ul><li><strong>原子性：</strong>一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li><li><strong>一致性：</strong>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li><li><strong>隔离性：</strong>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li><li><strong>持久性：</strong>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><p>我们通过以下例子来探究以下事务：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;   <span class="hljs-comment">#开始事务</span><br>...<br><span class="hljs-keyword">rollback</span>;  <span class="hljs-comment">#回滚事务</span><br><span class="hljs-keyword">savepoint</span> 回滚点;  <span class="hljs-comment">#添加回滚点</span><br><span class="hljs-keyword">rollback</span> <span class="hljs-keyword">to</span> 回滚点; <span class="hljs-comment">#回滚到指定回滚点</span><br>...<br><span class="hljs-keyword">commit</span>; <span class="hljs-comment">#提交事务</span><br><span class="hljs-comment">-- 一旦提交，就无法再进行回滚了！</span><br></code></pre></td></tr></tbody></table></figure><hr><h2 id="选学内容"><a href="#选学内容" class="headerlink" title="选学内容"></a>选学内容</h2><p><strong>函数</strong>和<strong>存储过程</strong>并没有包含在我们的教程当中，但是这并不代表它们就不重要，通过学习它们能够让你的数据库管理能力更上一层楼，它们能够捆绑一组SQL语句运行，并且可以反复使用，大大提高工作效率。</p>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;数据库基础&quot;&gt;&lt;a href=&quot;#数据库基础&quot; class=&quot;headerlink&quot; title=&quot;数据库基础&quot;&gt;&lt;/a&gt;数据库基础&lt;/h1&gt;&lt;p&gt;数据库是学习JavaWeb的一个前置，只有了解了数据库的操作和使用，我们才能更好地组织和管理网站应用产生的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2.baidu.com/it/u=873816781,3605513900&amp;amp;fm=26&amp;amp;fmt=auto&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是数据库&quot;&gt;&lt;a href=&quot;#什么是数据库&quot; class=&quot;headerlink&quot; title=&quot;什么是数据库&quot;&gt;&lt;/a&gt;什么是数据库&lt;/h2&gt;&lt;p&gt;数据库是数据管理的有效技术，是由一批数据构成的有序集合，这些数据被存放在结构化的数据表里。数据表之间相互关联，反映客观事物间的本质联系。数据库能有效地帮助一个组织或企业科学地管理各类信息资源。简而言之，我们的数据可以交给数据库来帮助我们进行管理，同时数据库能够为我们提供高效的访问性能。&lt;/p&gt;
&lt;p&gt;在JavaSE学习阶段中，我们学习了如何使用文件I/O来将数据保存到本地，这样就可以将一个数据持久地存储在本地，即使程序重新打开，我们也能加载回上一次的数据，但是当我们的数据变得非常多的时候，这样的方式就显得不太方便了。同时我们如果需要查找众多数据的中的某一个，就只能加载到内存再进行查找，这样显然是很难受的！&lt;/p&gt;
&lt;p&gt;而数据库就是专门做这事的，我们可以快速查找想要的数据，便捷地插入、修改和删除数据，并且数据库不仅能做这些事，还能提供更多便于管理数据和操作数据的功能！&lt;/p&gt;
&lt;h3 id=&quot;常见的数据库&quot;&gt;&lt;a href=&quot;#常见的数据库&quot; class=&quot;headerlink&quot; title=&quot;常见的数据库&quot;&gt;&lt;/a&gt;常见的数据库&lt;/h3&gt;&lt;p&gt;常见的数据库有很多种，包括但不限于：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Oracle</title>
    <link href="https://xiaofanshutu.github.io/posts/f145fed6.html"/>
    <id>https://xiaofanshutu.github.io/posts/f145fed6.html</id>
    <published>2025-07-07T09:36:01.015Z</published>
    <updated>2025-07-27T03:34:30.703Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Oracle简介"><a href="#Oracle简介" class="headerlink" title="Oracle简介"></a>Oracle简介</h1><h2 id="Oracle特点"><a href="#Oracle特点" class="headerlink" title="Oracle特点"></a>Oracle特点</h2><p>Oracle数据库具有以下特点：</p><ol><li>支持多用户，大事务量的事务处理</li><li>数据安全性和完整性控制</li><li>支持分布式数据处理</li><li>可移植性</li></ol><h2 id="Oracle体系结构"><a href="#Oracle体系结构" class="headerlink" title="Oracle体系结构"></a>Oracle体系结构</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>Oracle数据库是数据的物理存储。Oracle的数据库是指一个操作系统只有一个库，可以看做Oracle只有一个大数据库。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>一个Oracle实例（Oracle Instance）有一系列的后台进程（Background Processes）和内存结构（Memory Structures）组成。一个数据库可以有多个(n个)实例。</p><h3 id="数据文件-dbf"><a href="#数据文件-dbf" class="headerlink" title="数据文件(dbf)"></a>数据文件(dbf)</h3><ul><li>数据文件是数据库的物理存储单位。数据库的数据是存储在表空间中的。</li><li>一个表空间可以由一个或多个数据文件组成，一个数据文件只能属于一个表空间。</li><li>一旦数据文件被加入到某个表空间，就不能删除这个文件，如果要删除该数据文件，必须删除其所属的表空间才可以。</li></ul><h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><ul><li>表空间是Oracle对物理数据库上相关数据文件（ORA或者DBF文件）的逻辑映射。</li><li>一个数据库在逻辑上被划分成一到若干个表空间，每个表空间包含了在逻辑上相关联的一组结构。</li><li>每个数据库至少有一个表空间称之为 system 表空间 。</li><li>每个表空间由同一磁盘上的一个或多个文件组成，这些文件叫数据文件(datafile) 。一个数据文件只能属于一个表空间。</li></ul><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250707175858947.png" alt="image-20250707175858947"></p><p>注：</p><p>(1)表的数据，是有用户放入某一个表空间的，而这个表空间会随机把这些表数据放到一个或者多个数据文件中。</p><p>(2)逻辑结构最小单位是数据块，不是磁盘块。</p><p>由于 oracle 的数据库不是普通的概念， oracle 是由用户和表空间对数据进行管理和存放的。但是表不是由表空间去查询的，而是由用户去查的。因为不同用户可以在同一个表空间建立同一个名字的表！这里区分就是用户了！</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250707175956189.png" alt="image-20250707175956189"></p><p>图片理解：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250707180136371.png" alt="image-20250707180136371">这个符号是指一个数据文件由多个磁盘块组成</p><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p>表空间—&gt;用户—&gt;表</p><p>用户是在表空间下建立的。用户登陆后只能看到和操作自己的表 , Oracle的用户与MySQL的数据库类似，每建立一个应用需要创建一个用户。</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250707180041756.png" alt="image-20250707180041756"></p><p><strong>超级管理员账户</strong></p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250707192340153.png" alt="image-20250707192340153"></p><h1 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h1><h2 id="创建表空间"><a href="#创建表空间" class="headerlink" title="创建表空间"></a>创建表空间</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">tablespace</span> waterboss<br><span class="hljs-keyword">datafile</span> <span class="hljs-string">'D:\2_dan\learningVideo\oracle\waterboss.dbf'</span><br><span class="hljs-keyword">size</span> <span class="hljs-number">100</span>m<br><span class="hljs-keyword">autoextend</span> <span class="hljs-keyword">ON</span><br><span class="hljs-keyword">next</span> <span class="hljs-number">10</span>m;<br></code></pre></td></tr></tbody></table></figure><p>名字可以一样，也可以不一样</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250707181133991.png" alt="image-20250707181133991"></p><h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> wateruser<br><span class="hljs-keyword">IDENTIFIED</span> <span class="hljs-keyword">BY</span> <span class="hljs-number">123456</span><br><span class="hljs-keyword">default</span> <span class="hljs-keyword">tablespace</span> waterboss;<br></code></pre></td></tr></tbody></table></figure><p>wateruser：用户名</p><p>123456：密码</p><p>waterboss：默认表空间名称</p><h2 id="用户赋权"><a href="#用户赋权" class="headerlink" title="用户赋权"></a>用户赋权</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> dba <span class="hljs-keyword">to</span> wateruser;<span class="hljs-comment">--给用户赋dba权限</span><br></code></pre></td></tr></tbody></table></figure><h1 id="表的创建、修改与删除"><a href="#表的创建、修改与删除" class="headerlink" title="表的创建、修改与删除"></a>表的创建、修改与删除</h1><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p><strong>语法：</strong></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名称(<br>字段名 类型 长度 primary <span class="hljs-keyword">key</span><br>字段名 类型 长度<br>......<br>);<br></code></pre></td></tr></tbody></table></figure><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_owners<br>(<br><span class="hljs-keyword">id</span> <span class="hljs-built_in">number</span> primary <span class="hljs-keyword">key</span>,<br><span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar2</span>(<span class="hljs-number">30</span>),<br>addressid <span class="hljs-built_in">number</span>,<br>housenumber <span class="hljs-built_in">varchar2</span>(<span class="hljs-number">30</span>),<br>watermeter <span class="hljs-built_in">varchar2</span>(<span class="hljs-number">30</span>),<br>adddate <span class="hljs-built_in">date</span>,<br>ownertypeid <span class="hljs-built_in">number</span><br>);<br></code></pre></td></tr></tbody></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><strong>字符型</strong></p><ol><li>CHAR : 固定长度的字符类型，最多存储 2000 个字节</li><li>VARCHAR2 : 可变长度的字符类型，最多存储 4000 个字节</li><li>LONG : 大文本类型。 最大可以存储 2G</li></ol><p><strong>数值型</strong></p><p>NUMBER : 数值类型</p><p>例如：<br>NUMBER (5)   最大可以存的数为 99999<br>NUMBER(5,2) 最大可以存的数为 999.99</p><p><strong>日期型</strong></p><ol><li>DATE ：日期时间型，精确到秒</li><li>TIMESTAMP ：精确到秒的小数点后 9 位</li></ol><p><strong>二进制型</strong></p><ol><li>CLOB : 存储字符 最大可以存 4G</li><li>BLOB ：存储图像、声音、 视频等二进制数据 最多可以存 4G</li></ol><h2 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h2><p><strong>增加字段语法</strong></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名称 <span class="hljs-keyword">ADD</span><br>(<br>    列名<span class="hljs-number">1</span> 类型 [<span class="hljs-keyword">DEFAULT</span> 默认值]，<br>    列名<span class="hljs-number">2</span> 类型 [<span class="hljs-keyword">DEFAULT</span> 默认值]<br>);<br></code></pre></td></tr></tbody></table></figure><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> T_OWNERS <span class="hljs-keyword">ADD</span> ( REMARK <span class="hljs-built_in">VARCHAR2</span> ( <span class="hljs-number">20</span> ), OUTDATE <span class="hljs-built_in">DATE</span> ) ;<br></code></pre></td></tr></tbody></table></figure><p><strong>修改字段语法</strong></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名称 <span class="hljs-keyword">MODIFY</span><br>(<br>列名<span class="hljs-number">1</span> 类型 [<span class="hljs-keyword">DEFAULT</span> 默认值]，<br>列名<span class="hljs-number">2</span> 类型 [<span class="hljs-keyword">DEFAULT</span> 默认值]<br>)<br></code></pre></td></tr></tbody></table></figure><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> T_OWNERS <span class="hljs-keyword">MODIFY</span><br>(<br>    <span class="hljs-keyword">NAME</span> <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'hello'</span><br>)<br></code></pre></td></tr></tbody></table></figure><p><strong>修改字段名语法</strong></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名称 RNAME <span class="hljs-keyword">COLUMN</span> 原列名 <span class="hljs-keyword">TO</span> 新列名<br></code></pre></td></tr></tbody></table></figure><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> T_OWNERS <span class="hljs-keyword">RENAME</span> <span class="hljs-keyword">COLUMN</span> OUTDATE <span class="hljs-keyword">TO</span> EXITDATE<br></code></pre></td></tr></tbody></table></figure><p><strong>删除字段名</strong></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--删除一个字段</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名称 <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> 列名<br><br><span class="hljs-comment">--删除多个字段</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名称 <span class="hljs-keyword">DROP</span>( 列名<span class="hljs-number">1</span>, 列名<span class="hljs-number">2.</span>..)<br></code></pre></td></tr></tbody></table></figure><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--删除字段</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> T_OWNERS <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> REMARK<br></code></pre></td></tr></tbody></table></figure><h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> 表名称<br></code></pre></td></tr></tbody></table></figure><h1 id="数据增删改"><a href="#数据增删改" class="headerlink" title="数据增删改"></a>数据增删改</h1><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>语法：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名( 列名<span class="hljs-number">1</span>，列名<span class="hljs-number">2</span>，...) <span class="hljs-keyword">VALUES</span> ( 值<span class="hljs-number">1</span>，值<span class="hljs-number">2.</span>..)<br></code></pre></td></tr></tbody></table></figure><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> T_OWNERS_COPY <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">11</span>, <span class="hljs-string">'张三丰'</span>, <span class="hljs-number">1</span>, <span class="hljs-string">'123'</span>, <span class="hljs-string">'321'</span>, <span class="hljs-keyword">sysdate</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708070503640.png" alt="image-20250708070503640"></p><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><p><strong>方式1</strong></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> 表名 <span class="hljs-keyword">set</span> 列名<span class="hljs-number">1</span>=值<span class="hljs-number">1</span>, 列名<span class="hljs-number">2</span>=值<span class="hljs-number">2</span>,... <span class="hljs-keyword">where</span> 修改条件;<br></code></pre></td></tr></tbody></table></figure><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> T_OWNERS_COPY <span class="hljs-keyword">set</span> <span class="hljs-keyword">NAME</span> = <span class="hljs-string">'小红'</span>, ADDRESSID = <span class="hljs-string">'888'</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">1</span>;<br></code></pre></td></tr></tbody></table></figure><p><strong>方式2</strong></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">truncate</span> <span class="hljs-keyword">table</span> 表名<br></code></pre></td></tr></tbody></table></figure><p>两种方式的区别：</p><ol><li>truncate删除的数据不可以rollback，delete删除的数据可以rollback</li></ol><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>语法：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> fromm 表名 <span class="hljs-keyword">where</span> 删除条件;<br></code></pre></td></tr></tbody></table></figure><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> T_OWNERS_COPY <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">11</span>;<br></code></pre></td></tr></tbody></table></figure><h1 id="JDBC连接Oracle"><a href="#JDBC连接Oracle" class="headerlink" title="JDBC连接Oracle"></a>JDBC连接Oracle</h1><h2 id="导入驱动包ojdbc8-jar"><a href="#导入驱动包ojdbc8-jar" class="headerlink" title="导入驱动包ojdbc8.jar"></a>导入驱动包ojdbc8.jar</h2><p>oracle 19c安装之后的ojdbc.jar包在下面这个地方可以找到，D:\6_application\oracle\jdbc\lib</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250707185831853.png" alt="image-20250707185831853"></p><p>将上面的jar添加到工程的library，否则会报下面这个错误。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">java.lang.ClassNotFoundException: oracle.jdbc.driver.OracleDriver<br>at java.net.URLClassLoader.findClass(URLClassLoader.java:<span class="hljs-number">382</span>)<br>at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="hljs-number">424</span>)<br>at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:<span class="hljs-number">349</span>)<br>at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="hljs-number">357</span>)<br>at java.lang.Class.forName0(Native Method)<br>at java.lang.Class.forName(Class.java:<span class="hljs-number">264</span>)<br>at dao.BaseDao.&lt;clinit&gt;(BaseDao.java:<span class="hljs-number">11</span>)<br>at dao.OwnerDao.add(OwnerDao.java:<span class="hljs-number">15</span>)<br>at test.Test01.main(Test01.java:<span class="hljs-number">17</span>)<br>Exception in thread <span class="hljs-string">"main"</span> java.lang.RuntimeException: java.sql.SQLException: No suitable driver found <span class="hljs-keyword">for</span> jdbc:oracle:thin:<span class="hljs-meta">@localhost</span>:<span class="hljs-number">1521</span>:orcl<br>at dao.OwnerDao.add(OwnerDao.java:<span class="hljs-number">26</span>)<br>at test.Test01.main(Test01.java:<span class="hljs-number">17</span>)<br>Caused by: java.sql.SQLException: No suitable driver found <span class="hljs-keyword">for</span> jdbc:oracle:thin:<span class="hljs-meta">@localhost</span>:<span class="hljs-number">1521</span>:orcl<br>at java.sql.DriverManager.getConnection(DriverManager.java:<span class="hljs-number">689</span>)<br>at java.sql.DriverManager.getConnection(DriverManager.java:<span class="hljs-number">247</span>)<br>at dao.BaseDao.getConnection(BaseDao.java:<span class="hljs-number">23</span>)<br>at dao.OwnerDao.add(OwnerDao.java:<span class="hljs-number">15</span>)<br>... <span class="hljs-number">1</span> more<br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250707174713196.png" alt="image-20250707174713196"></p><h2 id="BaseDao"><a href="#BaseDao" class="headerlink" title="BaseDao"></a>BaseDao</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> dao;<br><br><span class="hljs-keyword">import</span> java.sql.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基础数据访问类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseDao</span> </span>{<br>    <span class="hljs-keyword">static</span> {<br>        <span class="hljs-keyword">try</span> {<br>            Class.forName(<span class="hljs-string">"oracle.jdbc.driver.OracleDriver"</span>); <span class="hljs-comment">// 加载Oracle JDBC驱动</span><br>        } <span class="hljs-keyword">catch</span> (Exception e) {<br>            e.printStackTrace();<br>        }<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取数据库连接</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 数据库连接对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>{<br>        <span class="hljs-comment">//痩连接: jdbc:oracle:thin</span><br>        <span class="hljs-keyword">return</span> DriverManager.getConnection(<span class="hljs-string">"jdbc:oracle:thin:@localhost:1521:orcl"</span>, <span class="hljs-string">"wateruser"</span>, <span class="hljs-string">"123456"</span>);<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 关闭数据库连接</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> conn 数据库连接对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(ResultSet rs, Statement stmt, Connection conn)</span> </span>{<br>        <span class="hljs-keyword">if</span> (rs != <span class="hljs-keyword">null</span>) {<br>            <span class="hljs-keyword">try</span> {<br>                rs.close();<br>            } <span class="hljs-keyword">catch</span> (SQLException e) {<br>                e.printStackTrace();<br>            }<br>        }<br><br>        <span class="hljs-keyword">if</span> (stmt != <span class="hljs-keyword">null</span>) {<br>            <span class="hljs-keyword">try</span> {<br>                stmt.close();<br>            } <span class="hljs-keyword">catch</span> (SQLException e) {<br>                e.printStackTrace();<br>            }<br>        }<br><br>        <span class="hljs-keyword">if</span> (conn != <span class="hljs-keyword">null</span>) {<br>            <span class="hljs-keyword">try</span> {<br>                conn.close();<br>            } <span class="hljs-keyword">catch</span> (SQLException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="OwnerDao"><a href="#OwnerDao" class="headerlink" title="OwnerDao"></a>OwnerDao</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> dao;<br><br><span class="hljs-keyword">import</span> entity.Owners;<br><br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.PreparedStatement;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OwnerDao</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Owners owner)</span> </span>{<br>        Connection conn = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">//预处理，防止注入攻击</span><br>        PreparedStatement stmt = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">try</span> {<br>            conn = BaseDao.getConnection();<br>            stmt = conn.prepareStatement(<span class="hljs-string">"INSERT INTO T_OWNERS_COPY (id, name, addressid, housenumber, watermeter, adddate, ownertypeid) VALUES (?, ?, ?, ?, ?, ?, ?)"</span>);<br>            stmt.setLong(<span class="hljs-number">1</span>, owner.getId());<br>            stmt.setString(<span class="hljs-number">2</span>, owner.getName());<br>            stmt.setLong(<span class="hljs-number">3</span>, owner.getAddressid());<br>            stmt.setString(<span class="hljs-number">4</span>, owner.getHousenumber());<br>            stmt.setString(<span class="hljs-number">5</span>, owner.getWatermeter());<br>            <span class="hljs-comment">//日期转为长整型Long, 然后再构造为java.sql.Date类型</span><br>            stmt.setDate(<span class="hljs-number">6</span>, <span class="hljs-keyword">new</span> java.sql.Date(owner.getAdddate().getTime()));<br>            stmt.setLong(<span class="hljs-number">7</span>, owner.getOwnertypeid());<br>            stmt.executeUpdate();<br>        } <span class="hljs-keyword">catch</span> (SQLException e) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        } <span class="hljs-keyword">finally</span> {<br>            BaseDao.close(<span class="hljs-keyword">null</span>, stmt, conn);<br>        }<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(Owners owner)</span> </span>{<br>        Connection conn = <span class="hljs-keyword">null</span>;<br>        PreparedStatement stmt = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">try</span> {<br>            conn = BaseDao.getConnection();<br>            stmt = conn.prepareStatement(<span class="hljs-string">"update T_OWNERS_COPY set name =?, addressid=?, housenumber=?, watermeter=?, adddate=?, ownertypeid=? where id=?"</span>);<br>            stmt.setString(<span class="hljs-number">1</span>, owner.getName());<br>            stmt.setLong(<span class="hljs-number">2</span>, owner.getAddressid());<br>            stmt.setString(<span class="hljs-number">3</span>, owner.getHousenumber());<br>            stmt.setString(<span class="hljs-number">4</span>, owner.getWatermeter());<br>            stmt.setDate(<span class="hljs-number">5</span>, <span class="hljs-keyword">new</span> java.sql.Date(owner.getAdddate().getTime()));<br>            stmt.setLong(<span class="hljs-number">6</span>, owner.getOwnertypeid());<br>            stmt.setLong(<span class="hljs-number">7</span>, owner.getId());<br>            stmt.executeUpdate();<br>        } <span class="hljs-keyword">catch</span> (SQLException e) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        } <span class="hljs-keyword">finally</span> {<br>            BaseDao.close(<span class="hljs-keyword">null</span>, stmt, conn);<br>        }<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(Owners owner)</span> </span>{<br>        Connection conn = <span class="hljs-keyword">null</span>;<br>        PreparedStatement stmt = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">try</span> {<br>            conn = BaseDao.getConnection();<br>            stmt = conn.prepareStatement(<span class="hljs-string">"delete from T_OWNERS_COPY where id=?"</span>);<br>            stmt.setLong(<span class="hljs-number">1</span>, owner.getId());<br>            stmt.executeUpdate();<br>        } <span class="hljs-keyword">catch</span> (SQLException e) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        } <span class="hljs-keyword">finally</span> {<br>            BaseDao.close(<span class="hljs-keyword">null</span>, stmt, conn);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="实体类Owners"><a href="#实体类Owners" class="headerlink" title="实体类Owners"></a>实体类Owners</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Owners</span> </span>{<br>    <span class="hljs-keyword">private</span> Long id;<span class="hljs-comment">//业主编号</span><br>    <span class="hljs-keyword">private</span> String name;<span class="hljs-comment">// 业主名称</span><br>    <span class="hljs-keyword">private</span> Long addressid;<span class="hljs-comment">// 地址编号</span><br>    <span class="hljs-keyword">private</span> String housenumber;<span class="hljs-comment">// 门牌号</span><br>    <span class="hljs-keyword">private</span> String watermeter;<span class="hljs-comment">// 水表编号</span><br>    <span class="hljs-keyword">private</span> Date adddate;<span class="hljs-comment">// 登记日期</span><br>    <span class="hljs-keyword">private</span> Long ownertypeid;<span class="hljs-comment">// 业主类型 ID</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> id;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Long id)</span> </span>{<br>        <span class="hljs-keyword">this</span>.id = id;<br>    }<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    其他getter，setter方法，省略</span><br><span class="hljs-comment">    */</span><br>}    <br></code></pre></td></tr></tbody></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test02</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        Owners owner = <span class="hljs-keyword">new</span> Owners();<br>        owner.setId(<span class="hljs-number">1L</span>);<br>        owner.setName(<span class="hljs-string">"张三"</span>);<br>        owner.setAddressid(<span class="hljs-number">111L</span>);<br>        owner.setHousenumber(<span class="hljs-string">"111号"</span>);<br>        owner.setWatermeter(<span class="hljs-string">"6666"</span>);<br>        owner.setAdddate(<span class="hljs-keyword">new</span> java.util.Date());<br>        owner.setOwnertypeid(<span class="hljs-number">888L</span>);<br><br>        OwnerDao.modify(owner);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>执行modify方法之前</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250707185508957.png" alt="image-20250707185508957"></p><p>执行modify方法之后</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250707185543105.png" alt="image-20250707185543105"></p><h1 id="数据导入与导出"><a href="#数据导入与导出" class="headerlink" title="数据导入与导出"></a>数据导入与导出</h1><h2 id="数据库导入与导出"><a href="#数据库导入与导出" class="headerlink" title="数据库导入与导出"></a>数据库导入与导出</h2><h3 id="整库导出"><a href="#整库导出" class="headerlink" title="整库导出"></a>整库导出</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">exp system/超级管理员用户system的密码 full=y <span class="hljs-comment">--full=y表示整库导出</span><br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250707191456554.png" alt="image-20250707191456554"></p><p>执行命令后会在当前目录下生成一个叫EXPDAT.DMP，此文件为备份文件。</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250707191409362.png" alt="image-20250707191409362"></p><p>添加file参数即可指定备份文件的名称</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">exp system/超级管理员用户system的密码 file=文件名 full=y<br></code></pre></td></tr></tbody></table></figure><h3 id="整库导入"><a href="#整库导入" class="headerlink" title="整库导入"></a>整库导入</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">imp system/超级管理员用户system的密码 full=y<br></code></pre></td></tr></tbody></table></figure><p>如果指定file 参数，则按照file指定的备份文件进行导入</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">imp system/超级管理员用户system的密码 full=y file=water.dmp<br></code></pre></td></tr></tbody></table></figure><h2 id="按用户导入与导出"><a href="#按用户导入与导出" class="headerlink" title="按用户导入与导出"></a>按用户导入与导出</h2><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">exp system/itcast owner=wateruser file=wateruser.dmp<br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250707191636590.png" alt="image-20250707191636590"></p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250707191650272.png" alt="image-20250707191650272"></p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250707191722469.png" alt="image-20250707191722469"></p><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">imp system/itcast file=wateruser.dmp fromuser=wateruser<br></code></pre></td></tr></tbody></table></figure><p>导入前特意删掉T_OWNERS_COPY表</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250707191857634.png" alt="image-20250707191857634"></p><p>导入后刷新，表成功导入</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250707191954325.png" alt="image-20250707191954325"></p><h2 id="按表导入与导出"><a href="#按表导入与导出" class="headerlink" title="按表导入与导出"></a>按表导入与导出</h2><h3 id="导出-1"><a href="#导出-1" class="headerlink" title="导出"></a>导出</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">exp wateruser/123456 file=a.dmp tables=t_account,a_area<br></code></pre></td></tr></tbody></table></figure><h3 id="导入-1"><a href="#导入-1" class="headerlink" title="导入"></a>导入</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">imp wateruser/123456 file=a.dmp tables=t_account,a_area<br></code></pre></td></tr></tbody></table></figure><h1 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h1><h2 id="简单条件查询"><a href="#简单条件查询" class="headerlink" title="简单条件查询"></a>简单条件查询</h2><h3 id="精确查询"><a href="#精确查询" class="headerlink" title="精确查询"></a>精确查询</h3><p>需求：查询水表编号为30408 的业主记录</p><p>查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>* <br><span class="hljs-keyword">FROM</span><br>T_OWNERS <br><span class="hljs-keyword">WHERE</span><br>watermeter = <span class="hljs-string">'30408'</span><br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708075359712.png" alt="image-20250708075359712"></p><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><p>需求：查询业主名称包含“刘”的业主记录</p><p>查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>* <br><span class="hljs-keyword">FROM</span><br>t_owners <br><span class="hljs-keyword">WHERE</span><br><span class="hljs-keyword">name</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'%刘%'</span><br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708075426288.png" alt="image-20250708075426288"></p><h3 id="and运算符"><a href="#and运算符" class="headerlink" title="and运算符"></a>and运算符</h3><p>需求：查询业主名称包含“刘”的并且门牌号包含5 的业主记录</p><p>查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>* <br><span class="hljs-keyword">FROM</span><br>t_owners <br><span class="hljs-keyword">WHERE</span><br><span class="hljs-keyword">name</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'%刘%'</span> <br><span class="hljs-keyword">AND</span> housenumber <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'%5%'</span><br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708075450264.png" alt="image-20250708075450264"></p><h3 id="or运算符"><a href="#or运算符" class="headerlink" title="or运算符"></a>or运算符</h3><p>需求：查询业主名称包含“刘”的或者门牌号包含5 的业主记录</p><p>查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>* <br><span class="hljs-keyword">FROM</span><br>t_owners <br><span class="hljs-keyword">WHERE</span><br><span class="hljs-keyword">name</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'%刘%'</span> <br><span class="hljs-keyword">OR</span> housenumber <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'%5%'</span><br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708075509435.png" alt="image-20250708075509435"></p><h3 id="and和or运算符混合使用"><a href="#and和or运算符混合使用" class="headerlink" title="and和or运算符混合使用"></a>and和or运算符混合使用</h3><p>需求：查询业主名称包含“刘”的或者门牌号包含5 的业主记录，并且地址编号<br>为3 的记录。</p><p>查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--and 的优先级比or大，需要用()来改变优先级。</span><br><span class="hljs-keyword">SELECT</span><br>* <br><span class="hljs-keyword">FROM</span><br>t_owners <br><span class="hljs-keyword">WHERE</span><br>( <span class="hljs-keyword">name</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'%刘%'</span> <span class="hljs-keyword">OR</span> housenumber <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'%5%'</span> ) <br><span class="hljs-keyword">AND</span> addressid =<span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708075539804.png" alt="image-20250708075539804"></p><h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><p>需求：查询台账记录中用水量大于等于10000，并且小于等于20000 的记录</p><ol><li><strong>用&gt;= 和&lt;=来实现</strong></li></ol><p>查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>* <br><span class="hljs-keyword">FROM</span><br>T_ACCOUNT <br><span class="hljs-keyword">WHERE</span><br>usenum &gt;= <span class="hljs-number">10000</span> <br><span class="hljs-keyword">AND</span> usenum &lt;= <span class="hljs-number">20000</span><br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708075618647.png" alt="image-20250708075618647"></p><ol start="2"><li><strong>用between .. and ..来实现</strong></li></ol><p>查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>* <br><span class="hljs-keyword">FROM</span><br>T_ACCOUNT <br><span class="hljs-keyword">WHERE</span><br>usenum <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">10000</span> <br><span class="hljs-keyword">AND</span> <span class="hljs-number">20000</span><br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708075642222.png" alt="image-20250708075642222"></p><h3 id="空值查询"><a href="#空值查询" class="headerlink" title="空值查询"></a>空值查询</h3><p>需求1：查询T_PRICETABLE 表中MAXNUM 为空的记录</p><p>查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>* <br><span class="hljs-keyword">FROM</span><br>T_PRICETABLE t <br><span class="hljs-keyword">WHERE</span><br>maxnum <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span><br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708075704292.png" alt="image-20250708075704292"></p><p>需求2：查询T_PRICETABLE 表中MAXNUM 不为空的记录</p><p>查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>* <br><span class="hljs-keyword">FROM</span><br>T_PRICETABLE t <br><span class="hljs-keyword">WHERE</span><br>maxnum <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span><br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708075718119.png" alt="image-20250708075718119"></p><h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><p>需求：查询业主表中的地址ID,不重复显示</p><p>查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span><br>addressid <br><span class="hljs-keyword">FROM</span><br>T_OWNERS<br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708075741271.png" alt="image-20250708075741271"></p><h2 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h2><p>需求1：对T_ACCOUNT 表按使用量进行升序排序</p><p>查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--默认是升序</span><br><span class="hljs-keyword">SELECT</span><br>* <br><span class="hljs-keyword">FROM</span><br>T_ACCOUNT <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><br>usenum<br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708075810038.png" alt="image-20250708075810038"></p><p>需求2：对T_ACCOUNT 表按使用量进行降序排序</p><p>查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>* <br><span class="hljs-keyword">FROM</span><br>T_ACCOUNT <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><br>usenum <span class="hljs-keyword">DESC</span><br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708075838844.png" alt="image-20250708075838844"></p><h2 id="基于伪列的查询"><a href="#基于伪列的查询" class="headerlink" title="基于伪列的查询"></a>基于伪列的查询</h2><p>在Oracle 的表的使用过程中，实际表中还有一些附加的列，称为伪列。伪列就<br>像表中的列一样，但是在表中并不存储。伪列只能查询，不能进行增删改操作。</p><h3 id="ROWID"><a href="#ROWID" class="headerlink" title="ROWID"></a>ROWID</h3><p>表中的每一行在数据文件中都有一个<strong>物理地址</strong>，ROWID 伪列返回的就是该行的<br>物理地址。</p><p>使用ROWID 可以快速的定位表中的某一行。</p><p>ROWID 值可以唯一的标识表中的一行。</p><p>由于ROWID 返回的是该行的物理地址，因此使用ROWID 可以显示行是如何存储的。</p><p>查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ROWID</span><br>,<br>t.* <br><span class="hljs-keyword">FROM</span><br>T_AREA t<br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708075920074.png" alt="image-20250708075920074"></p><h3 id="ROWNUM"><a href="#ROWNUM" class="headerlink" title="ROWNUM"></a>ROWNUM</h3><p>在查询 的结果集中，ROWNUMM为结果集中每一行标识一个行号。第一行返回1，第二行返回2…。通过它可以限制查询结果集中返回的行数。</p><p>查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ROWNUM</span><br>,<br>t.* <br><span class="hljs-keyword">FROM</span><br>T_OWNERTYPE t<br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708075937938.png" alt="image-20250708075937938"></p><h2 id="聚合统计"><a href="#聚合统计" class="headerlink" title="聚合统计"></a>聚合统计</h2><p>Oralce中的聚合统计是通过分组函数来实现的。</p><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><ol><li>求和sum</li></ol><p>需求：统计2012 年所有用户的用水量总和</p><p>查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br><span class="hljs-keyword">sum</span>( usenum ) <br><span class="hljs-keyword">FROM</span><br>t_account <br><span class="hljs-keyword">WHERE</span><br><span class="hljs-keyword">year</span> = <span class="hljs-string">'2012'</span><br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708075959651.png" alt="image-20250708075959651"></p><ol start="2"><li>求平均avg</li></ol><p>需求：统计2012 年所有用水量（字数）的平均值</p><p>查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br><span class="hljs-keyword">avg</span>(usenum) <br><span class="hljs-keyword">FROM</span><br>T_ACCOUNT <br><span class="hljs-keyword">WHERE</span><br><span class="hljs-keyword">year</span> = <span class="hljs-string">'2012'</span><br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708080047398.png" alt="image-20250708080047398"></p><ol start="3"><li>求最大值max</li></ol><p>需求：统计2012 年最高用水量（字数）</p><p>查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br><span class="hljs-keyword">max</span>( usenum ) <br><span class="hljs-keyword">FROM</span><br>T_ACCOUNT <br><span class="hljs-keyword">WHERE</span><br><span class="hljs-keyword">year</span> = <span class="hljs-string">'2012'</span><br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708080105204.png" alt="image-20250708080105204"></p><ol start="4"><li>求最小值min</li></ol><p>需求：统计2012 年最低用水量（字数）</p><p>查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br><span class="hljs-keyword">min</span>( usenum ) <br><span class="hljs-keyword">FROM</span><br>T_ACCOUNT <br><span class="hljs-keyword">WHERE</span><br><span class="hljs-keyword">year</span> = <span class="hljs-string">'2012'</span><br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708080122614.png" alt="image-20250708080122614"></p><ol start="5"><li>统计记录个数count</li></ol><p>需求：统计业主类型ID 为1 的业主数量</p><p>查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br><span class="hljs-keyword">count</span>( * ) <br><span class="hljs-keyword">FROM</span><br>T_OWNERS t <br><span class="hljs-keyword">WHERE</span><br>ownertypeid =<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708080141969.png" alt="image-20250708080141969"></p><h3 id="分组聚合group-by"><a href="#分组聚合group-by" class="headerlink" title="分组聚合group by"></a>分组聚合group by</h3><p>需求：按区域分组统计水费合计数</p><p>查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>areaid,<br><span class="hljs-keyword">sum</span>( money ) <br><span class="hljs-keyword">FROM</span><br>t_account <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span><br>areaid<br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708080200663.png" alt="image-20250708080200663"></p><h3 id="分组后条件查询having"><a href="#分组后条件查询having" class="headerlink" title="分组后条件查询having"></a>分组后条件查询having</h3><p>需求：查询水费合计大于16900 的区域及水费合计</p><p>查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>areaid,<br><span class="hljs-keyword">sum</span>( money ) <br><span class="hljs-keyword">FROM</span><br>t_account <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span><br>areaid <br><span class="hljs-keyword">HAVING</span><br><span class="hljs-keyword">sum</span>( money ) &gt; <span class="hljs-number">169000</span><br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708080220318.png" alt="image-20250708080220318"></p><h1 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h1><h2 id="多表内连接查询"><a href="#多表内连接查询" class="headerlink" title="多表内连接查询"></a>多表内连接查询</h2><p>需求1：查询显示业主编号，业主名称，业主类型名称，如下图：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708074137569.png" alt="image-20250708074137569"></p><p>查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>o.id 业主编号,<br>o.name 业主名称,<br>ot.name 业主类型 <br><span class="hljs-keyword">FROM</span><br>T_OWNERS o,<br>T_OWNERTYPE ot <br><span class="hljs-keyword">WHERE</span><br>o.ownertypeid = ot.id<br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708080240874.png" alt="image-20250708080240874"></p><p>需求2：查询显示业主编号，业主名称、地址和业主类型，如下图</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708074224084.png" alt="image-20250708074224084"></p><p>查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>o.id 业主编号,<br>o.name 业主名称,<br>ad.name 地址,<br>ot.name 业主类型 <br><span class="hljs-keyword">FROM</span><br>T_OWNERS o,<br>T_OWNERTYPE ot,<br>T_ADDRESS ad <br><span class="hljs-keyword">WHERE</span><br>o.ownertypeid = ot.id <br><span class="hljs-keyword">AND</span> o.addressid = ad.id<br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708080313376.png" alt="image-20250708080313376"></p><p>需求3：查询显示业主编号、业主名称、地址、所属区域、业主分类，如下<br>图：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708074255113.png" alt="image-20250708074255113"></p><p>查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>o.id 业主编号,<br>o.name 业主名称,<br>ar.name 区域,<br>ad.name 地址,<br>ot.name 业主类型 <br><span class="hljs-keyword">FROM</span><br>T_OWNERS o,<br>T_OWNERTYPE ot,<br>T_ADDRESS ad,<br>T_AREA ar <br><span class="hljs-keyword">WHERE</span><br>o.ownertypeid = ot.id <br><span class="hljs-keyword">AND</span> o.addressid = ad.id <br><span class="hljs-keyword">AND</span> ad.areaid = ar.id<br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708080428987.png" alt="image-20250708080428987"></p><p>需求：查询显示业主编号、业主名称、地址、所属区域、收费员、业主分类，如下图：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708074320508.png" alt="image-20250708074320508"></p><p>查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>ow.id 业主编号,<br>ow.name 业主名称,<br>ad.name 地址,<br>ar.name 所属区域,<br>op.name 收费员,<br>ot.name 业主类型 <br><span class="hljs-keyword">FROM</span><br>T_OWNERS ow,<br>T_OWNERTYPE ot,<br>T_ADDRESS ad,<br>T_AREA ar,<br>T_OPERATOR op <br><span class="hljs-keyword">WHERE</span><br>ow.ownertypeid = ot.id <br><span class="hljs-keyword">AND</span> ow.addressid = ad.id <br><span class="hljs-keyword">AND</span> ad.areaid = ar.id <br><span class="hljs-keyword">AND</span> ad.operatorid = op.id<br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708080457384.png" alt="image-20250708080457384"></p><h2 id="左外连接查询"><a href="#左外连接查询" class="headerlink" title="左外连接查询"></a>左外连接查询</h2><p>需求1：查询业主的账务记录，显示业主编号、名称、年、月、金额。如果此业主没有账务记录也要列出姓名。</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708074349057.png" alt="image-20250708074349057"></p><p>分析：业主表为左表、账务表为右表。</p><p>按照SQL1999标准的语法，查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>ow.id,<br>ow.name,<br>ac.year,<br>ac.month,<br>ac.money <br><span class="hljs-keyword">FROM</span><br>T_OWNERS ow<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> T_ACCOUNT ac <span class="hljs-keyword">ON</span> ow.id = ac.owneruuid<br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708080525688.png" alt="image-20250708080525688"></p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708080540024.png" alt="image-20250708080540024"></p><p>按照Oracle提供的语法，查询语句：</p><p>如果是左外连接，就在右表所在的条件后面加上(+)</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>ow.id,<br>ow.name,<br>ac.year,<br>ac.month,<br>ac.money <br><span class="hljs-keyword">FROM</span><br>T_OWNERS ow,<br>T_ACCOUNT ac <br><span class="hljs-keyword">WHERE</span><br>ow.id = ac.owneruuid ( + )<br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p>和上面的结果一样</p><h2 id="右外连接查询"><a href="#右外连接查询" class="headerlink" title="右外连接查询"></a>右外连接查询</h2><p>需求：查询业主的账务记录，显示业主编号、名称、年、月、金额。如果账务记录没有对应的业主信息，也要列出记录。如下图：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708074616276.png" alt="image-20250708074616276"></p><p>按照SQL1999标准的语法，查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>ow.id,<br>ow.name,<br>ac.year,<br>ac.month,<br>ac.money <br><span class="hljs-keyword">FROM</span><br>T_OWNERS ow<br><span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> T_ACCOUNT ac <span class="hljs-keyword">ON</span> ow.id = ac.owneruuid<br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708080640420.png" alt="image-20250708080640420"></p><p>按照Oracle提供的语法，查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>ow.id,<br>ow.name,<br>ac.year,<br>ac.month,<br>ac.money <br><span class="hljs-keyword">FROM</span><br>T_OWNERS ow,<br>T_ACCOUNT ac <br><span class="hljs-keyword">WHERE</span><br>ow.id ( + ) = ac.owneruuid<br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p>和上面的结果一样</p><h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><h2 id="where子句中的子查询"><a href="#where子句中的子查询" class="headerlink" title="where子句中的子查询"></a>where子句中的子查询</h2><h3 id="单行子查询"><a href="#单行子查询" class="headerlink" title="单行子查询"></a>单行子查询</h3><ul><li><p>只返回一条记录</p></li><li><p>单行操作符</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708074747823.png" alt="image-20250708074747823"></p></li></ul><p>需求：查询2012 年1 月用水量大于平均值的台账记录</p><p>查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>* <br><span class="hljs-keyword">FROM</span><br>T_ACCOUNT <br><span class="hljs-keyword">WHERE</span><br><span class="hljs-keyword">year</span> = <span class="hljs-string">'2012'</span> <br><span class="hljs-keyword">AND</span> <span class="hljs-keyword">month</span> = <span class="hljs-string">'01'</span> <br><span class="hljs-keyword">AND</span> usenum &gt; ( <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">avg</span>( usenum ) <span class="hljs-keyword">FROM</span> T_ACCOUNT <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">year</span> = <span class="hljs-string">'2012'</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">month</span> = <span class="hljs-string">'01'</span> )<br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708080721911.png" alt="image-20250708080721911"></p><h3 id="多行子查询"><a href="#多行子查询" class="headerlink" title="多行子查询"></a>多行子查询</h3><ul><li><p>可能会返回多条记录</p></li><li><p>多行操作符</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708074843832.png" alt="image-20250708074843832"></p></li></ul><h4 id="in运算符"><a href="#in运算符" class="headerlink" title="in运算符"></a>in运算符</h4><p>需求1：查询地址编号为1 、3、4 的业主记录</p><p>查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>* <br><span class="hljs-keyword">FROM</span><br>T_OWNERS <br><span class="hljs-keyword">WHERE</span><br>addressid <span class="hljs-keyword">IN</span> ( <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> )<br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708080750597.png" alt="image-20250708080750597"></p><p>需求2：查询地址含有“花园”的业主的信息</p><p>查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>* <br><span class="hljs-keyword">FROM</span><br>T_OWNERS <br><span class="hljs-keyword">WHERE</span><br>addressid <span class="hljs-keyword">IN</span> ( <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> t_address <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'%花园%'</span> )<br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708080813957.png" alt="image-20250708080813957"></p><p>需求3：查询地址不含有“花园”的业主的信息</p><p>查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>* <br><span class="hljs-keyword">FROM</span><br>T_OWNERS <br><span class="hljs-keyword">WHERE</span><br>addressid <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> ( <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> t_address <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'%花园%'</span> )<br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708080850962.png" alt="image-20250708080850962"></p><h2 id="from子句中的子查询"><a href="#from子句中的子查询" class="headerlink" title="from子句中的子查询"></a>from子句中的子查询</h2><p><strong>from 子句的子查询为多行子查询</strong><br>需求：查询显示业主编号，业主名称，业主类型名称，条件为业主类型为”居民”，使用子查询实现。</p><p>查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>* <br><span class="hljs-keyword">FROM</span><br>(<br><span class="hljs-keyword">SELECT</span><br>o.id 业主编号,<br>o.name 业主名称,<br>ot.name 业主类型 <br><span class="hljs-keyword">FROM</span><br>T_OWNERS o,<br>T_OWNERTYPE ot <br><span class="hljs-keyword">WHERE</span><br>o.ownertypeid = ot.id <br>) <br><span class="hljs-keyword">WHERE</span><br>业主类型= <span class="hljs-string">'居民'</span><br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708080916696.png" alt="image-20250708080916696"></p><h2 id="select子句中的子查询"><a href="#select子句中的子查询" class="headerlink" title="select子句中的子查询"></a>select子句中的子查询</h2><p><strong>select 子句的子查询必须为单行子查询</strong></p><p>需求1：列出业主信息，包括ID，名称，所属地址。</p><p>查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br><span class="hljs-keyword">id</span>,<br><span class="hljs-keyword">name</span>,<br>( <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">FROM</span> t_address <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = addressid ) addressname <br><span class="hljs-keyword">FROM</span><br>t_owners<br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708080954304.png" alt="image-20250708080954304"></p><p>需求2：列出业主信息，包括ID，名称，所属地址，所属区域。</p><p>老师写的查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br><span class="hljs-keyword">id</span>,<br><span class="hljs-keyword">name</span>,<br>( <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">FROM</span> t_address <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = addressid ) addressname,<br>( <span class="hljs-keyword">SELECT</span> ( <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">FROM</span> t_area <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = areaid ) <span class="hljs-keyword">FROM</span> t_address <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = addressid ) adrename <br><span class="hljs-keyword">FROM</span><br>t_owners;<br></code></pre></td></tr></tbody></table></figure><p>查询结果：</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250708081019128.png" alt="image-20250708081019128"></p><p>自己写的查询语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br><span class="hljs-keyword">id</span>,<br><span class="hljs-keyword">name</span>,<br>( <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">FROM</span> T_ADDRESS <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = ADDRESSID ) <span class="hljs-keyword">AS</span> addressName,<br>( <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">FROM</span> T_AREA <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = ( <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> T_ADDRESS <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = ADDRESSID ) ) <span class="hljs-keyword">AS</span> areaName <br><span class="hljs-keyword">FROM</span><br>T_OWNERS;<br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250712053136645.png" alt="image-20250712053136645"></p><p>犯过的错误</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br><span class="hljs-keyword">id</span>,<br><span class="hljs-keyword">name</span>,<br>( <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">FROM</span> T_ADDRESS <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = ADDRESSID ) <span class="hljs-keyword">AS</span> <span class="hljs-string">'addressName'</span>, <span class="hljs-comment">-- 会报错，因为子查询的结果列名使用了单引号 '，而在SQL中，单引号通常用于字符串值，而不是列别名。列别名应该使用双引号 " 或者直接省略引号。</span><br>( <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">FROM</span> T_AREA <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = ( <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> T_ADDRESS <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = ADDRESSID ) ) <span class="hljs-keyword">AS</span> <span class="hljs-string">'areaName'</span> <span class="hljs-comment">-- 会报错，原因同上</span><br><span class="hljs-keyword">FROM</span><br>T_OWNERS;<br></code></pre></td></tr></tbody></table></figure><h1 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h1><h2 id="简单分页"><a href="#简单分页" class="headerlink" title="简单分页"></a>简单分页</h2><p>rowNum只能是小于或者小于等于</p><p>需求：分页查询台账表T_ACCOUNT，每页10 条记录</p><p><strong>查询前10条数据：</strong></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ROWNUM</span><br>,<br>t.* <br><span class="hljs-keyword">FROM</span><br>T_ACCOUNT t <br><span class="hljs-keyword">WHERE</span><br><span class="hljs-keyword">ROWNUM</span> &lt;= <span class="hljs-number">10</span>;<br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250719073451830.png" alt="image-20250719073451830"></p><p><strong>查询第11条到第20条数据：</strong></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ROWNUM</span>, t.* <span class="hljs-keyword">FROM</span> T_ACCOUNT t <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">ROWNUM</span> &gt; <span class="hljs-number">10</span> <br><span class="hljs-keyword">AND</span> <span class="hljs-keyword">ROWNUM</span> &lt;= <span class="hljs-number">20</span>;<br></code></pre></td></tr></tbody></table></figure><p>查询不到数据，原因是rownum是在查询语句扫描每条记录的时候产生的，不能使用大于符号，只能使用小于或者小于等于符号。只用等于符号也不行。</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250719073432405.png" alt="image-20250719073432405"></p><p>将语句改正确</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>* <br><span class="hljs-keyword">FROM</span><br>( <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ROWNUM</span> r, t.* <span class="hljs-keyword">FROM</span> t_account t <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">ROWNUM</span> &lt;= <span class="hljs-number">20</span> ) <br><span class="hljs-keyword">WHERE</span><br>r &gt; <span class="hljs-number">10</span>;<br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250719073812413.png" alt="image-20250719073812413"></p><h2 id="基于排序的分页"><a href="#基于排序的分页" class="headerlink" title="基于排序的分页"></a>基于排序的分页</h2><p>需求：分页查询台账表T_ACCOUNT，每页10 条记录，按使用使用量降序排序。</p><ol><li><p>先将数据按照使用量降序排序</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>* <br><span class="hljs-keyword">FROM</span><br>t_account <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><br>usenum <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></tbody></table></figure></li></ol><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250719074155578.png" alt="image-20250719074155578"></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>* <br><span class="hljs-keyword">FROM</span><br>( <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ROWNUM</span> r, t.* <span class="hljs-keyword">FROM</span> ( <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> T_ACCOUNT <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> usenum <span class="hljs-keyword">DESC</span> ) t <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">ROWNUM</span> &lt;= <span class="hljs-number">20</span> ) <br><span class="hljs-keyword">WHERE</span><br>r &gt; <span class="hljs-number">10</span>  ;<br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250719074515377.png" alt="image-20250719074515377"></p><h1 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h1><h2 id="一、字符函数"><a href="#一、字符函数" class="headerlink" title="一、字符函数"></a>一、字符函数</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>ASCII</td><td>返回对应字符的十进制值</td></tr><tr><td>CHR</td><td>给出十进制返回字符</td></tr><tr><td>CONCAT</td><td>拼接两个字符串，与</td></tr><tr><td>INITCAT</td><td>将字符串的第一个字母变为大写</td></tr><tr><td>INSTR</td><td>找出某个字符串的位置</td></tr><tr><td>INSTRB</td><td>找出某个字符串的位置和字节数</td></tr><tr><td>LENGTH</td><td>以字符给出字符串的长度</td></tr><tr><td>LENGTHB</td><td>以字节给出字符串的长度</td></tr><tr><td>LOWER</td><td>将字符串转换成小写</td></tr><tr><td>LPAD</td><td>使用指定的字符在字符的左边填充</td></tr><tr><td>LTRIM</td><td>在左边裁剪掉指定的字符</td></tr><tr><td>RPAD</td><td>使用指定的字符在字符的右边填充</td></tr><tr><td>RTRIM</td><td>在右边裁剪掉指定的字符</td></tr><tr><td>REPLACE</td><td>执行字符串搜索和替换</td></tr><tr><td>SUBSTR</td><td>取字符串的子串</td></tr><tr><td>SUBSTRB</td><td>取字符串的子串（以字节）</td></tr><tr><td>SOUNDEX</td><td>返回一个同音字符串</td></tr><tr><td>TRANSLATE</td><td>执行字符串搜索和替换</td></tr><tr><td>TRIM</td><td>裁剪掉前面或后面的字符串</td></tr><tr><td>UPPER</td><td>将字符串变为大写</td></tr></tbody></table><h2 id="二、数值函数"><a href="#二、数值函数" class="headerlink" title="二、数值函数"></a>二、数值函数</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>ABS(value)</td><td>绝对值</td></tr><tr><td>CEIL(value)</td><td>大于或等于value的最小整数</td></tr><tr><td>COS(value)</td><td>余弦</td></tr><tr><td>COSH(value)</td><td>反余弦</td></tr><tr><td>EXP(value)</td><td>e 的value次幂</td></tr><tr><td>FLOOR(value)</td><td>小于或等于value的最大整数</td></tr><tr><td>LN(value)</td><td>value的自然对数</td></tr><tr><td>LOG(value)</td><td>value的以10为底的对数</td></tr><tr><td>MOD(value,divisor)</td><td>求模</td></tr><tr><td>POWER(value,exponent)</td><td>value的exponent次幂</td></tr><tr><td>ROUND(value,precision)</td><td>按precision 精度4舍5入</td></tr><tr><td>SIGN(value)</td><td>value 为正返回1;为负返回-1;为0 返回0.</td></tr><tr><td>SIN(value)</td><td>余弦</td></tr><tr><td>SINH(value)</td><td>反余弦</td></tr><tr><td>SQRT(value)</td><td>value的平方根</td></tr><tr><td>TAN(value)</td><td>正切</td></tr><tr><td>TANH(value)</td><td>反正切</td></tr><tr><td>TRUNC(value,按precision)</td><td>按照precision截取value</td></tr><tr><td>VSIZE(value)</td><td>返回value 在ORACLE的存储空间大小</td></tr></tbody></table><h2 id="三、日期函数"><a href="#三、日期函数" class="headerlink" title="三、日期函数"></a>三、日期函数</h2><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>ADD_MONTHS</td><td>在日期date 上增加count 个月</td></tr><tr><td>GREATEST(date1,date2,. . .)</td><td>从日期列表中选出最晚的日期</td></tr><tr><td>LAST_DAY( date )</td><td>返回日期date 所在月的最后一天</td></tr><tr><td>LEAST( date1, date2, . . .)</td><td>从日期列表中选出最早的日期</td></tr><tr><td>MONTHS_BETWEEN(date2,date1)</td><td>给出Date2 - date1 的月数(可以是小数)</td></tr><tr><td>NEXT_DAY( date,’day’)</td><td>给出日期date 之后下一天的日期，这里的day 为星期，<br>如： MONDAY,Tuesday 等。</td></tr><tr><td>NEW_TIME(date,’this’,’other’)</td><td>给出在this 时区=Other 时区的日期和时间</td></tr><tr><td>ROUND(date,’format’)</td><td>未指定format 时，如果日期中的时间在中午之前，则<br>将日期中的时间截断为12 A.M.(午夜，一天的开始),否<br>则进到第二天。时间截断为12 A.M.(午夜，一天的开始),<br>否则进到第二天。</td></tr><tr><td>TRUNC(date,’format’)</td><td>未指定format 时，将日期截为12 A.M.( 午夜，一天的<br>开始).</td></tr></tbody></table><h2 id="四、转换函数"><a href="#四、转换函数" class="headerlink" title="四、转换函数"></a>四、转换函数</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>CHARTOROWID</td><td>将字符转换到rowid类型</td></tr><tr><td>CONVERT</td><td>转换一个字符节到另外一个字符节</td></tr><tr><td>HEXTORAW</td><td>转换十六进制到raw 类型</td></tr><tr><td>RAWTOHEX</td><td>转换raw 到十六进制</td></tr><tr><td>ROWIDTOCHAR</td><td>转换ROWID 到字符</td></tr><tr><td>TO_CHAR</td><td>转换日期格式到字符串</td></tr><tr><td>TO_DATE</td><td>按照指定的格式将字符串转换到日期型</td></tr><tr><td>TO_MULTIBYTE</td><td>把单字节字符转换到多字节</td></tr><tr><td>TO_NUMBER</td><td>将数字字串转换到数字</td></tr><tr><td>TO_SINGLE_BYTE</td><td>转换多字节到单字节</td></tr></tbody></table><h2 id="五、其他函数"><a href="#五、其他函数" class="headerlink" title="五、其他函数"></a>五、其他函数</h2><h3 id="空值处理函数NVL"><a href="#空值处理函数NVL" class="headerlink" title="空值处理函数NVL"></a>空值处理函数NVL</h3><p>语法：</p><p>NVL（检测的值，如果为null 的值）；</p><p>需求：显示价格表中业主类型ID 为1 的价格记录，如果上限值为NULL,则显示9999999</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>PRICE,<br>MINNUM,<br>NVL( MAXNUM, <span class="hljs-number">9999999</span> ) <br><span class="hljs-keyword">FROM</span><br>T_PRICETABLE <br><span class="hljs-keyword">WHERE</span><br>OWNERTYPEID =<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250719080740253.png" alt="image-20250719080740253"></p><h3 id="空值处理函数NVL2"><a href="#空值处理函数NVL2" class="headerlink" title="空值处理函数NVL2"></a>空值处理函数NVL2</h3><p>语法：</p><p>NVL2（检测的值，如果不为null 的值，如果为null 的值）；</p><p>需求：显示价格表中业主类型ID 为1 的价格记录，如果上限值为NULL,显示“不限”.</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>PRICE,<br>MINNUM,<br>NVL2( MAXNUM, to_char( MAXNUM ), <span class="hljs-string">'不限'</span> ) <br><span class="hljs-keyword">FROM</span><br>T_PRICETABLE <br><span class="hljs-keyword">WHERE</span><br>OWNERTYPEID =<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250719080833116.png" alt="image-20250719080833116"></p><h3 id="条件取值decode"><a href="#条件取值decode" class="headerlink" title="条件取值decode"></a>条件取值decode</h3><p>语法：</p><p>decode(条件,值1,翻译值1,值2,翻译值2,…值n,翻译值n,缺省值)<br>【功能】根据条件返回相应值</p><p>需求：显示下列信息（不要关联查询业主类型表，直接判断1 2 3 的值）</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250719080904502.png" alt="image-20250719080904502"></p><p>写法1（Oracle特有的方法）：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span><br><span class="hljs-keyword">name</span>,<br><span class="hljs-keyword">decode</span>( ownertypeid, <span class="hljs-number">1</span>, <span class="hljs-string">' 居民'</span>, <span class="hljs-number">2</span>, <span class="hljs-string">' 行政事业单位</span><br><span class="hljs-string">'</span>, <span class="hljs-number">3</span>, <span class="hljs-string">'商业'</span> ) <span class="hljs-keyword">AS</span> 类型 <br><span class="hljs-keyword">FROM</span><br>T_OWNERS<br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250719081014248.png" alt="image-20250719081014248"></p><p>写法2：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br><span class="hljs-keyword">name</span>,<br>( <span class="hljs-keyword">CASE</span> ownertypeid <span class="hljs-keyword">WHEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">'居民'</span> <span class="hljs-keyword">WHEN</span> <span class="hljs-number">2</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">'行政事业单位'</span> <span class="hljs-keyword">WHEN</span> <span class="hljs-number">3</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">'商业'</span> <span class="hljs-keyword">ELSE</span> <span class="hljs-string">'其它'</span> <span class="hljs-keyword">END</span> ) <br><span class="hljs-keyword">FROM</span><br>T_OWNERS<br></code></pre></td></tr></tbody></table></figure><p>写法3：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br><span class="hljs-keyword">name</span>,<br>( <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> ownertypeid = <span class="hljs-number">1</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">'居民'</span> <span class="hljs-keyword">WHEN</span> ownertypeid = <span class="hljs-number">2</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">'行政事业'</span> <span class="hljs-keyword">WHEN</span> ownertypeid = <span class="hljs-number">3</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">'商业'</span> <span class="hljs-keyword">END</span> ) <br><span class="hljs-keyword">FROM</span><br>T_OWNERS<br></code></pre></td></tr></tbody></table></figure><h1 id="行列转换"><a href="#行列转换" class="headerlink" title="行列转换"></a>行列转换</h1><p>需求1：按月份统计2012 年各个地区的水费，如下图</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250719081215930.png" alt="image-20250719081215930"></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>( <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">FROM</span> T_AREA <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = areaid ) 区域,<br><span class="hljs-keyword">sum</span>( <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">month</span> = <span class="hljs-string">'01'</span> <span class="hljs-keyword">THEN</span> money <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span> <span class="hljs-keyword">END</span> ) 一月,<br><span class="hljs-keyword">sum</span>( <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">month</span> = <span class="hljs-string">'02'</span> <span class="hljs-keyword">THEN</span> money <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span> <span class="hljs-keyword">END</span> ) 二月,<br><span class="hljs-keyword">sum</span>( <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">month</span> = <span class="hljs-string">'03'</span> <span class="hljs-keyword">THEN</span> money <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span> <span class="hljs-keyword">END</span> ) 三月,<br><span class="hljs-keyword">sum</span>( <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">month</span> = <span class="hljs-string">'04'</span> <span class="hljs-keyword">THEN</span> money <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span> <span class="hljs-keyword">END</span> ) 四月,<br><span class="hljs-keyword">sum</span>( <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">month</span> = <span class="hljs-string">'05'</span> <span class="hljs-keyword">THEN</span> money <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span> <span class="hljs-keyword">END</span> ) 五月,<br><span class="hljs-keyword">sum</span>( <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">month</span> = <span class="hljs-string">'06'</span> <span class="hljs-keyword">THEN</span> money <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span> <span class="hljs-keyword">END</span> ) 六月,<br><span class="hljs-keyword">sum</span>( <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">month</span> = <span class="hljs-string">'07'</span> <span class="hljs-keyword">THEN</span> money <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span> <span class="hljs-keyword">END</span> ) 七月,<br><span class="hljs-keyword">sum</span>( <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">month</span> = <span class="hljs-string">'08'</span> <span class="hljs-keyword">THEN</span> money <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span> <span class="hljs-keyword">END</span> ) 八月,<br><span class="hljs-keyword">sum</span>( <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">month</span> = <span class="hljs-string">'09'</span> <span class="hljs-keyword">THEN</span> money <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span> <span class="hljs-keyword">END</span> ) 九月,<br><span class="hljs-keyword">sum</span>( <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">month</span> = <span class="hljs-string">'10'</span> <span class="hljs-keyword">THEN</span> money <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span> <span class="hljs-keyword">END</span> ) 十月,<br><span class="hljs-keyword">sum</span>( <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">month</span> = <span class="hljs-string">'11'</span> <span class="hljs-keyword">THEN</span> money <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span> <span class="hljs-keyword">END</span> ) 十一月,<br><span class="hljs-keyword">sum</span>( <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">month</span> = <span class="hljs-string">'12'</span> <span class="hljs-keyword">THEN</span> money <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span> <span class="hljs-keyword">END</span> ) 十二月 <br><span class="hljs-keyword">FROM</span><br>T_ACCOUNT <br><span class="hljs-keyword">WHERE</span><br><span class="hljs-keyword">year</span> = <span class="hljs-string">'2012'</span> <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span><br>areaid<br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250719081300175.png" alt="image-20250719081300175"></p><p>需求2：按季度统计2012 年各个地区的水费，如下图</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250719081323144.png" alt="image-20250719081323144"></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>( <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">FROM</span> T_AREA <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = areaid ) 区域,<br><span class="hljs-keyword">sum</span>( <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">month</span> &gt;= <span class="hljs-string">'01'</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">month</span> &lt;= <span class="hljs-string">'03'</span> <span class="hljs-keyword">THEN</span> money <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span> <span class="hljs-keyword">END</span> ) 第一季度,<br><span class="hljs-keyword">sum</span>( <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">month</span> &gt;= <span class="hljs-string">'04'</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">month</span> &lt;= <span class="hljs-string">'06'</span> <span class="hljs-keyword">THEN</span> money <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span> <span class="hljs-keyword">END</span> ) 第二季度,<br><span class="hljs-keyword">sum</span>( <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">month</span> &gt;= <span class="hljs-string">'07'</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">month</span> &lt;= <span class="hljs-string">'09'</span> <span class="hljs-keyword">THEN</span> money <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span> <span class="hljs-keyword">END</span> ) 第三季度,<br><span class="hljs-keyword">sum</span>( <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">month</span> &gt;= <span class="hljs-string">'10'</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">month</span> &lt;= <span class="hljs-string">'12'</span> <span class="hljs-keyword">THEN</span> money <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span> <span class="hljs-keyword">END</span> ) 第四季度 <br><span class="hljs-keyword">FROM</span><br>T_ACCOUNT <br><span class="hljs-keyword">WHERE</span><br><span class="hljs-keyword">year</span> = <span class="hljs-string">'2012'</span> <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span><br>areaid<br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250719081411134.png" alt="image-20250719081411134"></p><h1 id="分析函数"><a href="#分析函数" class="headerlink" title="分析函数"></a>分析函数</h1><p>以下三个分析函数可以用于排名使用。下图为三种排名方式的举例</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250719081439161.png" alt="image-20250719081439161"></p><ol><li>RANK 相同的值排名相同，排名跳跃<br>需求：对T_ACCOUNT 表的usenum字段进行排序，相同的值排名相同，排名跳跃</li></ol><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br><span class="hljs-keyword">rank</span> ( ) <span class="hljs-keyword">over</span> ( <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> usenum <span class="hljs-keyword">DESC</span> ),<br>usenum <br><span class="hljs-keyword">FROM</span><br>T_ACCOUNT<br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250719081601412.png" alt="image-20250719081601412"></p><ol start="2"><li><p>DENSE_RANK 相同的值排名相同，排名连续<br>需求：对T_ACCOUNT 表的usenum 字段进行排序，相同的值排名相同，排名连续</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br><span class="hljs-keyword">dense_rank</span> ( ) <span class="hljs-keyword">over</span> ( <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> usenum <span class="hljs-keyword">DESC</span> ),<br>usenum <br><span class="hljs-keyword">FROM</span><br>T_ACCOUNT<br></code></pre></td></tr></tbody></table></figure></li></ol><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250719081700064.png" alt="image-20250719081700064"></p><ol start="3"><li>ROW_NUMBER 返回连续的排名，无论值是否相等<br>需求：对T_ACCOUNT表的usenum字段进行排序，返回连续的排名，无论值是否相等</li></ol><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>row_number ( ) <span class="hljs-keyword">over</span> ( <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> usenum <span class="hljs-keyword">DESC</span> ),<br>usenum <br><span class="hljs-keyword">FROM</span><br>T_ACCOUNT<br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250719081814513.png" alt="image-20250719081814513"></p><p>用row_number实现分页查询</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>* <br><span class="hljs-keyword">FROM</span><br>( <span class="hljs-keyword">SELECT</span> row_number ( ) <span class="hljs-keyword">over</span> ( <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> usenum <span class="hljs-keyword">DESC</span> ) rownumber, usenum <span class="hljs-keyword">FROM</span> T_ACCOUNT ) <br><span class="hljs-keyword">WHERE</span><br>rownumber &gt; <span class="hljs-number">10</span> <br><span class="hljs-keyword">AND</span> rownumber &lt;= <span class="hljs-number">20</span><br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250719081933701.png" alt="image-20250719081933701"></p><h1 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h1><p>集合运算，集合运算就是将两个或者多个结果集组合成为一个结果集。</p><table><thead><tr><th>Key</th><th>Info</th></tr></thead><tbody><tr><td>UNION ALL(并集)</td><td>返回各个查询的所有记录，包括重复记录。</td></tr><tr><td>UNION(并集)</td><td>返回各个查询的所有记录，不包括重复记录。</td></tr><tr><td>INTERSECT(交集)</td><td>返回两个查询共有的记录。</td></tr><tr><td>MINUS(差集</td><td>返回第一个查询检索出的记录减去第二个查询检索出的记录之后剩余的记录。</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250719082031060.png" alt="image-20250719082031060"></p><h2 id="并集运算"><a href="#并集运算" class="headerlink" title="并集运算"></a>并集运算</h2><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250719082158826.png" alt="image-20250719082158826"></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--union all:不会去掉重复记录</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_owners <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>&lt;=<span class="hljs-number">7</span><br><span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_owners <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>&gt;=<span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250719082426321.png" alt="image-20250719082426321"></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--union: 会去掉重复记录</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_owners <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>&lt;=<span class="hljs-number">7</span><br><span class="hljs-keyword">union</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_owners <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>&gt;=<span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250719082528924.png" alt="image-20250719082528924"></p><h2 id="交集运算"><a href="#交集运算" class="headerlink" title="交集运算"></a>交集运算</h2><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250719082558263.png" alt="image-20250719082558263"></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_owners <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>&lt;=<span class="hljs-number">7</span><br><span class="hljs-keyword">intersect</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_owners <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>&gt;=<span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250719082647979.png" alt="image-20250719082647979"></p><h2 id="差集运算"><a href="#差集运算" class="headerlink" title="差集运算"></a>差集运算</h2><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250719082617814.png" alt="image-20250719082617814"></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_owners <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>&lt;=<span class="hljs-number">7</span><br><span class="hljs-keyword">minus</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_owners <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>&gt;=<span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250719082736722.png" alt="image-20250719082736722"></p><h3 id="差集实现分页"><a href="#差集实现分页" class="headerlink" title="差集实现分页"></a>差集实现分页</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ROWNUM</span><br>,<br>t.* <br><span class="hljs-keyword">FROM</span><br>T_ACCOUNT t <br><span class="hljs-keyword">WHERE</span><br><span class="hljs-keyword">ROWNUM</span> &lt;= <span class="hljs-number">20</span> <br><span class="hljs-keyword">MINUS</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ROWNUM</span><br>,<br>t.* <br><span class="hljs-keyword">FROM</span><br>T_ACCOUNT t <br><span class="hljs-keyword">WHERE</span><br><span class="hljs-keyword">ROWNUM</span> &lt;= <span class="hljs-number">10</span><br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250719082903295.png" alt="image-20250719082903295"></p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>视图是一种数据库对象，是从一个或者多个数据库表或视图中导出的虚表，视图所对应的数据不是真正的存在视图中，而是存储在所引用的数据表中，视图的结构和数据是对数据表进行查询的结果。</p><p>根据创建视图时给的条件，视图可以是一个数据表的一部分，也可以是多个基表的联合。</p><h2 id="创建或修改视图"><a href="#创建或修改视图" class="headerlink" title="创建或修改视图"></a>创建或修改视图</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [ <span class="hljs-keyword">OR</span> <span class="hljs-keyword">REPLACE</span> ] [ <span class="hljs-keyword">force</span> ] <span class="hljs-keyword">VIEW</span> view_name <span class="hljs-keyword">AS</span> subquery [ <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">CHECK</span> <span class="hljs-keyword">OPTION</span> ]<br>[ <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">read</span> <span class="hljs-keyword">ONLY</span>]<br></code></pre></td></tr></tbody></table></figure><p>解释：</p><p>OR REPLACE：如果该视图已经存在，Oracle会自动重建该视图</p><p>FORCE: 不管基表是否存在，都会创建该视图</p><p>WITH CHECK OPTION：插入或修改的数据必须满足视图定义的约束</p><p>WITH read ONLY：该视图上不能进行任何DML操作</p><h2 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> view_name;<br></code></pre></td></tr></tbody></table></figure><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="简单视图的创建和使用"><a href="#简单视图的创建和使用" class="headerlink" title="简单视图的创建和使用"></a>简单视图的创建和使用</h3><p>需求：创建视图：业务类型为1的业主信息</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> view_t_owners <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span><br>* <br><span class="hljs-keyword">FROM</span><br>t_owners <br><span class="hljs-keyword">WHERE</span><br>OWNERTYPEID = <span class="hljs-number">1</span>;<br></code></pre></td></tr></tbody></table></figure><p>查询视图数据</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>* <br><span class="hljs-keyword">FROM</span><br>view_t_owners;<br></code></pre></td></tr></tbody></table></figure><p>修改视图数据，基表的数据页会被修改</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> view_t_owners <br><span class="hljs-keyword">SET</span> <span class="hljs-keyword">name</span> = <span class="hljs-string">'林玲玲'</span> <br><span class="hljs-keyword">WHERE</span><br><span class="hljs-keyword">id</span> = <span class="hljs-number">4</span>;<br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250721074244020.png" alt="image-20250721074244020"></p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250721074402609.png" alt="image-20250721074402609"></p><h3 id="带约束检查的视图"><a href="#带约束检查的视图" class="headerlink" title="带约束检查的视图"></a>带约束检查的视图</h3><p>需求：根据地址表（T_ADDRESS）创建视图 VIEW_T_ADDRESS, 内容为区域 ID为 2 的记录。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <br><span class="hljs-keyword">OR</span> <span class="hljs-keyword">REPLACE</span> <span class="hljs-keyword">VIEW</span> view_T_ADDRESS <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span><br>* <br><span class="hljs-keyword">FROM</span><br>T_ADDRESS <br><span class="hljs-keyword">WHERE</span><br>AREAID = <span class="hljs-number">2</span> <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">CHECK</span> <span class="hljs-keyword">OPTION</span>;<br></code></pre></td></tr></tbody></table></figure><p>因为areaid是创建视图时使用的条件，所以不能修改它的值，执行下面的update会报错。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> view_t_address <br><span class="hljs-keyword">SET</span> areaid = <span class="hljs-number">1</span> <br><span class="hljs-keyword">WHERE</span><br><span class="hljs-keyword">id</span> = <span class="hljs-number">3</span>;<br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250721075116352.png" alt="image-20250721075116352"></p><h3 id="只读视图"><a href="#只读视图" class="headerlink" title="只读视图"></a>只读视图</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <br><span class="hljs-keyword">OR</span> <span class="hljs-keyword">REPLACE</span> <span class="hljs-keyword">VIEW</span> view_t_owners1 <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span><br>* <br><span class="hljs-keyword">FROM</span><br>T_OWNERS <br><span class="hljs-keyword">WHERE</span><br>ownertypeid = <span class="hljs-number">1</span> <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">read</span> <span class="hljs-keyword">ONLY</span><br></code></pre></td></tr></tbody></table></figure><p>执行update的时候会报错</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> view_t_owners1 <br><span class="hljs-keyword">SET</span> <span class="hljs-keyword">name</span> = <span class="hljs-string">'summer'</span> <br><span class="hljs-keyword">WHERE</span><br><span class="hljs-keyword">id</span> = <span class="hljs-number">1</span>;<br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250721075411176.png" alt="image-20250721075411176"></p><h3 id="创建带错误的视图"><a href="#创建带错误的视图" class="headerlink" title="创建带错误的视图"></a>创建带错误的视图</h3><p>基表不存在，根据这个不存在的基表创建视图</p><p>我这个sql报错了，为什么？？？</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <br><span class="hljs-keyword">OR</span> raplace <span class="hljs-keyword">force</span> <span class="hljs-keyword">VIEW</span> view_t_temp <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span><br>* <br><span class="hljs-keyword">FROM</span><br>t_temp<br></code></pre></td></tr></tbody></table></figure><h3 id="复杂视图"><a href="#复杂视图" class="headerlink" title="复杂视图"></a>复杂视图</h3><h4 id="多表关联查询"><a href="#多表关联查询" class="headerlink" title="多表关联查询"></a>多表关联查询</h4><p>需求：创建视图，查询显示业主编号 业主名称，业主类型名称</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <br><span class="hljs-keyword">OR</span> <span class="hljs-keyword">REPLACE</span> <span class="hljs-keyword">VIEW</span> view_owners <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span><br>o.id 业主编号 ,<br>o.name 业主名称 ,<br>ot.name 业主类型 <br><span class="hljs-keyword">FROM</span><br>T_OWNERS o,<br>T_OWNERTYPE ot <br><span class="hljs-keyword">WHERE</span><br>o.ownertypeid = ot.id<br></code></pre></td></tr></tbody></table></figure><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> view_owners<br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250721075805523.png" alt="image-20250721075805523"></p>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;Oracle简介&quot;&gt;&lt;a href=&quot;#Oracle简介&quot; class=&quot;headerlink&quot; title=&quot;Oracle简介&quot;&gt;&lt;/a&gt;Oracle简介&lt;/h1&gt;&lt;h2 id=&quot;Oracle特点&quot;&gt;&lt;a href=&quot;#Oracle特点&quot; class=&quot;headerlink&quot; title=&quot;Oracle特点&quot;&gt;&lt;/a&gt;Oracle特点&lt;/h2&gt;&lt;p&gt;Oracle数据库具有以下特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;支持多用户，大事务量的事务处理&lt;/li&gt;
&lt;li&gt;数据安全性和完整性控制&lt;/li&gt;
&lt;li&gt;支持分布式数据处理&lt;/li&gt;
&lt;li&gt;可移植性&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Oracle体系结构&quot;&gt;&lt;a href=&quot;#Oracle体系结构&quot; class=&quot;headerlink&quot; title=&quot;Oracle体系结构&quot;&gt;&lt;/a&gt;Oracle体系结构&lt;/h2&gt;&lt;h3 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#数据库&quot; class=&quot;headerlink&quot; title=&quot;数据库&quot;&gt;&lt;/a&gt;数据库&lt;/h3&gt;&lt;p&gt;Oracle数据库是数据的物理存储。Oracle的数据库是指一个操作系统只有一个库，可以看做Oracle只有一个大数据库。&lt;/p&gt;
&lt;h3 id=&quot;实例&quot;&gt;&lt;a href=&quot;#实例&quot; class=&quot;headerlink&quot; title=&quot;实例&quot;&gt;&lt;/a&gt;实例&lt;/h3&gt;&lt;p&gt;一个Oracle实例（Oracle Instance）有一系列的后台进程（Background Processes）和内存结构（Memory Structures）组成。一个数据库可以有多个(n个)实例。&lt;/p&gt;</summary>
    
    
    
    <category term="Oracle" scheme="https://xiaofanshutu.github.io/categories/Oracle/"/>
    
    
  </entry>
  
  <entry>
    <title>事务</title>
    <link href="https://xiaofanshutu.github.io/posts/93ac284c.html"/>
    <id>https://xiaofanshutu.github.io/posts/93ac284c.html</id>
    <published>2025-07-02T22:59:12.930Z</published>
    <updated>2025-07-02T23:06:43.133Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="事务概述"><a href="#事务概述" class="headerlink" title="事务概述"></a>事务概述</h1><ol><li><p>事务是一个最小的工作单元。在数据库当中，事务表示一件完整的事儿。</p></li><li><p>一个业务的完成可能需要多条DML语句共同配合才能完成，例如转账业务，需要执行两条DML语句，先更新张三账户的余额，再更新李四账户的余额，为了保证转账业务不出现问题，就必须保证要么同时成功，要么同时失败，怎么保证同时成功或者同时失败呢？就需要使用事务机制。</p></li><li><p>也就是说用了事务机制之后，在同一个事务当中，多条DML语句会同时成功，或者同时失败，不会出现一部分成功，一部分失败的现象。</p></li><li><p>事务只针对DML语句有效：因为只有这三个语句是改变表中数据的。</p><ol><li>insert</li><li>delete</li><li>update<h1 id="事务四大特性：ACID"><a href="#事务四大特性：ACID" class="headerlink" title="事务四大特性：ACID"></a>事务四大特性：ACID</h1></li></ol></li><li><p>原子性（Atomicity）：是指事务包含的所有操作要么全部成功，要么同时失败。</p></li><li><p>一致性（Consistency）：是指事务开始前，和事务完成后，数据应该是一致的。例如张三和李四的钱加起来是5000，中间不管进行过多少次的转账操作(update)，总量5000是不会变的。这就是事务的一致性。</p></li><li><p>隔离性（Isolation）：隔离性是当多个⽤户并发访问数据库时，⽐如操作同⼀张表时，数据库为每⼀个⽤户开启的事务，不能被其他事务的操作所⼲扰，多个并发事务之间要相互隔离。</p></li><li><p>持久性（Durability）：持久性是指⼀个事务⼀旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p><h1 id="演示MySQL事务"><a href="#演示MySQL事务" class="headerlink" title="演示MySQL事务"></a>演示MySQL事务</h1><p>在dos命令窗口中开启MySQL事务：start transaction; 或者：begin;<br>回滚事务：rollback;<br>提交事务：commit;<br>只要执行以上的rollback或者commit，事务都会结束。<br>MySQL默认情况下采用的事务机制是：自动提交。所谓自动提交就是只要执行一条DML语句则提交一次。</p><h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250703070002096.png"></p></li></ol><p><strong>隔离级别从低到高排序：读未提交 &lt; 读提交 &lt; 可重复读 &lt; 串行化**<br>**不同隔离级别会存在不同的现象，现象按照严重性从高到低排序：脏读 &gt; 不可重复读 &gt; 幻读</strong></p><h2 id="查看与设置隔离级别"><a href="#查看与设置隔离级别" class="headerlink" title="查看与设置隔离级别"></a>查看与设置隔离级别</h2><p>mysql默认的隔离级别：可重复读（REPEATABLE READ）。</p><ul><li>查看当前会话的隔离级别：select @@transaction_isolation;</li><li>查看全局的隔离级别：select @@gobal.transaction_isolation;</li></ul><p>设置事务隔离级别：</p><ul><li>会话级：set session transaction isolation level read committed;</li><li>全局级：set global transaction isolation level read committed;<h2 id="不同现象"><a href="#不同现象" class="headerlink" title="不同现象"></a>不同现象</h2><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3>指的是一个事务读取了另一个事务尚未提交的数据，即读取了另一个事务中的脏数据（Dirty Data）。在此情况下，如果另一个事务回滚了或者修改了这些数据，那么读取这些脏数据的事务所处理的数据就是不准确的。<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3>指在一个事务内，多次读取同一个数据行，得到的结果可能是不一样的。这是由于其他事务对数据行做出了修改操作，导致数据的不一致性。<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3>指在事务执行过程中，前后两次相同的查询条件得到的结果集不一致，可能会变多或变少。<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><h3 id="读未提交（READ-UNCOMMITTED）"><a href="#读未提交（READ-UNCOMMITTED）" class="headerlink" title="读未提交（READ UNCOMMITTED）"></a>读未提交（READ UNCOMMITTED）</h3>A事务与B事务，A事务可以读取到B事务未提交的数据。这是最低的隔离级别。几乎两个事务之间没有隔离。这种隔离级别是一种理论层面的，在实际的数据库产品中，没有从这个级别起步的。<br>当事务隔离级别是读未提交时，三种现象都存在：脏读，不可重复读，幻读。<br>我们可以开启两个DOS命令窗口，模拟两个事务，演示一下这种隔离级别。三种现象中最严重的是脏读，我们只需要演示脏读问题即可，因为存在脏读的话，就一定存在不可重复读和幻读问题。</li></ul><p>将全局事务隔离级别设置为：READ UNCOMMITTED</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> <span class="hljs-keyword">transaction</span> <span class="hljs-keyword">isolation</span> <span class="hljs-keyword">level</span> <span class="hljs-keyword">read</span> uncommitted;<br></code></pre></td></tr></tbody></table></figure><p>开启两个DOS命令窗口来模拟两个事务：A事务与B事务。</p><table><thead><tr><th><strong>A事务</strong></th><th><strong>B事务</strong></th></tr></thead><tbody><tr><td>mysql&gt; use powernode</td><td></td></tr><tr><td></td><td>mysql&gt; use powernode</td></tr><tr><td>mysql&gt; start transaction;</td><td></td></tr><tr><td></td><td>mysql&gt; start transaction;</td></tr><tr><td>mysql&gt; select * from a;</td><td></td></tr><tr><td><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250703070014427.png"></td><td></td></tr><tr><td></td><td>mysql&gt; insert into a values(4);</td></tr><tr><td>mysql&gt; select * from a;</td><td></td></tr><tr><td><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250703070018545.png"></td><td></td></tr></tbody></table><p>通过以上测试，可以看到，A事务读取到了B事务还没有提交的数据。这种现象就是脏读。</p><h3 id="读提交（READ-COMMITTED）"><a href="#读提交（READ-COMMITTED）" class="headerlink" title="读提交（READ COMMITTED）"></a>读提交（READ COMMITTED）</h3><p>A事务与B事务，A事务可以读取到B事务提交之后的数据。Oracle数据库默认的就是这种隔离级别。</p><p>将数据库的全局事务隔离级别设置为读提交：READ COMMITTED</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> <span class="hljs-keyword">transaction</span> <span class="hljs-keyword">isolation</span> <span class="hljs-keyword">level</span> <span class="hljs-keyword">read</span> committed;<br></code></pre></td></tr></tbody></table></figure><p>演示：</p><table><thead><tr><th><strong>A事务</strong></th><th><strong>B事务</strong></th></tr></thead><tbody><tr><td>mysql&gt; use powernode</td><td></td></tr><tr><td></td><td>mysql&gt; use powernode</td></tr><tr><td>mysql&gt; start transaction;</td><td></td></tr><tr><td></td><td>mysql&gt; start transaction;</td></tr><tr><td>mysql&gt; select * from a;</td><td></td></tr><tr><td><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250703070023567.png"></td><td></td></tr><tr><td></td><td>mysql&gt; insert into a values(4);</td></tr><tr><td>mysql&gt; select * from a;</td><td></td></tr><tr><td><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250703070027578.png"></td><td></td></tr><tr><td></td><td>mysql&gt; commit;</td></tr><tr><td>mysql&gt; select * from a;</td><td></td></tr><tr><td><img src="https://cdn.nlark.com/yuque/0/2024/png/21376908/1709004165277-dac7bc73-55ba-4034-bd48-b975689ffb41.png#averageHue=%230f0e0d&amp;clientId=u0fbbe02e-04ac-4&amp;from=paste&amp;height=214&amp;id=ucc8e1eca&amp;originHeight=214&amp;originWidth=298&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=4626&amp;status=done&amp;style=shadow&amp;taskId=u2cac7a44-ba45-4bd7-86c2-2d280c9de57&amp;title=&amp;width=298" alt="image.png"></td><td></td></tr></tbody></table><p>通过以上测试看出，A事务只能读取到B事务提交之后的数据。这种隔离级别解决了脏读问题，但肯定是存在不可重复读和幻读问题。因为只要事务B进行了增删改操作之后并提交了，事务A读取到的数据肯定是不同的。即：不可重复读和幻读都存在。</p><h3 id="可重复读（REPEATABLE-READ）"><a href="#可重复读（REPEATABLE-READ）" class="headerlink" title="可重复读（REPEATABLE READ）"></a>可重复读（REPEATABLE READ）</h3><p>这个隔离级别是MySQL数据库默认的。<br>A事务和B事务，A事务开启后，读取了某一条记录，然后B事务对这条记录进行修改并提交，A事务读取到的还是修改前的数据。这种隔离级别称为可重复读。</p><p>将数据库全局隔离级别修改为可重复读：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> <span class="hljs-keyword">transaction</span> <span class="hljs-keyword">isolation</span> <span class="hljs-keyword">level</span> repeatable <span class="hljs-keyword">read</span>;<br></code></pre></td></tr></tbody></table></figure><p>演示：</p><table><thead><tr><th><strong>A事务</strong></th><th><strong>B事务</strong></th></tr></thead><tbody><tr><td>mysql&gt; use powernode</td><td></td></tr><tr><td></td><td>mysql&gt; use powernode</td></tr><tr><td>mysql&gt; start transaction;</td><td></td></tr><tr><td></td><td>mysql&gt; start transaction;</td></tr><tr><td>mysql&gt; select empno,ename,sal from emp where empno=7369;</td><td></td></tr><tr><td><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250703070032177.png"></td><td></td></tr><tr><td></td><td>mysql&gt; update emp set ename=’SMITH’,sal=8000 where empno=7369;</td></tr><tr><td></td><td>mysql&gt; commit;</td></tr><tr><td>mysql&gt; select empno,ename,sal from emp where empno=7369;</td><td></td></tr><tr><td><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250703070035832.png"></td><td></td></tr></tbody></table><p>通过以上测试得知：当事务隔离级别设置为可重复读时，避免了不可重复读问题。</p><p>那么在MySQL当中，当事务隔离级别设置为可重复读时，能够避免幻读问题吗？测试一下：</p><table><thead><tr><th><strong>事务A</strong></th><th><strong>事务B</strong></th></tr></thead><tbody><tr><td>mysql&gt; use powernode</td><td></td></tr><tr><td></td><td>mysql&gt; use powernode</td></tr><tr><td>mysql&gt; start transaction;</td><td></td></tr><tr><td></td><td>mysql&gt; start transaction;</td></tr><tr><td>mysql&gt; select * from a;</td><td></td></tr><tr><td><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250703070040811.png"></td><td></td></tr><tr><td></td><td>mysql&gt; insert into a values(5);</td></tr><tr><td></td><td>mysql&gt; commit;</td></tr><tr><td>mysql&gt; select * from a;</td><td></td></tr><tr><td><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250703070045242.png"></td><td></td></tr></tbody></table><p>通过以上测试得知：<strong>当事务隔离级别设置为可重复读时，也避免了幻读问题。是完全避免了幻读问题吗？并不是。</strong>请看以下测试：</p><table><thead><tr><th><strong>事务A</strong></th><th><strong>事务B</strong></th></tr></thead><tbody><tr><td>mysql&gt; use powernode</td><td></td></tr><tr><td></td><td>mysql&gt; use powernode</td></tr><tr><td>mysql&gt; start transaction;</td><td></td></tr><tr><td></td><td>mysql&gt; start transaction;</td></tr><tr><td>mysql&gt; select * from a;</td><td></td></tr><tr><td><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250703070626277.png" alt="image-20250703070626277"></td><td></td></tr><tr><td></td><td>mysql&gt; insert into a values(6);</td></tr><tr><td></td><td>mysql&gt; commit;</td></tr><tr><td>mysql&gt; select * from a <strong>for update;</strong></td><td></td></tr><tr><td><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250703070100658.png"></td><td></td></tr></tbody></table><p>通过以上测试得知：<strong>当事务隔离级别设置为可重复读，MySQL会尽最大努力避免幻读问题，但这种隔离级别无法完全避免幻读问题。</strong></p><h3 id="串行化（SERIALIZABLE）"><a href="#串行化（SERIALIZABLE）" class="headerlink" title="串行化（SERIALIZABLE）"></a>串行化（SERIALIZABLE）</h3><p>这种隔离级别最高，避免了所有的问题，缺点是效率低，因为这种隔离级别会导致事务排队处理，不支持并发。</p><p>设置数据库全局隔离级别为串行化：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> <span class="hljs-keyword">transaction</span> <span class="hljs-keyword">isolation</span> <span class="hljs-keyword">level</span> <span class="hljs-keyword">serializable</span>;<br></code></pre></td></tr></tbody></table></figure><p>演示：</p><table><thead><tr><th><strong>事务A</strong></th><th><strong>事务B</strong></th></tr></thead><tbody><tr><td>mysql&gt; use powernode</td><td></td></tr><tr><td></td><td>mysql&gt; use powernode</td></tr><tr><td>mysql&gt; start transaction;</td><td></td></tr><tr><td></td><td>mysql&gt; start transaction;</td></tr><tr><td>mysql&gt; select * from a;</td><td></td></tr><tr><td><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250703070107886.png"></td><td></td></tr><tr><td>mysql&gt; insert into a values(7);</td><td></td></tr><tr><td></td><td>mysql&gt; select * from a;</td></tr><tr><td><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250703070113102.png"></td><td></td></tr><tr><td>mysql&gt; commit;</td><td></td></tr><tr><td></td><td><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250703070117518.png"></td></tr></tbody></table><p>通过以上测试得知：当事务隔离级别设置为串行化时，事务只能排队执行，不支持并发。</p><h2 id="可重复读的幻读问题"><a href="#可重复读的幻读问题" class="headerlink" title="可重复读的幻读问题"></a>可重复读的幻读问题</h2><p>在上面讲解过程中我提到，MySQL默认的隔离级别可重复读，在很大程度上避免了幻读问题（并不能完全解决），那么它是如何解决幻读问题的呢，解决方案包括两种：</p><ul><li><p>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好的避免了幻读问题。</p></li><li><p>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好的避免了幻读问题。</p><h3 id="快照读是如何解决幻读的"><a href="#快照读是如何解决幻读的" class="headerlink" title="快照读是如何解决幻读的"></a>快照读是如何解决幻读的</h3><p>什么是快照读？普通的select语句都是采用的快照读。顾名思义：在整个事务的处理过程中，执行相同的一个select语句时，每次都是读取的快照。（快照指的是固定的某个时刻的数据，就像现实世界中的拍照一样，把那个美好的时刻留下来）。也就是说，当事务隔离级别是可重复读，并且执行的select语句是一个普通的select语句时，都会采用快照读的方式读取数据，底层实现原理是：</p></li><li><p>底层由 MVCC（多版本并发控制）实现，实现的方式是开始事务后，在执行第一个查询语句后，会创建一个 Read View，后续的查询语句利用这个 Read View，通过这个 Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的，即使中途有其他事务插入了新纪录，是查询不出来这条数据的，所以就很好的避免了幻读问题。</p></li></ul><p>演示：</p><table><thead><tr><th><strong>事务A</strong></th><th><strong>事务B</strong></th></tr></thead><tbody><tr><td>mysql&gt; use powernode</td><td></td></tr><tr><td></td><td>mysql&gt; use powernode</td></tr><tr><td>mysql&gt; start transaction;</td><td></td></tr><tr><td></td><td>mysql&gt; start transaction;</td></tr><tr><td>mysql&gt; select * from a; //快照读</td><td></td></tr><tr><td><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250703070123937.png"></td><td></td></tr><tr><td></td><td>mysql&gt; insert into a values(5);</td></tr><tr><td></td><td>mysql&gt; commit;</td></tr><tr><td>mysql&gt; select * from a; //快照读</td><td></td></tr><tr><td><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250703070128632.png"></td><td></td></tr></tbody></table><h3 id="当前读是如何解决幻读的"><a href="#当前读是如何解决幻读的" class="headerlink" title="当前读是如何解决幻读的"></a>当前读是如何解决幻读的</h3><p>当前读，顾名思义：每一次都读取最新的数据。当前读包括：update、delete、insert、select…for update。这个很好理解，因为增删改的时候都要基于最新的数据进行增删改。<br>而select…for update原理是：对查询范围内的数据进行加锁，不允许其它事务对这个范围内的数据进行增删改。也就是说这个select语句范围内的数据是不允许并发的，只能排队执行，从而避免幻读问题。<br>select…for update加的锁叫做：next-key lock。我们可以称其为：间隙锁 + 记录锁。间隙锁用来保证在锁定的范围内不允许insert操作。记录锁用来保证在锁定的范围内不允许delete和update操作。</p><p>假如有这样的数据：<br><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250703070133681.png"><br>SQL语句是这样写的：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> a <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">between</span> <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> <span class="hljs-number">4</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></tbody></table></figure><p>那么id在[2-4]区间的所有记录行被锁定，不能插入3是通过间隙锁来搞定的。不能修改或删除2和4是通过记录锁来搞定的。</p><p>演示：</p><table><thead><tr><th><strong>事务A</strong></th><th><strong>事务B</strong></th></tr></thead><tbody><tr><td>mysql&gt; use powernode</td><td></td></tr><tr><td></td><td>mysql&gt; use powernode</td></tr><tr><td>mysql&gt; start transaction;</td><td></td></tr><tr><td></td><td>mysql&gt; start transaction;</td></tr><tr><td>mysql&gt; select * from a where id between 2 and 4 for update; // 当前读</td><td></td></tr><tr><td></td><td><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250703070138619.png"></td></tr></tbody></table><h3 id="出现幻读的两种情况"><a href="#出现幻读的两种情况" class="headerlink" title="出现幻读的两种情况"></a>出现幻读的两种情况</h3><p>在同一个事务处理过程中，如果前后两次都采用快照读，或者都采用当前读，则不会出现幻读问题。如果第一次使用快照读，后面使用了当前读，则会出现幻读问题。</p><h4 id="第一种产生幻读的场景"><a href="#第一种产生幻读的场景" class="headerlink" title="第一种产生幻读的场景"></a>第一种产生幻读的场景</h4><p>A事务与B事务。在A事务中第一次查询使用快照读，B事务插入数据。然后在A事务中第二次查询使用当前读。则会产生幻读现象。<br>演示：</p><table><thead><tr><th><strong>事务A</strong></th><th><strong>事务B</strong></th></tr></thead><tbody><tr><td>mysql&gt; use powernode</td><td></td></tr><tr><td></td><td>mysql&gt; use powernode</td></tr><tr><td>mysql&gt; start transaction;</td><td></td></tr><tr><td></td><td>mysql&gt; start transaction;</td></tr><tr><td>mysql&gt; select * from a;</td><td></td></tr><tr><td><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250703070144039.png"></td><td></td></tr><tr><td></td><td>mysql&gt; insert into a values(5);</td></tr><tr><td></td><td>mysql&gt; commit;</td></tr><tr><td>mysql&gt; select * from a for update; // 产生了幻读</td><td></td></tr><tr><td><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250703070150445.png"></td><td></td></tr></tbody></table><h4 id="第二种产生幻读的场景"><a href="#第二种产生幻读的场景" class="headerlink" title="第二种产生幻读的场景"></a>第二种产生幻读的场景</h4><p>事务A与事务B，在事务A中第一次查询使用快照读，在事务B中插入一条数据，然后在事务A中更新事务B插入的那条记录，最后在事务A中再次使用快照读。则会发生幻读现象。</p><table><thead><tr><th><strong>事务A</strong></th><th><strong>事务B</strong></th></tr></thead><tbody><tr><td>mysql&gt; use powernode</td><td></td></tr><tr><td></td><td>mysql&gt; use powernode</td></tr><tr><td>mysql&gt; start transaction;</td><td></td></tr><tr><td></td><td>mysql&gt; start transaction;</td></tr><tr><td>mysql&gt; select * from a;</td><td></td></tr><tr><td><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250703070156454.png"></td><td></td></tr><tr><td></td><td>mysql&gt; insert into a values(6);</td></tr><tr><td></td><td>mysql&gt; commit;</td></tr><tr><td>mysql&gt; update a set id=100 where id=6; //主要是因为这个SQL语句的执行触发了当前读</td><td></td></tr><tr><td>mysql&gt; select * from a; // 产生了幻读</td><td></td></tr><tr><td><img src="C:\Users\winner\AppData\Roaming\Typora\typora-user-images\image-20250703070201823.png"></td><td></td></tr></tbody></table><h3 id="总结可重复读的幻读问题"><a href="#总结可重复读的幻读问题" class="headerlink" title="总结可重复读的幻读问题"></a>总结可重复读的幻读问题</h3><p>MySQL的可重复读隔离级别（默认隔离级），根据不同的查询方式，分别提出了避免幻读的方案：</p><ul><li>针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读。</li><li>针对当前读（select … for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读。</li></ul><p>我举例了两个发生幻读场景的例子。</p><ul><li>第一个例子：对于快照读， MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。</li><li>第二个例子：对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。</li></ul><p>所以，MySQL 可重复读隔离级别并没有彻底解决幻读，只是很大程度上避免了幻读现象的发生。<br>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。</p>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;事务概述&quot;&gt;&lt;a href=&quot;#事务概述&quot; class=&quot;headerlink&quot; title=&quot;事务概述&quot;&gt;&lt;/a&gt;事务概述&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;事务是一个最小的工作单元。在数据库当中，事务表示一件完整的事儿。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个业务的完成可能需要多条DML语句共同配合才能完成，例如转账业务，需要执行两条DML语句，先更新张三账户的余额，再更新李四账户的余额，为了保证转账业务不出现问题，就必须保证要么同时成功，要么同时失败，怎么保证同时成功或者同时失败呢？就需要使用事务机制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;也就是说用了事务机制之后，在同一个事务当中，多条DML语句会同时成功，或者同时失败，不会出现一部分成功，一部分失败的现象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;事务只针对DML语句有效：因为只有这三个语句是改变表中数据的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;insert&lt;/li&gt;
&lt;li&gt;delete&lt;/li&gt;
&lt;li&gt;update&lt;h1 id=&quot;事务四大特性：ACID&quot;&gt;&lt;a href=&quot;#事务四大特性：ACID&quot; class=&quot;headerlink&quot; title=&quot;事务四大特性：ACID&quot;&gt;&lt;/a&gt;事务四大特性：ACID&lt;/h1&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;原子性（Atomicity）：是指事务包含的所有操作要么全部成功，要么同时失败。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一致性（Consistency）：是指事务开始前，和事务完成后，数据应该是一致的。例如张三和李四的钱加起来是5000，中间不管进行过多少次的转账操作(update)，总量5000是不会变的。这就是事务的一致性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;隔离性（Isolation）：隔离性是当多个⽤户并发访问数据库时，⽐如操作同⼀张表时，数据库为每⼀个⽤户开启的事务，不能被其他事务的操作所⼲扰，多个并发事务之间要相互隔离。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;持久性（Durability）：持久性是指⼀个事务⼀旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。&lt;/p&gt;
&lt;h1 id=&quot;演示MySQL事务&quot;&gt;&lt;a href=&quot;#演示MySQL事务&quot; class=&quot;headerlink&quot; title=&quot;演示MySQL事务&quot;&gt;&lt;/a&gt;演示MySQL事务&lt;/h1&gt;&lt;p&gt;在dos命令窗口中开启MySQL事务：start transaction; 或者：begin;&lt;br&gt;回滚事务：rollback;&lt;br&gt;提交事务：commit;&lt;br&gt;只要执行以上的rollback或者commit，事务都会结束。&lt;br&gt;MySQL默认情况下采用的事务机制是：自动提交。所谓自动提交就是只要执行一条DML语句则提交一次。&lt;/p&gt;
&lt;h1 id=&quot;事务隔离级别&quot;&gt;&lt;a href=&quot;#事务隔离级别&quot; class=&quot;headerlink&quot; title=&quot;事务隔离级别&quot;&gt;&lt;/a&gt;事务隔离级别&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/growingbambi/typora/master/image-20250703070002096.png&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;隔离级别从低到高排序：读未提交 &amp;lt; 读提交 &amp;lt; 可重复读 &amp;lt; 串行化**&lt;br&gt;**不同隔离级别会存在不同的现象，现象按照严重性从高到低排序：脏读 &amp;gt; 不可重复读 &amp;gt; 幻读&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;查看与设置隔离级别&quot;&gt;&lt;a href=&quot;#查看与设置隔离级别&quot; class=&quot;headerlink&quot; title=&quot;查看与设置隔离级别&quot;&gt;&lt;/a&gt;查看与设置隔离级别&lt;/h2&gt;&lt;p&gt;mysql默认的隔离级别：可重复读（REPEATABLE READ）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查看当前会话的隔离级别：select @@transaction_isolation;&lt;/li&gt;
&lt;li&gt;查看全局的隔离级别：select @@gobal.transaction_isolation;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设置事务隔离级别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;会话级：set session transaction isolation level read committed;&lt;/li&gt;
&lt;li&gt;全局级：set global transaction isolation level read committed;&lt;h2 id=&quot;不同现象&quot;&gt;&lt;a href=&quot;#不同现象&quot; class=&quot;headerlink&quot; title=&quot;不同现象&quot;&gt;&lt;/a&gt;不同现象&lt;/h2&gt;&lt;h3 id=&quot;脏读&quot;&gt;&lt;a href=&quot;#脏读&quot; class=&quot;headerlink&quot; title=&quot;脏读&quot;&gt;&lt;/a&gt;脏读&lt;/h3&gt;指的是一个事务读取了另一个事务尚未提交的数据，即读取了另一个事务中的脏数据（Dirty Data）。在此情况下，如果另一个事务回滚了或者修改了这些数据，那么读取这些脏数据的事务所处理的数据就是不准确的。&lt;h3 id=&quot;不可重复读&quot;&gt;&lt;a href=&quot;#不可重复读&quot; class=&quot;headerlink&quot; title=&quot;不可重复读&quot;&gt;&lt;/a&gt;不可重复读&lt;/h3&gt;指在一个事务内，多次读取同一个数据行，得到的结果可能是不一样的。这是由于其他事务对数据行做出了修改操作，导致数据的不一致性。&lt;h3 id=&quot;幻读&quot;&gt;&lt;a href=&quot;#幻读&quot; class=&quot;headerlink&quot; title=&quot;幻读&quot;&gt;&lt;/a&gt;幻读&lt;/h3&gt;指在事务执行过程中，前后两次相同的查询条件得到的结果集不一致，可能会变多或变少。&lt;h2 id=&quot;隔离级别&quot;&gt;&lt;a href=&quot;#隔离级别&quot; class=&quot;headerlink&quot; title=&quot;隔离级别&quot;&gt;&lt;/a&gt;隔离级别&lt;/h2&gt;&lt;h3 id=&quot;读未提交（READ-UNCOMMITTED）&quot;&gt;&lt;a href=&quot;#读未提交（READ-UNCOMMITTED）&quot; class=&quot;headerlink&quot; title=&quot;读未提交（READ UNCOMMITTED）&quot;&gt;&lt;/a&gt;读未提交（READ UNCOMMITTED）&lt;/h3&gt;A事务与B事务，A事务可以读取到B事务未提交的数据。这是最低的隔离级别。几乎两个事务之间没有隔离。这种隔离级别是一种理论层面的，在实际的数据库产品中，没有从这个级别起步的。&lt;br&gt;当事务隔离级别是读未提交时，三种现象都存在：脏读，不可重复读，幻读。&lt;br&gt;我们可以开启两个DOS命令窗口，模拟两个事务，演示一下这种隔离级别。三种现象中最严重的是脏读，我们只需要演示脏读问题即可，因为存在脏读的话，就一定存在不可重复读和幻读问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将全局事务隔离级别设置为：READ UNCOMMITTED&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="https://xiaofanshutu.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>视图</title>
    <link href="https://xiaofanshutu.github.io/posts/50a54d3c.html"/>
    <id>https://xiaofanshutu.github.io/posts/50a54d3c.html</id>
    <published>2025-07-02T22:46:02.851Z</published>
    <updated>2025-07-02T22:53:57.145Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>只能将select语句创建为视图。</p></li><li><p>创建视图</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">replace</span> <span class="hljs-keyword">view</span> v_emp <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> e.ename,d.dname <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> e.deptno = d.deptno;<br></code></pre></td></tr></tbody></table></figure></li><li><p>视图作用</p><ol><li>如果开发中有一条非常复杂的SQL，而这个SQL在多处使用，会给开发和维护带来成本。使用视图可以降低开发和维护的成本。</li><li>视图可以隐藏表的字段名。</li></ol></li><li><p>修改视图</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">view</span> v_emp <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> e.ename,d.dname,d.deptno <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> e.deptno = d.deptno;<br></code></pre></td></tr></tbody></table></figure></li><li><p>删除视图</p><ol><li>drop view if exists v_emp;</li></ol></li><li><p>对视图增删改（DML：insert delete update）可以影响到原表数据。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;只能将select语句创建为视图。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建视图&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;replace&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;view&lt;/span&gt; v_emp &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; e.ename,d.dname &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; emp e &lt;span class=&quot;hljs-keyword&quot;&gt;join&lt;/span&gt; dept d &lt;span class=&quot;hljs-keyword&quot;&gt;on&lt;/span&gt; e.deptno = d.deptno;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;视图作用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果开发中有一条非常复杂的SQL，而这个SQL在多处使用，会给开发和维护带来成本。使用视图可以降低开发和维护的成本。&lt;/li&gt;
&lt;li&gt;视图可以隐藏表的字段名。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改视图&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;view&lt;/span&gt; v_emp &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; e.ename,d.dname,d.deptno &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; emp e &lt;span class=&quot;hljs-keyword&quot;&gt;join&lt;/span&gt; dept d &lt;span class=&quot;hljs-keyword&quot;&gt;on&lt;/span&gt; e.deptno = d.deptno;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;删除视图&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;drop view if exists v_emp;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对视图增删改（DML：insert delete update）可以影响到原表数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary>
    
    
    
    <category term="MySQL" scheme="https://xiaofanshutu.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库设计三范式</title>
    <link href="https://xiaofanshutu.github.io/posts/80436e1d.html"/>
    <id>https://xiaofanshutu.github.io/posts/80436e1d.html</id>
    <published>2025-07-02T13:41:22.456Z</published>
    <updated>2025-07-02T13:45:23.490Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是数据库设计三范式"><a href="#什么是数据库设计三范式" class="headerlink" title="什么是数据库设计三范式"></a>什么是数据库设计三范式</h1><p>数据库表设计的原则。教你怎么设计数据库表有效，并且节省空间。</p><h1 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h1><ol><li>第一范式：任何一张表都应该有主键，每个字段是原子性的不能再分<ol><li>以下表的设计不符合第一范式：无主键，并且联系方式可拆分。</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250702214226489.png"></p><ol start="2"><li>应该这样设计：</li></ol><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250702214230960.png"></p><ol start="2"><li>第二范式：建立在第一范式基础上的，另外要求所有非主键字段完全依赖主键，不能产生部分依赖<ol><li>以下表存储了学生和老师的信息</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250702214234959.png"><br>虽然符合第一范式，但是违背了第二范式，学生姓名、老师姓名都产生了部分依赖。导致数据冗余。</p><ol start="2"><li>以下这种设计方式就是符合第二范式的：</li></ol><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250702214239651.png"></p><ol start="3"><li>第三范式：建立在第二范式基础上的，非主键字段不能传递依赖于主键字段<ol><li>以下设计方式就是违背第三范式的</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250702214244205.png"><br>以上因为产生了传递依赖，导致班级名称冗余。</p><ol start="2"><li>以下这种方式就是符合第三范式的：</li></ol><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250702214248100.png"></p><h1 id="一对多怎么设计"><a href="#一对多怎么设计" class="headerlink" title="一对多怎么设计"></a>一对多怎么设计</h1><p>口诀：一对多两张表，多的表加外键。<br><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250702214252987.png"><br><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250702214259929.png"></p><h1 id="多对多怎么设计"><a href="#多对多怎么设计" class="headerlink" title="多对多怎么设计"></a>多对多怎么设计</h1><p>多对多三张表，关系表添加外键。<br><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250702214304436.png"></p><h1 id="一对一怎么设计"><a href="#一对一怎么设计" class="headerlink" title="一对一怎么设计"></a>一对一怎么设计</h1><p>两种方案：</p><ol><li>第一种：主键共享</li></ol><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250702214308522.png"></p><ol start="2"><li>第二种：外键唯一</li></ol><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250702214312778.png"></p><h1 id="最终的设计"><a href="#最终的设计" class="headerlink" title="最终的设计"></a>最终的设计</h1><p>最终以满足客户需求为原则，有的时候会拿空间换速度。</p>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;什么是数据库设计三范式&quot;&gt;&lt;a href=&quot;#什么是数据库设计三范式&quot; class=&quot;headerlink&quot; title=&quot;什么是数据库设计三范式&quot;&gt;&lt;/a&gt;什么是数据库设计三范式&lt;/h1&gt;&lt;p&gt;数据库表设计的原则。教你怎么设计数据库表有效，并且节省空间。&lt;/p&gt;
&lt;h1 id=&quot;三范式&quot;&gt;&lt;a href=&quot;#三范式&quot; class=&quot;headerlink&quot; title=&quot;三范式&quot;&gt;&lt;/a&gt;三范式&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;第一范式：任何一张表都应该有主键，每个字段是原子性的不能再分&lt;ol&gt;
&lt;li&gt;以下表的设计不符合第一范式：无主键，并且联系方式可拆分。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/growingbambi/typora/master/image-20250702214226489.png&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;应该这样设计：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/growingbambi/typora/master/image-20250702214230960.png&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;第二范式：建立在第一范式基础上的，另外要求所有非主键字段完全依赖主键，不能产生部分依赖&lt;ol&gt;
&lt;li&gt;以下表存储了学生和老师的信息&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/growingbambi/typora/master/image-20250702214234959.png&quot;&gt;&lt;br&gt;虽然符合第一范式，但是违背了第二范式，学生姓名、老师姓名都产生了部分依赖。导致数据冗余。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="https://xiaofanshutu.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL表相关</title>
    <link href="https://xiaofanshutu.github.io/posts/31637be2.html"/>
    <id>https://xiaofanshutu.github.io/posts/31637be2.html</id>
    <published>2025-06-30T23:16:56.277Z</published>
    <updated>2025-07-01T00:07:26.004Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h1><p>语法格式：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名(<br>  字段名<span class="hljs-number">1</span> 数据类型,<br>  字段名<span class="hljs-number">2</span> 数据类型,<br>  字段名<span class="hljs-number">3</span> 数据类型,<br>  ......<br>);<br></code></pre></td></tr></tbody></table></figure><p>例如：创建学生表</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_student(<br>  <span class="hljs-keyword">no</span> <span class="hljs-built_in">int</span>,<br>  <span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>,<br>  gender <span class="hljs-built_in">char</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">'男'</span><br>);<br></code></pre></td></tr></tbody></table></figure><h1 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h1><p>语法格式：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> 表名(字段名<span class="hljs-number">1</span>, 字段名<span class="hljs-number">2</span>, 字段名<span class="hljs-number">3</span>,......) <span class="hljs-keyword">values</span> (值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,值<span class="hljs-number">3</span>,......);<br></code></pre></td></tr></tbody></table></figure><p>字段名和值要一一对应。类型要一一对应，数量要一一对应。<br>字段名也可以省略，如果字段名省略就表示把所有字段名都写上去了，并且顺序和建表时的顺序相同。</p><h1 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h1><p>语法格式：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> 表名;<br></code></pre></td></tr></tbody></table></figure><p>或者</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span> 表名;<br></code></pre></td></tr></tbody></table></figure><p>判断是否存在这个表，如果存在则删除。避免不存在时的报错。</p><h1 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h1><p>数据类型（data_type）是指系统中所允许的数据的类型。数据库中的每个列都应该有适当的数据类型，用于限制或允许该列中存储的数据。例如，列中存储的为数字，则相应的数据类型应该为数值类型。<br>如果使用错误的数据类型可能会严重影响应用程序的功能和性能，所以在设计表时，应该特别重视数据列所用的数据类型。更改包含数据的列不是一件小事，这样做可能会导致数据丢失。因此，在创建表时必须为每个列设置正确的数据类型和长度。<br>MySQL 的数据类型可以分为整数类型、浮点数类型、定点数类型、日期和时间类型、字符串类型、二进制类型等。</p><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>tinyint：1个字节（微小整数）<br>smallint：2个字节（小整数）<br>mediumint：3个字节（中等大小的整数）<br><strong>int（integer）：4个字节（普通大小整数）</strong><br><strong>bigint：8个字节（大整数）</strong></p><h2 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h2><p>float：4个字节，单精度（最多5位小数）<br><strong>double：8个字节，双精度（最多16位小数）</strong></p><h2 id="定点数类型"><a href="#定点数类型" class="headerlink" title="定点数类型"></a>定点数类型</h2><p>decimal：定点数类型。底层实际上采用字符串的形式存储数字。<br>语法：decimal(m, d)<br>例如：decimal(3, 2) 表示3个有效数字，2个小数。（有效数字最多65个，小数位最多30个）</p><h2 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h2><p>year：1个字节，只存储年，格式YYYY<br>time：3个字节，只存储时间，格式HH:MM:SS / HHMMSS<br>date：3个字节，只存储年月日，格式：YYYY-MM-DD<br>datetime：8个字节，存储年月日+时分秒，格式：YYYY-MM-DD HH:MM:SS（从公元1000年<del>公元9999年）<br>timestamp：4个字节，存储年月日+时分秒，格式：YYYY-MM-DD HH:MM:SS（从公元1980年</del>公元2040年）或者格式为 YYYYMMDDHHMMSS（采用这种格式不需要使用单引号，当然你使用单引号也可以）</p><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><h3 id="char"><a href="#char" class="headerlink" title="char"></a>char</h3><p><strong>char(m)：</strong>m长度是0~255个字符。<br>固定长度字符串，在定义时指定字符串列长。当保存时，在右侧填充空格以达到指定的长度。m表示列的长度，范围是 0～255 个字符。<br>例如，CHAR(4) 定义了一个固定长度的字符串列，包含的字符个数最大为 4。当插入的字符长度大于4，则报错（除非超过4个长度之后都是空格字符，则空格字符会自动被删除用来保证插入的成功）。</p><h3 id="varchar"><a href="#varchar" class="headerlink" title="varchar"></a>varchar</h3><p><strong>varchar(m)：</strong>m长度是0~16383个字符<br>长度可变的字符串。varchar 的最大实际长度由最长的行的大小和使用的字符集确定，而实际占用的空间为字符串的实际长度加 1。<br>例如，varchar(50) 定义了一个最大长度为 50 的字符串，如果插入的字符串只有 10 个字符，则实际存储的字符串为 10 个字符和一个字符串结束字符。varchar在值保存和检索时尾部的空格仍保留。<br><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250701072008930.png"></p><h3 id="text"><a href="#text" class="headerlink" title="text"></a>text</h3><p><strong>text类型：</strong></p><ul><li>tinytext 表示长度为 255字符的 TEXT 列。</li><li>text 表示长度为 65535字符的 TEXT 列。</li><li>mediumtext 表示长度为 16777215字符的 TEXT 列。</li><li>longtext 表示长度为 4294967295 或 4GB 字符的 TEXT 列。<h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3></li></ul><p><strong>enum类型：</strong></p><ul><li><p>语法：&lt;字段名&gt; enum(‘值1’,’值2’,…)</p></li><li><p>该字段插入值时，只能是指定的枚举值。</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250701080656297.png" alt="image-20250701080656297"></p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3></li></ul><p><strong>set类型：</strong></p><ul><li><p>语法：&lt;字段名&gt; set(‘值1’,’值2’,’值3’,…)   注意：值不可重复。</p></li><li><p>该字段插入值时，只能是指定的值。</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250701080722000.png" alt="image-20250701080722000"></p></li></ul><h2 id="二进制类型"><a href="#二进制类型" class="headerlink" title="二进制类型"></a>二进制类型</h2><p>BLOB（Binary Large Object）类型：二进制大对象，可以存储图片、声音、视频等文件。</p><ul><li>blob：小的，最大长度65535个字节</li><li>mediumblob：中等的，最大长度16777215个字节</li><li>longblob：大的，最大长度4GB的字节<h1 id="增删改表结构DDL"><a href="#增删改表结构DDL" class="headerlink" title="增删改表结构DDL"></a>增删改表结构DDL</h1><h2 id="创建一个学生表"><a href="#创建一个学生表" class="headerlink" title="创建一个学生表"></a>创建一个学生表</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_student(<br>  <span class="hljs-keyword">no</span> <span class="hljs-built_in">bigint</span>,<br>  <span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>),<br>  age <span class="hljs-built_in">int</span> <span class="hljs-keyword">comment</span> <span class="hljs-string">'年龄'</span><br>);<br></code></pre></td></tr></tbody></table></figure><h2 id="查看建表语句"><a href="#查看建表语句" class="headerlink" title="查看建表语句"></a>查看建表语句</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名;<br></code></pre></td></tr></tbody></table></figure><h2 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">rename</span> 新表名;<br></code></pre></td></tr></tbody></table></figure><h2 id="新增字段"><a href="#新增字段" class="headerlink" title="新增字段"></a>新增字段</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span> 字段名 数据类型;<br></code></pre></td></tr></tbody></table></figure><h2 id="修改字段名"><a href="#修改字段名" class="headerlink" title="修改字段名"></a>修改字段名</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">change</span> 旧字段名 新字段名 数据类型;<br></code></pre></td></tr></tbody></table></figure><h2 id="修改字段数据类型"><a href="#修改字段数据类型" class="headerlink" title="修改字段数据类型"></a>修改字段数据类型</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">modify</span> <span class="hljs-keyword">column</span> 字段名 数据类型;<br></code></pre></td></tr></tbody></table></figure><h2 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">drop</span> 字段名;<br></code></pre></td></tr></tbody></table></figure></li></ul><h1 id="DML语句"><a href="#DML语句" class="headerlink" title="DML语句"></a>DML语句</h1><p>当我们对表中的数据进行增删改的时候，称它为DML语句。（数据操纵语言），主要包括：insert、delete、update</p><h2 id="insert-增"><a href="#insert-增" class="headerlink" title="insert 增"></a>insert 增</h2><p>语法格式：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> 表名(字段名<span class="hljs-number">1</span>,字段名<span class="hljs-number">2</span>,字段名<span class="hljs-number">3</span>,...) <span class="hljs-keyword">values</span>(值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,值<span class="hljs-number">3</span>,...);<br></code></pre></td></tr></tbody></table></figure><p>表名后面的小括号当中的字段名如果省略掉，表示自动将所有字段都列出来了，并且字段的顺序和建表时的顺序一致。<br>一般为了可读性强，建议把字段名写上。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> 表名 <span class="hljs-keyword">values</span>(值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,值<span class="hljs-number">3</span>,...);<br></code></pre></td></tr></tbody></table></figure><p>一次可以插入多条记录：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_stu(<span class="hljs-keyword">no</span>,<span class="hljs-keyword">name</span>,age) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">'jack'</span>,<span class="hljs-number">20</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">'lucy'</span>,<span class="hljs-number">30</span>);<br></code></pre></td></tr></tbody></table></figure><h2 id="delete-删"><a href="#delete-删" class="headerlink" title="delete 删"></a>delete 删</h2><p>语法格式：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment"># 将所有记录全部删除</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名;<br><br><span class="hljs-comment"># 删除符合条件的记录</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">where</span> 条件;<br></code></pre></td></tr></tbody></table></figure><p>以上的删除属于DML的方式删除，这种删除的数据是可以通过事务回滚的方式重新恢复的，但是删除的效率较低。（这种删除是支持事务的。）<br>另外还有一种删除表中数据的方式，但是这种方式不支持事务，不可以回滚，删了之后数据是永远也找不回来了。这种删除叫做：表被截断。<br>注意：这个语句删除效率非常高，巨大的表，瞬间干掉所有数据。但不可恢复。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">truncate</span> <span class="hljs-keyword">table</span> 表名;<br></code></pre></td></tr></tbody></table></figure><h2 id="update-改"><a href="#update-改" class="headerlink" title="update 改"></a>update 改</h2><p>语法格式：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> 表名 <span class="hljs-keyword">set</span> 字段名<span class="hljs-number">1</span>=值<span class="hljs-number">1</span>, 字段名<span class="hljs-number">2</span>=值<span class="hljs-number">2</span>, 字段名<span class="hljs-number">3</span>=值<span class="hljs-number">3</span> <span class="hljs-keyword">where</span> 条件;<br></code></pre></td></tr></tbody></table></figure><p>如果没有更新条件的话，所有记录全部更新。</p><h1 id="约束constraint"><a href="#约束constraint" class="headerlink" title="约束constraint"></a>约束constraint</h1><p>创建表时，可以给表的字段添加约束，可以保证数据的完整性、有效性。比如大家上网注册用户时常见的：用户名不能为空。对不起，用户名已存在。等提示信息。<br>约束通常包括：</p><ul><li>非空约束：not null</li><li>检查约束：check</li><li>唯一性约束：unique</li><li>主键约束：primary key</li><li>外键约束：foreign key<h2 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h2>语法格式：<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_stu(<br>  <span class="hljs-keyword">no</span> <span class="hljs-built_in">int</span>,<br>  <span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>,<br>  age <span class="hljs-built_in">int</span><br>);<br></code></pre></td></tr></tbody></table></figure>name字段不能为空。插入数据时如果没有给name指定值，则报错。</li></ul><h2 id="检查约束"><a href="#检查约束" class="headerlink" title="检查约束"></a>检查约束</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_stu(<br>  <span class="hljs-keyword">no</span> <span class="hljs-built_in">int</span>,<br>  <span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>),<br>  age <span class="hljs-built_in">int</span>,<br>  <span class="hljs-keyword">check</span>(age &gt; <span class="hljs-number">18</span>)<br>);<br></code></pre></td></tr></tbody></table></figure><h2 id="唯一性约束"><a href="#唯一性约束" class="headerlink" title="唯一性约束"></a>唯一性约束</h2><p>语法格式：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_stu(<br>  <span class="hljs-keyword">no</span> <span class="hljs-built_in">int</span>,<br>  <span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>),<br>  email <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">unique</span><br>);<br></code></pre></td></tr></tbody></table></figure><p>email字段设置为唯一性，唯一性的字段值是可以为NULL的。但不能重复。以上在字段后面添加的约束，叫做列级约束。<br>当然，添加约束还有另一种方式：表级约束：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_stu(<br>  <span class="hljs-keyword">no</span> <span class="hljs-built_in">int</span>,<br>  <span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>),<br>  email <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>),<br>  <span class="hljs-keyword">unique</span>(email)<br>);<br></code></pre></td></tr></tbody></table></figure><p>使用表级约束可以为多个字段添加联合唯一。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_stu(<br>  <span class="hljs-keyword">no</span> <span class="hljs-built_in">int</span>,<br>  <span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>),<br>  email <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>),<br>  <span class="hljs-keyword">unique</span>(<span class="hljs-keyword">name</span>,email)<br>);<br></code></pre></td></tr></tbody></table></figure><p>创建约束时也可以给约束起名字，将来可以通过约束的名字来删除约束：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_stu(<br>  <span class="hljs-keyword">no</span> <span class="hljs-built_in">int</span>,<br>  <span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>),<br>  email <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>),<br>  <span class="hljs-keyword">constraint</span> t_stu_name_email_unique <span class="hljs-keyword">unique</span>(<span class="hljs-keyword">name</span>,email)<br>);<br></code></pre></td></tr></tbody></table></figure><p>所有的约束都存储在一个系统表当中：table_constraints。这个系统表在这个数据库当中：information_schema</p><h2 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h2><ol><li><p>主键：primary key，简称PK</p></li><li><p>主键约束的字段不能为NULL，并且不能重复。</p></li><li><p>任何一张表都应该有主键，没有主键的表可以视为无效表。</p></li><li><p>主键值是这行记录的身份证号，是唯一标识。在数据库表中即使两条数据一模一样，但由于主键值不同，我们也会认为是两条完全的不同的数据。</p></li><li><p>主键分类：</p><ol><li>根据字段数量分类：<ol><li>单一主键（1个字段作为主键）==&gt;建议的</li><li>复合主键（2个或2个以上的字段作为主键）</li></ol></li><li>根据业务分类：<ol><li>自然主键（主键和任何业务都无关，只是一个单纯的自然数据）===&gt;建议的</li><li>业务主键（主键和业务挂钩，例如：银行卡账号作为主键）</li></ol></li></ol></li><li><p>单一主键（建议使用这种方式）</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_student(<br>  <span class="hljs-keyword">id</span> <span class="hljs-built_in">bigint</span> primary <span class="hljs-keyword">key</span>,<br>  sno <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">unique</span>,<br>  sname <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span><br>)<br></code></pre></td></tr></tbody></table></figure></li><li><p>复合主键（很少用，了解）</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_user(<br>  <span class="hljs-keyword">no</span> <span class="hljs-built_in">int</span>,<br>  <span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>),<br>  age <span class="hljs-built_in">int</span>,<br>  primary <span class="hljs-keyword">key</span>(<span class="hljs-keyword">no</span>,<span class="hljs-keyword">name</span>)<br>);<br></code></pre></td></tr></tbody></table></figure></li><li><p>主键自增：既然主键值是一个自然的数字，mysql为主键值提供了一种自增机制，不需要我们程序员维护，mysql自动维护该字段</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_vip(<br>  <span class="hljs-keyword">no</span> <span class="hljs-built_in">int</span> primary <span class="hljs-keyword">key</span> auto_increment,<br>  <span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>)<br>);<br></code></pre></td></tr></tbody></table></figure></li></ol><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><ol><li>有这样一个需求：要求设计表，能够存储学生以及学校信息。<ol><li>第一种方案：一张表</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250701071955954.png"><br>这种方式会导致数据冗余，浪费空间。</p><ol start="2"><li>第二种方案：两张表：一张存储学生，一张存储学校</li></ol><p>t_school 表<br><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250701071952148.png"><br>t_student 表<br><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250701071948405.png"><br>如果采用以上两张表存储数据，对于学生表来说，sno这个字段的值是不能随便填的，这个sno是学校编号，必须要求这个字段中的值来自学校表的sno。<br>为了达到要求，此时就必须要给t_student表的sno字段添加外键约束了。</p><ol start="2"><li>外键约束：foreign key，简称FK。</li><li>添加了外键约束的字段中的数据必须来自其他字段，不能随便填。</li><li>假设给a字段添加了外键约束，要求a字段中的数据必须来自b字段，b字段不一定是主键，但至少要有唯一性。</li><li>外键约束可以给单个字段添加，叫做单一外键。也可以给多个字段联合添加，叫做复合外键。复合外键很少用。</li><li>a表如果引用b表中的数据，可以把b表叫做父表，把a表叫做子表。<ol><li>创建表时，先创建父表，再创建子表。</li><li>插入数据时，先插入父表，在插入子表。</li><li>删除数据时，先删除子表，再删除父表。</li><li>删除表时，先删除子表，再删除父表。</li></ol></li><li>如何添加外键：<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_school( <br>  sno <span class="hljs-built_in">int</span> primary <span class="hljs-keyword">key</span>, <br>  sname <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <br>); <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_student( <br>  <span class="hljs-keyword">no</span> <span class="hljs-built_in">int</span> primary <span class="hljs-keyword">key</span>, <br>  <span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>), <br>  age <span class="hljs-built_in">int</span>, <br>  sno <span class="hljs-built_in">int</span>, <br>  <span class="hljs-keyword">constraint</span> t_school_sno_fk <span class="hljs-keyword">foreign</span> <span class="hljs-keyword">key</span>(sno) <span class="hljs-keyword">references</span> t_school(sno) <br>);<br></code></pre></td></tr></tbody></table></figure></li></ol><ol start="8"><li>级联删除</li></ol><p>创建子表时，外键可以添加：on delete cascade，这样在删除父表数据时，子表会级联删除。谨慎使用。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_student( <br>  <span class="hljs-keyword">no</span> <span class="hljs-built_in">int</span> primary <span class="hljs-keyword">key</span>, <br>  <span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>), <br>  age <span class="hljs-built_in">int</span>, <br>  sno <span class="hljs-built_in">int</span>, <br>  <span class="hljs-keyword">constraint</span> t_school_sno_fk <span class="hljs-keyword">foreign</span> <span class="hljs-keyword">key</span>(sno) <span class="hljs-keyword">references</span> t_school(sno) <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> <span class="hljs-keyword">cascade</span> <br>);<br></code></pre></td></tr></tbody></table></figure><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">###删除约束</span><br>alert table t_student <span class="hljs-keyword">drop</span> <span class="hljs-keyword">foreign</span> <span class="hljs-keyword">key</span> t_student_sno_fk;<br><span class="hljs-comment">###添加约束</span><br>alert table t_student add constraint t_student_sno_fk foreign key(sno) references t_school(sno) on <span class="hljs-keyword">delete</span> <span class="hljs-keyword">cascade</span>;<br></code></pre></td></tr></tbody></table></figure><ol start="9"><li><p>级联更新 </p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_student( <br>  <span class="hljs-keyword">no</span> <span class="hljs-built_in">int</span> primary <span class="hljs-keyword">key</span>, <br>  <span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>), <br>  age <span class="hljs-built_in">int</span>, <br>  sno <span class="hljs-built_in">int</span>, <br>  <span class="hljs-keyword">constraint</span> t_school_sno_fk <span class="hljs-keyword">foreign</span> <span class="hljs-keyword">key</span>(sno) <span class="hljs-keyword">references</span> t_school(sno) <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> <span class="hljs-keyword">cascade</span> <br>);<br></code></pre></td></tr></tbody></table></figure></li><li><p>级联置空</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_student( <br>  <span class="hljs-keyword">no</span> <span class="hljs-built_in">int</span> primary <span class="hljs-keyword">key</span>, <br>  <span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>), <br>  age <span class="hljs-built_in">int</span>, <br>  sno <span class="hljs-built_in">int</span>, <br>  <span class="hljs-keyword">constraint</span> t_school_sno_fk <span class="hljs-keyword">foreign</span> <span class="hljs-keyword">key</span>(sno) <span class="hljs-keyword">references</span> t_school(sno) <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> <span class="hljs-keyword">set</span> <span class="hljs-literal">null</span> <br>);<br></code></pre></td></tr></tbody></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;创建表&quot;&gt;&lt;a href=&quot;#创建表&quot; class=&quot;headerlink&quot; title=&quot;创建表&quot;&gt;&lt;/a&gt;创建表&lt;/h1&gt;&lt;p&gt;语法格式：&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;table&lt;/span&gt; 表名(&lt;br&gt;  字段名&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; 数据类型,&lt;br&gt;  字段名&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; 数据类型,&lt;br&gt;  字段名&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; 数据类型,&lt;br&gt;  ......&lt;br&gt;);&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;例如：创建学生表&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;table&lt;/span&gt; t_student(&lt;br&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;no&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;,&lt;br&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;varchar&lt;/span&gt;,&lt;br&gt;  gender &lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#39;男&#39;&lt;/span&gt;&lt;br&gt;);&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h1 id=&quot;插入数据&quot;&gt;&lt;a href=&quot;#插入数据&quot; class=&quot;headerlink&quot; title=&quot;插入数据&quot;&gt;&lt;/a&gt;插入数据&lt;/h1&gt;&lt;p&gt;语法格式：&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;into&lt;/span&gt; 表名(字段名&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, 字段名&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, 字段名&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,......) &lt;span class=&quot;hljs-keyword&quot;&gt;values&lt;/span&gt; (值&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,值&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,值&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,......);&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;字段名和值要一一对应。类型要一一对应，数量要一一对应。&lt;br&gt;字段名也可以省略，如果字段名省略就表示把所有字段名都写上去了，并且顺序和建表时的顺序相同。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="https://xiaofanshutu.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL数据库概述</title>
    <link href="https://xiaofanshutu.github.io/posts/ca9a1c2c.html"/>
    <id>https://xiaofanshutu.github.io/posts/ca9a1c2c.html</id>
    <published>2025-06-29T23:08:23.981Z</published>
    <updated>2025-06-29T23:37:55.231Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是数据库"><a href="#什么是数据库" class="headerlink" title="什么是数据库"></a>什么是数据库</h1><ul><li>数据库是一门独立的学科，只要是做软件开发的，数据库都要学。</li><li>数据库（电子化的文件柜）是“按照数据结构来组织、存储和管理数据的仓库”。是一个长期存储在计算机内的、有组织的、可共享的、统一管理的大量数据的集合。</li><li>它的存储空间很大，可以存放百万条、千万条、上亿条数据。</li><li>数据库并不是随意地将数据进行存放，是有一定的规则的，否则查询的效率会很低。</li><li>当今世界是一个充满着数据的互联网世界，充斥着大量的数据。即这个互联网世界就是数据世界。数据的来源有很多，比如出行记录、消费记录、浏览的网页、发送的消息等等。除了文本类型的数据，图像、音乐、声音都是数据。</li><li>数据库对应的英文单词是DataBase，简称DB。</li></ul><h1 id="数据库类型"><a href="#数据库类型" class="headerlink" title="数据库类型"></a>数据库类型</h1><ul><li>关系型数据库<ul><li>关系型数据库是依据关系模型来创建的数据库。所谓关系模型就是“一对一、一对多、多对多”等关系模型，关系模型就是指二维表格模型，因而一个关系型数据库就是由二维表及其之间的联系组成的一个数据组织。</li><li>关系型数据可以很好地存储一些关系模型的数据，比如一个老师对应多个学生的数据（“多对多”），一本书对应多个作者（“一对多”），一本书对应一个出版日期（“一对一”）。</li><li>关系模型包括数据结构（数据存储的问题，二维表）、操作指令集合（SQL语句）、完整性约束(表内数据约束、表与表之间的约束)。</li></ul></li><li>非关系型数据库（NoSQL）<ul><li>NoSQL，泛指非关系型的数据库。随着互联网web2.0网站的兴起，传统的关系数据库在处理web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，出现了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。</li><li>NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，特别是大数据应用难题。NoSQL最常见的解释是“non-relational”， “Not Only SQL”也被很多人接受。</li><li>NoSQL仅仅是一个概念，泛指非关系型的数据库，区别于关系数据库，它们不保证关系数据的ACID特性。NoSQL是一项全新的数据库革命性运动，其拥护者们提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入。</li><li>NoSQL有如下优点：易扩展，NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。无形之间也在架构的层面上带来了可扩展的能力。大数据量，高性能，NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单。<h1 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h1></li></ul></li></ul><ul><li>数据库管理系统（Database Management System，简称DBMS）是为管理数据库而设计的电脑软件系统，一般具有存储、截取、安全保障、备份等基础功能。</li><li>数据库管理系统是数据库系统的核心组成部分，主要完成对数据库的操作与管理功能，实现数据库对象的创建、数据库存储数据的查询、添加、修改与删除操作和数据库的用户管理、权限管理等。</li><li>常见的数据库管理系统有：MySQL、Oracle、DB2、MS SQL Server、SQLite、PostgreSQL、Sybase等。</li></ul><h1 id="什么是SQL"><a href="#什么是SQL" class="headerlink" title="什么是SQL"></a>什么是SQL</h1><ul><li>结构化查询语言（Structured Query Language）简称SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。</li><li>结构化查询语言是高级的非过程化编程语言，允许用户在高层数据结构上工作。它不要求用户指定对数据的存放方法，也不需要用户了解具体的数据存放方式，所以具有完全不同底层结构的不同数据库系统, 可以使用相同的结构化查询语言作为数据输入与管理的接口。结构化查询语言语句可以嵌套，这使它具有极大的灵活性和强大的功能。</li><li>SQL的分类<ul><li>DQL<ul><li>数据查询语言（Data Query Language, DQL）是SQL语言中，负责进行数据查询而不会对数据本身进行修改的语句，这是最基本的SQL语句。保留字SELECT是DQL（也是所有SQL）用得最多的动词，其他DQL常用的保留字有FROM，WHERE，GROUP BY，HAVING和ORDER BY。这些DQL保留字常与其他类型的SQL语句一起使用。</li></ul></li><li>DDL<ul><li>数据定义语言 (Data Definition Language, DDL) 是SQL语言集中，负责数据结构定义与数据库对象定义的语言，由CREATE、ALTER与DROP三个语法所组成，最早是由 Codasyl (Conference on Data Systems Languages) 数据模型开始，现在被纳入 SQL 指令中作为其中一个子集。</li></ul></li><li>DML<ul><li>数据操纵语言（Data Manipulation Language, DML）是SQL语言中，负责对数据库对象运行数据访问工作的指令集，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入、更新与删除。</li></ul></li><li>DCL<ul><li>数据控制语言 (Data Control Language) 在SQL语言中，是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。由 GRANT 和 REVOKE 两个指令组成。DCL以控制用户的访问权限为主，GRANT为授权语句，对应的REVOKE是撤销授权语句。</li></ul></li><li>TPL<ul><li>数据事务管理语言（Transaction Processing Language）它的语句能确保被DML语句影响的表的所有行及时得以更新。TPL语句包括BEGIN TRANSACTION，COMMIT和ROLLBACK。</li></ul></li><li>CCL<ul><li>指针控制语言（Cursor Control Language），它的语句，像DECLARE CURSOR，FETCH INTO和UPDATE WHERE CURRENT用于对一个或多个表单独行的操作。</li></ul></li></ul></li><li>DBMS、SQL、DB之间的关系<ul><li>DBMS通过执行SQL来操作DB中的数据。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;什么是数据库&quot;&gt;&lt;a href=&quot;#什么是数据库&quot; class=&quot;headerlink&quot; title=&quot;什么是数据库&quot;&gt;&lt;/a&gt;什么是数据库&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;数据库是一门独立的学科，只要是做软件开发的，数据库都要学。&lt;/li&gt;
&lt;li&gt;数据库（电子化的文件柜）是“按照数据结构来组织、存储和管理数据的仓库”。是一个长期存储在计算机内的、有组织的、可共享的、统一管理的大量数据的集合。&lt;/li&gt;
&lt;li&gt;它的存储空间很大，可以存放百万条、千万条、上亿条数据。&lt;/li&gt;
&lt;li&gt;数据库并不是随意地将数据进行存放，是有一定的规则的，否则查询的效率会很低。&lt;/li&gt;
&lt;li&gt;当今世界是一个充满着数据的互联网世界，充斥着大量的数据。即这个互联网世界就是数据世界。数据的来源有很多，比如出行记录、消费记录、浏览的网页、发送的消息等等。除了文本类型的数据，图像、音乐、声音都是数据。&lt;/li&gt;
&lt;li&gt;数据库对应的英文单词是DataBase，简称DB。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;数据库类型&quot;&gt;&lt;a href=&quot;#数据库类型&quot; class=&quot;headerlink&quot; title=&quot;数据库类型&quot;&gt;&lt;/a&gt;数据库类型&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;关系型数据库&lt;ul&gt;
&lt;li&gt;关系型数据库是依据关系模型来创建的数据库。所谓关系模型就是“一对一、一对多、多对多”等关系模型，关系模型就是指二维表格模型，因而一个关系型数据库就是由二维表及其之间的联系组成的一个数据组织。&lt;/li&gt;
&lt;li&gt;关系型数据可以很好地存储一些关系模型的数据，比如一个老师对应多个学生的数据（“多对多”），一本书对应多个作者（“一对多”），一本书对应一个出版日期（“一对一”）。&lt;/li&gt;
&lt;li&gt;关系模型包括数据结构（数据存储的问题，二维表）、操作指令集合（SQL语句）、完整性约束(表内数据约束、表与表之间的约束)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;非关系型数据库（NoSQL）&lt;ul&gt;
&lt;li&gt;NoSQL，泛指非关系型的数据库。随着互联网web2.0网站的兴起，传统的关系数据库在处理web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，出现了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。&lt;/li&gt;
&lt;li&gt;NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，特别是大数据应用难题。NoSQL最常见的解释是“non-relational”， “Not Only SQL”也被很多人接受。&lt;/li&gt;
&lt;li&gt;NoSQL仅仅是一个概念，泛指非关系型的数据库，区别于关系数据库，它们不保证关系数据的ACID特性。NoSQL是一项全新的数据库革命性运动，其拥护者们提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入。&lt;/li&gt;
&lt;li&gt;NoSQL有如下优点：易扩展，NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。无形之间也在架构的层面上带来了可扩展的能力。大数据量，高性能，NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单。&lt;h1 id=&quot;数据库管理系统&quot;&gt;&lt;a href=&quot;#数据库管理系统&quot; class=&quot;headerlink&quot; title=&quot;数据库管理系统&quot;&gt;&lt;/a&gt;数据库管理系统&lt;/h1&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;数据库管理系统（Database Management System，简称DBMS）是为管理数据库而设计的电脑软件系统，一般具有存储、截取、安全保障、备份等基础功能。&lt;/li&gt;
&lt;li&gt;数据库管理系统是数据库系统的核心组成部分，主要完成对数据库的操作与管理功能，实现数据库对象的创建、数据库存储数据的查询、添加、修改与删除操作和数据库的用户管理、权限管理等。&lt;/li&gt;
&lt;li&gt;常见的数据库管理系统有：MySQL、Oracle、DB2、MS SQL Server、SQLite、PostgreSQL、Sybase等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;什么是SQL&quot;&gt;&lt;a href=&quot;#什么是SQL&quot; class=&quot;headerlink&quot; title=&quot;什么是SQL&quot;&gt;&lt;/a&gt;什么是SQL&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;结构化查询语言（Structured Query Language）简称SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。&lt;/li&gt;
&lt;li&gt;结构化查询语言是高级的非过程化编程语言，允许用户在高层数据结构上工作。它不要求用户指定对数据的存放方法，也不需要用户了解具体的数据存放方式，所以具有完全不同底层结构的不同数据库系统, 可以使用相同的结构化查询语言作为数据输入与管理的接口。结构化查询语言语句可以嵌套，这使它具有极大的灵活性和强大的功能。&lt;/li&gt;
&lt;li&gt;SQL的分类&lt;ul&gt;
&lt;li&gt;DQL&lt;ul&gt;
&lt;li&gt;数据查询语言（Data Query Language, DQL）是SQL语言中，负责进行数据查询而不会对数据本身进行修改的语句，这是最基本的SQL语句。保留字SELECT是DQL（也是所有SQL）用得最多的动词，其他DQL常用的保留字有FROM，WHERE，GROUP BY，HAVING和ORDER BY。这些DQL保留字常与其他类型的SQL语句一起使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DDL&lt;ul&gt;
&lt;li&gt;数据定义语言 (Data Definition Language, DDL) 是SQL语言集中，负责数据结构定义与数据库对象定义的语言，由CREATE、ALTER与DROP三个语法所组成，最早是由 Codasyl (Conference on Data Systems Languages) 数据模型开始，现在被纳入 SQL 指令中作为其中一个子集。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DML&lt;ul&gt;
&lt;li&gt;数据操纵语言（Data Manipulation Language, DML）是SQL语言中，负责对数据库对象运行数据访问工作的指令集，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入、更新与删除。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DCL&lt;ul&gt;
&lt;li&gt;数据控制语言 (Data Control Language) 在SQL语言中，是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。由 GRANT 和 REVOKE 两个指令组成。DCL以控制用户的访问权限为主，GRANT为授权语句，对应的REVOKE是撤销授权语句。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TPL&lt;ul&gt;
&lt;li&gt;数据事务管理语言（Transaction Processing Language）它的语句能确保被DML语句影响的表的所有行及时得以更新。TPL语句包括BEGIN TRANSACTION，COMMIT和ROLLBACK。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CCL&lt;ul&gt;
&lt;li&gt;指针控制语言（Cursor Control Language），它的语句，像DECLARE CURSOR，FETCH INTO和UPDATE WHERE CURRENT用于对一个或多个表单独行的操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DBMS、SQL、DB之间的关系&lt;ul&gt;
&lt;li&gt;DBMS通过执行SQL来操作DB中的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</summary>
    
    
    
    <category term="MySQL" scheme="https://xiaofanshutu.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL数据库安装</title>
    <link href="https://xiaofanshutu.github.io/posts/1bbb3b3c.html"/>
    <id>https://xiaofanshutu.github.io/posts/1bbb3b3c.html</id>
    <published>2025-06-29T23:08:23.981Z</published>
    <updated>2025-06-30T14:07:52.359Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySQL概述"><a href="#MySQL概述" class="headerlink" title="MySQL概述"></a>MySQL概述</h1><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630215621242.png" alt="image-20250630215621242"></p><ul><li>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，MySQL AB公司被Sun公司收购，Sun公司又被Oracle公司收购，目前属于Oracle公司。</li><li>MySQL是目前最流行的关系型数据库管理系统，在WEB应用方面MySQL是最好的RDBMS应用软件之一。 国内淘宝网站就使用的是MySQL集群。</li><li>MySQL特点<ul><li>MySQL有开源版本和收费版本，你使用开源版本是不收费的。</li><li>MySQL支持大型数据库，可以处理上千万记录的大型数据库。</li><li>MySQL使用标准的SQL数据库语言形式。</li><li>MySQL在很多系统上面都支持。</li><li>MySQL对Java，C都有很好的支持，当然其他的语言也支持比如Python、PHP。</li><li>MySQL是可以定制的，采用了GPL协议，你可以修改源码来开发自己的MySQL系统。</li></ul></li></ul><h1 id="MySQL的下载"><a href="#MySQL的下载" class="headerlink" title="MySQL的下载"></a>MySQL的下载</h1><h2 id="官网下载"><a href="#官网下载" class="headerlink" title="官网下载"></a>官网下载</h2><ul><li>第一步：打开MySQL官网<a href="https://www.mysql.com/">https://www.mysql.com/</a></li></ul><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630215717943.png" alt="image-20250630215717943"></p><ul><li>第二步：点击”DOWNLOADS”</li></ul><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630220059394.png" alt="image-20250630220059394"></p><ul><li>第三步：当前页继续下拉，直到找到下图链接</li></ul><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630220645283.png" alt="image-20250630220645283"></p><ul><li>第四步：点击上图链接，进入下面页面，其中“MySQL Community Server”是解压版mysql，“MySQL Installer for Windows”是安装版，这里我们选择解压版</li></ul><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630220635582.png" alt="image-20250630220635582"></p><ul><li>第五步：点击上图“MySQL Community Server”</li></ul><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630220628384.png" alt="image-20250630220628384"></p><ul><li>第六步：点击上图第1个“Download”</li></ul><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630220621251.png" alt="image-20250630220621251"></p><ul><li>第七步：点击上图“No thanks, just start my download.”开始下载，直到下载完毕。</li></ul><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630220612749.png" alt="image-20250630220612749"></p><h2 id="网盘下载"><a href="#网盘下载" class="headerlink" title="网盘下载"></a>网盘下载</h2><p>链接：<a href="https://pan.baidu.com/s/1lRWC069K8GE-8rxr259ArQ?pwd=2009">https://pan.baidu.com/s/1lRWC069K8GE-8rxr259ArQ?pwd=2009</a> 提取码：2009</p><h1 id="MySQL安装与配置"><a href="#MySQL安装与配置" class="headerlink" title="MySQL安装与配置"></a>MySQL安装与配置</h1><ul><li>将下载的zip压缩包解压，我这里直接解压到C盘的根目录下</li></ul><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630220604822.png" alt="image-20250630220604822"></p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630220548051.png" alt="image-20250630220548051"></p><p>mysql的根目录为：C:\mysql-8.0.24-winx64</p><ul><li>将C:\mysql-8.0.24-winx64\bin目录配置到环境变量path当中</li></ul><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630220536490.png" alt="image-20250630220536490"></p><ul><li>初始化data目录</li></ul><p>使用管理员身份打开dos命令窗口（按win键，输入cmd，点击管理员身份运行）</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630220529460.png" alt="image-20250630220529460"></p><p>cd命令切换到mysql的bin目录下，执行mysqld –initialize –console进行data目录初始化，此时会在控制台生成一个随机密码，下图红框中就是随机密码</p><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630220520282.png" alt="image-20250630220520282"></p><p>技巧：左键选中密码，直接点击右键，此时密码已经复制到剪贴板中了，<br>然后随便找一个文件，将密码粘贴到文件中保存起来。</p><ul><li>安装MySQL服务：cd命令切换到bin目录下，执行命令mysqld -install</li></ul><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630220508206.png" alt="image-20250630220508206"></p><ul><li>查看mysql服务名称：此电脑-右键-管理-服务和应用程序-服务-找MySQL服务，如下图mysql服务名称：MySQL</li></ul><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630220501421.png" alt="image-20250630220501421"></p><ul><li>启动MySQL服务：net start mysql，注意start后面是mysql服务的名称</li></ul><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630220453540.png" alt="image-20250630220453540"></p><p>停止mysql服务的命令：net stop mysql<br>注意：启停mysql服务也可以在上一步的图中点击右键进行启停服务。</p><ul><li>登录mysql：输入mysql -uroot -p，然后回车，输入刚才的随机密码，然后回车，看到下图表示成功登录mysql</li></ul><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630220441823.png" alt="image-20250630220441823"></p><ul><li>修改MySQL的root账户密码：ALTER USER ‘root’@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘新密码’;</li></ul><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630220435007.png" alt="image-20250630220435007"></p><ul><li>使用新密码登录mysql</li></ul><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630220426928.png" alt="image-20250630220426928"></p><h1 id="MySQL卸载"><a href="#MySQL卸载" class="headerlink" title="MySQL卸载"></a>MySQL卸载</h1><ul><li>停止mysql的服务</li></ul><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630220419488.png" alt="image-20250630220419488"></p><ul><li>删除mysql服务</li></ul><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630220410118.png" alt="image-20250630220410118"></p><ul><li>删除mysql的目录</li></ul><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630220402191.png" alt="image-20250630220402191"></p><h1 id="登录MySQL"><a href="#登录MySQL" class="headerlink" title="登录MySQL"></a>登录MySQL</h1><h2 id="本地登录"><a href="#本地登录" class="headerlink" title="本地登录"></a>本地登录</h2><ul><li>如果mysql的服务是启动的，打开dos命令窗口，输入：mysql -uroot -p，回车，然后输入root账户的密码</li></ul><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630220345579.png" alt="image-20250630220345579"></p><p>解释“mysql -uroot -p”：<br>mysql是一个命令，在bin目录下，对应的命令文件是mysql.exe，如果将bin目录配置到环境<br>变量path中，才可以在以上位置使用该命令。<br>-uroot 表示登录的用户是root，u实际上是user单词的首字母。<br>-p 表示登录时使用密码，p实际上是password单词的首字母。</p><ul><li>也可以将密码以明文的形式写到-p后面，这样做可能会导致你的密码泄露</li></ul><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630220335977.png" alt="image-20250630220335977"></p><h2 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h2><ul><li>假设mysql安装在A机器上，现在你要在B机器上连接mysql数据库，此时需要使用远程登录，远程登录时加上远程机器的ip地址即可</li></ul><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630220318198.png" alt="image-20250630220318198"></p><p>-h中的h实际上是host单词的首字母。在-h后面的是远程计算机的ip地址。<br>127.0.0.1是计算机默认的本机IP地址。<br>127.0.0.1又可以写作：localhost，他们是等效的。<br>注意：mysql默认情况下root账户是不支持远程登录的，其实这是一种安全策略，<br>为了保护root账户的安全。如果希望root账户支持远程登录，这是需要进行设置的。</p><ul><li><p>mysql8 开放root账户远程登录权限（危险动作）</p><p>第一步：现在本地使用root账户登录mysql</p><p>第二步：use mysql;</p><p>第三步：update user set host = ‘%’ where user = ‘root’;</p><p>第四步：flush privileges;</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;MySQL概述&quot;&gt;&lt;a href=&quot;#MySQL概述&quot; class=&quot;headerlink&quot; title=&quot;MySQL概述&quot;&gt;&lt;/a&gt;MySQL概述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630215621242.png&quot; alt=&quot;image-20250630215621242&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，MySQL AB公司被Sun公司收购，Sun公司又被Oracle公司收购，目前属于Oracle公司。&lt;/li&gt;
&lt;li&gt;MySQL是目前最流行的关系型数据库管理系统，在WEB应用方面MySQL是最好的RDBMS应用软件之一。 国内淘宝网站就使用的是MySQL集群。&lt;/li&gt;
&lt;li&gt;MySQL特点&lt;ul&gt;
&lt;li&gt;MySQL有开源版本和收费版本，你使用开源版本是不收费的。&lt;/li&gt;
&lt;li&gt;MySQL支持大型数据库，可以处理上千万记录的大型数据库。&lt;/li&gt;
&lt;li&gt;MySQL使用标准的SQL数据库语言形式。&lt;/li&gt;
&lt;li&gt;MySQL在很多系统上面都支持。&lt;/li&gt;
&lt;li&gt;MySQL对Java，C都有很好的支持，当然其他的语言也支持比如Python、PHP。&lt;/li&gt;
&lt;li&gt;MySQL是可以定制的，采用了GPL协议，你可以修改源码来开发自己的MySQL系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;MySQL的下载&quot;&gt;&lt;a href=&quot;#MySQL的下载&quot; class=&quot;headerlink&quot; title=&quot;MySQL的下载&quot;&gt;&lt;/a&gt;MySQL的下载&lt;/h1&gt;&lt;h2 id=&quot;官网下载&quot;&gt;&lt;a href=&quot;#官网下载&quot; class=&quot;headerlink&quot; title=&quot;官网下载&quot;&gt;&lt;/a&gt;官网下载&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;第一步：打开MySQL官网&lt;a href=&quot;https://www.mysql.com/&quot;&gt;https://www.mysql.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630215717943.png&quot; alt=&quot;image-20250630215717943&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第二步：点击”DOWNLOADS”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630220059394.png&quot; alt=&quot;image-20250630220059394&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="https://xiaofanshutu.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL初始化数据</title>
    <link href="https://xiaofanshutu.github.io/posts/f4fc1fe7.html"/>
    <id>https://xiaofanshutu.github.io/posts/f4fc1fe7.html</id>
    <published>2025-06-29T23:08:23.981Z</published>
    <updated>2025-06-30T14:17:31.084Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySQL命令行基本命令"><a href="#MySQL命令行基本命令" class="headerlink" title="MySQL命令行基本命令"></a>MySQL命令行基本命令</h1><ol><li>列出当前数据库管理系统中有哪些数据库。<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">databases</span>;<br></code></pre></td></tr></tbody></table></figure></li></ol><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630221212047.png" alt="image-20250630221212047"></p><ol start="2"><li><p>创建数据库，起名bjpowernode。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> bjpowernode1;<br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630221358468.png" alt="image-20250630221358468"></p></li><li><p> 使用bjpowernode数据库。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">use</span> bjpowernode;<br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630221518167.png" alt="image-20250630221518167"></p></li></ol><ol start="4"><li><p>查看当前用的是哪个数据库。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">database</span>();<br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630221529447.png" alt="image-20250630221529447"></p></li><li><p> 查看当前数据库中有哪些表。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">tables</span>;<br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630221541925.png" alt="image-20250630221541925"></p></li></ol><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630221552087.png" alt="image-20250630221552087"></p><ol start="6"><li><p> 删除数据库bjpowernode。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">database</span> bjpowernode;<br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630221610116.png" alt="image-20250630221610116"></p></li><li><p>退出mysql</p><ol><li>exit</li><li>quit</li><li>ctrl + c</li></ol></li><li><p>查看当前mysql版本</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">version</span>();<br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630221615405.png" alt="image-20250630221615405"><br>还可以使用mysql.exe命令来查看版本信息（在没有登录mysql之前使用）：mysql –version<br><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630221633302.png" alt="image-20250630221633302"></p></li></ol><h1 id="数据库表的概述"><a href="#数据库表的概述" class="headerlink" title="数据库表的概述"></a>数据库表的概述</h1><table><thead><tr><th>name</th><th>age</th><th>gender</th></tr></thead><tbody><tr><td>张三</td><td>20</td><td>男</td></tr><tr><td>李四</td><td>22</td><td>女</td></tr></tbody></table><ul><li>以上就是数据库表格的直观展示形式。</li><li>表格英文单词table。</li><li>表是数据库存储数据的基本单元，数据库存储数据的时候，是将数据存储在表对象当中的。为什么将数据存储在表中呢？因为表存储数据非常直观。</li><li>任何一张表都有行和列：<ul><li>行：记录（一行就是一条数据）</li><li>列：字段（name字段、age字段、gender字段）</li></ul></li><li>每个字段包含以下属性：<ul><li>字段名：name、age、gender都是字段的名字</li><li>字段的数据类型：每个字段都有数据类型，比如：字符类型、数字类型、日期类型</li><li>字段的数据长度：每个字段有可能会有长度的限制</li><li>字段的约束：比如某些字段要求该字段下的数据不能重复、不能为空等，用来保证表格中数据合法有效</li></ul></li></ul><h1 id="初始化测试数据"><a href="#初始化测试数据" class="headerlink" title="初始化测试数据"></a>初始化测试数据</h1><p>为了方便后面内容的学习，老师提前准备了表以及表中的测试数据，以下是建表并且初始化数据的sql脚本</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> EMP;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> DEPT;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> SALGRADE;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> DEPT(DEPTNO <span class="hljs-built_in">int</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span> ,<br>DNAME <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">14</span>) ,<br>LOC <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">13</span>),<br>primary <span class="hljs-keyword">key</span> (DEPTNO)<br>);<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> EMP(EMPNO <span class="hljs-built_in">int</span>(<span class="hljs-number">4</span>)  <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span> ,<br>ENAME <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">10</span>),<br>JOB <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">9</span>),<br>MGR <span class="hljs-built_in">INT</span>(<span class="hljs-number">4</span>),<br>HIREDATE <span class="hljs-built_in">DATE</span>  <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,<br>SAL <span class="hljs-keyword">DOUBLE</span>(<span class="hljs-number">7</span>,<span class="hljs-number">2</span>),<br>COMM <span class="hljs-keyword">DOUBLE</span>(<span class="hljs-number">7</span>,<span class="hljs-number">2</span>),<br>primary <span class="hljs-keyword">key</span> (EMPNO),<br>DEPTNO <span class="hljs-built_in">INT</span>(<span class="hljs-number">2</span>) <br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> SALGRADE( GRADE <span class="hljs-built_in">INT</span>,<br>LOSAL <span class="hljs-built_in">INT</span>,<br>HISAL <span class="hljs-built_in">INT</span><br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> DEPT ( DEPTNO, DNAME, LOC ) <span class="hljs-keyword">VALUES</span> ( <span class="hljs-number">10</span>, <span class="hljs-string">'ACCOUNTING'</span>, <span class="hljs-string">'NEW YORK'</span>); <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> DEPT ( DEPTNO, DNAME, LOC ) <span class="hljs-keyword">VALUES</span> ( <span class="hljs-number">20</span>, <span class="hljs-string">'RESEARCH'</span>, <span class="hljs-string">'DALLAS'</span>); <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> DEPT ( DEPTNO, DNAME, LOC ) <span class="hljs-keyword">VALUES</span> ( <span class="hljs-number">30</span>, <span class="hljs-string">'SALES'</span>, <span class="hljs-string">'CHICAGO'</span>); <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> DEPT ( DEPTNO, DNAME, LOC ) <span class="hljs-keyword">VALUES</span> ( <span class="hljs-number">40</span>, <span class="hljs-string">'OPERATIONS'</span>, <span class="hljs-string">'BOSTON'</span>); <br> <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) <span class="hljs-keyword">VALUES</span> ( <span class="hljs-number">7369</span>, <span class="hljs-string">'SMITH'</span>, <span class="hljs-string">'CLERK'</span>, <span class="hljs-number">7902</span>,  <span class="hljs-string">'1980-12-17'</span>, <span class="hljs-number">800</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">20</span>); <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) <span class="hljs-keyword">VALUES</span> ( <span class="hljs-number">7499</span>, <span class="hljs-string">'ALLEN'</span>, <span class="hljs-string">'SALESMAN'</span>, <span class="hljs-number">7698</span>,  <span class="hljs-string">'1981-02-20'</span>, <span class="hljs-number">1600</span>, <span class="hljs-number">300</span>, <span class="hljs-number">30</span>); <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) <span class="hljs-keyword">VALUES</span> ( <span class="hljs-number">7521</span>, <span class="hljs-string">'WARD'</span>, <span class="hljs-string">'SALESMAN'</span>, <span class="hljs-number">7698</span>,  <span class="hljs-string">'1981-02-22'</span>, <span class="hljs-number">1250</span>, <span class="hljs-number">500</span>, <span class="hljs-number">30</span>); <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) <span class="hljs-keyword">VALUES</span> ( <span class="hljs-number">7566</span>, <span class="hljs-string">'JONES'</span>, <span class="hljs-string">'MANAGER'</span>, <span class="hljs-number">7839</span>,  <span class="hljs-string">'1981-04-02'</span>, <span class="hljs-number">2975</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">20</span>); <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) <span class="hljs-keyword">VALUES</span> ( <span class="hljs-number">7654</span>, <span class="hljs-string">'MARTIN'</span>, <span class="hljs-string">'SALESMAN'</span>, <span class="hljs-number">7698</span>,  <span class="hljs-string">'1981-09-28'</span>, <span class="hljs-number">1250</span>, <span class="hljs-number">1400</span>, <span class="hljs-number">30</span>); <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) <span class="hljs-keyword">VALUES</span> ( <span class="hljs-number">7698</span>, <span class="hljs-string">'BLAKE'</span>, <span class="hljs-string">'MANAGER'</span>, <span class="hljs-number">7839</span>,  <span class="hljs-string">'1981-05-01'</span>, <span class="hljs-number">2850</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">30</span>); <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) <span class="hljs-keyword">VALUES</span> ( <span class="hljs-number">7782</span>, <span class="hljs-string">'CLARK'</span>, <span class="hljs-string">'MANAGER'</span>, <span class="hljs-number">7839</span>,  <span class="hljs-string">'1981-06-09'</span>, <span class="hljs-number">2450</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">10</span>); <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) <span class="hljs-keyword">VALUES</span> ( <span class="hljs-number">7788</span>, <span class="hljs-string">'SCOTT'</span>, <span class="hljs-string">'ANALYST'</span>, <span class="hljs-number">7566</span>,  <span class="hljs-string">'1987-04-19'</span>, <span class="hljs-number">3000</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">20</span>); <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) <span class="hljs-keyword">VALUES</span> ( <span class="hljs-number">7839</span>, <span class="hljs-string">'KING'</span>, <span class="hljs-string">'PRESIDENT'</span>, <span class="hljs-literal">NULL</span>,  <span class="hljs-string">'1981-11-17'</span>, <span class="hljs-number">5000</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">10</span>); <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) <span class="hljs-keyword">VALUES</span> ( <span class="hljs-number">7844</span>, <span class="hljs-string">'TURNER'</span>, <span class="hljs-string">'SALESMAN'</span>, <span class="hljs-number">7698</span>,  <span class="hljs-string">'1981-09-08'</span>, <span class="hljs-number">1500</span>, <span class="hljs-number">0</span>, <span class="hljs-number">30</span>); <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) <span class="hljs-keyword">VALUES</span> ( <span class="hljs-number">7876</span>, <span class="hljs-string">'ADAMS'</span>, <span class="hljs-string">'CLERK'</span>, <span class="hljs-number">7788</span>,  <span class="hljs-string">'1987-05-23'</span>, <span class="hljs-number">1100</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">20</span>); <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) <span class="hljs-keyword">VALUES</span> ( <span class="hljs-number">7900</span>, <span class="hljs-string">'JAMES'</span>, <span class="hljs-string">'CLERK'</span>, <span class="hljs-number">7698</span>,  <span class="hljs-string">'1981-12-03'</span>, <span class="hljs-number">950</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">30</span>); <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) <span class="hljs-keyword">VALUES</span> ( <span class="hljs-number">7902</span>, <span class="hljs-string">'FORD'</span>, <span class="hljs-string">'ANALYST'</span>, <span class="hljs-number">7566</span>,  <span class="hljs-string">'1981-12-03'</span>, <span class="hljs-number">3000</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">20</span>); <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) <span class="hljs-keyword">VALUES</span> ( <span class="hljs-number">7934</span>, <span class="hljs-string">'MILLER'</span>, <span class="hljs-string">'CLERK'</span>, <span class="hljs-number">7782</span>,  <span class="hljs-string">'1982-01-23'</span>, <span class="hljs-number">1300</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">10</span>); <br> <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> SALGRADE ( GRADE, LOSAL, HISAL ) <span class="hljs-keyword">VALUES</span> ( <span class="hljs-number">1</span>, <span class="hljs-number">700</span>, <span class="hljs-number">1200</span>); <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> SALGRADE ( GRADE, LOSAL, HISAL ) <span class="hljs-keyword">VALUES</span> ( <span class="hljs-number">2</span>, <span class="hljs-number">1201</span>, <span class="hljs-number">1400</span>); <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> SALGRADE ( GRADE, LOSAL, HISAL ) <span class="hljs-keyword">VALUES</span> ( <span class="hljs-number">3</span>, <span class="hljs-number">1401</span>, <span class="hljs-number">2000</span>); <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> SALGRADE ( GRADE, LOSAL, HISAL ) <span class="hljs-keyword">VALUES</span> ( <span class="hljs-number">4</span>, <span class="hljs-number">2001</span>, <span class="hljs-number">3000</span>); <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> SALGRADE ( GRADE, LOSAL, HISAL ) <span class="hljs-keyword">VALUES</span> ( <span class="hljs-number">5</span>, <span class="hljs-number">3001</span>, <span class="hljs-number">9999</span>); <br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></tbody></table></figure><ul><li>什么是sql脚本：文件名是.sql，并且该文件中编写了大量的SQL语句，执行sql脚本程序就相当于批量执行SQL语句。</li><li>你入职的时候，项目一般都是进展了一部分，多数情况下你进项目组的时候数据库的表以及数据都是有的，项目经理第一天可能会给你一个较大的sql脚本文件，你需要执行这个脚本文件来初始化你的本地数据库。（当然，也有可能数据库是共享的。）</li><li>创建文件：bjpowernode.sql，把以上SQL语句全部复制到sql脚本文件中。</li><li>执行SQL脚本文件，初始化数据库<ul><li>第一步：命令窗口登录mysql</li><li>第二步：创建数据库bjpowernode（如果之前已经创建就不需要再创建了）：create database bjpowernode;</li><li>第三步：使用数据库bjpowernode：use bjpowernode;</li><li>第四步：source命令执行sql脚本，注意：source命令后面是sql脚本文件的绝对路径。</li></ul></li></ul><p>&nbsp;       <img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630221644143.png" alt="image-20250630221644143"></p><ul><li>第五步：查看是否初始化成功，执行：show tables;</li></ul><p>&nbsp;       <img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630221703872.png" alt="image-20250630221703872"></p><ul><li>使用其他的mysql客户端工具也可以执行sql脚本，比如navicat。使用source命令执行sql脚本的优点：<strong>可支持大文件</strong>。</li></ul><h1 id="熟悉测试数据"><a href="#熟悉测试数据" class="headerlink" title="熟悉测试数据"></a>熟悉测试数据</h1><p>emp dept salgrade三张表分别存储什么信息</p><ul><li>emp：员工信息</li><li>dept：部门信息</li><li>salgrade：工资等级信息</li></ul><p>查看表结构：desc或describe，语法格式：desc或describe +表名<br><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630221713009.png" alt="image-20250630221713009"><br>以上的结果展示的不是表中的数据，而是表的结构。</p><ul><li>Field是字段名</li><li>Type是这个字段的数据类型</li><li>Null是这个字段是否允许为空</li><li>Key是这个字段是否为主键或外键</li><li>Default是这个字段的默认值</li></ul><p>对以上表结构进行解释说明：</p><ul><li>emp表<ul><li>empno：员工编号，int类型（整数），不能为空，主键（主键后期学习约束时会进行说明）</li><li>ename：员工姓名，varchar类型（字符串）</li><li>job：工作岗位，varchar类型</li><li>mgr：上级领导编号，int类型</li><li>hiredate：雇佣日期，date类型（日期类型）</li><li>sal：月薪，double类型（带有浮点的数字）</li><li>comm：补助津贴，double类型</li><li>deptno：部门编号，int类型</li></ul></li><li>dept表<ul><li>deptno：部门编号，int类型，主键</li><li>dname：部门名称，varchar类型</li><li>loc：位置，varchar类型</li></ul></li><li>salgrade表<ul><li>grade：等级，int类型</li><li>losal：最低工资，int类型</li><li>hisal：最高工资，int类型</li></ul></li></ul><p>对于以上表结构要提前了解，后面学习的内容需要你马上反应出：哪个字段是什么意思。<br>查看一下表中的数据，来加深一下印象（以下SQL语句会在后面课程中学习）：<br><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630221723278.png" alt="image-20250630221723278"></p>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;MySQL命令行基本命令&quot;&gt;&lt;a href=&quot;#MySQL命令行基本命令&quot; class=&quot;headerlink&quot; title=&quot;MySQL命令行基本命令&quot;&gt;&lt;/a&gt;MySQL命令行基本命令&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;列出当前数据库管理系统中有哪些数据库。&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;databases&lt;/span&gt;;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;




&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630221212047.png&quot; alt=&quot;image-20250630221212047&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;p&gt;创建数据库，起名bjpowernode。&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;database&lt;/span&gt; bjpowernode1;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630221358468.png&quot; alt=&quot;image-20250630221358468&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt; 使用bjpowernode数据库。&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; bjpowernode;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630221518167.png&quot; alt=&quot;image-20250630221518167&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;&lt;p&gt;查看当前用的是哪个数据库。&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;database&lt;/span&gt;();&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630221529447.png&quot; alt=&quot;image-20250630221529447&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt; 查看当前数据库中有哪些表。&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;tables&lt;/span&gt;;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630221541925.png&quot; alt=&quot;image-20250630221541925&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630221552087.png&quot; alt=&quot;image-20250630221552087&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;&lt;p&gt; 删除数据库bjpowernode。&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;drop&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;database&lt;/span&gt; bjpowernode;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630221610116.png&quot; alt=&quot;image-20250630221610116&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;退出mysql&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;exit&lt;/li&gt;
&lt;li&gt;quit&lt;/li&gt;
&lt;li&gt;ctrl + c&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查看当前mysql版本&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;version&lt;/span&gt;();&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630221615405.png&quot; alt=&quot;image-20250630221615405&quot;&gt;&lt;br&gt;还可以使用mysql.exe命令来查看版本信息（在没有登录mysql之前使用）：mysql –version&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/growingbambi/typora/master/image-20250630221633302.png&quot; alt=&quot;image-20250630221633302&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;数据库表的概述&quot;&gt;&lt;a href=&quot;#数据库表的概述&quot; class=&quot;headerlink&quot; title=&quot;数据库表的概述&quot;&gt;&lt;/a&gt;数据库表的概述&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;age&lt;/th&gt;
&lt;th&gt;gender&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;张三&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;男&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;李四&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;女&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="MySQL" scheme="https://xiaofanshutu.github.io/categories/MySQL/"/>
    
    
  </entry>
  
</feed>
