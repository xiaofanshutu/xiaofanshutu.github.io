

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="面向过程编程计算机中的二进制表示在计算机中，所有的内容都是二进制形式表示。十进制是以10为进位，如9+1&#x3D;10；二进制则是满2进位（因为我们的计算机是电子的，电平信号只有高位和低位，你也可以暂且理解为通电和不通电，高电平代表1，低电平代表0，由于只有0和1，因此只能使用2进制表示我们的数字！）比如1+1&#x3D;10&#x3D;2^1+0，一个位也叫一个bit，8个bit称为1字节，16个bit称为一个字，32个b">
<meta property="og:type" content="article">
<meta property="og:title" content="Java入门篇">
<meta property="og:url" content="https://xiaofanshutu.github.io/posts/41562565.html">
<meta property="og:site_name" content="caomeidafu">
<meta property="og:description" content="面向过程编程计算机中的二进制表示在计算机中，所有的内容都是二进制形式表示。十进制是以10为进位，如9+1&#x3D;10；二进制则是满2进位（因为我们的计算机是电子的，电平信号只有高位和低位，你也可以暂且理解为通电和不通电，高电平代表1，低电平代表0，由于只有0和1，因此只能使用2进制表示我们的数字！）比如1+1&#x3D;10&#x3D;2^1+0，一个位也叫一个bit，8个bit称为1字节，16个bit称为一个字，32个b">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/09/16/76GgjWYz4DPBy1p.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/17/Z7AiBPNO6ylML4z.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/17/dvizHYa2fCOKhA3.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/17/ZgzMUafmYAKoOXt.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/17/vAnPCgx5ThEUBHe.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/17/JmdQkSw2qc4ZTuW.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/17/1TtJdKcvRWPfAI2.png">
<meta property="og:image" content="https://s2.loli.net/2025/07/07/JKZYc2uUHswqhEF.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/17/KovME45pl2sPiBN.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/17/jxW3KfwBACidyMY.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/17/TeUCBM9ZzINuoa8.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/17/URJxsgXvzYMQh8t.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/17/TdhHPN64UnyFozq.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/17/3zjJoeL6bgdRqNA.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/17/Kt6rfkYE1HSvNnl.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/18/zy1wuvj6gfHmAZS.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/growingbambi/typora/master/image-20251019231942442.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/24/aQPow8piljRCs2d.png">
<meta property="article:published_time" content="2025-10-28T00:16:33.246Z">
<meta property="article:modified_time" content="2025-10-28T00:17:14.586Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2022/09/16/76GgjWYz4DPBy1p.png">
  
  
  
  <title>Java入门篇 - caomeidafu</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"xiaofanshutu.github.io","root":"/","version":"1.9.8","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="caomeidafu" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 30vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">Java入门篇</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-28 08:16" pubdate>
          2025年10月28日 早上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          13k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          112 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Java入门篇</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="面向过程编程"><a href="#面向过程编程" class="headerlink" title="面向过程编程"></a>面向过程编程</h2><h3 id="计算机中的二进制表示"><a href="#计算机中的二进制表示" class="headerlink" title="计算机中的二进制表示"></a>计算机中的二进制表示</h3><p>在计算机中，所有的内容都是二进制形式表示。十进制是以10为进位，如9+1=10；二进制则是满2进位（因为我们的计算机是电子的，电平信号只有高位和低位，你也可以暂且理解为通电和不通电，高电平代表1，低电平代表0，由于只有0和1，因此只能使用2进制表示我们的数字！）比如1+1=10=2^1+0，一个位也叫一个bit，8个bit称为1字节，16个bit称为一个字，32个bit称为一个双字，64个bit称为一个四字，我们一般采用字节来描述数据大小。</p>
<p>111 = 7</p>
<p>注意这里的bit跟我们生活中的网速MB/s是不一样的，小b代表的是bit，大B代表的是Byte字节（8bit = 1Byte字节），所以说我们办理宽带的时候，100Mbps这里的b是小写的，所以说实际的网速就是100/8 = 12.5 MB/s了。</p>
<blockquote>
<p>十进制的7 -&gt; 在二进制中为 111 = 2^2 + 2^1 + 2^0</p>
</blockquote>
<p>现在有4个bit位，最大能够表示多大的数字呢？</p>
<ul>
<li>最小：0000 =&gt; 0</li>
<li>最大：1111 =&gt; 23+22+21+20 =&gt; 8 + 4 + 2 + 1 = 15</li>
</ul>
<p>在Java中，无论是小数还是整数，他们都要带有符号（和C语言不同，C语言有无符号数）所以，首位就作为我们的符号位，还是以4个bit为例，首位现在作为符号位（1代表负数，0代表正数）：</p>
<ul>
<li>最小：1111 =&gt; -(22+21+2^0) =&gt; -7</li>
<li>最大：0111 =&gt; +(22+21+2^0) =&gt; +7 =&gt; 7</li>
</ul>
<p>现在，我们4bit能够表示的范围变为了-7~+7，这样的表示方式称为<strong>原码</strong>。虽然原码表示简单，但是原码在做加减法的时候，很麻烦！以4bit位为例：</p>
<blockquote>
<p>1+(-1) = 0001 + 1001 = 怎么让计算机去计算？（虽然我们知道该去怎么算，但是计算机不知道！）</p>
</blockquote>
<p>我们得创造一种更好的表示方式！于是我们引入了<strong>反码</strong>：</p>
<ul>
<li>正数的反码是其原码本身 </li>
<li>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反</li>
</ul>
<p>经过上面的定义，我们再来进行加减法：</p>
<blockquote>
<p>1+(-1) = 0001 + 1110 = 1111 =&gt; -0 （直接相加，这样就简单多了！）</p>
</blockquote>
<p>思考：1111代表-0，0000代表+0，在我们实数的范围内，0有正负之分吗？0既不是正数也不是负数，那么显然这样的表示依然不够合理！根据上面的问题，我们引入了最终的解决方案，那就是<strong>补码</strong>，定义如下：</p>
<ul>
<li>正数的补码就是其本身 （不变！）</li>
<li>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1（即在反码的基础上+1，此时1000表示-8）</li>
<li>对补码再求一次补码就可得该补码对应的原码。</li>
</ul>
<p>比如-7原码为1111，反码为1000，补码就是1001了，-6原码为1110，反码为1001，补码就是1010。所以在补码下，原本的1000就作为新增的最小值-8存在。</p>
<p>所以现在就已经能够想通，-0已经被消除了！我们再来看上面的运算：</p>
<blockquote>
<p>1+(-1) = 0001 + 1111 = (1)0000 =&gt; +0 （现在无论你怎么算，也不会有-0了！）</p>
</blockquote>
<p>所以现在，1111代表的不再是-0，而是-1，相应的，由于消除-0，负数多出来一个可以表示的数（1000拿去表示-8了），那么此时4bit位能够表示的范围是：-8~+7（Java使用的就是补码！）在了解了计算机底层的数据表示形式之后，我们再来学习这些基本数据类型就会很轻松了。</p>
<h3 id="整数类形"><a href="#整数类形" class="headerlink" title="整数类形"></a>整数类形</h3><p>在Java中，整数类型包括以下几个：</p>
<ul>
<li>byte 字节型 （8个bit，也就是1个字节）范围：-128~+127</li>
<li>short 短整形（16个bit，也就是2个字节）范围：-32768~+32767</li>
<li>int 整形（32个bit，也就是4个字节）最常用的类型：-2147483648 ~ +2147483647</li>
<li>long 长整形（64个bit，也就是8个字节）范围：-9223372036854775808 ~ +9223372036854775807</li>
</ul>
<p>这里我们来使用一下，其实这几种变量都可以正常表示整数：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">short</span> a = <span class="hljs-number">10</span>;<br>    System.out.println(a);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>因为都可以表示整数，所以说我们可以将小的整数类型值传递给大的整数类型：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">short</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> b = a;   <span class="hljs-comment">//小的类型可以直接传递给表示范围更大的类型</span><br>    System.out.println(b);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>我们在将小的整数类型传递给大的整数类型时发生了<strong>隐式类型转换</strong>，只要是从存储范围小的类型到存储范围大的类型，都支持隐式类型转换，它可以自动将某种类型的值，转换为另一种类型，比如上面就是将short类型的值转换为了int类型的值。</p>
<p>实际上我们在为变量赋一个常量数值时，也发生了隐式类型转换，比如：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>   <span class="hljs-keyword">byte</span> b = <span class="hljs-number">10</span>;    <span class="hljs-comment">//这里的整数常量10，实际上默认情况下是int类型，但是由于正好在对应类型可以表示的范围内，所以说直接转换为了byte类型的值</span><br>}<br></code></pre></td></tr></tbody></table></figure>

<p>由于直接编写的整数常量值默认为<code>int</code>，这里需要特别注意一下，比如下面这种情况：</p>
<p><img src="https://s2.loli.net/2022/09/16/76GgjWYz4DPBy1p.png" srcset="/img/loading.gif" lazyload alt="image-20220916232420547"></p>
<p>按照<code>long</code>类型的规定，实际上是可以表示这么大的数字的，但是为什么这里报错了呢？这是因为我们直接在代码中写的常量数字，默认情况下就是<code>int</code>类型，这么大肯定是表示不下的，如果需要将其表示为一个long类型的常量数字，那么需要在后面添加大写或是小写的<code>L</code>才可以。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">long</span> a = <span class="hljs-number">922337203685477580L</span>;   <span class="hljs-comment">//这样就可以正常编译通过了</span><br>}<br></code></pre></td></tr></tbody></table></figure>

<p>当然，针对于这种很长的数字，为了提升辨识度，我们可以使用下划线分割每一位：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>   <span class="hljs-keyword">int</span> a = <span class="hljs-number">1_000_000</span>;    <span class="hljs-comment">//当然这里依然表示的是1000000，没什么区别，但是辨识度会更高</span><br>}<br></code></pre></td></tr></tbody></table></figure>

<p>我们也可以以8进制或是16进制表示一个常量值：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-comment">//十六进制</span><br>    System.out.println(<span class="hljs-number">0xA</span>);<br>    System.out.println(<span class="hljs-number">0X12</span>);<span class="hljs-comment">//18</span><br>    System.out.println(<span class="hljs-number">0X1A</span>);<span class="hljs-comment">//26</span><br>    <br>    <span class="hljs-comment">//八进制</span><br>    System.out.println(<span class="hljs-number">012</span>);<span class="hljs-comment">//10</span><br>    System.out.println(<span class="hljs-number">0112</span>);<span class="hljs-comment">//74</span><br>}<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>十六进制：</strong> 以<code>0x</code>开头的都是十六进制表示法，十六进制满16进一，但是由于我们的数学只提供了0-9这十个数字，10、11、12…15该如何表示呢，我们使用英文字母A按照顺序开始表示，A表示10、B表示11…F表示15。比如上面的0xA实际上就是我们十进制中的10。</li>
<li><strong>八进制：</strong> 以0开头的都是八进制表示法，八进制就是满8进一，所以说只能使用0-7这几个数字，比如上面的012实际上就是十进制的10。</li>
<li>二进制：以0B开头，满2进1</li>
</ul>
<h4 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h4><p>原码，反码，补码：</p>
<p>正数：三个码的值相同</p>
<p>负数：除符号位之外，其余位取反变为反码；接着反码加1，变为补码</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">2147483647</span>;<span class="hljs-comment">//int最大值 二进制形式：01111111 11111111 11111111 11111111</span><br>    <span class="hljs-keyword">int</span> a = i + <span class="hljs-number">1</span>;<br>    System.out.println(a);<span class="hljs-comment">//-2147483648 二进制形式：10000000 00000000 00000000 00000000</span><br>    <br>    <span class="hljs-keyword">int</span> num = -<span class="hljs-number">2147483648</span>;<br>    <span class="hljs-comment">// 原码</span><br>    System.out.println(<span class="hljs-string">"原码: "</span> + Integer.toBinaryString(num));<span class="hljs-comment">//原码: 10000000000000000000000000000000</span><br><br>    <span class="hljs-comment">// 反码</span><br>    <span class="hljs-keyword">int</span> onesComplement = ~num;<br>    System.out.println(<span class="hljs-string">"反码: "</span> + Integer.toBinaryString(onesComplement));<span class="hljs-comment">//反码: 1111111111111111111111111111111</span><br><br>    <span class="hljs-comment">// 补码</span><br>    <span class="hljs-keyword">int</span> twosComplement = onesComplement + <span class="hljs-number">1</span>;<br>    System.out.println(<span class="hljs-string">"补码: "</span> + Integer.toBinaryString(twosComplement));<span class="hljs-comment">//补码: 10000000000000000000000000000000</span><br>}<br></code></pre></td></tr></tbody></table></figure>



<h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>前面我们介绍了整数类型，我们接着来看看浮点类型，在Java中也可以轻松地使用小数。</p>
<p>首先来看看Java中的小数类型包含哪些：</p>
<ul>
<li>float 单精度浮点型 （32bit，4字节）</li>
<li>double 双精度浮点型（64bit，8字节）</li>
</ul>
<p>所以说我们来总结一下隐式类型转换规则：byte→short(char)→int→long→float→double</p>
<h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>字符类型也是一个重要的基本数据类型，它可以表示计算机中的任意一个字符（包括中文、英文、标点等一切可以显示出来的字符）</p>
<ul>
<li>char 字符型（16个bit，也就是2字节，它不带符号）范围是0 ~ 65535</li>
</ul>
<p>可以看到char类型依然存储的是数字，那么它是如何表示每一个字符的呢？实际上每个数字在计算机中都会对应一个字符，首先我们需要介绍ASCII码：</p>
<p><img src="https://s2.loli.net/2022/09/17/Z7AiBPNO6ylML4z.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>比如我们的英文字母<code>A</code>要展示出来，那就是一个字符的形式，而其对应的ASCII码值为65，所以说当char为65时，打印出来的结果就是大写的字母A了：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">char</span> c = <span class="hljs-number">65</span>;<br>    System.out.println(c);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>得到结果为：</p>
<p><img src="https://s2.loli.net/2022/09/17/dvizHYa2fCOKhA3.png" srcset="/img/loading.gif" lazyload alt="image-20220917110854266"></p>
<p>或者我们也可以直接写一个字符常量值赋值：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">char</span> c = <span class="hljs-string">'A'</span>;    <span class="hljs-comment">//字符常量值需要使用单引号囊括，并且内部只能有一个字符</span><br>    System.out.println(c);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>这种写法效果与上面是一样的。</p>
<p>不过，我们回过来想想，这里的字符表里面不就128个字符吗，那<code>char</code>干嘛要两个字节的空间来存放呢？我们发现表中的字符远远没有我们所需要的那么多，这里只包含了一些基础的字符，中文呢？那么多中文字符（差不多有6000多个），用ASCII编码表那128个肯定是没办法全部表示的，但是我们现在需要在电脑中使用中文。这时，我们就需要扩展字符集了。</p>
<blockquote>
<p>我们可以使用两个甚至多个字节来表示一个中文字符，这样我们能够表示的数量就大大增加了，GB2132方案规定当连续出现两个大于127的字节时（注意不考虑符号位，此时相当于是第一个bit位一直为1了），表示这是一个中文字符（所以为什么常常有人说一个英文字符占一字节，一个中文字符占两个字节），这样我们就可以表示出超过7000种字符了，不仅仅是中文，甚至中文标点、数学符号等，都可以被正确的表示出来。</p>
<p>不过这样能够表示的内容还是不太够，除了那些常见的汉字之外，还有很多的生僻字，比如龘、錕、釿、拷这类的汉字，后来干脆直接只要第一个字节大于127，就表示这是一个汉字的开始，无论下一个字节是什么内容（甚至原来的128个字符也被编到新的表中），这就是Windows至今一直在使用的默认GBK编码格式。</p>
<p>虽然这种编码方式能够很好的解决中文无法表示的问题，但是由于全球还有很多很多的国家以及很多很多种语言，所以我们的最终目标是能够创造一种可以表示全球所有字符的编码方式，整个世界都使用同一种编码格式，这样就可以同时表示全球的语言了。所以这时就出现了一个叫做ISO的（国际标准化组织）组织，来定义一套编码方案来解决所有国家的编码问题，这个新的编码方案就叫做Unicode（准确的说应该是规定的字符集，包含了几乎全世界所有语言的字符），规定每个字符必须使用两个字节，即用16个bit位来表示所有的字符（也就是说原来的那128个字符也要强行用两位来表示）</p>
<p>但是这样的话实际上是很浪费资源的，因为这样很多字符都不会用到两字节来保存，肯定不能直接就这样去表示，这会导致某些字符浪费了很多空间，我们需要一个更加好用的具体的字符编码方式。所以最后就有了UTF-8编码格式（它是Unicode字符集的一个编码规则），区分每个字符的开始是根据字符的高位字节来区分的，比如用一个字节表示的字符，第一个字节高位以“0”开头；用两个字节表示的字符，第一个字节的高位为以“110”开头，后面一个字节以“10开头”；用三个字节表示的字符，第一个字节以“1110”开头，后面俩字节以“10”开头；用四个字节表示的字符，第一个字节以“11110”开头，后面的三个字节以“10”开头：</p>
<figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">10000011 </span><span class="hljs-number">10000110</span>    //这就是一个连续出现都大于<span class="hljs-number">127</span>的字节（注意这里是不考虑符号位的）<br></code></pre></td></tr></tbody></table></figure>

<p>所以如果我们的程序需要表示多种语言，最好采用UTF-8编码格式，它最多可以表示4个字节的内容。随着编码规则的演进，后来又有了UTF-16编码格式，采用BMP字符节省空间，它大量对于中文字符的应用效果更好，Java在运行时采用的就是UTF-16，几乎全世界的语言用到的字符都可以表示出来。</p>
</blockquote>
<table>
<thead>
<tr>
<th>Unicode符号范围（十六进制）</th>
<th>UTF-8编码方式(二进制)</th>
</tr>
</thead>
<tbody><tr>
<td>0000 0000 ~ 0000 007F</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>0000 0080 ~ 0000 07FF</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0000 0800 ~ 0000 FFFF</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0001 0000 ~ 0010 FFFF</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody></table>
<p><strong>注意：</strong> Unicode 是“字符集”，也就是有哪些字符，而UTF-8、UTF-16 是“编码规则”，也就是怎么对这些字符编码，怎么以二进制的形式保存，千万不要搞混了。</p>
<p>简而言之，char实际上需要两个字节才能表示更多种类的字符，所以，<code>char</code>类型可以直接表示一个中文字符：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-string">'淦'</span>;   <span class="hljs-comment">//使用int类型接收字符类型常量值可以直接转换为对应的编码</span><br>    System.out.println(a);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>得到结果为：</p>
<p><img src="https://s2.loli.net/2022/09/17/ZgzMUafmYAKoOXt.png" srcset="/img/loading.gif" lazyload alt="image-20220917111838629"></p>
<p>Java程序在编译为<code>.class</code>文件之后，会采用UTF-8的编码格式，支持的字符也非常多，所以你甚至可以直接把变量名写成中文，依然可以编译通过：</p>
<p><img src="https://s2.loli.net/2022/09/17/vAnPCgx5ThEUBHe.png" srcset="/img/loading.gif" lazyload alt="image-20220917112033102"></p>
<p>介绍完了字符之后，我们接着来看看字符串，其实字符串我们在一开始就已经接触到了。字符虽然可以表示一个中文，但是它没办法表示多个字符：</p>
<p><img src="https://s2.loli.net/2022/09/17/JmdQkSw2qc4ZTuW.png" srcset="/img/loading.gif" lazyload alt="image-20220917114628564"></p>
<p>但是实际上我们使用率最高的还是多个字符的情况，我们需要打印一连串的字符。这个时候，我们就可以使用字符串了：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    String str = <span class="hljs-string">"啊这"</span>;    <span class="hljs-comment">//字符串需要使用双引号囊括，字符串中可以包含0-N个字符</span><br>}<br></code></pre></td></tr></tbody></table></figure>

<p>注意，这里使用的类型是<code>String</code>类型，这种类型并<strong>不是基本数据类型</strong>，它是对象类型，我们会在下一章继续对其进行介绍，这里我们只需要简单了解一下就可以了。</p>
<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>布尔类型是Java中的一个比较特殊的类型，它并不是存放数字的，而是状态，它有下面的两个状态：</p>
<ul>
<li>true  -  真</li>
<li>false  -  假</li>
</ul>
<p>布尔类型（boolean）只有<code>true</code>和<code>false</code>两种值，也就是要么为真，要么为假，布尔类型的变量通常用作流程控制判断语句（不同于C语言，C语言中一般使用0表示false，除0以外的所有数都表示true）布尔类型占据的空间大小并未明确定义，而是根据不同的JVM会有不同的实现。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">boolean</span> b = <span class="hljs-keyword">true</span>;   <span class="hljs-comment">//值只能是true或false</span><br>    System.out.println(b);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>如果给一个其他的值，会无法编译通过：</p>
<p><img src="https://s2.loli.net/2022/09/17/1TtJdKcvRWPfAI2.png" srcset="/img/loading.gif" lazyload alt="image-20220917115424504"></p>
<p>至此，基本数据类型的介绍就结束了。</p>
<h3 id="Java-10-局部变量类型推断"><a href="#Java-10-局部变量类型推断" class="headerlink" title="(Java 10) 局部变量类型推断"></a>(Java 10) 局部变量类型推断</h3><p>Java 10 引入了 <code>var</code> 关键字，可以在局部变量声明时自动推断变量类型，从而简化代码。</p>
<p>例如我们现在想要创建一个整形变量，我们之前是这样编写的：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-comment">//如果需要改成其他类型，前面的int也得跟着改</span><br></code></pre></td></tr></tbody></table></figure>

<p>在Java10之后，我们可以使用<code>var</code>关键字来根据后面的结果自动识别类型：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br></code></pre></td></tr></tbody></table></figure>

<p>此时，无论我们修改后面的变量值为什么类型的值，都可以自动进行推断：</p>
<p><img src="https://s2.loli.net/2025/07/07/JKZYc2uUHswqhEF.png" srcset="/img/loading.gif" lazyload alt="image-20250707180952852"></p>
<p>实际上这个特性很多语言都有，Java选择在Java10才上线此功能，有点为时已晚。由于Java社区普遍较为保守，很多开发者在刚推出时倾向于继续使用显式类型声明，特别是在代码稳定性和可读性方面。所以，这种用法在很多项目里面并不常见，这里只做了解即可。</p>
<hr>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>前面我们介绍了多种多样的基本数据类型，但是光有这些基本数据类型还不够，我们还需要让这些数据之间进行运算，才可以真正意义上发挥计算机的作用。</p>
<p>要完成计算，我们需要借助运算符来完成，实际上我们在数学中就已经接触过多种多样的运算符了。</p>
<blockquote>
<p>比如：+   -    ×    ÷</p>
</blockquote>
<p>这些运算符都是我们在初等数学中学习的，而使用规则也很简单，我们只需要将需要进行运算的两个数放到运算符的两边就可以了：</p>
<blockquote>
<p>比如：10 ÷ 2</p>
</blockquote>
<p>上面运算的结果就是5了，而在Java中，我们同样可以使用这样的方式来进行运算。</p>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>首先我们还是来回顾一下之前认识的老朋友：赋值运算符。</p>
<p>赋值运算符可以直接给某个变量赋值：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">666</span>;   <span class="hljs-comment">//使用等号进行赋值运算</span><br>}<br></code></pre></td></tr></tbody></table></figure>

<p><strong>使用规则为：</strong> 赋值运算符的左边必须是一个可以赋值的目标，比如变量，右边可以是任意满足要求的值，包括变量。</p>
<p>当然，赋值运算符并不只是单纯的赋值，它是有结果的：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">int</span> b = a = <span class="hljs-number">777</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>当出现连续使用赋值运算符时，按照从右往左的顺序进行计算，首先是<code>a = 777</code>，计算完成后，a的值就变成了777，计算完成后，会得到计算结果（赋值运算的计算结果就是赋的值本身，就像1 + 1的结果是2一样，a = 1的结果就是1）此时继续进行赋值计算，那么b就被赋值为<code>a = 777</code>的计算结果，同样的也是 777 了。</p>
<p>所以，使用连等可以将一连串变量都赋值为最右边的值。</p>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><h4 id="加减"><a href="#加减" class="headerlink" title="加减"></a>加减</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">short</span> b = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> c = a + b;   <br>  	<span class="hljs-comment">//使用整数进行运算，小类型需要转换为大类型，short、byte、char一律转换为int再进行计算（无论算式中有无int，都会自动转换）结果也是int；如果算式中出现了long类型，那么全部都需要转换到long类型再进行计算，结果也是long，总之就是依大的来</span><br>}<br></code></pre></td></tr></tbody></table></figure>

<ol>
<li>b自动转换为了int类型进行计算，最后得到结果也是int类型的：</li>
</ol>
<p><img src="https://s2.loli.net/2022/09/17/KovME45pl2sPiBN.png" srcset="/img/loading.gif" lazyload alt="image-20220917141359260"></p>
<ol start="2">
<li>小数和整数一起计算同样会发生隐式类型转换：</li>
</ol>
<p><img src="https://s2.loli.net/2022/09/17/jxW3KfwBACidyMY.png" srcset="/img/loading.gif" lazyload alt="image-20220917141955891"></p>
<ol start="3">
<li>我们也可以将加减号作为正负符号使用，比如我们现在需要让a变成自己的相反数：</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    a = -a;   <span class="hljs-comment">//减号此时作为负号运算符在使用，会将右边紧跟的目标变成相反数</span><br>    System.out.println(a);   <span class="hljs-comment">//这里就会得到-10了</span><br>}<br></code></pre></td></tr></tbody></table></figure>

<ol start="4">
<li>加法支持对字符串的拼接：</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    String str = <span class="hljs-string">"伞兵"</span> + <span class="hljs-string">"lbw"</span>;   <span class="hljs-comment">//我们可以使用加号来拼接两个字符串</span><br>    System.out.println(str);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>最后这个字符串就变成了拼接后的结果了：</p>
<p><img src="https://s2.loli.net/2022/09/17/TeUCBM9ZzINuoa8.png" srcset="/img/loading.gif" lazyload alt="image-20220917145901135"></p>
<ol start="5">
<li>字符串不仅可以跟字符串拼接，也可以跟基本数据类型拼接：</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    String str = <span class="hljs-string">"伞兵"</span> + <span class="hljs-keyword">true</span> + <span class="hljs-number">1.5</span> + <span class="hljs-string">'A'</span>;<br>    System.out.println(str);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>最后就可以得到对应的结果了：</p>
<p><img src="https://s2.loli.net/2022/09/17/URJxsgXvzYMQh8t.png" srcset="/img/loading.gif" lazyload alt="image-20220917150010919"></p>
<h4 id="乘除"><a href="#乘除" class="headerlink" title="乘除"></a>乘除</h4><ol>
<li>两个整数在进行除法运算时，得到的结果也是整数（会直接砍掉小数部分，注意不是四舍五入）</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">8</span>, b = <span class="hljs-number">5</span>;<br>    System.out.println(a / b);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>上面是两个int类型的值进行的除法运算，正常情况下8除以5应该得到1.6，但是由于结果也是整数，所以说最后小数部分被丢弃：</p>
<p><img src="https://s2.loli.net/2022/09/17/TdhHPN64UnyFozq.png" srcset="/img/loading.gif" lazyload alt="image-20220917141816599"></p>
<ol start="2">
<li>如果是两个小数一起计算的话，因为结果也是小数，所以说就可以准确得到结果：</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">double</span> a = <span class="hljs-number">8.0</span>, b = <span class="hljs-number">5.0</span>;<br>    System.out.println(a / b);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p><img src="https://s2.loli.net/2022/09/17/3zjJoeL6bgdRqNA.png" srcset="/img/loading.gif" lazyload alt="image-20220917142201392"></p>
<ol start="3">
<li>整数和小数一起计算，由于所有的整数范围都比小数小，根据规则，整数和小数一起计算时，所有的整数都会变成小数参与运算，所以说最后的结果也就是小数了，同样可以得到正确的结果：</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">double</span> a = <span class="hljs-number">8.0</span>;<br>    <span class="hljs-keyword">int</span> b = <span class="hljs-number">5</span>;<br>    System.out.println(a / b);<br>}<br></code></pre></td></tr></tbody></table></figure>

<h4 id="取模（余数）"><a href="#取模（余数）" class="headerlink" title="取模（余数）"></a>取模（余数）</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    System.out.println(a % <span class="hljs-number">3</span>);   <span class="hljs-comment">//比如这里对a进行取模操作，实际上就是计算除以3的余数</span><br>}<br></code></pre></td></tr></tbody></table></figure>

<p>比如上面的是 10 % 3 得到的结果就是10除以3最后的余数1，取模操作也是非常好用的。</p>
<p>比如我们查看某个数是否为双数，只需要将其对2进行取模操作即可，因为如果是双数一定是可以整除的，如果是单数一定会余1：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    System.out.println(<span class="hljs-number">17</span> % <span class="hljs-number">2</span>);   <span class="hljs-comment">//17不是双数，所以说最后会得到1</span><br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="括号运算符"><a href="#括号运算符" class="headerlink" title="括号运算符"></a>括号运算符</h3><ol>
<li>我们可以通过添加括号的方式来提升某些运算的优先级</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> b = (a = <span class="hljs-number">8</span>) * (-a + <span class="hljs-number">10</span>);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        1. 括号的优先级是最高的，我们需要先计算括号中的内容，如果存在多个括号，就从左往右计算</span><br><span class="hljs-comment">        2. 首先是 a = 8，计算完成之后a变成8，并且运算结果也为8</span><br><span class="hljs-comment">        3. 然后是后面的加法，-a就是-8，加上10就是2</span><br><span class="hljs-comment">        4. 最后才是乘法，左边此时是8，右边是2，最后结果为16</span><br><span class="hljs-comment">     */</span><br>    System.out.println(b);<br>}<br></code></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>括号是可以嵌套的，这一点跟数学中也是一样的，只不过我们不需要使用方括号和花括号，一律使用小括号就行了。在嵌套的情况下，会优先计算最内层括号中的算式</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> b = (<span class="hljs-number">2</span> + (<span class="hljs-number">3</span> + <span class="hljs-number">1</span>) * <span class="hljs-number">3</span>) * <span class="hljs-number">2</span>;<br>    System.out.println(b);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>这里会优先计算 3 + 1的结果，然后由于第二层都在一个括号中，所以说按照正常优先级计算，2 + 4 * 3  = 14，最后来到最外层14*2 = 28，计算结束。</p>
<ol start="3">
<li>括号除了可以用来提升运算优先级，也可以用作<strong>强制类型转换</strong></li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">short</span> b = (<span class="hljs-keyword">short</span>) a;   <span class="hljs-comment">//在括号中填写上强制转换的类型，就可以强制转换到对应的类型了</span><br>}<br></code></pre></td></tr></tbody></table></figure>

<p>强制类型转换存在一定的风险，比如：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">128</span>;   <span class="hljs-comment">//已经超出byte的范围了</span><br>    <span class="hljs-keyword">byte</span> b = (<span class="hljs-keyword">byte</span>) a;  <span class="hljs-comment">//此时强制类型转换为byte类型，那么只会保留byte能够表示的bit位</span><br>    System.out.println(b);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>比如这里的128：</p>
<ul>
<li>00000000 00000000 00000000 10000000  -&gt;  byte只有一个字节，所以说只保留最后8位 -&gt; 10000000</li>
</ul>
<p>这里的10000000，由于第一个位置是符号位，导致此时直接变成了byte的最小值：</p>
<p><img src="https://s2.loli.net/2022/09/17/Kt6rfkYE1HSvNnl.png" srcset="/img/loading.gif" lazyload alt="image-20220917151028191"></p>
<p>所以说强制类型转换只有在明确不会出现问题的情况下，才可以使用。</p>
<p>有了强制类型转换，我们就可以很轻松地让两个整数计算出小数的结果了：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">8</span>, b = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">double</span> c = a/(<span class="hljs-keyword">double</span>)b;  <br>  	<span class="hljs-comment">//强制类型转换的优先级跟正负号一样</span><br>  	<span class="hljs-comment">//计算时，只需要将其中一者转换为double类型，此时按照隐式类型转换规则，全都会变成double参与运算，所以结果也就是小数了</span><br>    System.out.println(c);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>各位思考一下下面的这种情况可以正确得到小数的结果吗？</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">8</span>, b = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">double</span> c = (<span class="hljs-keyword">double</span>) (a/b);<br>    System.out.println(c);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>不能得到，因为括号将a/b的运算优先进行了，此时得到的结果已经是一个整数结果，再转换为double毫无意义。</p>
<h3 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">8</span>;<br>    a++;   <span class="hljs-comment">//自增</span><br>  	a--;   <span class="hljs-comment">//自减</span><br>    System.out.println(a);<br>}<br></code></pre></td></tr></tbody></table></figure>

<ol>
<li>自增自减运算符可以放到操作数的前后：</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">8</span>;<br>    ++a;   <span class="hljs-comment">//自增运算符在前在后最终效果都是让a自增1，是一样的</span><br>    System.out.println(a);<br>}<br></code></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>自增自减操作同样是有结果的，放在操作数前后得到的结果是不一样的：</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">int</span> b = a++;   <span class="hljs-comment">//先出结果，再自增</span><br>    System.out.println(b);  <span class="hljs-comment">//b得到的是a自增前的值，结果是8</span><br>}<br></code></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">int</span> b = ++a;   <span class="hljs-comment">//先自增，再出结果</span><br>    System.out.println(b);   <span class="hljs-comment">//b得到的是a自增之后的结果，结果是9</span><br>}<br></code></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>以其他的数进行自增操作</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">8</span>;<br>    a += <span class="hljs-number">4</span>;   <span class="hljs-comment">//加号和等号连在一起，与a = a + 4效果完全一样</span><br>    System.out.println(a);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>并且结果也是操作之后的结果：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">int</span> b = a += <span class="hljs-number">4</span>;   <span class="hljs-comment">//+=的运算结果就是自增之后的结果</span><br>    System.out.println(b);  <span class="hljs-comment">//所以b就是12</span><br>}<br></code></pre></td></tr></tbody></table></figure>

<p>不止加法，包括我们前面介绍的全部算术运算符，都是支持这种缩写的：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">8</span>;<br>    a *= <span class="hljs-number">9</span>;   <span class="hljs-comment">//跟 a = a * 9 等价</span><br>    System.out.println(a);   <span class="hljs-comment">//得到72</span><br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>我们可以使用位运算符直接以二进制形式操作目标，位运算符包括：&amp;    |    ^    ~</p>
<ol>
<li><p>按位与&amp;</p>
<p>按位与实际上就是让这两个数每一位都进行比较，如果这一位两个数都是1，那么结果就是1，否则就是0：</p>
</li>
<li><p>按位或</p>
<p>只要任意一个为1（不能同时为0）那么结果就是1</p>
</li>
<li><p>按位异或</p>
<p>只有两边不相同的情况下，结果才是1，也就是说一边是1一边是0的情况：</p>
</li>
<li><p>按位取反</p>
<p>如果这一位上是1，变成0，如果是0，变成1：</p>
</li>
<li><p>位移运算符</p>
<ul>
<li><strong>左移操作&lt;&lt;：</strong> 高位直接丢弃，低位补0<ul>
<li>向左移动，尾部用0填充</li>
<li>左移操作每进行一次，结果就会x2</li>
</ul>
</li>
<li><strong>右移操作&gt;&gt;：</strong> 低位直接丢弃，符号位是什么高位补什么<ul>
<li>向右移动，头部用符号位数字填充</li>
<li>右移操作可以快速进行除以2的计算</li>
</ul>
</li>
<li><strong>无符号右移&gt;&gt;&gt;：</strong>使用考虑符号位的右移操作，一旦考虑符号位，那么符号会被移动：</li>
</ul>
</li>
</ol>
<ol start="6">
<li>位移操作也可以缩写：</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> c = -<span class="hljs-number">1</span>;<br>    c = c &lt;&lt; <span class="hljs-number">2</span>;<br>    System.out.println(c);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>可以缩写为：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> c = -<span class="hljs-number">1</span>;<br>    c &lt;&lt;= <span class="hljs-number">2</span>;    <span class="hljs-comment">//直接运算符连上等号即可，跟上面是一样的</span><br>    System.out.println(c);<br>}<br></code></pre></td></tr></tbody></table></figure>



<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>关系判断的结果只可能是真或是假，所以说得到的结果是一个<code>boolean</code>类型的值。关系判断运算符包括：</p>
<figure class="highlight asciidoc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">&gt;   大于<br>&lt;   小于<br><span class="hljs-section">==  等于（注意是两个等号连在一起，不是一个等号，使用时不要搞混了）</span><br>!=  不等于<br>&gt;=  大于等于<br>&lt;=  小于等于<br></code></pre></td></tr></tbody></table></figure>

<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符会出现短路的情况，只要第一个不是真，就算第二个是真也不可能了。逻辑运算符包括：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&amp;&amp;     与运算，要求两边同时为<span class="hljs-keyword">true</span>才能返回<span class="hljs-keyword">true</span><br>||     或运算，要求两边至少要有一个为<span class="hljs-keyword">true</span>才能返回<span class="hljs-keyword">true</span><br>!      非运算，一般放在表达式最前面，表达式用括号扩起来，表示对表达式的结果进行反转<br></code></pre></td></tr></tbody></table></figure>

<ol>
<li><p>与运算。左右两边同时为真，得到的结果才是真，否则一律为假</p>
</li>
<li><p>或运算。两边只要有至少一边满足，结果就为true，如果都不满足，那么就是false</p>
</li>
<li><p>非运算。可以将结果变成相反的样子。</p>
</li>
<li><p>三元运算符。三元运算符可以根据判断条件，返回不同的结果，比如我们想要判断：</p>
</li>
</ol>
<ul>
<li>当a &gt; 10时，给b赋值’A’</li>
<li>当a &lt;= 10时，给b赋值’B’</li>
</ul>
<p>我们就可以使用三元运算符来完成：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">char</span> b = a &gt; <span class="hljs-number">10</span> ? <span class="hljs-string">'A'</span> : <span class="hljs-string">'B'</span>;   <span class="hljs-comment">//三元运算符需要三个内容，第一个是判断语句，第二个是满足判断语句的值，第三个是不满足判断语句的值</span><br>    System.out.println(b);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>三元运算符：</p>
<figure class="highlight ada"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">判断语句 ? 结果<span class="hljs-number">1</span> : 结果2<br></code></pre></td></tr></tbody></table></figure>

<p>因此，上面的判断为假，所以说返回的是结果2，那么最后b得到的就是<code>B</code>这个字符了。</p>
<h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><table>
<thead>
<tr>
<th align="center">优先级</th>
<th align="center">运算符</th>
<th align="center">结合性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">( )</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">! ~   -   +  (强制类型转换)  ++   –</td>
<td align="center">从右向左</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">*   /  %</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">+   -</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">&lt;&lt;   &gt;&gt;   &gt;&gt;&gt;</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">&gt;   &lt;   &gt;=   &gt;=</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">==     !=</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">&amp;</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">^</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">|</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">&amp;&amp;</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">||</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">? :</td>
<td align="center">从右向左</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">=  +=  -=  *=   /=   %=   &amp;=   |=   ^=   &lt;&lt;=  &gt;&gt;=  &gt;&gt;&gt;=</td>
<td align="center">从右向左</td>
</tr>
</tbody></table>
<hr>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>我们的程序都是从上往下依次运行的，但是，仅仅是这样还不够，我们需要更加高级的控制语句来使得程序更加有趣。比如，判断一个整数变量，大于1则输出yes，小于1则输出no，这时我们就需要用到选择结构来帮助我们完成条件的判断和程序的分支走向。学习过C语言就很轻松！</p>
<p>在前面我们介绍了运算符，我们可以通过逻辑运算符和关系运算符对某些条件进行判断，并得到真或是假的结果。这一部分我们将继续使用这些运算符进行各种判断。</p>
<h3 id="代码块与作用域"><a href="#代码块与作用域" class="headerlink" title="代码块与作用域"></a>代码块与作用域</h3><h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (条件判断) 判断成功执行的代码;<br></code></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">15</span>;<br>    <span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">10</span>) {    <span class="hljs-comment">//只有判断成功时，才会执行下面的代码块中内容，否则直接跳过</span><br>        System.out.println(<span class="hljs-string">"a大于10"</span>);<br>        System.out.println(<span class="hljs-string">"a的值为："</span>+a);<br>    } <span class="hljs-keyword">else</span> {   <span class="hljs-comment">//当判断不成功时，会执行else代码块中的代码</span><br>        System.out.println(<span class="hljs-string">"a小于10"</span>);<br>        System.out.println(<span class="hljs-string">"a的值为："</span>+a);<br>    }<br>    System.out.println(<span class="hljs-string">"我是外层"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p><code>if-else</code>语句就像两个分支，跟据不同的判断情况从而决定下一步该做什么，这跟我们之前认识的三元运算符性质比较类似。</p>
<h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span> (目标) {   <span class="hljs-comment">//我们需要传入一个目标，比如变量，或是计算表达式等</span><br>  <span class="hljs-keyword">case</span> 匹配值:    <span class="hljs-comment">//如果目标的值等于我们这里给定的匹配值，那么就执行case后面的代码</span><br>    代码...<br>    <span class="hljs-keyword">break</span>;    <span class="hljs-comment">//代码执行结束后需要使用break来结束，否则会溜到下一个case继续执行代码</span><br>}<br></code></pre></td></tr></tbody></table></figure>

<p>比如现在我们要根据学生的等级进行分班，学生有ABC三个等级：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">char</span> c = <span class="hljs-string">'A'</span>;<br>    <span class="hljs-keyword">switch</span> (c) {  <span class="hljs-comment">//这里目标就是变量c</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'A'</span>:    <span class="hljs-comment">//分别指定ABC三个匹配值，并且执行不同的代码</span><br>            System.out.println(<span class="hljs-string">"去尖子班！准备冲刺985大学！"</span>);<br>            <span class="hljs-keyword">break</span>;   <span class="hljs-comment">//执行完之后一定记得break，否则会继续向下执行下一个case中的代码</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'B'</span>:<br>            System.out.println(<span class="hljs-string">"去平行班！准备冲刺一本！"</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'C'</span>:<br>            System.out.println(<span class="hljs-string">"去职高深造。"</span>);<br>            <span class="hljs-keyword">break</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="Java-14-Switch表达式"><a href="#Java-14-Switch表达式" class="headerlink" title="(Java 14) Switch表达式"></a>(Java 14) Switch表达式</h3><p>在Java 12中，官方对switch进行了增强，它提供了更加简洁和表达力强的方式来替代传统的switch语句，最终在Java 14中正式上线。假设现在我们要给不同分数的学生打等级（学生满分10分）我们之前学习的传统<code>switch</code>语句像这样写：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> score = <span class="hljs-number">9</span>;<br><span class="hljs-keyword">char</span> grade;<br><span class="hljs-keyword">switch</span> (score) {<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<br>        grade = <span class="hljs-string">'A'</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>        grade = <span class="hljs-string">'B'</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>        grade = <span class="hljs-string">'C'</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        grade = <span class="hljs-string">'D'</span>;<br>}<br>System.out.println(<span class="hljs-string">"学生等级为: "</span> + grade);<br></code></pre></td></tr></tbody></table></figure>

<p>每一种情况都要单独编写<code>case</code>和<code>break</code>语句，从现在开始，我们可以使用新的<code>switch</code>语法了，它的分支结果可以直接作为返回结果给到前面的变量，或是在后续课程中用做方法返回值使用：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> score = <span class="hljs-number">9</span>;<br><span class="hljs-comment">//直接让grade接受switch的结果</span><br><span class="hljs-keyword">char</span> grade = <span class="hljs-keyword">switch</span> (score) {<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>, <span class="hljs-number">9</span> -&gt; <span class="hljs-string">'A'</span>;   <span class="hljs-comment">//case后面直接使用-&gt;来指定返回结果</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span> -&gt; <span class="hljs-string">'B'</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>, <span class="hljs-number">7</span> -&gt; <span class="hljs-string">'C'</span>;  <span class="hljs-comment">//当存在多个匹配条件时，使用逗号分隔</span><br>    <span class="hljs-keyword">default</span> -&gt; <span class="hljs-string">'D'</span>;<br>};  <span class="hljs-comment">//别忘了这种写法相当于赋值，最后需要加分号</span><br>System.out.println(<span class="hljs-string">"学生等级为: "</span> + grade);<br></code></pre></td></tr></tbody></table></figure>

<p>是不是看起来简单多了？其中<code>grade</code>得到的就是每一个<code>case</code>语句<code>-&gt;</code>符号后的结果，不需要任何<code>break</code>操作，分支会自动结束，不会出现之前的向下继续移动的情况。详细语法规则如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">var</span> res = <span class="hljs-keyword">switch</span> (obj) {   <span class="hljs-comment">//这里和之前的switch语句是一样的，但是注意这样的switch是有返回值的，所以可以被变量接收</span><br>    <span class="hljs-keyword">case</span> [匹配值, ...] -&gt; <span class="hljs-string">"优秀"</span>;   <span class="hljs-comment">//case后直接添加匹配值，匹配值可以存在多个，需要使用逗号隔开，使用 -&gt; 来返回如果匹配此case语句的结果</span><br>    <span class="hljs-keyword">case</span> ...   <span class="hljs-comment">//根据不同的分支，可以存在多个case</span><br>    <span class="hljs-keyword">default</span> -&gt; <span class="hljs-string">"不及格"</span>;   <span class="hljs-comment">//注意，表达式要求必须涵盖所有的可能，所以是需要添加default的</span><br>};<br></code></pre></td></tr></tbody></table></figure>

<p>不过，有些时候可能我们并不能直接指定返回的结果，比如存在前置操作的情况下，我们可以像这样编写：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span> grade = <span class="hljs-keyword">switch</span> (score) {<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">9</span> -&gt; <span class="hljs-string">'A'</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span> -&gt; <span class="hljs-string">'B'</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>, <span class="hljs-number">7</span> -&gt; {<br>        System.out.println(<span class="hljs-string">"我是额外操作"</span>);   <span class="hljs-comment">//存在前置操作，无法直接指定结果</span><br>        yield <span class="hljs-string">'C'</span>;   <span class="hljs-comment">//在最后使用yield关键字来指定结果</span><br>    }<br>    <span class="hljs-keyword">default</span> -&gt; <span class="hljs-string">'D'</span>;<br>};<br></code></pre></td></tr></tbody></table></figure>

<p>我们可以使用<code>yield</code>关键字来指定延迟返回的结果，同样的，不需要任何<code>break</code>操作，分支会自动结束（注意<code>yield</code>执行之后，后续不能再有任何代码了，因为已经结束了）</p>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (表达式<span class="hljs-number">1</span>;表达式<span class="hljs-number">2</span>;表达式<span class="hljs-number">3</span>) 循环体;<br></code></pre></td></tr></tbody></table></figure>

<p>我们也可以在循环过程中提前终止或是加速循环的进行，这里我们需要认识两个新的关键字：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {<br>        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;   <span class="hljs-comment">//比如我们希望当i等于1时跳过这一轮，不执行后面的打印</span><br>        System.out.println(<span class="hljs-string">"伞兵一号卢本伟准备就绪！"</span>);<br>        System.out.println(<span class="hljs-string">"当前i的值为："</span>+i);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<h5 id="continue关键字"><a href="#continue关键字" class="headerlink" title="continue关键字"></a>continue关键字</h5><p>我们可以使用<code>continue</code>关键字来跳过本轮循环，直接开启下一轮。这里的跳过是指，循环体中，无论后面有没有未执行的代码，一律不执行，直接结束当前循环，开启下一轮。</p>
<h5 id="break关键字"><a href="#break关键字" class="headerlink" title="break关键字"></a>break关键字</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {<br>    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;   <span class="hljs-comment">//我们希望当i等于1时提前结束</span><br>    System.out.println(<span class="hljs-string">"伞兵一号卢本伟准备就绪！"</span>);<br>    System.out.println(<span class="hljs-string">"当前i的值为："</span>+i);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>我们可以使用<code>break</code>关键字来提前终止整个循环，和上面一样，本轮循环中无论后续还有没有未执行的代码，都不会执行了，而是直接结束整个循环，跳出到循环外部。</p>
<p>虽然使用break和continue关键字能够更方便的控制循环，但是注意在多重循环嵌套下，它只对离它最近的循环生效（就近原则）：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">4</span>; ++i) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">4</span>; ++j) {<br>        <span class="hljs-keyword">if</span>(i == j) <span class="hljs-keyword">continue</span>;    <span class="hljs-comment">//当i == j时加速循环</span><br>        System.out.println(i+<span class="hljs-string">", "</span>+j);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>这里的<code>continue</code>加速的对象并不是外层的for，而是离它最近的内层for循环，<code>break</code>也是同样的规则：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">4</span>; ++i) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">4</span>; ++j) {<br>        <span class="hljs-keyword">if</span>(i == j) <span class="hljs-keyword">break</span>;    <span class="hljs-comment">//当i == j时终止循环</span><br>        System.out.println(i+<span class="hljs-string">", "</span>+j);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<h5 id="标签outer"><a href="#标签outer" class="headerlink" title="标签outer:"></a>标签outer:</h5><p>如果我们想要终止或者是加速外层循环呢，我们可以为循环语句打上标签</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">outer: <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">4</span>; ++i) {   <span class="hljs-comment">//在循环语句前，添加 标签: 来进行标记</span><br>    inner: <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">4</span>; ++j) {<br>        <span class="hljs-keyword">if</span>(i == j) <span class="hljs-keyword">break</span> outer;    <span class="hljs-comment">//break后紧跟要结束的循环标记，当i == j时终止外层循环</span><br>        System.out.println(i+<span class="hljs-string">", "</span>+j);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(循环条件) 循环体;<br></code></pre></td></tr></tbody></table></figure>

<p>相比for循环，while循环更多的用在不明确具体的结束时机的情况下，而for循环更多用于明确知道循环的情况，比如我们现在明确要进行循环10次，此时用for循环会更加合适一些，又比如我们现在只知道当<code>i</code>大于10时需要结束循环，但是<code>i</code>在循环多少次之后才不满足循环条件我们并不知道，此时使用while就比较合适了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">100</span>;   <span class="hljs-comment">//比如现在我们想看看i不断除以2得到的结果会是什么，但是循环次数我们并不明确</span><br>    <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) {   <span class="hljs-comment">//现在唯一知道的是循环条件，只要大于0那么就可以继续除</span><br>        System.out.println(i);<br>        i /= <span class="hljs-number">2</span>;   <span class="hljs-comment">//每次循环都除以2</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>上面的这种情况就非常适合使用while循环。</p>
<p>和for循环一样，while也支持使用break和continue来进行循环的控制，以及嵌套使用：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) {<br>        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">10</span>) <span class="hljs-keyword">break</span>;<br>        System.out.println(i);<br>        i /= <span class="hljs-number">2</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<h4 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h4><p>我们也可以反转循环判断的时机，可以先执行循环内容，然后再做循环条件判断，这里要用到<code>do-while</code>语句：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">do</span> {  <span class="hljs-comment">//无论满不满足循环条件，先执行循环体里面的内容</span><br>        System.out.println(<span class="hljs-string">"Hello World!"</span>);<br>        i++;<br>    } <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">10</span>);   <span class="hljs-comment">//再做判断，如果判断成功，开启下一轮循环，否则结束</span><br>}<br></code></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="实战练习"><a href="#实战练习" class="headerlink" title="实战练习"></a>实战练习</h2><h3 id="寻找水仙花数"><a href="#寻找水仙花数" class="headerlink" title="寻找水仙花数"></a>寻找水仙花数</h3><blockquote>
<p>“水仙花数（Narcissistic number）也被称为超完全数字不变数（pluperfect digital invariant, PPDI）、自恋数、自幂数、阿姆斯壮数或阿姆斯特朗数（Armstrong number），水仙花数是指<strong>一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身。</strong>例如：1^3 + 5^3+ 3^3 = 153。”</p>
</blockquote>
<p>现在请你设计一个Java程序，打印出所有1000以内的水仙花数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">100</span>; i &lt; <span class="hljs-number">1000</span>; i++) {<br>    <span class="hljs-keyword">int</span> bai = i / <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">int</span> shi = (i % <span class="hljs-number">100</span>) / <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> ge = i % <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">if</span> (i == bai * bai * bai + shi * shi * shi + ge * ge * ge) {<br>        System.out.println(i);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>





<h3 id="打印九九乘法表"><a href="#打印九九乘法表" class="headerlink" title="打印九九乘法表"></a>打印九九乘法表</h3><p><img src="https://s2.loli.net/2022/09/18/zy1wuvj6gfHmAZS.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) {<br>        System.out.print(i + <span class="hljs-string">"*"</span> + j + <span class="hljs-string">"="</span> + (i * j) + <span class="hljs-string">"\t"</span>);<br>    }<br>    System.out.println();<br>}<br></code></pre></td></tr></tbody></table></figure>

<p><img src="https://raw.githubusercontent.com/growingbambi/typora/master/image-20251019231942442.png" srcset="/img/loading.gif" lazyload alt="image-20251019231942442"></p>
<h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><blockquote>
<p>斐波那契数列（Fibonacci sequence），又称<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%BB%84%E9%87%91%E5%88%86%E5%89%B2/115896">黄金分割</a>数列，因数学家莱昂纳多·斐波那契（Leonardo Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：<strong>1、1、2、3、5、8、13、21、34、……</strong>在数学上，斐波那契数列以如下被以递推的方法定义：<em>F</em>(0)=0，<em>F</em>(1)=1, <em>F</em>(n)=<em>F</em>(n - 1)+<em>F</em>(n - 2)（<em>n</em> ≥ 2，<em>n</em> ∈ N*）在现代物理、准<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%99%B6%E4%BD%93%E7%BB%93%E6%9E%84/10401467">晶体结构</a>、化学等领域，斐波纳契数列都有直接的应用，为此，美国数学会从 1963 年起出版了以《斐波纳契数列季刊》为名的一份数学杂志，用于专门刊载这方面的研究成果。</p>
</blockquote>
<p>斐波那契数列：1，1，2，3，5，8，13，21，34，55，89…，不难发现一个规律，实际上从第三个数开始，每个数字的值都是前两个数字的和，现在请你设计一个Java程序，可以获取斐波那契数列上任意一位的数字，比如获取第5个数，那么就是5。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    <span class="hljs-keyword">int</span> target = <span class="hljs-number">7</span>, result;  <span class="hljs-comment">//target是要获取的数，result是结果</span><br><br>    <span class="hljs-comment">//请在这里实现算法</span><br><br>    System.out.println(result);<br>}<br></code></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1 1 2 3 5 8 13 21 34 55 89</span><br><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> target = <span class="hljs-number">6</span>;<br><span class="hljs-keyword">int</span> result;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= target; i++) {<br>    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span> || i == <span class="hljs-number">2</span>) {<br>        result = <span class="hljs-number">1</span>;<br>    } <span class="hljs-keyword">else</span> {<br>        result = a + b;<br>        a = b;<br>        b = result;<br>    }<br>    System.out.print(result + <span class="hljs-string">" "</span>);<span class="hljs-comment">//1 1 2 3 5 8 </span><br>}<br></code></pre></td></tr></tbody></table></figure>

<h2 id="面向对象高级篇"><a href="#面向对象高级篇" class="headerlink" title="面向对象高级篇"></a>面向对象高级篇</h2><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><h4 id="成员内部类（实例内部类）"><a href="#成员内部类（实例内部类）" class="headerlink" title="成员内部类（实例内部类）"></a>成员内部类（实例内部类）</h4><ol>
<li><strong>非静态内部类可以直接访问外部类的实例变量。</strong>（因为成员内部类本身就是某个对象所有的，每个对象都有这样的一个类定义。）</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mia;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 非静态内部类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cow</span> </span>{<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> weight;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cow</span><span class="hljs-params">()</span> </span>{<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> weight)</span> </span>{<br>        <span class="hljs-keyword">this</span>.weight = weight;<br>    }<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CowLeg</span> </span>{<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> length;<br>        <span class="hljs-keyword">private</span> String color;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CowLeg</span><span class="hljs-params">()</span> </span>{<br>        }<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CowLeg</span><span class="hljs-params">(<span class="hljs-keyword">double</span> length, String color)</span> </span>{<br>            <span class="hljs-keyword">this</span>.length = length;<br>            <span class="hljs-keyword">this</span>.color = color;<br>        }<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">info</span><span class="hljs-params">()</span> </span>{<br>            System.out.println(<span class="hljs-string">"牛腿的颜色是："</span> + color + <span class="hljs-string">", 高是："</span> + length);<br>            System.out.println(<span class="hljs-string">"奶牛重是："</span> + weight);<br>            <span class="hljs-comment">// 非静态内部类可以直接访问外部类的实例变量。</span><br>            <br>        }<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getLength</span><span class="hljs-params">()</span> </span>{<br>            <span class="hljs-keyword">return</span> length;<br>        }<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLength</span><span class="hljs-params">(<span class="hljs-keyword">double</span> length)</span> </span>{<br>            <span class="hljs-keyword">this</span>.length = length;<br>        }<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getColor</span><span class="hljs-params">()</span> </span>{<br>            <span class="hljs-keyword">return</span> color;<br>        }<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setColor</span><span class="hljs-params">(String color)</span> </span>{<br>            <span class="hljs-keyword">this</span>.color = color;<br>        }<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{<br>        CowLeg cowLeg = <span class="hljs-keyword">new</span> CowLeg(<span class="hljs-number">1.2</span>, <span class="hljs-string">"黑白相间"</span>);<br>        System.out.println(cowLeg.length);<br>        cowLeg.info();<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        Cow cow = <span class="hljs-keyword">new</span> Cow(<span class="hljs-number">378.9</span>);<br>        cow.test();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p><img src="https://s2.loli.net/2022/09/24/aQPow8piljRCs2d.png" srcset="/img/loading.gif" lazyload alt="image-20220924123600217"></p>
<ol start="2">
<li><strong>访问外部类和内部类同名的变量</strong></li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mia;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示如何区分外部类和内部类同名的变量</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 访问同名变量时，遵循就近原则</span><br><span class="hljs-comment"> *      访问外部类实例变量：外部类名.this.变量名</span><br><span class="hljs-comment"> *      访问内部类实例变量：this.变量名 (在内部类中使用this，表示当前内部类对象)</span><br><span class="hljs-comment"> *      访问内部类方法内的局部变量：直接使用变量名</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscernVariable</span> </span>{<br>    <span class="hljs-keyword">private</span> String prop = <span class="hljs-string">"外部类的实例变量"</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InClass</span> </span>{<br>        <span class="hljs-keyword">private</span> String prop = <span class="hljs-string">"内部类的实例变量"</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">info</span><span class="hljs-params">()</span> </span>{<br>            <span class="hljs-keyword">var</span> prop = <span class="hljs-string">"方法内的局部变量"</span>;<br>            System.out.println(<span class="hljs-string">"外部类的实例变量值:"</span> + DiscernVariable.<span class="hljs-keyword">this</span>.prop);<span class="hljs-comment">// 使用 外部类名.this.变量名 访问外部类的实例变量</span><br>            System.out.println(<span class="hljs-string">"内部类的实例变量值："</span> + <span class="hljs-keyword">this</span>.prop);<span class="hljs-comment">// 使用 this.变量名 访问内部类的实例变量</span><br>            System.out.println(<span class="hljs-string">"方法内的局部变量值："</span> + prop);<br>        }<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">var</span> in = <span class="hljs-keyword">new</span> InClass();<br>        in.info();<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        <span class="hljs-keyword">new</span> DiscernVariable().test();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>对方法的调用也是类似，</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>{<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String name)</span></span>{<br>        <span class="hljs-keyword">this</span>.toString();		<span class="hljs-comment">//内部类自己的toString方法</span><br>        <span class="hljs-keyword">super</span>.toString();       <span class="hljs-comment">//内部类父类的toString方法</span><br>        Test.<span class="hljs-keyword">this</span>.toString();   <span class="hljs-comment">//外部类的toSrting方法</span><br>        Test.<span class="hljs-keyword">super</span>.toString();  <span class="hljs-comment">//外部类父类的toString方法</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>



<ol start="3">
<li><strong>外部类访问非静态内部类的实例变量</strong></li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mia;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示非静态内部类访问外部类的实例变量，以及外部类访问非静态内部类的实例变量</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 非静态内部类可以直接访问外部类的private实例变量</span><br><span class="hljs-comment"> * 外部类不能直接访问非静态内部类的实例变量，需要先创建内部类的实例，然后通过该实例访问内部类的实例变量</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span> </span>{<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> outProp;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>{<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> intProp = <span class="hljs-number">5</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accessOuterProp</span><span class="hljs-params">()</span> </span>{<br>            <span class="hljs-comment">// 非静态内部类可以直接访问外部类的private实例变量</span><br>            System.out.println(<span class="hljs-string">"外部类的outProp值为："</span> + outProp);<br>        }<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accessInnerProp</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-comment">// 外部类不能直接访问非静态内部类的实例变量</span><br>        <span class="hljs-comment">// 下面这段代码会出现编译错误</span><br>        <span class="hljs-comment">//  System.out.println("内部类的inProp值为：" + inProp);</span><br><br>        <span class="hljs-comment">// 需要先创建内部类的实例，然后通过该实例访问内部类的实例变量</span><br>        System.out.println(<span class="hljs-string">"内部类的inProp值为："</span> + <span class="hljs-keyword">new</span> Inner().intProp);<br><br>        System.out.println(<span class="hljs-string">"访问外部类的实例变量："</span>);<br>        <span class="hljs-keyword">new</span> Inner().accessOuterProp();<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        <span class="hljs-comment">// 下面这行代码，只创建了外部类对象，未创建内部类对象</span><br>        Outer outer = <span class="hljs-keyword">new</span> Outer();<br>        outer.accessInnerProp();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<ol start="4">
<li>不能在外部类的静态成员中使用非静态内部类</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mia;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示静态成员不能直接访问非静态成员</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticTest</span> </span>{<br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">In</span> </span>{<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        <span class="hljs-comment">// 编译错误</span><br>        <span class="hljs-comment">// 静态成员（main方法）不能直接访问非静态成员（In类）</span><br>        <span class="hljs-comment">// new In();// 'com. mia. StaticTest. this' cannot be referenced from a static context</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<ol start="5">
<li>在非静态内部类中定义静态成员（Java 17开始）</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mia;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示非静态内部类中定义静态成员</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 在Java 16之前，</span><br><span class="hljs-comment"> * 非静态内部类中不能定义静态成员（静态变量、静态方法、静态代码块）</span><br><span class="hljs-comment"> * 因为非静态内部类的实例是依赖于外部类的实例的，而静态成员是属于类本身的，与实例无关</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 在Java 16以后的版本，</span><br><span class="hljs-comment"> * 允许在非静态内部类中定义静态成员</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerHasStatic</span> </span>{<br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>{<br>        <span class="hljs-comment">// 从Java16开始，非静态内部类中允许定义静态成员（静态代码块，静态常量，静态方法）</span><br>        <span class="hljs-keyword">static</span> {<br>            System.out.println(<span class="hljs-string">"静态代码块被执行"</span>);<br>        }<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> inProp = <span class="hljs-number">5</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{<br>            System.out.println(<span class="hljs-string">"静态方法被调用"</span>);<br>        }<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        System.out.println(<span class="hljs-string">"访问非静态内部类的静态变量："</span> + Inner.inProp);<br>        Inner.test();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>



<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><ol>
<li><p>静态内部类不能访问外部类的非静态成员。可以访问外部类的静态成员。</p>
<p>如果静态内部类的方法不是静态方法，那么调用该方法的时候，仍然需要创建静态内部类的对象，通过该对象调用实例方法。</p>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mia;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 示静态内部类访问外部类的静态变量</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 静态内部类不能访问外部类的非静态变量</span><br><span class="hljs-comment"> * 静态内部类可以直接访问外部类的静态变量</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticInnerClassTest</span> </span>{<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> prop1 = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> prop2 = <span class="hljs-number">20</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">staticMethod</span><span class="hljs-params">()</span> </span>{<br>        System.out.println(<span class="hljs-string">"外部类的静态方法"</span>);<br>    }<br><br>    <span class="hljs-comment">// 静态内部类是独立的类，不依赖外部类实例；但如果内部类的方法是实例方法，调用它时仍需先创建该内部类的实例。</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticInnerClass</span> </span>{<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accessOuterProp</span><span class="hljs-params">()</span> </span>{<br>            System.out.println(<span class="hljs-string">"访问外部类的静态变量prop2："</span> + prop2);<br>            <span class="hljs-comment">// 访问外部类的静态方法</span><br>            staticMethod();<br><br>            <span class="hljs-comment">// 编译错误，静态内部类不能访问外部类的非静态变量</span><br><span class="hljs-comment">//            System.out.println("访问外部类的非静态变量prop1：" + prop1);</span><br>        }<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        <span class="hljs-comment">// 因为静态内部类的方法不是静态方法，所以需要先创建静态内部类的实例，然后通过该实例调用方法</span><br>        StaticInnerClass staticInnerClass = <span class="hljs-keyword">new</span> StaticInnerClass();<br>        staticInnerClass.accessOuterProp();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<ol start="2">
<li><p>外部类访问静态内部类的成员</p>
<p>访问静态内部类的静态成员：静态内部类类名.静态变量名</p>
<p>访问静态内部类的非静态成员：先创建静态内部类的实例/对象，通过该实例/对象访问非静态成员</p>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mia;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 访问静态内部类的成员</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessStaticInnerClass</span> </span>{<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticInnerClass</span> </span>{<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> prop1 = <span class="hljs-number">9</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> prop2 = <span class="hljs-number">5</span>;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accessInnerProp</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-comment">// 下面代码出现错误，访问格式不对</span><br>        <span class="hljs-comment">// System.out.println(prop1);</span><br><br>        <span class="hljs-comment">// 外部类可以直接访问静态内部类的静态变量：静态内部类类名.静态变量名</span><br>        System.out.println(<span class="hljs-string">"静态内部类的静态成员prop1: "</span> + StaticInnerClass.prop1);<br><br>        <span class="hljs-comment">// 外部类访问静态内部类的实例变量，需要先创建静态内部类的实例，然后通过该实例访问</span><br>        StaticInnerClass staticInnerClass = <span class="hljs-keyword">new</span> StaticInnerClass();<br>        System.out.println(<span class="hljs-string">"静态内部类的实例成员prop2: "</span> + staticInnerClass.prop2);<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        AccessStaticInnerClass accessStaticInnerClass = <span class="hljs-keyword">new</span> AccessStaticInnerClass();<br>        accessStaticInnerClass.accessInnerProp();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>



<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>定义在方法中的类叫局部内部类，作用域只在方法中。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mia;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 局部内部类示例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocalInnerClass</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerBase</span> </span>{<br>            <span class="hljs-keyword">int</span> a;<br>        }<br><br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerSub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InnerBase</span> </span>{<br>            <span class="hljs-keyword">int</span> b;<br>        }<br><br>        InnerSub innerSub = <span class="hljs-keyword">new</span> InnerSub();<br>        innerSub.a = <span class="hljs-number">10</span>;<br>        innerSub.b = <span class="hljs-number">20</span>;<br>        System.out.println(<span class="hljs-string">"a="</span> + innerSub.a + <span class="hljs-string">",b="</span> + innerSub.b);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>



<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><ol>
<li>通过实现接口来创建匿名内部类</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mia;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 匿名内部类实现接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Product</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getPrice</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;<br>}<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnonymousTest</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        AnonymousTest anonymousTest = <span class="hljs-keyword">new</span> AnonymousTest();<br>        anonymousTest.test(<span class="hljs-keyword">new</span> Product() {<span class="hljs-comment">// 匿名内部类实现接口的时候，new 接口()后面的这个()里面不能有任何参数</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getPrice</span><span class="hljs-params">()</span> </span>{<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">99.9</span>;<br>            }<br><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">"笔记本电脑"</span>;<br>            }<br>        });<br>    }<br><br>    <span class="hljs-comment">// 接收一个Product接口类型的参数</span><br>    <span class="hljs-comment">// 需要用对象调用该方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Product p)</span> </span>{<br>        System.out.println(<span class="hljs-string">"产品名称: "</span> + p.getName());<br>        System.out.println(<span class="hljs-string">"产品价格: "</span> + p.getPrice());<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>上面实现匿名内部类的代码等价于下面这段代码</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnonymousProduct</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Product</span> </span>{<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getPrice</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">99.9</span>;<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"笔记本电脑"</span>;<br>    }<br>}<br>anonymousTest.test(<span class="hljs-keyword">new</span> AnonymousProduct());<br></code></pre></td></tr></tbody></table></figure>



<ol start="2">
<li>通过继承父类来创建匿名内部类</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mia;<br><br><span class="hljs-comment">// 抽象类Device，有两个构造器，一个有参构造器，一个无参构造器</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Device</span> </span>{<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getPrice</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Device</span><span class="hljs-params">()</span> </span>{<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Device</span><span class="hljs-params">(String name)</span> </span>{<br>        <span class="hljs-keyword">this</span>.name = name;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> name;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>{<br>        <span class="hljs-keyword">this</span>.name = name;<br>    }<br>}<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnonymousInner</span> </span>{<br>    <span class="hljs-comment">// 接收一个Device类型的参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Device d)</span> </span>{<br>        System.out.println(<span class="hljs-string">"设备名称: "</span> + d.getName());<br>        System.out.println(<span class="hljs-string">"设备价格: "</span> + d.getPrice());<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        AnonymousInner anonymousInner = <span class="hljs-keyword">new</span> AnonymousInner();<br><br>        <span class="hljs-comment">// 调用有参构造器创建匿名内部类（Device）对象</span><br>        anonymousInner.test(<span class="hljs-keyword">new</span> Device(<span class="hljs-string">"iPhone17"</span>) {<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getPrice</span><span class="hljs-params">()</span> </span>{<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">5499</span>;<br>            }<br>        });<br><br>        <span class="hljs-comment">// 调用无参构造器创建匿名内部类（Device）对象</span><br>        Device d = <span class="hljs-keyword">new</span> Device() {<br>            {<br>                System.out.println(<span class="hljs-string">"匿名内部类的代码块"</span>);<br>            }<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getPrice</span><span class="hljs-params">()</span> </span>{<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">210</span>;<br>            }<br><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{<span class="hljs-comment">//可以改造抽象类的普通方法？？？</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-string">"小米手环8"</span>;<br>            }<br>        };<br>        anonymousInner.test(d);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>从Java 8开始，匿名内部类、局部内部类允许访问非final的局部变量</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在Java 8以前下面语句将提示错误：age必须使用final修饰</span><br><span class="hljs-comment"> * 从Java 8开始，匿名内部类、局部内部类允许访问非final的局部变量</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br>}<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ATest</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        <span class="hljs-keyword">int</span> age = <span class="hljs-number">8</span>;<br>        <span class="hljs-comment">// 下面代码将会导致1处的代码编译错误</span><br><span class="hljs-comment">//        age = 9;</span><br>        <span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> A() {<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{<br>                <span class="hljs-comment">// 在Java 8以前下面语句将提示错误：age必须使用final修饰</span><br>                <span class="hljs-comment">// 从Java 8开始，匿名内部类、局部内部类允许访问非final的局部变量</span><br>                System.out.println(age);<span class="hljs-comment">// 1️⃣由于age局部变量被匿名内部类访问了，因此age相当于被final修饰了 Variable 'age' is accessed from within inner class, needs to be final or effectively final</span><br>            }<br>        };<br>        a.test();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><p>前面我们介绍了匿名内部类，我们可以通过这种方式创建一个临时的实现子类。</p>
<p>特别的，<strong>如果一个接口中有且只有一个待实现的抽象方法</strong>，那么我们可以将匿名内部类简写为Lambda表达式：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Study study = () -&gt; System.out.println(<span class="hljs-string">"我是学习方法！"</span>);   <span class="hljs-comment">//是不是感觉非常简洁！</span><br>  	study.study();<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在初学阶段，为了简化学习，各位小伙伴就认为Lambda表达式就是匿名内部类的简写就行了（Lambda表达式的底层其实并不只是简简单单的语法糖替换，感兴趣的可以在新特性篇视频教程中了解）</p>
<p>那么它是一个怎么样的简写规则呢？我们来看一下Lambda表达式的具体规范：</p>
<ul>
<li>标准格式为：<code>([参数类型 参数名称,]...) ‐&gt; { 代码语句，包括返回值 }</code></li>
<li>和匿名内部类不同，Lambda仅支持接口，不支持抽象类</li>
<li>接口内部必须有且仅有一个抽象方法（可以有多个方法，但是必须保证其他方法有默认实现，必须留一个抽象方法出来）</li>
</ul>
<p>比如我们之前写的Study接口，只要求实现一个无参无返回值的方法，所以说直接就是最简单的形式：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">() -&gt; System.out.println(<span class="hljs-string">"我是学习方法！"</span>);   <span class="hljs-comment">//跟之前流程控制一样，如果只有一行代码花括号可省略</span><br></code></pre></td></tr></tbody></table></figure>

<p>当然，如果有一个参数和返回值的话：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Study study = (a) -&gt; {<br>        System.out.println(<span class="hljs-string">"我是学习方法"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"今天学会了"</span>+a;    <span class="hljs-comment">//实际上这里面就是方法体，该咋写咋写</span><br>    };<br>    System.out.println(study.study(<span class="hljs-number">10</span>));<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>注意，如果方法体中只有一个返回语句，可以直接省去花括号和<code>return</code>关键字：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Study study = (a) -&gt; {<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"今天学会了"</span>+a;   <span class="hljs-comment">//这种情况是可以简化的</span><br>};<br></code></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Study study = (a) -&gt; <span class="hljs-string">"今天学会了"</span>+a;<br></code></pre></td></tr></tbody></table></figure>

<p>如果参数只有一个，那么可以省去小括号：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Study study = a -&gt; <span class="hljs-string">"今天学会了"</span>+a;<br></code></pre></td></tr></tbody></table></figure>

<p>是不是感觉特别简洁，实际上我们程序员追求的就是写出简洁高效的代码，而Java也在朝这个方向一直努力，近年来从Java 9开始出现的一些新语法基本都是各种各样的简写版本。</p>
<p>如果一个方法的参数需要的是一个接口的实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    test(a -&gt; <span class="hljs-string">"今天学会了"</span>+a);   <span class="hljs-comment">//参数直接写成lambda表达式</span><br>}<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Study study)</span></span>{<br>    study.study(<span class="hljs-number">10</span>);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>当然，这还只是一部分，对于已经实现的方法，如果我们想直接作为接口抽象方法的实现，我们还可以使用方法引用。</p>
<h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>方法引用就是将一个已实现的方法，直接作为接口中抽象方法的实现（当然前提是方法定义得一样才行）</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Study</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;   <span class="hljs-comment">//待实现的求和方法</span><br>}<br></code></pre></td></tr></tbody></table></figure>

<p>那么使用时候，可以直接使用Lambda表达式：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Study study = (a, b) -&gt; a + b;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>只不过还能更简单，因为Integer类中默认提供了求两个int值之和的方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Integer类中就已经有对应的实现了</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{<br>    <span class="hljs-keyword">return</span> a + b;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>此时，我们可以直接将已有方法的实现作为接口的实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Study study = (a, b) -&gt; Integer.sum(a, b);   <span class="hljs-comment">//直接使用Integer为我们通过好的求和方法</span><br>    System.out.println(study.sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>));<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>我们发现，Integer.sum的参数和返回值，跟我们在Study中定义的完全一样，所以说我们可以直接使用方法引用：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Study study = Integer::sum;    <span class="hljs-comment">//使用双冒号来进行方法引用，静态方法使用 类名::方法名 的形式</span><br>    System.out.println(study.sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>));<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>方法引用其实本质上就相当于将其他方法的实现，直接作为接口中抽象方法的实现。任何方法都可以通过方法引用作为实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Study</span> </span>{<br>    <span class="hljs-function">String <span class="hljs-title">study</span><span class="hljs-params">()</span></span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>如果是普通从成员方法，我们同样需要使用对象来进行方法引用：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Main main = <span class="hljs-keyword">new</span> Main();<br>    Study study = main::lbwnb;   <span class="hljs-comment">//成员方法因为需要具体对象使用，所以说只能使用 对象::方法名 的形式</span><br>}<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">lbwnb</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"卡布奇诺今犹在，不见当年倒茶人。"</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>因为现在只需要一个String类型的返回值，由于String的构造方法在创建对象时也会得到一个String类型的结果，所以说：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>    Study study = String::<span class="hljs-keyword">new</span>;    <span class="hljs-comment">//没错，构造方法也可以被引用，使用new表示</span><br>}<br></code></pre></td></tr></tbody></table></figure>

<p>反正只要是符合接口中方法的定义的，都可以直接进行方法引用，对于Lambda表达式和方法引用，在Java新特性介绍篇视频教程中还有详细的讲解，这里就不多说了。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Java/" class="category-chain-item">Java</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Java入门篇</div>
      <div>https://xiaofanshutu.github.io/posts/41562565.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月28日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/98735cb0.html" title="泛型程序设计">
                        <span class="hidden-mobile">泛型程序设计</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
